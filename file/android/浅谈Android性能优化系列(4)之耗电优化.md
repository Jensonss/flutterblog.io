# 0x00 前言

作为移动设备，电池重要性不言而喻，设备没有电那就真的只能拿来砸核桃了。所以作为开发者的我们，为了给用户带来更好的体验，耗电优化一直是我们撇不开的话题。

# 0x01 为什么耗电

![屏幕快照 2017-03-23 下午2.51.24.png](https://jenson-1258324340.cos.ap-beijing.myqcloud.com/%E7%94%A8%E6%88%B7app%E8%80%97%E7%94%B5.png)

通过上图先把用户-电量这一流程抽象出来，

设备的耗电和硬件本身无关，根本原因在于对硬件的使用，耗电越严重说明对硬件使用的越频繁。

<!-- more -->

先看下移动设备元件耗电大户有哪些：
![fullsizerender.jpg](https://jenson-1258324340.cos.ap-beijing.myqcloud.com/%E8%80%97%E7%94%B5%E6%A8%A1%E5%9D%97%E6%AF%94%E4%BE%8B%E5%9B%BE.png)

# 0x02 屏幕

屏幕是耗电最大元件之一，但是用户要和app交互就要点亮屏幕，有人可能会觉得屏幕的明暗是用户自己根据喜好设定的，我们无可奈何。其实不然，在有些时候是可以通过UI的设计来减少屏幕电能消耗的。

在这之前我们先来看下目前常用手机屏幕材质：LCD和LED(OLED)。

- LCD概述
  LCD又名液晶显示屏，屏幕由成千上万液晶分子负责像素显示，并通过背光来将其照亮。所以说每个像素点都使用了同一个光源，每个像素消耗的电量是相同的。

- LED概述
  LED每个屏幕像素都可以看成是一个LED灯，由RGB三种颜色共同呈现，不同颜色能量消耗也各不相同。黑色不使用任何颜色，不消耗能量，白色相反使用了所有颜色且亮度高，所以能量消耗也更多。

  

  

  **优化方案：较暗的颜色比明亮的颜色更节能，所以在很多留白的地方可以考虑使用偏暗的色调，当然这要在不影响用户体验的前提下。**

# 0x03 网络

参考[浅谈Android性能优化系列(3)之网络优化](http://www.jensondev.me/2017/09/26/%E6%B5%85%E8%B0%88Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%B3%BB%E5%88%97-4-%E4%B9%8B%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/)

# 0x04 CPU

当应用退到后台运行时， 尽量减少应用的主动运行。

锁屏、 灭屏、 程序 放置后台时，释放或停止Android涉 及耗电的服务。

当检测到CPU时间片消耗异常时， 深入线程分析： 

通过获取运行过程中线程的CPU时间片消耗， 去抓取消耗时间片异常的线程， 通过线程去定位相应代码逻辑。

使用**traceview**，定位CPU占用率异常的方法。

## 位移替代除法

浮点运算比整数运算相对更消耗cpu时间片，相应耗电也就增加，因而在编码过程尽量减少浮点运算，

例如使用位移代替除法。

## 动画释放

对于动画效果比较炫的界面， 灭屏后CPU占用率仍然很高，

最可能的原因就是动画没有及时释放。   

## 避免wakelock不正确使用

wakelock可以唤醒设备也可以阻止设备休眠。

在PowerManager类中谷歌已经声明了：

这个类会影响设备电量，除非必须，否则尽量不要使用该类，同时使用完毕要尽快释放。

wankelock有几种类型，在使用时注意选择正确地类型。

降低对系统的唤醒频率， 使用partial wake lock代替full wake lock， 

因为屏幕的亮起， 也会消耗手机电量。

在注册后，也要注意及时释放，否则锁的持有时间会被一直计算到电量消耗中。  

无论是间接还是直接 的，否则会让CPU 无法休眠， 导致严重的耗电问题。

### 注意兼容wakeLock

WakeLock有一个接口setReferenceCounted， 用来设置WakeLock的计数机制， 

官方默认为计数：true为计数， false为不计数。 

所谓计数即每一个acquire必须对应一个release； 

不计数则是无论有多少个acquire， 一个release就可以释放。

虽然官方说默认是计数的， 但是有的第三方ROM做了修改， 使默认是不计数的。

所以在使用时注意查看并设置好兼容性问题。

### 间接引用wakeLock

在调用音视频API时，看似我们只是简单调用了Media某些功能，

但是深入API分析会发现其源码内部一些地方间接使用了wakeLock。

所以如果在退入后台后音视频资源没有及时释放，也就间接导致wakeLock一直注册中。

## JobScheduler

很多时候为了满足我们的需求而没有考虑cpu的感受，

为了执行1s中的数据去唤醒cpu，但实际却消耗了约两分钟的电量。

为此谷歌在5.0系统下提供了JobScheduler组件，使用场景：

必要不紧急，可延迟执行的任务，比如数据块更新，bug日志上报。

耗电大的任务，如备份在充电时执行。

## Doze模式

Doze模式通过限制应用访问网络及其他一些操作频率，从而减少cpu开销达到省电目的。

在6.0系统上未连接电源、屏幕关闭就会进入Doze模式。

但是为了不影响应用正常工作，系统还会周期性退出Doze，

在退出期间去执行那些被挂起的任务，这个时间窗口称作维护窗口。

# 0x05 其他优化

## 传感器

每个传感器都有最大信号频率，开发者在使用传感器时要设置合适的采样频率。

最后在使用完成后一定要进行注销，否则激活的传感器会一直进行检测，造成cpu负载和电量消耗。

为了耗电优化干的这些活用户感知不到，但是如果不去优化，肆意使用，那用户就很容易感知到了。