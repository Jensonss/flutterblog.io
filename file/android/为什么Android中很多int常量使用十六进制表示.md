# 0x00 前言

在Java或者Android中，发现很多涉及框架和源码地方，很多int常量都是使用十六进制表示的，而不是我们日常开发中直接使用我们最熟悉的十进制。这是为什么呢？换个问法，这样做有什么好处呢？

```java
    public static final int FLAG_DEBUG_TRIAGED_MISSING = 0x00000100;
    public static final int FLAG_IGNORE_EPHEMERAL = 0x00000200;
    public static final int FLAG_ACTIVITY_NO_HISTORY = 0x40000000;
    public static final int FLAG_ACTIVITY_NEW_TASK = 0x10000000;
    public static final int FLAG_ACTIVITY_MULTIPLE_TASK = 0x08000000;
    public static final int FLAG_ACTIVITY_CLEAR_TASK = 0X00008000;
    public static final int FLAG_ACTIVITY_TASK_ON_HOME = 0X00004000;

```

<!-- more -->

猜测可能的原因：

①为了美观

②为了方便位运算

③关于①我是瞎说的

既然多采用十六进制，那就先简单看看什么是十六进制

# 0x01 十六进制简单介绍

以0x或0X开头，使用数字0~9及字符A~F表示16个可能的值，这种进制方式一般称为十六进制。

一个int占4个字节，32位。

十六进制中0xF最大，二进制表示：1111，用4位即可表示出来，所以在用十六进制表示int时，通常0x后面跟8位数字/字符，这样就可以表示满一个int值。也就是前言中所看到的。

# 0x02 发现规律

通过前言中的代码可以发现基本上频繁出现的只有1，2，4，8几个数字而其他位置都是0占位。为什么会出现这种情况呢？

首先把上面的十六进制转换成二进制看一下：

`0x00000100`转换二进制`0001 0000 0000`

`0x00000200`转换二进制`0010 0000 0000` 

`0X00004000`转换二进制`0100 0000 0000 0000`

`0X00008000`转换二进制`1000 0000 0000`

转换后可以发现，1，2，4，8这几个值很特殊，在二进制中表示这几个数时都只要某一位为1，其他位用0占位即可表示。

换句话说，二进制的4位表示十六进制中的一个数字，而这4位中若只有其中一位为1的话，那么可能的值情况为1=2º，2=2¹，4=2²，8=2³。



这样做有什么好处呢？

# 0x03 这样做的好处

- 拿位移来说因为只有一个数字带值，其他都是0占位，位移时大脑中快速把十六进制转为二进制然后补0位即可。

  拿0x200来说，换算二进制我只要把2用二进制0010在大脑中展示出来，然后后面跟8个0就换算完成。如果0x200>>1,右移1位，相当于1后面的9个0被砍掉一个，左边高位补0。

  二进制表示由`0010 0000 0000`变成了`0001 0000 000`。值由512变成了256，可见右移1位相当于除以2。前面十六进制和二进制转换是在大脑中完成，转换到十进制我是笔算的，可能这是采用十六进制表示int原因之一吧。

  同样左移思路也是如此。

- 位与&/位或|

  位与/位或是对参与运算的数的二进制进行位与/位或。

  位与&：两数二进制对应位均为1时结果才为1，其余为0

  位或|：两数二进制对应位有一个为1时，结果位就为1

  在源码和框架中，很多时候需要存储一些状态组合，比如：

  ```java
     public Intent addFlags(int flags) {
          mFlags |= flags;
          return this;
      }
  ```

  最后在一些地方会根据状态组合的不同值来做出不同的响应。这时使用1，2，4，8这种格式的十六进制就很方便，因为不同的状态值只是在二进制的不同位上用1标记而已。这样最后可以根据mFlags的值二进制有多少位为1，基本就能判断有多少种状态。当然这里说的是位或。