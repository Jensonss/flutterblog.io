[
  {
    "title" : "5L杯子和3L杯子取出4L水的问题",
    "created_time" : "2017-09-20 17:23:02",
    "body" : "# 0x00 前言\r\n\r\n这道题和我之前的农夫过河、四人过桥问题都是一个类型的，不过该题较之前两道题更简单，因为涉及 元素更少。\r\n\r\n下面直接说下思路\r\n\r\n<!-- more -->\r\n\r\n# 0x01 思路\r\n\r\n4L和5L、3L的杯子有什么关系？找到关系，再从关系入手\r\n\r\n譬如4L可以用1L和3L合并得来，而3L可以直接通过3L杯子拿到。\r\n\r\n接下来就是如何拿到1L的量，而这又可以通过3L-2L得到，那么再继续2L又是如何得到呢？\r\n\r\n有现成的5L和3L，简单的就可以得到2L，所以实现步骤就很简单了：\r\n\r\n|  步骤  |   操作   | 5L杯子 | 3L杯子 |\r\n| :--: | :----: | :--: | :--: |\r\n|  1   |  3L装满  |  0   |  3   |\r\n|  2   | 3L倒入5L |  3   |  0   |\r\n|  3   |  3L装满  |  3   |  3   |\r\n|  4   | 3L倒入5L |  5   |  1   |\r\n|  5   |  5L清空  |  0   |  1   |\r\n|  6   | 3L倒入5L |  1   |  0   |\r\n|  7   |  3L装满  |  1   |  3   |\r\n|  8   | 3L倒入5L |  4   |  0   |\r\n|  9   |   完成   |  4   |  0   |\r\n\r\n上面是通过1L和3L合并得来的，下面通过5L-1L得到4L，下面看看实现步骤：\r\n\r\n| 步骤   | 操作     | 5L杯子 | 3L杯子 |\r\n| ---- | ------ | ---- | ---- |\r\n| 1    | 5L装满   | 5    | 0    |\r\n| 2    | 5L倒入3L | 2    | 3    |\r\n| 3    | 3L清空   | 2    | 0    |\r\n| 4    | 5L倒入3L | 0    | 2    |\r\n| 5    | 5L装满   | 5    | 2    |\r\n| 6    | 5L倒入3L | 4    | 3    |\r\n| 7    | 完成     | 4    | 3    |\r\n|      |        |      |      |\r\n\r\n这种方式实现步骤更简单一些。细想一下会发现，这两种方式都有点类似递归"
  },
  {
    "title" : "番茄工作法使用说明书",
    "created_time" : "2017-04-21 20:55:54",
    "body" : "今天花了点时间把番茄工作法这本书看完了，和以前上学时45分钟每节课的感觉差不多，只是这个时间更短，流程也更细化，容易让人集中注意力。\r\n\r\n先来几个问题看看中刀的人有多少：\r\n1.有拖延症，上午的工作要拖到下午，下午的工作要拖到明天或者有反正周六要加班，那就周五多玩玩，刷刷微博这样的思想。\r\n2.经常我们想看一本书，看了一点后就厌烦抛诸脑后，等过一段时间兴致又来了想继续读，发现前面的内容已经忘了不得已要从头开始，如此往复，一年到头一本书还在原地徘徊，年终总结时才悔恨不已。\r\n3.上班就开始干活，但是手头的事情刚干了一点，又一摊新的工作挤进来，然后倒手又去忙新的事情，经常下班了感觉忙了一天却没有一件拿得出手的已完成的活来交差。\r\n如果你有上面的一种或者几种那么番茄工作法适合你。\r\n\r\n<!-- more -->\r\n\r\n## 番茄工作法的历史\r\n番茄工作法是由弗朗西斯科·西里洛在1992年创建的，但其实在更早的时候西里洛就已经使用了。20世纪80年代西里洛还在大学时，由于学习效率低下作业完不成，就在想怎么让自己踏实的学一会，哪怕十分钟也行。如果有人监督帮忙掐表，会不会很好，后来西里洛找到了厨房定时器，形状酷似番茄，就这样他邂逅了番茄钟。\r\n\r\n![未命名.png](http:\/\/upload-images.jianshu.io\/upload_images\/1796052-be51678192608453.png?imageMogr2\/auto-orient\/strip%7CimageView2\/2\/w\/1240)\r\n\r\n## 什么是番茄工作法？\r\n简单的说就是列出要做的事，标记当天要完成的，设置闹钟为25分钟，然后从第一件事情开始做。还要有每日回顾、每日承诺、中断和预估等。\r\n\r\n```\r\n番茄工作法是一套简单的流程，它可以让我们提高时间观念、提升注意力、加强自我决策意识、改善目前不好的工作流程从而提高工作效率，当然这一切好处的前提是正确并长期的执行了番茄法。\r\n```\r\n\r\n## 番茄工作法需要哪些工具？\r\n一个番茄钟\r\n铅笔\/橡皮\r\n三张表格(活动清单、今日待办、记录)\r\n\r\n![fullsizerender.jpg](http:\/\/upload-images.jianshu.io\/upload_images\/1796052-3a5435880d169f91.jpg?imageMogr2\/auto-orient\/strip%7CimageView2\/2\/w\/1240)\r\n\r\n## 番茄工作法流程详解\r\n### 将近期要完成的活动\/任务加入到活动清单\r\n把近几天准备工作的内容填写到活动清单中，活动清单内容力求简洁，不要求别人看懂，只需要自己几个月后仍能看懂即可。\r\n如果某件事明确了必须在某时间之前完成，则可以在活动末尾加上最后期限作为提醒。\r\n\r\n\r\n![fullsizerender(1).jpg](http:\/\/upload-images.jianshu.io\/upload_images\/1796052-bcb5ae9b4fa83b5d.jpg?imageMogr2\/auto-orient\/strip%7CimageView2\/2\/w\/1240)\r\n\r\n\r\n### 从活动清单中选择今日要完成的几项抄入到今日待办中\r\n今日待办的任务一定是要从活动清单抄入过来的，如果是自己又单独创建的那活动清单有何意义？填写今日待办时要注意划分优先级(事情的重要程度)，然后给每个待办预估需要多少番茄钟来完成，在待办后面用方格表示出来。\r\n\r\n\r\n![fullsizerender(4).jpg](http:\/\/upload-images.jianshu.io\/upload_images\/1796052-6386cf28a2aa20ff.jpg?imageMogr2\/auto-orient\/strip%7CimageView2\/2\/w\/1240)\r\n\r\n\r\n```\r\n从开始的活动清单列举，到今日待办的筛选，有没有觉得原本杂乱无章的事情，现在有了头绪而且当天\b目标已经明确只需要放手去做了。无形中注意力已经转移到所选活动了。\r\n```\r\n### 准备好工作后，启动番茄钟时间设定为25分钟。\r\n注意每个番茄钟都是原子性的，即不能再分割，一旦番茄钟启动，25分钟必须从一而终。\r\n可能有人会有疑问：如果番茄钟期间渴了怎么办？有人打电话或者有同事来询问怎么办？别急，这些都是中断，参见步骤4。\r\n### 开始工作，直到番茄钟响铃结束\r\n工作期间可能会受到中断，在日常工作中，中断是不可完全避免的，需要自己处理好中断。\r\n中断有两种形式：内部中断和外部中断。\r\n```内部中断 是自己造成的，是直觉向大脑发出信号，告诉我让我去专注当下活动以外的事情。```\r\n\r\n比如工作了一会，突然想打开qq去群里扯皮几句，想起有个电话没有回复，水杯没水了要去续杯等，这些都是来自自身内部的本能，其实是想拖延，这时该怎么办？接受、记录然后继续番茄钟。\r\n首先看引起中断原因，如果是突然想起没有做的事情，那么可以在今日待办(如果想起的事情不紧急可以直接加入到活动清单中，并在左边加一个“U”表示计划外事件“unplanned”)下方添加一个“计划外紧急”栏目，记录中断原因(下图中的③)，并在今日待办的当前活动后面添加一个 撇号 ' (下图中的①)，表示当下活动产生一个内部中断，记录完成继续番茄钟。\r\n 至于说要聊天扯皮和续杯，等到番茄钟结束后再去，当然如果只是喝水那你想喝多少喝多少。\r\n如果作为初学者感觉内部中断太多，可以尝试缩小番茄钟为5、10、15分钟。当然番茄钟的每次更改至少要保持两个星期再次更改。\r\n```外部中断 是别人造成的，有人向你询问请你帮忙，等你答复，外部中断往往具有互动性。但是我们不能因为保护番茄钟就拒绝帮忙同事，毕竟低头不见抬头见的。```\r\n可以在番茄钟期间手机、邮件静音，\r\n同事来面谈，如果比较急可以商量稍后推迟下，用下一个番茄钟来解决中断事件，而不是在当前活动直接中断处理；如果不着急可以添加到计划外事件，同时在当前活动后添加一个减号 -(下图中的②)，表示受到一次外部中断；如果非常着急，那么不得已只有废弃当前的番茄钟，先帮同事解决问题，过后休息一会然后开启新的番茄钟开始专注起来。\r\n\r\n每个番茄钟结束都要在今日待办的当下活动方格中画×。如果当下活动已经完成则可以给活动内容划一条横线表示完成状态(下图中的③)。\r\n\r\n![fullsizerender(5).jpg](http:\/\/upload-images.jianshu.io\/upload_images\/1796052-4ab23cde90bb31c5.jpg?imageMogr2\/auto-orient\/strip%7CimageView2\/2\/w\/1240)\r\n\r\n### 休息\r\n小休时间一般为3-5分钟，每隔4个番茄钟就大休一次，大休一般15-30分钟。注意休息期间要站起来走动一下，让自己能消除对上一个番茄钟的思考，完全抽身出来放松下。可以泡杯茶或咖啡，去个厕所，窗台发呆等，总之拒绝任何用脑的活动。\r\n以下说明了休息时箭头所指从最佳到最差休息方式：\r\n![fullsizerender(3).jpg](http:\/\/upload-images.jianshu.io\/upload_images\/1796052-32cc2cfdbfaad96f.jpg?imageMogr2\/auto-orient\/strip%7CimageView2\/2\/w\/1240)\r\n\r\n### 开始下一个番茄钟，重复3-5步\r\n\r\n### 下班前记录\r\n记录什么内容？记录当天完成的番茄钟数、被打断数、今日待办完成数等，通过记录可以知晓自己承诺完成了多少，相差多少，如果差距很大，就要寻找原因。经过一段时间的记录，数据可视化，看自己的承诺和已完成是否越来越接近。通过记录发现总结不足，在以后的清单中持续改善。\r\n\r\n以上只介绍了番茄工作法流程和一些需要注意的点，其他一些边缘内容或者没有get到的点欢迎探讨。"
  },
  {
    "title" : "反转字符串",
    "created_time" : "2017-07-27 13:28:07",
    "body" : "# 0x00 前言\r\n\r\n比如abc，反转后cba\r\n\r\n\r\n\r\n# 0x01 实现\r\n\r\n```java\r\n\tpublic static String reverseStr(String str) {\r\n\t\tStringBuilder sb = new StringBuilder();\r\n\t\tfor (int i = str.length() - 1; i >= 0; i--) {\r\n\t\t\tsb.append(str.charAt(i));\r\n\t\t}\r\n\t\treturn sb.toString();\r\n\t}\r\n```\r\n\r\n上面这种是遍历所有字符串长度，复杂度为O(n)。\r\n\r\n<!-- more -->\r\n\r\n应该还有更好的方法:\r\n\r\n```java\r\n\tpublic static String reverse(String str) {\r\n\t\tint len = str.length();\r\n\t\tint max = len - 1;\r\n\t\tchar[] chars = str.toCharArray();\r\n\t\tfor (int i = 0; i < (len >> 1); i++) {\r\n\t\t\tchar pre = str.charAt(i);\r\n\t\t\tchar last = str.charAt(max);\r\n\t\t\tchars[i] = last;\r\n\t\t\tchars[max] = pre;\r\n\t\t\tmax--;\r\n\t\t}\r\n\t\treturn String.valueOf(chars);\r\n\t}\r\n```"
  },
  {
    "title" : "搞清minSDKVersion、targetSDKVersion和compileSDKVersion都是什么鬼",
    "created_time" : "2017-04-21 20:55:54",
    "body" : ">一直以来对这几个SDK版本概念都有点模糊不清，对于API的使用又会产生什么样的影响。所以今天花点时间来记录下。\r\n\r\n\r\n\r\n![屏幕快照 2017-04-19 下午12.09.45.png](http:\/\/upload-images.jianshu.io\/upload_images\/1796052-947f3215a5f6169e.png?imageMogr2\/auto-orient\/strip%7CimageView2\/2\/w\/1240)\r\n# minSDKVersion\r\n顾名思义是设置sdk最低版本的。作用就是操作系统会拒绝低于\r\n该标准的APP的安装。\r\n\r\n例如，minSDKVersion设置为16(Jelly Bean 4.1系统)，那么该APP将只能运行在4.1系统以上的设备中，想要在2.3系统上安装是不被允许的。\r\n\r\nminSDKVersion比较容易理解，经常让我混淆的时其他两个版本设置会对API产生的影响。\r\n\r\n<!-- more -->\r\n\r\n# targetSDKVersion\r\ntargetSDKVersion就是设置SDK目标版本，目标版本的设置就是为了告诉Android系统：本APP是设计计划给哪个API级别运行的。\r\n\r\n一般情况下目标版本设置为当前Android最新版本即可。既然是一般那也就有特殊情况，什么情况下需要修改目标版本呢？\r\n\r\n如果新发布的SDK版本会对UI显示甚至操作系统运行机制产生影响，而你的APP又没有做好应对措施，为了保证你的APP正常运行，那你需要降低目标版本。因为你的目标版本仍然是旧的SDK，所以在新版系统中那些新的变化会在你的APP中被忽略，继而保证其正常运行。\r\n\r\n例如，Android6.0系统增加了动态权限机制，如果为了追时髦，盲目把你的targetSDKVersion设置为23(6.0)，那么在需要使用权限的地方将会出现异常。为此，在你做好动态权限申请之前，为保障APP正常运行，你需要将目标版本设置低于23。\r\n\r\n# compileSDKVersion\r\ncompileSDKVersion是设置编译版本。\r\n\r\n一般来说编译目标版本是选择最新的SDK，这样可以及时使用体验到新的API提供的新功能。\r\n\r\n值得注意的是，如果minSDKVersion和compileSDKVersion版本差距比较大的话，可能会造成API的不兼容。例如，你的最低版本是2.3 ，但是编译版本是5.0，API中使用了4.0SDK提供的一些新API，这样的后果是在2.3系统中运行到该处代码时会发生异常崩溃。这是因为代码的不兼容造成的。如图：\r\n\r\n![屏幕快照 2017-04-19 下午1.05.00.png](http:\/\/upload-images.jianshu.io\/upload_images\/1796052-67bfb13669a8dce2.png?imageMogr2\/auto-orient\/strip%7CimageView2\/2\/w\/1240)\r\n\r\n如何解决这种API的不兼容呢？\r\n一种办法是提升minSDKVersion到新API使用的SDK版本，但是这种方法只是回避兼容性，并没有确实解决问题，而且还要放弃低版本部分市场。\r\n比较好的做法是在使用新API地方做设备版本的检查。Build.VERSION_SDK_INT常量表示当前Android设备的版本号。可以将该常量同新API版本进行比较，如果版本大于等于新版API版本号，则正常使用新API功能，否则使用旧的调用。兼容设置如下：\r\n\r\n![屏幕快照 2017-04-19 下午1.16.40.png](http:\/\/upload-images.jianshu.io\/upload_images\/1796052-a2d7e548c4a118cf.png?imageMogr2\/auto-orient\/strip%7CimageView2\/2\/w\/1240)\r\n\r\n>注意：compileSDKVersion是和编译器打交道的，而minSDKVersion和targetSDKVersion是和系统打交道的。"
  },
  {
    "title" : "关于Canvas的一些概念",
    "created_time" : "2017-08-03 14:46:20",
    "body" : "# 前言\r\n\r\n在Android开发中不管是图片的绘制还是控件的绘制都少不了**Canvas**的参与。\r\n\r\n**Canvas**如此重要，对其多一些了解自然是对开发有益的。\r\n\r\n# 获得对象\r\n\r\n有两种获得Canvas对象的方法：\r\n\r\n- 重写onDraw方法，使用参数中的Canvas\r\n- 直接创建Canvas对象\r\n\r\n<!-- more -->\r\n\r\n# 它有什么用\r\n\r\nCanvas一般译为“画布”。而画布一般只是用来承载画像的，显然在Android中叫Canvas为画布，显然狭隘了。因为Android开发中，Canvas不仅提供了动画特效还提供了常见图形绘制方法，比如圆形、矩形、扇形等。\r\n\r\n在进行绘制过程中，还需要借助Pain辅助，Paint可以理解为画笔。\r\n\r\n\r\n\r\n# 绘制图形方法\r\n\r\n- 绘制文字\r\n\r\n  `drawText(String text, float x, float y, Paint paint)`\r\n\r\n  `drawText(char[] text, int index, int count, float x, float y, Paint paint)`\r\n\r\n  `drawText(CharSequence text, int start, int end, float x, float y, Paint paint)`\r\n\r\n  **float x**：文本开始的x轴位置\r\n\r\n  **float y**：文本开始的y轴位置\r\n\r\n  **text**：要绘制的文本\r\n\r\n  **paint**: 使用的画笔\r\n\r\n  **start**：文本开始的位置\r\n\r\n  **end**：文本结束的位置\r\n\r\n  ​\r\n\r\n- 绘制圆形\r\n\r\n  `drawCircle(float cx, float cy, float radius, Paint paint)`\r\n\r\n  **float cx**：圆心x轴坐标\r\n\r\n  **float cy**：圆心y轴坐标\r\n\r\n  **float radius**：圆半径\r\n\r\n  **paint**：画笔\r\n\r\n  ​\r\n\r\n- 绘制线条\r\n\r\n  `drawLine(float startX, float startY, float stopX, float stopY, Paint paint)`\r\n\r\n  **float startX**：起点x坐标\r\n\r\n  **float startY**：起点y坐标\r\n\r\n  **float stopX**：终点x坐标\r\n\r\n  **float stopY**：终点y坐标\r\n\r\n  ​\r\n\r\n- 绘制椭圆\r\n\r\n  `drawOval(float left, float top, float right, float bottom, Paint paint)`\r\n\r\n  `drawOval(RectF oval, Paint paint)`\r\n\r\n  这里的两个方法可以是一样的，因为绘制一个**RectF**也是需要方法一中的四个点。\r\n\r\n  **float left**：左下\r\n\r\n  **float top**：左上\r\n\r\n  **float right**：右上\r\n\r\n  **float bottom**：右下\r\n\r\n  ​\r\n\r\n- 绘制弧度\r\n\r\n  `drawArc(float left, float top, float right, float bottom, float startAngle, float sweepAngle, boolean useCenter, Paint paint)`\r\n\r\n  ​\r\n\r\n  `drawArc(RectF oval, float startAngle, float sweepAngle, boolean useCenter, Paint paint)`\r\n\r\n  **float startAngle**：开始角度\r\n\r\n  **float sweepAngle**：扫过角度\r\n\r\n  **boolean useCenter**：是否和中心连线 \r\n\r\n  ​\r\n\r\n- 绘制矩形\r\n\r\n  `drawRect(float left, float top, float right, float bottom, Paint paint)`\r\n\r\n  `drawRect(Rect r, Paint paint)`\r\n\r\n  ​\r\n\r\n- 绘制多边形\r\n\r\n  多边形绘制需要用到Path，路径类\r\n\r\n  用到moveTo，lineTo等常用方法\r\n\r\n  `moveTo(float x, float y)`\r\n\r\n  `lineTo(float x, float y)`\r\n\r\n  ​\r\n\r\n- 绘制赛贝尔曲线\r\n\r\n  赛贝尔曲线的绘制也用到了Path。\r\n\r\n  `quadTo(float x1, float y1, float x2, float y2)`\r\n\r\n  ​\r\n\r\n- 绘制点\r\n\r\n  `drawPoint(float x, float y, Paint paint)`\r\n\r\n  `drawPoints(float[] pts, Paint paint)`\r\n\r\n  **float x**：点x轴坐标\r\n\r\n  **float y**：点y轴坐标\r\n\r\n  **float pts**：点数组，每两个值组合一个点，最后如果不够2个点则忽略。\r\n\r\n  ​\r\n\r\n- 绘制图片\r\n\r\n  `drawBitmap(Bitmap bitmap, Matrix matrix, Paint paint)`\r\n\r\n  ​\r\n\r\n  ​\r\n\r\n# 动画方法\r\n\r\n- 位移\r\n\r\n  `translate(float dx, float dy)`\r\n\r\n  **float dx**：x轴移动距离\r\n\r\n  **float dy**：y轴移动距离\r\n\r\n  ​\r\n\r\n- 缩放\r\n\r\n  `scale(float sx, float sy)`\r\n\r\n  `scale(float sx, float sy, float px, float py)`\r\n\r\n  **float sx**：x轴放大倍数\r\n\r\n  **float sy**：y轴放大倍数\r\n\r\n  **float px, float py**：以该点为中心缩放\r\n\r\n- 旋转\r\n\r\n  `rotate(float degrees)`\r\n\r\n  `rotate(float degrees, float px, float py)`\r\n\r\n  **float degrees**：旋转角度\r\n\r\n  **float px, float py**：以px，py组成的点为中心旋转degrees角度\r\n\r\n\r\n\r\n# save和restore\r\n\r\n- save保存画布\r\n\r\n  把save之前的数据保存起来，以便后续的操作在一个新的图层。\r\n\r\n- restore合并图层\r\n\r\n  把save之前和之后的多个图层进行合并"
  },
  {
    "title" : "关于Intent那些事",
    "created_time" : "2017-07-17 15:51:08",
    "body" : "# 0x00 前言\r\n\r\nIntent，译为“意图”。从汉语角度理解，意图是什么意思？意图谋反，就是想要谋反。所以意图可以通俗理解为想要做什么。当然这里的“想要做什么”是告诉Android系统的而不是别人。\r\n\r\n虽然想要做什么就告诉Android系统，但是并不是为所欲为的。通过Intent只能请求三大组件：Activity，Service，Broadcast。\r\n\r\n<!-- more -->\r\n\r\n# 0x01 抽象理解\r\n\r\n因为涉及三个组件，这里不会单独讲每个组件和Intent。startActivity不要叫启动Activity，startService也不要叫启动服务，我们把他们抽象为一个请求。通过Intent向Android发出请求，Android去哪给你匹配呢？你不注册系统当然没地方找，所以我们要在AndroidManifest.xml中进行注册(广播可以动态注册)。注册的作用不光告诉系统可以从这找我，还告诉系统本组件只接收满足要求的请求。说到要求这就要提到IntentFilter了，每个IntentFilter代表一种要求，一个组件可以有多种要求即多个IntentFilter，但只要满足一种就能请求成功。系统所要做的就是把接收到得请求Intent和组件的要求IntentFilter进行匹配，如果匹配上了则牵手成功~\r\n\r\n这个流程抽象为：\r\n\r\n![请求流程](关于Intent那些事\/请求流程.png)\r\n\r\n# 0x02 分类\r\n\r\n通过Intent告诉Android系统“我想要做什么”，可以有两种方式阐述，一种是直白的表述“我想要启动某个页面”，我们称之为显性，另一种是告诉系统“我想要一个满足我某些要求的页面”,至于是哪个或哪几个页面由系统决定，如果是多个可以返回列表给我，这种称之为隐性。\r\n\r\n>Intent从请求性质上分为显性和隐性两种。\r\n\r\n\r\n\r\n由于显性Intent指定了具体的请求，如下：\r\n\r\n```java\r\nintent.setClass(Context packageContext, Class<?> cls)\r\n```\r\n\r\n所以匹配并不会发生在显性Intent,显性组件注册时一般这样的：\r\n\r\n```xml\r\n<activity android:name=\".ThirdActivity\" \/>\r\n```\r\n\r\n没有多余的要求。\r\n\r\n在抽象理解中，IntentFilter匹配只是为隐性准备的。\r\n\r\n下面要了解具体匹配规则如何：\r\n\r\n# 0x03 匹配规则\r\n\r\n要了解匹配规则是怎样的，首先要知道是从哪几方面入手匹配的，由于Android系统也是根据组件注册的要求进行匹配，所以看看注册时的IntentFilter有哪些属性就知道要匹配哪些方面了：\r\n\r\n```xml\r\n <intent-filter>\r\n     <action android:name=\"android.intent.action.CALL\" \/>\r\n     <category android:name=\"android.intent.category.DEFAULT\" \/>\r\n     <data android:mimeType=\"image\/*\"\/>\r\n     <data android:scheme=\"http\"\/>\r\n <\/intent-filter>\r\n```\r\n\r\n显然系统匹配也就是匹配category、action和data。\r\n\r\n下面分别来看看这三种是分别如何匹配的：\r\n\r\n**注意：下面将原理、源码、实例三管齐下** \r\n\r\n- category如何匹配\r\n\r\n  > 匹配原理：\r\n  >\r\n  > ①在请求的Intent中需要在IntentFilter找到匹配项才算匹配成功。\r\n  >\r\n  > ②如果Intent没有添加任何category，那么系统会自动给你添加android.intent.category.DEFAULT，所以如果你的三大组件是为隐性启动准备的，那么你就要在注册时手动添加<category android:name=\"android.intent.category.DEFAULT\" \/>。\r\n  >\r\n  > ③当然如果添加了其他值得category也可以不用添加default了。\r\n\r\n  ​\r\n\r\n\r\n\r\n- action如何匹配\r\n\r\n  > 匹配原理：\r\n  >\r\n  > ①IntentFilter如果没有声明action，则所有Intent都不能匹配成功。\r\n  >\r\n  > ②若IntentFilter声明了action，而Intent没有不带任何action，则匹配通过。\r\n  >\r\n  > ③若IntentFilter声明了action，Intent也声明了action，那么Intent中action必须是IntentFilter中action的子集才能匹配成功。\r\n\r\n\r\n\r\n- data如何匹配\r\n\r\n  data分为两部分，MIME type和URI。\r\n\r\n  - MIME type就是表明数据格式类型，方便系统正确解析处理\r\n\r\n    MIME type又分为两部分：主类型type和子类型subtype，以\"\/\"分割。比如：\r\n\r\n    video\/mp4，image\/jpeg。\r\n\r\n  - URI 唯一资源标识符\r\n\r\n    URI分为scheme、Authory和path三部分。\r\n\r\n    scheme表示采用协议，既可以是http网络协议也可以是本地content和file协议。\r\n\r\n    Authority由host和port组成。\r\n\r\n    path表示文件在host中具体位置。\r\n\r\n  了解了data组成，下面说说data匹配原理\r\n\r\n  > 匹配原理：\r\n  >\r\n  > ①data只匹配IntentFilter中所拥有部分。\r\n  >\r\n  > ②如果Intent中既没有MIME，也没用URI，那么IntentFilter中也都不能有才能通过。\r\n  >\r\n  > ③若Intent没有指定类型，只指定了URI，那么IntentFilter必须没有指定类型。特殊情况下能根据URI推断出类型，这种情况按⑤情况算。\r\n  >\r\n  > ④若Intent只指定了类型，没有URI。那么IntentFilter也必须没有指定URI\r\n  >\r\n  > ⑤若Intent同时指定了类型和URI，那么必须都匹配上才能通过。"
  },
  {
    "title" : "垃圾回收机制~关于GC",
    "created_time" : "2017-07-26 20:25:26",
    "body" : "# 0x00 前言\r\n\r\n很多人通过Java才听说GC的，甚至刚开始做开发时以为GC是Java独有的。其实不然，GC是一项很古老的技术，与Lisp语言在20世纪60年代一同出现的。\r\n\r\n虽然GC不是Java独有的，但是不得不承认，GC很大成分上是因为Java的广泛应用才被广大开发者所熟知的。\r\n\r\n说到GC不得不提一个人：John McCarthy，Lisp语言之父和人工智能之父，同时还是GC之父，其论文中提到的算法就是标记-清除算法。\r\n\r\n如果是一门语言可以从基础语法学起，但是GC该如何学习呢？\r\n\r\n**其实问答形式就是最好的学习方式**\r\n\r\n# 0x01 什么是GC\r\n\r\nGC(垃圾回收)，通过查找无效对象释放空间达到自动管理内存的目的。\r\n\r\n<!-- more -->\r\n\r\n# 0x02 如何确定垃圾\r\n\r\n要查找垃圾对象，首先要知道什么样对象才算是垃圾对象才好对症下药。\r\n\r\n**在内存中，不再被引用的对象就称为垃圾对象**\r\n\r\n现在的问题又转到如何确定一个对象是否被引用？\r\n\r\n首先想到一种方法是给每个对象都添加一个计数器功能，这个计数器用例记录引用自己的指针数量，每多一个引用数量计数器就增加1，每减少一个引用数量计数器就减少1，如果计数器为0，说明没有其他对象引用当前对象，那么这个对象就是垃圾对象，可以被回收。这种方式叫做**引用计数法**\r\n\r\n引用计数法虽然容易理解，但是因为缺点也很明显，所以不得不另寻它法。这时**可达性分析法**就登场了。\r\n\r\n**可达性分析法**也可以称为**跟踪收集器法**，找一个对象作为GC的根节点(Root)，通过对对象的连续引用形成一条引用链，如果一个对象能够通过直接或间接的到达Root称为对象可达，否则称为对象不可达。对于不可达对象就可以判定为垃圾对象。\r\n\r\n\r\n\r\n# 0x03 如何回收垃圾\r\n\r\n上一节知道了哪些对象是垃圾，现在该讨论有哪些方式能回收垃圾了。\r\n\r\n常用的GC算法有**标记-清除算法**、**标记-整理算法**、**复制算法**、**分代GC**、**G1 GC**。\r\n\r\n## 标记-清除算法\r\n\r\n**标记-清除算法(Mark-Weep)**看名字就知道分为标记和清除两个阶段。\r\n\r\n**注意一点这里的标记是指标记活着的对象，而非死对象。**\r\n\r\n**标记阶段**从Root开始首先标记Root能直接访问的对象，然后递归通过指针能访问到得对象，同时把这些对象做标记。\r\n\r\n**清除阶段**遍历堆内存，把未被标记的对象清除以达到垃圾回收目的。\r\n\r\n图片表示如下：\r\n\r\n![标记清除](http:\/\/othg5ggzi.bkt.clouddn.com\/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4.png)\r\n\r\n图中问题很明显：回收后会产生大量的内存碎片，不利于对内存连续要求的数据结构的使用，譬如数组。\r\n\r\n\r\n\r\n## 标记-整理算法\r\n\r\n**标记-整理算法也叫标记-压缩**，这里的标记阶段和上面的标记-清除的标记阶段完全一样，不同的是整理阶段是对清除阶段的改进。\r\n\r\n整理阶段简单来说就是把活着的对象移动到一端，然后从边界处清除另一端所有空间。\r\n\r\n图片表示如下：\r\n\r\n![标记整理](http:\/\/othg5ggzi.bkt.clouddn.com\/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86.png)\r\n\r\n\r\n\r\n优点是有效利用堆，但又不会产生内存碎片。\r\n\r\n缺点是浪费时间，整理阶段要搜索三次堆内存，而标记-清除算法的清除阶段只搜索一次堆内存。\r\n\r\n\r\n\r\n## 复制算法\r\n\r\n**复制算法**是把堆内存分为两块空间标识为from和to。当from空间被占满时，GC把活着的对象复制到to空间，复制完成后把from和to标识互换，GC结束。为了保证from空间对象都能复制到to空间，须要保证from和to空间大小一致。\r\n\r\n图片表示如下：\r\n\r\n![复制算法](http:\/\/othg5ggzi.bkt.clouddn.com\/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png)\r\n\r\n\r\n\r\n复制算法吞吐量优秀，分配内存速度快，没有碎片，但是堆内存利用率低下\r\n\r\n\r\n\r\n## 分代GC\r\n\r\n根据日常研发总结出一个经验“大部分对象在生成后不久就变成垃圾，很少能活的久”。据此经验，分代GC引入了“年龄”的概念。经历过一次GC后活下来的对象年龄+1。\r\n\r\n**分代GC**把内存分为新生代和老年代，针对不同的年代使用不同的GC算法。刚生产的对象称为新生代对象，活到一定年龄的称为老年代对象。\r\n\r\n我们把对新对象执行的GC称为**新生代GC(minor GC)**， 把老年代对象执行的GC称为**老年代GC(major GC)**。\r\n\r\n**分代GC属于综合性GC，对上面GC算法的综合使用。**\r\n\r\n图片表示如下：\r\n\r\n![分代GC](http:\/\/othg5ggzi.bkt.clouddn.com\/%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6.png)\r\n\r\n如图所示：**新生代空间包括Eden，S0和S1三个区，老年代空间是Old区**\r\n\r\n其中新生代每次回收只有少数对象存活，可以使用复制算法，而老年代对象存活率高也没用额外空间，可以使用标记-整理和标记清除算法。\r\n\r\n刚开始时，Eden用来存放刚创建的对象，S0和S1为空，如果发生GC，Eden区幸存对象转移到S0区，如果S0区已有数据前提下再次进行GC时，会把Eden和S0区存活对象转移到S1区，同时清空Eden和S0，然后交换S0和S1标识。经过一定次数的GC仍然存活的对象转移到老年代。\r\n\r\n\r\n\r\n## G1 GC\r\n\r\n\r\n\r\n\r\n\r\n# 0x04 谁来回收垃圾\r\n\r\n知道了哪些对象是垃圾，也知道了用哪些算法来回收垃圾，然后呢？直接满地调用算法回收垃圾吗？\r\n\r\n当然不是！GC要分时机且统一来回收垃圾，这里是由垃圾收集器来来根据时机统一回收垃圾对象。\r\n\r\n由于各方面需求原因，垃圾收集器也是有多种的。\r\n\r\n\r\n\r\n未完待续......."
  },
  {
    "title" : "了解Http",
    "created_time" : "2017-08-30 11:57:11",
    "body" : "# 0x00 前言\r\n\r\n只要是编程，无论学哪种语言，网络就是逃不开的话题，而Http又是网络上层协议应用最广泛的一种。\r\n\r\n那么该如何学习Http？下图是个人总结的学习Http比较容易让人记忆的思维导图。下面的介绍也是按照该四维导图来说明。\r\n\r\n![了解Http](http:\/\/othg5ggzi.bkt.clouddn.com\/%E4%BA%86%E8%A7%A3http.png)\r\n\r\n<!-- more -->\r\n\r\n# 0x01 Http历史\r\n\r\n## 一次web请求\r\n\r\n当我们在浏览器URL窗口输入www.jensondev.me时，就会看到我们需要的内容。这期间发生了什么？\r\n\r\n懂一点的人会说浏览器收到URL请求，发送给服务器，然后接收服务器内容并显示。\r\n\r\n更懂一点的人会说浏览器收到URL进行DNS解析，发送给服务器，然后接收服务器内容并显示\r\n\r\n那么什么是DNS，什么又是URL，又都有什么用？\r\n\r\n## DNS\r\n\r\nDNS，全名Domain Name System，域名解析系统。\r\n\r\n域名的出现是为了方便记忆，但是通过网络定位到对应服务器需要的是IP，DNS就是提供域名到IP得解析服务。\r\n\r\n## URL和URI\r\n\r\nURL，Uniform Resource Locator，统一资源定位符，URL就是浏览器访问页面输入的网址。\r\n\r\nURI，Uniform Resource Identifier ，统一资源标识符，\r\n\r\nURI表示互联网中某一资源，而URL表示资源的地点。URL是URI子集。\r\n\r\nURI格式如图：\r\n\r\n![URI格式](http:\/\/othg5ggzi.bkt.clouddn.com\/URI%E6%A0%BC%E5%BC%8F.png)\r\n\r\n## Http诞生\r\n\r\n1989年CERN的Tim Berners-Lee提出让身处两地的研究者进行交流和知识共享的设想。\r\n\r\n当时的理念很简单很纯粹：就是借助多文档相互关联形成一个超文本，形成可以相互参阅的WWW。\r\n\r\n这一理念的实现需要三个技术共同支撑：指定文档地址的URL，标记文本的语言HTML，传输文档的协议Http。\r\n\r\n1990年CERN研发世界第一台Web服务器和浏览器。同年Http协议诞生，但是没有作为标准被建立，所以这个时候版本是1.0以前，被称为Http0.9。\r\n\r\n1995年6月Http标准被公布，正式命名为Http1.0\r\n\r\n1997年1月Http1.1公布，也是目前的主流版本。\r\n\r\n\r\n\r\n## TCP\/IP\r\n\r\n上面介绍了Http的历史信息，但是Http是基于TCPIP的，要了解Http还要了解下TCPIP。\r\n\r\n电脑之间如何通信？\r\n\r\n要实现电脑之间通信要适用不同的硬件、不同的语言、不同的系统。而这需要一个通用的协议。\r\n\r\nTCPIP就是在这基础上诞生的，TCPIP从上至下分为4层：应用层、传输层、网络层和数据链路层。\r\n\r\n![TCPIP分层](http:\/\/othg5ggzi.bkt.clouddn.com\/TCPIP%E5%88%86%E5%B1%82.png)\r\n\r\n把 TCP\/IP 层次化是有好处的。比如，如果互联网只由一个协议统筹，某个地方需要改变设计时，就必须把所有部分整体替换掉。而分层之后只需把变动的层替换掉即可。把各层之间的接口部分规划好之后，每个层次内部的设计就能够自由改动了。\r\n\r\n数据流每经过一层都会添加当前层首部信息：\r\n\r\n![tcpip首部](http:\/\/othg5ggzi.bkt.clouddn.com\/TCPIP%E5%88%86%E5%B1%82%E9%A6%96%E9%83%A8.png)\r\n\r\n\r\n\r\n\r\n\r\n# 0x02 初涉Http\r\n\r\n## 无状态\r\n\r\nHttp协议设计简洁，仅仅实现数据交互，所以也是无状态协议。HTTP 协议自身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理。\r\n\r\n但是随着web的发展，很多网站需要状态保存，所以引入了cookie技术。\r\n\r\n## 请求方法\r\n\r\nHttp协议通过请求和响应进行通信交互，在请求时不同的方法有不同的应用场景。\r\n\r\n先看下方法分类：\r\n\r\n| 方法      | 说明          | 支持版本    |\r\n| ------- | ----------- | ------- |\r\n| GET     | 获取资源        | 1.0、1.1 |\r\n| POST    | 传输实体主体      | 1.0、1.1 |\r\n| PUT     | 传输文件        | 1.0、1.1 |\r\n| HEAD    | 获得报文首部      | 1.0、1.1 |\r\n| DELETE  | 删除文件        | 1.0、1.1 |\r\n| OPTIONS | 询问支持的方法     | 1.1     |\r\n| TRACE   | 追踪路径        | 1.1     |\r\n| CONNECT | 要求用隧道协议连接代理 | 1.1     |\r\n| LINK    | 建立和资源之间的联系  | 1.0     |\r\n| UNLINK  | 断开连接关系      | 1.0     |\r\n\r\n- GET：获取资源\r\n- POST：传输实体主体\r\n- PUT：传输文件\r\n- HEAD：获得报文首部\r\n- DELETE：删除文件\r\n- OPTIONS：询问支持的方法\r\n- TRACE：追踪路径\r\n- CONNECT：要求用隧道协议连接代理\r\n\r\n## 持久连接\r\n\r\nHTTP 协议的初始版本中，每进行一次 HTTP 通信就要断开一次TCP 连接，这种情况在早期传输的都是小型文本消息时性能上不显优劣。但是随着近年互联网的发展，通信数据愈来愈大，每次通信都要新建和断开连接，耗费时间增加的同时也增加了通信开销。\r\n\r\n为了解决TCP这个问题，HTTP\/1.1 和一部分的 HTTP\/1.0 想出了持久连接（HTTP Persistent Connections，也称为 HTTP keep-alive 或HTTP connection reuse）的方法。\r\n\r\n持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。\r\n\r\n持久连接的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。另外，减少开销的那部分时间，使HTTP 请求和响应能够更早地结束，这样 Web 页面的显示速度也就相应提高了。\r\n在 HTTP\/1.1 中，所有的连接默认都是持久连接，但在 HTTP\/1.0 内并未标准化，可以通过首部的**connection = keep-alive**属性实现持久连接。\r\n\r\n\r\n\r\n# 0x03 报文\r\n\r\n用于 HTTP 协议交互的信息被称为 HTTP 报文，所以在Http中分为请求报文和响应报文两种。\r\n\r\n而 报文又分为报文首部和报文主体两块。\r\n\r\n## 首部\r\n\r\n**根据请求报文和相应报文，首部也分为请求首部和响应首部。**\r\n\r\n**请求首部**包括请求行、请求首部字段、通用首部字段、实体首部字段\r\n\r\n**响应首部**包括状态行、响应首部字段、通用首部字段、实体首部字段\r\n\r\n请求报文和响应报文结构如图：\r\n\r\n![请求报文和响应报文结构](http:\/\/othg5ggzi.bkt.clouddn.com\/%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E5%92%8C%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E7%9A%84%E7%BB%93%E6%9E%84.png)\r\n\r\n请求报文和响应报文结构实例如图：\r\n\r\n![请求报文和响应报文结构实例](http:\/\/othg5ggzi.bkt.clouddn.com\/%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E5%92%8C%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E7%9A%84%E7%BB%93%E6%9E%84%E5%AE%9E%E4%BE%8B.png)\r\n\r\n\r\n\r\n\r\n\r\n## 状态码\r\n\r\n状态码的任务就是对返回结果的描述。\r\n\r\n![状态码](http:\/\/othg5ggzi.bkt.clouddn.com\/%E7%8A%B6%E6%80%81%E7%A0%81.png)\r\n\r\n通过状态码我们可以知道服务器是否正确处理了我们的请求，如果出错了，那原因是什么。\r\n\r\n状态码以3位数字和短语组成，数字第一位指定响应类别，响应类别主要有5种：\r\n\r\n| 状态码  | 名称                     | 原因短语          |\r\n| ---- | ---------------------- | ------------- |\r\n| 1XX  | Informational（信息性状态码）  | 接收的请求正在处理     |\r\n| 2XX  | Success（成功状态码）         | 请求正常处理完毕      |\r\n| 3XX  | Redirection（重定向状态码）    | 需要进行附加操作以完成请求 |\r\n| 4XX  | Client Error（客户端错误状态码） | 服务器无法处理请求     |\r\n| 5XX  | Server Error（服务器错误状态码） | 服务器处理请求出错     |\r\n\r\n### 2XX\r\n\r\n- 200\u0007 OK \r\n\r\n  表示从客户端发来的请求在服务器端被正常处理了\r\n\r\n- 204\u0007 No\u0007Content\r\n\r\n  该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体。比如，当从浏览器发出请求处理后，返回 204 响应，那么浏览器显示的页面不发生更新\r\n\r\n- 206\u0007 Partial\u0007Content\r\n\r\n  该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。\r\n\r\n### 3XX\r\n\r\n- 301 Moved\u0007Permanently\r\n\r\n  永久性重定向。该状态码表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。也就是说，如果已经把资源对应的 URI保存为书签了，这时应该按 Location 首部字段提示的 URI 重新保存。像下方给出的请求 URI，当指定资源路径的最后忘记添加斜杠“ \/”，就会产生 301 状态码\r\n\r\n- 302\u0007 Found\r\n\r\n  临时性重定向。该状态码表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问。\r\n\r\n  和 301 Moved Permanently 状态码相似，但 302 状态码代表的资源不是被永久移动，只是临时性质的。换句话说，已移动的资源对应的URI 将来还有可能发生改变。比如，用户把 URI 保存成书签，但不会像301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码的页面对应的 URI。\r\n\r\n- 303\u0007 See\u0007Other\r\n\r\n  该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET方法定向获取请求的资源。\r\n  303 状态码和 302 Found 状态码有着相同的功能，但 303 状态码明确表示客户端应当采用 GET 方法获取资源，这点与 302 状态码有区别。比如，当使用 POST 方法访问 CGI 程序，其执行后的处理结果是希望客户端能以 GET 方法重定向到另一个 URI 上去时，返回 303 状态码。虽然 302 Found 状态码也可以实现相同的功能，但这里使用 303 状态码是最理想的。 \r\n\r\n- 304\u0007 Not\u0007Modified\r\n\r\n  该状态码表示客户端发送附带条件的请求 A 时，服务器端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回 304 NotModified（服务器端资源未改变，可直接使用客户端未过期的缓存）。\r\n  304 状态码返回时，不包含任何响应的主体部分。 **304 虽然被划分在3XX 类别中，但是和重定向没有关系**\r\n\r\n- 307\u0007 Temporary\u0007Redirect\r\n\r\n  临时重定向。该状态码与 302 Found 有着相同的含义。尽管 302 标准禁止 POST 变换成 GET，但实际使用时大家并不遵守。307 会遵照浏览器标准，不会从 POST 变成 GET。但是，对于处理\r\n  响应时的行为，每种浏览器有可能出现不同的情况。\r\n\r\n### 4XX\r\n\r\n- 400\u0007 Bad\u0007Request\r\n\r\n  该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码\r\n\r\n- 401\u0007 Unauthorized\r\n\r\n  该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。另外若之前已进行过 1 次请求，则表示用户认证失败。返回含有 401 的响应必须包含一个适用于被请求资源的WWWAuthenticate 首部用以质询（challenge）用户信息。当浏览器初次接收到 401 响应，会弹出认证用的对话窗口。\r\n\r\n- 403\u0007 Forbidden\r\n\r\n  该状态码表明对请求资源的访问被服务器拒绝了。服务器端没有必要给出拒绝的详细理由，但如果想作说明的话，可以在实体的主体部分对原因进行描述，这样就能让用户看到了。未获得文件系统的访问授权，访问权限出现某些问题（从未授权的发送源 IP 地址试图访问）等列举的情况都可能是发生 403 的原因。\r\n\r\n- 404\u0007 Not\u0007Found\r\n\r\n  该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用\r\n\r\n\r\n\r\n### 5XX\r\n\r\n- 500\u0007 Internal\u0007Server\u0007Error\r\n\r\n  该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web应用存在的 bug 或某些临时的故障\r\n\r\n- 503 \u0007Service\u0007Unavailable\r\n\r\n  该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入 RetryAfter 首部字段再返回给客户端\r\n\r\n## 认证\r\n\r\n认证有什么用？\r\n\r\n用来限制某些页面只想让特定人查看，为此，服务器就要通过某种方式能知晓用户身份是否符合该特定人群来给出适合的响应。\r\n\r\nHttp1.1中使用的认证方式有：\r\n\r\n- BASIC 认证（基本认证）\r\n- DIGEST 认证（摘要认证）\r\n- SSL 客户端认证\r\n- FormBase 认证（基于表单认证）\r\n\r\n这里主要讲下基本认证和摘要认证\r\n\r\n### BASIC 认证（基本认证）\r\n\r\nBASIC认证是从Http1.0就定义的认证方式。\r\n\r\n首先看下基本认证流程：\r\n\r\n![基本认证流程](http:\/\/othg5ggzi.bkt.clouddn.com\/%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B.png)\r\n\r\n从流程图很容易看出，操作a中直接向服务器请求图片时，由于服务器开启了基本认证，而客户端没有携带认证信息，这时操作b中给客户端返回了401，在上面状态码中我们了解到401Unauthorizeds是由于没有认证信息才出现的情况。\r\n\r\n那么如何添加Basic认证信息呢？看操作c，在请求头首部中添加**Authorization: Basic YnJpYW4tdG90dHk6T3ch**首部信息，其中YnJpYW4tdG90dHk6T3ch这个乱码为使用Base64编码后生成的字符串。一般来说参与编码的是用户名和密码，且用户名和密码之间使用冒号：隔开，即base64（username:pwd）==YnJpYW4tdG90dHk6T3ch。\r\n\r\n最后操作d接受基本认证信息，返回正确响应报文。\r\n\r\n**注意：基本认证简单但不安全，base64只是一直编码而非加密，很容易被有恶意的人通过解码得知用户名密码。所以通过基本认证发送的信息可以说是明文发送。为了保证数据安全最好配合SSL一起使用。**\r\n\r\n另外就算密码不被切取，一旦认证信息被拦截，第三者就可以凭借拿到的认证信息进行重放攻击，这时本该该用户看到的文档权限被第三者一览无余。\r\n\r\n### DIGEST 认证（摘要认证）\r\n\r\n可以认为摘要认证是对基本认证的一个改进：\r\n\r\n永远不会以明文方式在网络上发送密码。\r\n可以防止恶意用户捕获并重放认证的握手过程。\r\n可以有选择地防止对报文内容的篡改。\r\n防范其他几种常见的攻击方式。\r\n\r\n看下摘要认证流程图：\r\n\r\n![摘要认证流程](http:\/\/othg5ggzi.bkt.clouddn.com\/%E6%91%98%E8%A6%81%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B.png)\r\n\r\n摘要认证中传递的信息不是密码本身，而是通过一个算法取得的密码摘要部分内容。这样防止了密码被切取的风险。为了防止重放攻击，服务器会生成一个nonce随机数，客户端使用密码和随机数通过算法计算出摘要，这样每次请求的摘要都是不一样的。\r\n\r\n\r\n\r\n## Https\r\n\r\n\r\n\r\n未完待续。。。。\r\n\r\n# 0x04 其他\r\n\r\n\r\n\r\n## web内容\r\n\r\n\r\n\r\n## web攻击\r\n\r\n\r\n\r\n## 其他功能\r\n\r\n\r\n\r\n### Http2.0\r\n\r\n\r\n\r\n### SPDY\r\n\r\n\r\n\r\n### WebSocket"
  },
  {
    "title" : "两个栈实现队列功能",
    "created_time" : "2017-05-18 16:28:16",
    "body" : "# 0x00 前言\r\n\r\n用2个栈实现队列，首先要明白栈和队列的区别：栈是FILO，队列是FIFO。明白了这两点就比较容易实现了。\r\n\r\n\r\n\r\n# 0x01 分析 \r\n\r\n栈是一端开口，队列是两端开口，如果要让栈实现队列功能，需要2个栈一个负责进数据，一个负责出数据。为了保证出数据的顺序，在出数据栈不为空时，入数据的栈中数据不能往出数据的栈里存。\r\n\r\n<!-- more -->\r\n\r\n# 0x02 实现\r\n\r\n在2个栈数据都为空时注意抛出异常。\r\n\r\n```\r\n\r\nimport java.util.Stack;\r\n\r\n\/**\r\n * 两个栈实现队列功能\r\n * @author jenson\r\n *\/\r\npublic class StackToQueue {\r\n\tprivate Stack<Integer> inStack = new Stack<>();\r\n\tprivate Stack<Integer> outStack = new Stack<>();\r\n\r\n\t\/**\r\n\t * 添加元素\r\n\t * @param value\r\n\t *\/\r\n\tpublic void add(int value) {\r\n\t\tinStack.push(value);\r\n\t}\r\n\r\n\t\/**\r\n\t * 出队列\r\n\t * @return\r\n\t *\/\r\n\tpublic int poll() {\r\n\t\tif (inStack.isEmpty() && outStack.isEmpty()) {\r\n\t\t\tqueueEmptyException();\r\n\t\t} else {\r\n\t\t\tif (outStack.isEmpty()) {\r\n\t\t\t\treverse();\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn outStack.pop();\r\n\t}\r\n\r\n\t\/**\r\n\t * 查看队列头的元素 <\/br>\r\n\t * 注意一点：如果出栈队列为空，则把入栈数据倒入到处栈，然后从出栈取<br>\r\n\t * 如果两个栈都为空抛异常\r\n\t * \r\n\t *\/\r\n\tpublic int peek() {\r\n\t\tif (inStack.isEmpty() && outStack.isEmpty()) {\r\n\t\t\tqueueEmptyException();\r\n\t\t} else {\r\n\t\t\tif (outStack.isEmpty()) {\r\n\t\t\t\treverse();\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn outStack.peek();\r\n\r\n\t}\r\n\r\n\t\/**\r\n\t * 入栈数据倒入到出栈\r\n\t *\/\r\n\tprivate void reverse() {\r\n\t\twhile (!inStack.isEmpty()) {\r\n\t\t\toutStack.push(inStack.pop());\r\n\t\t}\r\n\t}\r\n\r\n\tprivate void queueEmptyException() {\r\n\t\tthrow new RuntimeException(\"队列为空\");\r\n\t}\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tStackToQueue stackToQueue = new StackToQueue();\r\n\t\tstackToQueue.add(9);\r\n\t\tstackToQueue.add(5);\r\n\t\tstackToQueue.add(2);\r\n\t\tstackToQueue.add(7);\r\n\r\n\t\tSystem.out.println(stackToQueue.peek());\r\n\t\tSystem.out.println(stackToQueue.poll());\r\n\t}\r\n}\r\n\r\n```"
  },
  {
    "title" : "农夫带着狼、羊和白菜过河问题",
    "created_time" : "2017-05-10 17:55:25",
    "body" : "一个农夫带着一只狼，一只羊和一棵白菜来到河边要过河，船只狭小，一次农夫只能带一样物品过河，如果农夫不在场，狼会吃羊，羊也会吃白菜。那么农夫如何才能过河或者证明出无解。\r\n\r\n\r\n\r\n这是一道自古有之的谜题，但是一些公司也有把这作为笔试题...\r\n\r\n看到这个题我的第一个想法就是船上系一根绳，把狼和白菜一起放船上，待漂到对岸后再用绳子拉过来，然后农夫抱着羊过河。不过这太投机取巧了啊哈哈。还是来点务实的吧：\r\n\r\n<!-- more -->\r\n\r\n务实的想法就是要农夫一直和船一起。毕竟不能指望顺风船自动漂对岸然后狼羊白菜自动下船吧。\r\n\r\n食物链是这样的：狼>羊>白菜\r\n\r\n农夫只要离开，食物链就会发生吞食，所以要让食物链隔开。\r\n\r\n那么第一步做法就明白了：必须带羊过河~~\r\n\r\n我们假设A为现在所在岸边，B为目的岸边\r\n\r\n\r\n\r\n| 步骤        | A    | B      |\r\n| --------- | ---- | ------ |\r\n| ①农夫带着羊过河  | 狼和白菜 | 羊      |\r\n| ②农夫独自返回A  |      |        |\r\n| ③农夫带着白菜过河 | 狼    | 羊和白菜   |\r\n| ④农夫带着羊返回  | 羊和狼  | 白菜     |\r\n| ⑤农夫带着狼过河  | 羊    | 白菜和狼   |\r\n| ⑥农夫独自返回A  |      |        |\r\n| ⑦农夫带着羊过河  |      | 白菜、狼和羊 |\r\n\r\n\r\n\r\n其实这个解法不是唯一的。\r\n\r\n虽然第一步都是要带着羊过河，但是第三步带着白菜和带狼都是可以的。\r\n\r\n| 步骤        | A    | B      |\r\n| --------- | ---- | ------ |\r\n| ③农夫带着狼过河  | 白菜   | 羊和狼    |\r\n| ④农夫带着羊返回A | 白菜和羊 | 狼      |\r\n| ⑤农夫带着白菜过河 | 羊    | 狼和白菜   |\r\n| ⑥农夫独自返回A  |      |        |\r\n| ⑦农夫带着羊过河  |      | 狼、白菜和羊 |\r\n|           |      |        |"
  },
  {
    "title" : "浅谈Android事件传递机制",
    "created_time" : "2017-07-24 17:34:17",
    "body" : "# 0x00 前言\r\n\r\n为什么点下屏幕某个位置时候，系统会找到正确地控件来响应？\r\n\r\n为什么按下按下返回键系统会让当前窗口页面关闭而不是下面的那个页面？\r\n\r\n很多时候多问自己个为什么就发现自己会的其实还很少。\r\n\r\n# 0x01 冯诺依曼模型回顾\r\n\r\n![冯诺依曼模型](http:\/\/othg5ggzi.bkt.clouddn.com\/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E6%A8%A1%E5%9E%8B.png)\r\n\r\n讲事件传递为什么把冯诺依曼模型带进来了？\r\n\r\n事件传递的事件来自哪里？\r\n\r\n基本的事件来自按键、屏幕，属于输入设备，而最终事件的结果要显示在屏幕上(输出设备)，这样才算完成一次交互。其实这里屏幕同时兼顾输入和输出。\r\n\r\n有了输入设备，系统是如何从中采集数据的呢？\r\n\r\n<!-- more -->\r\n\r\n# 0x02 设备节点到ViewRootImpl\r\n\r\n## Android系统是基于Linux的，而输入事件是接收是由Linux内核完成的。\r\n\r\n当发现输入设备可用时，Linux内核会在\/dev\/input\/目录下创建名称为event0~n的设备节点。当设备不可用时则删除对应节点。\r\n\r\n*如果刚才的不好理解，那么可以理解windows这种情况：当我们新买的鼠标插入USB口时，右下角一般弹窗正在安装USB驱动，而最终会在设备管理中多出一个USBHub设备节点，拔掉USB时就会消失*\r\n\r\n输入设备准备就绪，当有事件发生时，Linux内核收到硬件中断，然后把中断加工成原始输入事件存入对应设备节点中。\r\n\r\n输入事件已经有了，用户空间只要读取事件信息就可以了。\r\n\r\n## 在用户空间这块输入事件的负责人是谁呢？\r\n\r\nAndroid系统为我们指定好了负责人：InputManagerService(后面直接称：IMS)。\r\n\r\nIMS和WMS，AMS一样都属于系统服务，在系统启动时由SystemServer统一启动。所以只要看看源码才能知道具体情况如何。\r\n\r\n首先看下`SystemServer`启动情况：\r\n\r\n```java\r\n    \/**\r\n     * The main entry point from zygote.\r\n     *\/\r\n    public static void main(String[] args) {\r\n        new SystemServer().run();\r\n    }\r\n\r\nprivate void run() {\r\n      \/\/ Start services.\r\n        try {\r\n            startBootstrapServices();\r\n            startCoreServices();\r\n            startOtherServices();\r\n        } catch (Throwable ex) {\r\n            Slog.e(\"System\", \t\"******************************************\");\r\n            Slog.e(\"System\", \"************ Failure starting system services\", ex);\r\n            throw ex;\r\n        }\r\n}\r\n```\r\n\r\n通过源码发现`SystemServer`通过main方法直接启动的。当然这里run方法代码只是关键的一部分，如果都粘贴上来会影响分析。\r\n\r\n那么IMS在哪启动的呢？其实IMS通过`startOtherServices`方法启动。\r\n\r\n```java\r\n    private void startOtherServices() {\r\n         WindowManagerService wm = null;\r\n        InputManagerService inputManager = null;\r\n\r\n\t\t wm = WindowManagerService.main(context, inputManager,\r\n                    mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL,\r\n                    !mFirstBoot, mOnlyCore);\r\n            ServiceManager.addService(Context.WINDOW_SERVICE, wm);\r\n            ServiceManager.addService(Context.INPUT_SERVICE, inputManager);\r\n\r\n            inputManager = new InputManagerService(context);\r\n           inputManager.setWindowManagerCallbacks(wm.getInputMonitor());\r\n            inputManager.start();\r\n\t}\r\n```\r\n\r\n这里不仅启动了IMS，还有WMS，还给IMS设置了一个`wm.getInputMonitor()`，这个设置有什么用先不用管。最后调用了start方法。\r\n\r\n目前只只知道IMS是用户空间的输入事件负责人，具体如何负责还要继续看，IMS的start方法调用了`        nativeStart(mPtr);`，看的出来这是要进入C层实现了。\r\n\r\n找到Java层IMS对应的C层实现，打开文件找到`nativeStart`实现：\r\n\r\n```c++\r\nstatic void nativeStart(JNIEnv* env, jclass clazz, jlong ptr) {\r\n    NativeInputManager* im = reinterpret_cast<NativeInputManager*>(ptr);\r\n\r\n    status_t result = im->getInputManager()->start();\r\n    if (result) {\r\n        jniThrowRuntimeException(env, \"Input manager could not be started.\");\r\n    }\r\n}\r\n```\r\n\r\n方法如此简单，又是个躯壳，仅仅调用了其他类的方法。\r\n\r\n下面看看`start()`里面干了什么，\r\n\r\n注意一点：这里显示的是`NativeInputManager`，但其实找到的是`InputManager`,多态特性。\r\n\r\n```C++\r\nstatus_t InputManager::start() {    \r\n    status_t result = mDispatcherThread->run(\"InputDispatcher\", PRIORITY_URGENT_DISPLAY);\r\n    if (result) {\r\n        ALOGE(\"Could not start InputDispatcher thread due to error %d.\", result);\r\n        return result;\r\n    }\r\n\r\n    result = mReaderThread->run(\"InputReader\", PRIORITY_URGENT_DISPLAY);\r\n    if (result) {\r\n        ALOGE(\"Could not start InputReader thread due to error %d.\", result);\r\n\r\n        mDispatcherThread->requestExit();\r\n        return result;\r\n    }\r\n\r\n    return OK;\r\n}\r\n```\r\n\r\n这次真的是全部代码，没有精简，看的出来好像start就启动了两个线程。\r\n\r\nmDispatcherThread对应`InputDispatcherThread`类，负责事件分发\r\n\r\nmReaderThread对应`InputReaderThread`类，负责事件读取\r\n\r\n现在我们基本可以猜到，一个线程读取事件，读取后把事件信息传递给分发线程，由分发线程继续处理。\r\n\r\n当然这还都只是猜测，实践是检验真理的唯一标准。\r\n\r\n## 看看InputReaderThread干了什么\r\n\r\n首先看看`InputReaderThread`源码\r\n\r\n```C++\r\n\/* Reads raw events from the event hub and processes them, endlessly. *\/\r\nclass InputReaderThread : public Thread {\r\npublic:\r\n    InputReaderThread(const sp<InputReaderInterface>& reader);\r\n    virtual ~InputReaderThread();\r\n\r\nprivate:\r\n    sp<InputReaderInterface> mReader;\r\n\r\n    virtual bool threadLoop();\r\n};\r\n```\r\n\r\n`InputReaderThread`继承了Thread，在执行run方法时会回调`threadLoop`。从`virtual`知道这是一个虚函数，来看看具体实现：\r\n\r\n```C++\r\nbool InputReaderThread::threadLoop() {\r\n    mReader->loopOnce();\r\n    return true;\r\n}\r\n```\r\n\r\nmReader对应`InputReader`类，看下`loopOnce`方法实现：\r\n\r\n```C++\r\n\r\nvoid InputReader::loopOnce() {\r\n    int32_t oldGeneration;\r\n    int32_t timeoutMillis;\r\n    bool inputDevicesChanged = false;\r\n    Vector<InputDeviceInfo> inputDevices;\r\n    { \/\/ acquire lock\r\n        AutoMutex _l(mLock);\r\n\r\n        oldGeneration = mGeneration;\r\n        timeoutMillis = -1;\r\n\r\n        uint32_t changes = mConfigurationChangesToRefresh;\r\n        if (changes) {\r\n            mConfigurationChangesToRefresh = 0;\r\n            timeoutMillis = 0;\r\n            refreshConfigurationLocked(changes);\r\n        } else if (mNextTimeout != LLONG_MAX) {\r\n            nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);\r\n            timeoutMillis = toMillisecondTimeoutDelay(now, mNextTimeout);\r\n        }\r\n    } \/\/ release lock\r\n    \/\/这里就是我们开始说的从设备节点读取输入事件的函数了。\r\n    size_t count = mEventHub->getEvents(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE);\r\n\r\n    { \/\/ acquire lock\r\n        AutoMutex _l(mLock);\r\n        mReaderIsAliveCondition.broadcast();\r\n\r\n        if (count) {\r\n          \/\/处理事件\r\n            processEventsLocked(mEventBuffer, count);\r\n        }\r\n\r\n        if (mNextTimeout != LLONG_MAX) {\r\n            nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);\r\n            if (now >= mNextTimeout) {\r\n#if DEBUG_RAW_EVENTS\r\n                ALOGD(\"Timeout expired, latency=%0.3fms\", (now - mNextTimeout) * 0.000001f);\r\n#endif\r\n                mNextTimeout = LLONG_MAX;\r\n                timeoutExpiredLocked(now);\r\n            }\r\n        }\r\n\r\n        if (oldGeneration != mGeneration) {\r\n            inputDevicesChanged = true;\r\n            getInputDevicesLocked(inputDevices);\r\n        }\r\n    } \/\/ release lock\r\n\r\n    \/\/ Send out a message that the describes the changed input devices.\r\n    if (inputDevicesChanged) {\r\n        mPolicy->notifyInputDevicesChanged(inputDevices);\r\n    }\r\n\r\n    \/\/ Flush queued events out to the listener.\r\n    \/\/ This must happen outside of the lock because the listener could potentially call\r\n    \/\/ back into the InputReader's methods, such as getScanCodeState, or become blocked\r\n    \/\/ on another thread similarly waiting to acquire the InputReader lock thereby\r\n    \/\/ resulting in a deadlock.  This situation is actually quite plausible because the\r\n    \/\/ listener is actually the input dispatcher, which calls into the window manager,\r\n    \/\/ which occasionally calls into the input reader.\r\n    mQueuedListener->flush();\r\n}\r\n```\r\n\r\n上面方法主要执行了三个流程：\r\n\r\n①通过`mEventHub->getEvents`读取事件\r\n\r\n​\t这里不再继续深入，重点理解②③\r\n\r\n②通过`processEventsLocked`处理事件\r\n\r\n这方法里面有`processEventsForDeviceLocked`方法，这是处理一般事件的方法。\r\n\r\n```C++\r\nvoid InputReader::processEventsForDeviceLocked(int32_t deviceId,\r\n        const RawEvent* rawEvents, size_t count) {\r\n    ssize_t deviceIndex = mDevices.indexOfKey(deviceId);\r\n    if (deviceIndex < 0) {\r\n        ALOGW(\"Discarding event for unknown deviceId %d.\", deviceId);\r\n        return;\r\n    }\r\n\r\n    InputDevice* device = mDevices.valueAt(deviceIndex);\r\n    if (device->isIgnored()) {\r\n        \/\/ALOGD(\"Discarding event for ignored deviceId %d.\", deviceId);\r\n        return;\r\n    }\r\n\r\n    device->process(rawEvents, count);\r\n}\r\n```\r\n\r\n这里根据`deviceId`生成`InputDevice`。进而调用`device->process`。\r\n\r\n```C++\r\n for (size_t i = 0; i < numMappers; i++) {\r\n                InputMapper* mapper = mMappers[i];\r\n                mapper->process(rawEvent);\r\n            }\r\n```\r\n\r\n最终引出了`InputMapper`，这是一个基类，而对于触摸事件会调用`TouchInputMapper`类的`process`方法：\r\n\r\n```C++\r\nvoid TouchInputMapper::process(const RawEvent* rawEvent) {\r\n    mCursorButtonAccumulator.process(rawEvent);\r\n    mCursorScrollAccumulator.process(rawEvent);\r\n    mTouchButtonAccumulator.process(rawEvent);\r\n\r\n    if (rawEvent->type == EV_SYN && rawEvent->code == SYN_REPORT) {\r\n        sync(rawEvent->when);\r\n    }\r\n}\r\n```\r\n\r\n后面经过一系列方法调用，事件信息封装到`NotifyMotionArgs args`，通过`getListener()->notifyMotion(&args)`方法把事件加入到队列中。然后开始③过程。\r\n\r\n\r\n\r\n③通过`mQueuedListener->flush()`事件转移到`InputDispatcherThread`。\r\n\r\n看看`flush`源码：\r\n\r\n```C++\r\nvoid QueuedInputListener::flush() {\r\n    size_t count = mArgsQueue.size();\r\n    for (size_t i = 0; i < count; i++) {\r\n        NotifyArgs* args = mArgsQueue[i];\r\n        args->notify(mInnerListener);\r\n        delete args;\r\n    }\r\n    mArgsQueue.clear();\r\n}\r\n```\r\n\r\n这个方法遍历事件，同时执行`notify`，然后从队列删除消息，\r\n\r\n`NotifyArgs`也是基类，有多种子类，其中触摸事件为`NotifyMotionArgs`，其`notify`方法如下：\r\n\r\n```C++\r\nvoid NotifyMotionArgs::notify(const sp<InputListenerInterface>& listener) const {\r\n    listener->notifyMotion(this);\r\n}\r\n```\r\n\r\n这里的`listener`指向`InputDispatcher`，而`InputDispatcher`隶属于`InputDispatcherThread` ，下一节继续\r\n\r\n\r\n\r\n## 看看InputDispatcherThread干了什么\r\n\r\n`InputDispatcherThread`执行的时候调用了`threadLoop`然后调用了`mDispatcher->dispatchOnce();`。经过一些列调用会转战到`InputChannel::sendMessage`。\r\n\r\n继续上一节，看看`InputDispatcher`中`notifyMotion`方法：\r\n\r\n```C++\r\n  void InputDispatcher::notifyMotion(const NotifyMotionArgs* args) {\r\n\r\n  \tneedWake = enqueueInboundEventLocked(newEntry);\r\n       if (needWake) {\r\n        mLooper->wake();\r\n    }\r\n  }\r\n```\r\n\r\n方法主要做了这两件事：\r\n\r\n①事件再次加入队列\r\n\r\n​\t其中还执行了`findTouchedWindowAtLocked`查找当前活动窗口并拿到句柄。\r\n\r\n②唤醒looper。\r\n\r\n\r\n\r\n> 这里疑惑的一点是：事件加入队列，唤醒looper，接下来应该是looper循环读取消息队列进行事件分发，但是这里没有找到和dispatchOnce想关联的地方。可能有疏漏地方。以后发现问题会及时更新上。这里直接继续InputChannel::sendMessage来说。\r\n\r\n\r\n\r\n`InputChannel`是负责与app窗口进行通信的，通过WMS找到对应的窗口。那么`InputChannel`到底是怎么找到窗口的？\r\n\r\n在WMS的`addWindow`方法中有这样几行代码：\r\n\r\n```c++\r\npublic int addWindow(Session session, IWindow client, int seq,\r\n            WindowManager.LayoutParams attrs, int viewVisibility, int displayId,\r\n            Rect outContentInsets, Rect outStableInsets, InputChannel outInputChannel) {\r\n            \r\n                \r\n                String name = win.makeInputChannelName();\r\n                InputChannel[] inputChannels = InputChannel.openInputChannelPair(name);\r\n                win.setInputChannel(inputChannels[0]);\r\n                inputChannels[1].transferTo(outInputChannel);\r\n\r\n                mInputManager.registerInputChannel(win.mInputChannel, win.mInputWindowHandle);\r\n            \r\n            }\r\n```\r\n\r\n这里是在Activity初始化时想WMS添加的窗口的调用方法，其中在添加窗口时候就已经给这个窗口设置了通信通道。\r\n\r\n然后看下`InputChannel.openInputChannelPair`里面做了什么：\r\n\r\n```c++\r\nstatus_t InputChannel::openInputChannelPair(const String8& name,\r\n        sp<InputChannel>& outServerChannel, sp<InputChannel>& outClientChannel) {\r\n    int sockets[2];\r\n    if (socketpair(AF_UNIX, SOCK_SEQPACKET, 0, sockets)) {\r\n        status_t result = -errno;\r\n        ALOGE(\"channel '%s' ~ Could not create socket pair.  errno=%d\",\r\n                name.string(), errno);\r\n        outServerChannel.clear();\r\n        outClientChannel.clear();\r\n        return result;\r\n    }\r\n\r\n    int bufferSize = SOCKET_BUFFER_SIZE;\r\n    setsockopt(sockets[0], SOL_SOCKET, SO_SNDBUF, &bufferSize, sizeof(bufferSize));\r\n    setsockopt(sockets[0], SOL_SOCKET, SO_RCVBUF, &bufferSize, sizeof(bufferSize));\r\n    setsockopt(sockets[1], SOL_SOCKET, SO_SNDBUF, &bufferSize, sizeof(bufferSize));\r\n    setsockopt(sockets[1], SOL_SOCKET, SO_RCVBUF, &bufferSize, sizeof(bufferSize));\r\n\r\n    String8 serverChannelName = name;\r\n    serverChannelName.append(\" (server)\");\r\n    outServerChannel = new InputChannel(serverChannelName, sockets[0]);\r\n\r\n    String8 clientChannelName = name;\r\n    clientChannelName.append(\" (client)\");\r\n    outClientChannel = new InputChannel(clientChannelName, sockets[1]);\r\n    return OK;\r\n}\r\n```\r\n\r\n这里主要创建了两个`InputChannel`，一个服务端一个客户端，这里的的`InputChannel`是基于socket的，这个socket不是网络的socket而是Unix特有的关于文件的Unix domain socket。\r\n\r\n## WMS和ViewRootImpl\r\n\r\n经过一些列的调转，最终会回调到`InputEventReceiver`的`dispatchInputEvent`方法。\r\n\r\n这个方法是C++通过JNi回调的：\r\n\r\n```java\r\n    \/\/ Called from native code.\r\n    @SuppressWarnings(\"unused\")\r\n    private void dispatchInputEvent(int seq, InputEvent event) {\r\n        mSeqMap.put(event.getSequenceNumber(), seq);\r\n        onInputEvent(event);\r\n    }\r\n```\r\n\r\n上面的`InputEventReceiver` 对象其实是`WindowInputEventReceiver` 的引用，所以`onInputEvent`其实调用的`WindowInputEventReceiver`方法：\r\n\r\n```java\r\n\t\t@Override\r\n        public void onInputEvent(InputEvent event) {\r\n            enqueueInputEvent(event, this, 0, true);\r\n        }\r\n```\r\n\r\n`enqueueInputEvent`通过连续调用，跳转到`deliverInputEvent`：\r\n\r\n```java\r\n    private void deliverInputEvent(QueuedInputEvent q) {\r\n        Trace.asyncTraceBegin(Trace.TRACE_TAG_VIEW, \"deliverInputEvent\",\r\n                q.mEvent.getSequenceNumber());\r\n        if (mInputEventConsistencyVerifier != null) {\r\n            mInputEventConsistencyVerifier.onInputEvent(q.mEvent, 0);\r\n        }\r\n\r\n        InputStage stage;\r\n        if (q.shouldSendToSynthesizer()) {\r\n            stage = mSyntheticInputStage;\r\n        } else {\r\n            stage = q.shouldSkipIme() ? mFirstPostImeInputStage : mFirstInputStage;\r\n        }\r\n\r\n        if (stage != null) {\r\n            stage.deliver(q);\r\n        } else {\r\n            finishInputEvent(q);\r\n        }\r\n    }\r\n```\r\n\r\n这里的`stage`是多态形式，但是最终会调用`ViewPostImeInputStage`的`onProcess`方法。\r\n\r\n```java\r\n       @Override\r\n        protected int onProcess(QueuedInputEvent q) {\r\n            if (q.mEvent instanceof KeyEvent) {\r\n                return processKeyEvent(q);\r\n            } else {\r\n                \/\/ If delivering a new non-key event, make sure the window is\r\n                \/\/ now allowed to start updating.\r\n                handleDispatchDoneAnimating();\r\n                final int source = q.mEvent.getSource();\r\n                if ((source & InputDevice.SOURCE_CLASS_POINTER) != 0) {\r\n                    return processPointerEvent(q);\r\n                } else if ((source & InputDevice.SOURCE_CLASS_TRACKBALL) != 0) {\r\n                    return processTrackballEvent(q);\r\n                } else {\r\n                    return processGenericMotionEvent(q);\r\n                }\r\n            }\r\n        }\r\n```\r\n\r\n由于是触摸事件，所以会执行`processPointerEvent`方法：\r\n\r\n```java\r\n       private int processPointerEvent(QueuedInputEvent q) {\r\n            final MotionEvent event = (MotionEvent)q.mEvent;\r\n\r\n            mAttachInfo.mUnbufferedDispatchRequested = false;\r\n            boolean handled = mView.dispatchPointerEvent(event);\r\n            if (mAttachInfo.mUnbufferedDispatchRequested && !mUnbufferedInputDispatch) {\r\n                mUnbufferedInputDispatch = true;\r\n                if (mConsumeBatchedInputScheduled) {\r\n                    scheduleConsumeBatchedInputImmediately();\r\n                }\r\n            }\r\n            return handled ? FINISH_HANDLED : FORWARD;\r\n        }\r\n```\r\n\r\n发现有` boolean handled = mView.dispatchPointerEvent(event);`这么一句话，看来现在已经开始向view分发事件了。\r\n\r\n这里的`mView`是指向`DecorView`，剩下的内容下节继续\r\n\r\n\r\n\r\n# 0x03 ViewRootImpl到View \r\n\r\n通过View的`dispatchPointerEvent`调用了`dispatchTouchEvent`，\r\n\r\n因为`DecorView`重写了`dispatchTouchEvent`方法，看下这个内容：\r\n\r\n```java\r\n  @Override\r\n        public boolean dispatchTouchEvent(MotionEvent ev) {\r\n            final Callback cb = getCallback();\r\n            return cb != null && !isDestroyed() && mFeatureId < 0 ? cb.dispatchTouchEvent(ev)\r\n                    : super.dispatchTouchEvent(ev);\r\n        }\r\n```\r\n\r\n这里的`getCallback`返回的是Activity引用，如果Activity没有销毁，则调用Activity的`dispatchTouchEvent`方法。代码如下：\r\n\r\n```java\r\n    public boolean dispatchTouchEvent(MotionEvent ev) {\r\n        if (ev.getAction() == MotionEvent.ACTION_DOWN) {\r\n            onUserInteraction();\r\n        }\r\n        if (getWindow().superDispatchTouchEvent(ev)) {\r\n            return true;\r\n        }\r\n        return onTouchEvent(ev);\r\n    }\r\n```\r\n\r\n这里注意一点，如果`getWindow().superDispatchTouchEvent(ev)`返回true，则不继续执行Activity的`onTouchEvent`。\r\n\r\n这里的getWinddow就是PhoneWindow，而PhoneWindow的`superDispatchTouchEvent`直接引用了DecorView的`superDispatchTouchEvent`，接着调用了`super.dispatchTouchEvent(event)`，这里的super是ViewGroup，这里主要做了两件事：①判断当前ViewGroup是否拦截事件，如果拦截则执行`onInterceptTouchEvent`。②如果不拦截，事件也没取消，则事件向子View分发。在向子View分发前会先判断子View是否接受事件及事件是否在子View范围内。如果都为true了则调用`dispatchTransformedTouchEvent`。这里面调用了子View的`dispatchTouchEvent`。\r\n\r\n子View的`dispatchTouchEvent`里面会判断`touchListener.onTouch`方法和`onTouchEvent`方法。\r\n\r\n\r\n\r\n# 0x04 事件传递须知\r\n\r\n ①如果DecorView的`dispatchPointerEvent`方法返回true表示事件消费成功。\r\n\r\n②如果Activity没有销毁，则回调Activity的`dispatchTouchEvent`,如果phone window的`superDispatchTouchEvent`返回true表示被DecorView或其子View消耗了事件，则不执行Activity的onTouchEvent方法。\r\n\r\n③如果ViewGroup执行dispatchTouchEvent方法，先判断是否需要拦截事件：\r\n\r\n如果需要拦截则执行onInterceptTouchEvent方法。\r\n\r\n如果拦截返回true，则不继续事件传递，如果返回false，则继续，首先判断子View是否接受事件及是否在范围内，如果都符合则传递给子View。\r\n\r\n④如果子View执行dispatchTouchEvent方法，会先判断是否设置onTouchListener，\r\n\r\n如果设置了则执行onTouch方法。如果该方法返回true，则不继续执行子View 的onTouchEvent方法，否则继续执行ouTouchEvent方法。\r\n\r\n⑤如果ouTouchEvent方法执行，actionDown时检查长按事件，actionUp时检查onClick事件。"
  },
  {
    "title" : "浅谈Android性能优化系列(0)之为什么需要性能优化",
    "created_time" : "2017-09-25 22:40:50",
    "body" : "# 0X00 前言\r\n\r\n现在做开发，不管刚入门菜鸟还是资深大牛，总是离不开性能优化\/性能调优的话题。那么到底什么是性能优化呢？\r\n\r\n个人认为通过技术手段，使程序运行达到了比之前版本更好的效果，就是性能优化。\r\n\r\n为什么性能优化是我们绕不开的话题呢？\r\n\r\n<!-- more -->\r\n\r\n# 0x01 为什么需要性能优化\r\n\r\n关于为什么需要性能优化这个问题，我想很多人都会即时作答：“为用户提供更好的体验\"。\r\n\r\n既然说到为用户提供更好体验，设想一下，假如用户并不在意所谓的体验，只要功能完成就行了。那么这时公司还会考虑做性能优化吗？\r\n\r\n我想大多数公司都不会去做”这样一件无意义的事“了。公司是以盈利为目的，怎么会在用户不care的点上花费大量人力物力财力呢？\r\n\r\n然而现实恰恰相反的，随着科技发展，用户对产品体验要求越来越高，加上当前产品同质化严重，特色功能只能吸引用户，而良好的用户体验才是留住用户的关键。\r\n\r\n# 0x02 从哪些方面入手性能优化\r\n\r\n只说性能优化太过笼统，为了提供良好用户体验，应该从哪些方面着手呢？\r\n\r\n换句话说，在产品体验上，用户会通过感知哪些方面来评价产品好坏？这样一说答案就很明显了，就是平常我们自己使用程序都会唠叨的那几个方面：点几下就崩溃、玩一会就没电、没多久流量就超了、打开页面很卡、安装包太大、占了300兆内存~\r\n\r\n> 把上面几个方面归纳下就是：程序稳定性优化、耗电检测优化、网络优化、UI渲染优化、安装包优化和内存优化 6个方面。\r\n\r\n\r\n\r\n# 0x03 结束语\r\n\r\n这是本系列开篇，从为什么要性能优化发散到优化入手的6各方面，为后续章节做铺垫。\r\n\r\n目前预计未来会写6篇关于具体方面优化和6篇相关方面工具使用，共计12篇。希望通过这12篇让自己当然希望也能帮助别人对Android整体性能优化有个了解，最终形成自己的知识脉络。"
  },
  {
    "title" : "浅谈Android性能优化系列(1)之安装包大小优化",
    "created_time" : "2017-09-25 23:35:04",
    "body" : "# 0x00 前言\r\n\r\n可能会有人有疑问，安装包还需要优化吗？现在流量都用不完的！\r\n\r\n这样来说吧，优化有多方面好处的：\r\n\r\n①节省用户流量\r\n\r\n②安装包越小，用户就越快下载完，缩短了联网时间，联网时间短耗电也就越少\r\n\r\n③越快下载完，用户就越能提前使用APP，避免对用户耐心的过多消磨。\r\n\r\n所以，安装包优化还是有必要的。\r\n\r\n<!-- more -->\r\n\r\n# 0x01 安装包构成\r\n\r\n要想优化安装包，首先知道包由哪些部分组成的。这是电视猫app解压后目录：\r\n\r\n![安装包构成](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/%E5%AE%89%E8%A3%85%E5%8C%85%E6%9E%84%E6%88%90.png)\r\n\r\n\r\n\r\n目录中com和org两个文件夹是第三方包信息，不用管着两个。\r\n\r\n- assets可以存放资源和配置等各种文件，但是这里的资源文件不会像res中那样生成ID，而是通过AssetManager获取\r\n- dex是Java文件编程成class文件后又经过虚拟机优化压缩形成的\r\n- lib中存放native类库，根据不同CPU架构有四种类型：armeabi，armeabi-v7a，x86，mips。\r\n- META-INF保存了app签名信息\r\n- res中存放了资源文件\r\n- resources.arsc 记录资源文件和资源ID映射。可以根据ID查找资源\r\n- AndroidManifest.xml是app配置文件注册四大组件，声明权限等。\r\n\r\n知道了各个部分作用就大概知道了该从哪方面入手了：代码和资源，因为包中这两个部分占了很大一部分。\r\n\r\n# 0x02 代码优化\r\n\r\n代码优化其实包含了Java代码和Native代码，但是因为Native代码涉及了C和C++，这里不做阐述，但是说下lib库还是有必要的\r\n\r\n## lib库\r\n\r\n根据cpu架构lib中分为四种类型，但是目前大部分移动设备都是基于arm和arm-v7a的。x86和mips较少。而且据说x86兼容arm指令集，所以适配库优先考虑arm和arm-v7a两种即可。\r\n\r\n## 删除无用代码\r\n\r\n无用代码是指工程中那些未被引用的代码和文件， 比如未被引用的变量、 方法和类等。 \r\n\r\n这种情况的出现主要是一些在旧版本的开发中使用的变量、 方法或类在新版本中不用了或者被替换成了新的变\r\n\r\n量、 方法或类，而旧的又没有及时删除， 遗留在工程代码中  。\r\n\r\n**PMD 可以检查  未使用的局部变量、参数和private方法 **\r\n\r\n## 整理冗余代码\r\n\r\n冗余代码是指重复的代码或经过优化后可以用一段代码量更小的代码替换的代码， \r\n\r\n比如完全一样的代码、 重命名标识符后完全一样的代码、 插入或删除语句后完全一样的代码、 重新排列语句后完\r\n\r\n全一样的代码， 以及结构一样或类似的代码。 \r\n\r\n好的代码应该降低冗余度， 提高复用率， 这除了能使代码量减少， 还能提高代码可读性。  \r\n\r\n**定期codereview和使用  simian  工具都可以减少冗余代码的产生**\r\n\r\n## 减少方法数\r\n\r\n\r\n\r\n## ProGuard代码混淆\r\n\r\nProGuard具有压缩(移除无效类、方法、属性)、优化、混淆功能。\r\n\r\n- 开启混淆\r\n\r\n  ```groovy\r\n      buildTypes {\r\n          release {\r\n              minifyEnabled true\/\/开启混淆\r\n              proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' \/\/混淆文件\r\n          }\r\n      }\r\n  ```\r\n\r\n- 压缩\r\n\r\n  压缩功能是默认开启的，如果对某个或某些文件不想压缩可以使用：\r\n\r\n  `-dontshrink class * extends android.app.Activity`。\r\n\r\n- 优化\r\n\r\n  优化optimization默认开启，如果不开启可以使用：\r\n\r\n  `-dontoptimize`。一些相对复杂的方法时，压缩后可能会抛出errors，这时可以不压缩。\r\n\r\n- 混淆\r\n\r\n  混淆也是默认开启,如果对某些文件不想混淆可以使用：\r\n\r\n  `-dontobfuscate`。\r\n\r\n- 保留\r\n\r\n  如果想保留某些类、成员等不被混淆可以使用：\r\n\r\n  `-kepp`。\r\n\r\n  关于proguard更多使用方法可参考：\r\n\r\n  [Android进阶之ProGuard代码混淆](http:\/\/hanhailong.com\/2015\/12\/28\/Android%E8%BF%9B%E9%98%B6%E4%B9%8BProGuard%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86\/)\r\n\r\n  [Jean同学的Proguard私房物语](https:\/\/my.oschina.net\/u\/659658\/blog\/71976)\r\n\r\n# 0x03 资源优化\r\n\r\n这里的资源优化主要是Res资源。\r\n\r\n## 删除无用资源\r\n\r\n因为需求变更，版本更新等因素，很多研发只是一味的把新的资源文件让res下面扔，却没哟及时的把不用的文件给清理掉，长此以往导致res越来越臃肿。\r\n\r\nres资源的定时清理是很有必要的，但是资源那么多如何快速清理呢？\r\n\r\nAndroid提供了非常好用的工具Lint快速检测res中未使用的资源并给出提示。\r\n\r\n运行Analyze—>Run Inspection By Name ，弹窗输入：\r\n\r\n![lint](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/lint.png)\r\n\r\n执行结果如下：\r\n\r\n![lint_result](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/lint_result.png)\r\n\r\n其中lint.png图片没有使用，可以删除。Lint不只检测图片，而是res中所有资源包括未使用的string。\r\n\r\n\r\n\r\n## 资源混淆\r\n\r\n资源混淆简单来说就是将res\/drawable-xhdpi\/icon_pic， png变成res\/drawablexhdpi\/f.png， \r\n\r\n或我们甚至可以将文件路径也同时混淆， 改成R\/s\/f.png。 同时， 还需要修改resources.arsc中的映射关系。\r\n\r\n资源混淆能减小安装包的原因如下：\r\n\r\n- resources.arsc变小。\r\n\r\n- 文件信息变小。 由于采用了超短路径， 例如res\/drawable\/first_page.png被改为R\/o\/f.png。\r\n\r\n- 签名信息会变小。 由于采用了超短路径， 签名过程需要对每个文件使用SHA1算法生成摘要信息。\r\n\r\n\r\n\r\n  需要注意的是， 如果代码是通过getIdentifier方式获得资源， 那么这些资源需要放\r\n  置在白名单中。  \r\n\r\n\r\n\r\n## 图片处理\r\n\r\n### 图片压缩\r\n\r\n在app打包时，aapt会对图片进行压缩处理，但是这种压缩比较有限。\r\n\r\n因此我们可以再拿到设计给的图片后，使用一些工具进行二次压缩，\r\n\r\n比如Zopfli，这时谷歌开源项目。再比如PNGoo。\r\n\r\n###   JPG与PNG的转换  \r\n\r\nPNG是一种无损格式， JPG是有损格式。 \r\n\r\nJPG在处理颜色很多的图片时， 根据压缩率的不同， 有时会去掉一些肉眼识别差距较小的中间颜色。 \r\n\r\n但是PNG对于无损这个基本要求， 会严格保留所有的色彩数。 \r\n\r\n所以， 在图片尺寸大， 或者色彩数量多（特别是渐变色多） 的时候， PNG的体积会明显大于JPG。\r\n\r\n在这种情况下，我们可以有所取舍：\r\n\r\n小尺寸、 色彩数少、 或者有alpha通道透明度的时候， 使用PNG；大尺寸、 色彩渐变色多的用JPG。\r\n\r\n对于这一点的处理， 建议跟设计师进行协商， 寻求图片质量和大小的一个折中方案。\r\n\r\n> 对于可以使用JPG格式的图片， 最好不要从PNG转JPG，而是让设计师出图时直接出JPG格式的图片，\r\n>\r\n> 相对来说， 后者的效果要更好。  \r\n\r\n### 使用点9图\r\n\r\nAndroid系统程序对点9图有优化的算法。\r\n\r\n 使用点9图技术后， 只需采用一套界面切图去适配不同的分辨率， 减少了图片量， 也就减少了安装包的大小。 \r\n\r\n而且我们不需要专门做处理就可以实现其拉伸， 也减少了代码量和开发工作量。  \r\n\r\n### 图片网络化\r\n\r\n对于有些图片， 它们所在的界面本身不是特别重要或者使用比较少， 这时可以考虑把这些图片通过网络来下载。 \r\n\r\n当用户第一次进入图片所在的界面时就去下载， 下载失败影响也不是很大。\r\n\r\n适当把图片网络化处理， 也是一个比较有效的瘦身方法 。\r\n\r\n### webp图片\r\n\r\nwebp压缩⽐⽐JPG更⾼，从4.0开始支持，但是这时不支持透明度。较好地支持从4.2.2开始。\r\n\r\n### 资源图片最少化\r\n\r\n这里最少化有2个参考原则：\r\n\r\n①简单的图片shape画\r\n\r\n②多状态的图片filter画\r\n\r\n下面分别说说这两个原则都是什么意思\r\n\r\n- 简单的图片shape画\r\n\r\n  这里的简单是图形简单，颜色简单，比如矩形、圆角等纯色能用shape方便绘制出来的。\r\n\r\n- 多状态的图片filter画\r\n\r\n  这里的filter是colorFilter。\r\n\r\n  比如一些按钮都有默认背景色和选中背景色。这时设计一般会提供两套图片，如果使用colorFilter，我们只要一套就可以了。\r\n\r\n# 0x04精简第三方库\r\n\r\n很多时候可能只需要第三方库的一部分功能，这时可以根据公司业务需求进行精简，这样会有个问题就是后期的库版本更新会是个问题。\r\n\r\n# 0x05插件化\r\n\r\n把一些使用率不高的业务模块再需要的时候从服务器下载，动态加载。\r\n\r\n# 0x06zip压缩\r\n\r\n分析打包过程，对dex和res进行深度压缩。"
  },
  {
    "title" : "浅谈Android性能优化系列(2)之稳定性优化",
    "created_time" : "2017-09-26 17:47:22",
    "body" : "# 0x00 前言\r\n\r\n上一节讲了安装包优化，本节说下稳定性优化方面入手点。\r\n\r\n相比于电量和网络，稳定性可视性更高，什么是可视性？就是用户的感知程度！\r\n\r\n电量多耗了百分之几和网络流量多跑了几兆，可能用户并不会注意到，但是一旦发生ANR或者Crash，用户基本是\r\n\r\n必感知的，而且每一次的感知都会降低对你的APP的忍耐度，一旦忍耐度耗光，你的APP也就要该卸载了。\r\n\r\n因为稳定性是个很宽泛的话题，影响因素也很多，譬如内存的不合理利用造成频繁GC，导致OOm等都可以算是稳定性范围，但是这里我们只讨论2个场景：ANR和Crash。\r\n\r\n# 0x01 ANR\r\n\r\n## ANR介绍\r\n\r\n什么是ANR？Application Not Response，应用无响应。\r\n\r\n要解决ANR，首先要知道什么原因引起的ANR才好入手，主要有一下几种类型：\r\n\r\n-  KeyDispatchTimeout ：输入事件5s未完成\r\n-  BroadcastTimeout ：广播10s未完成\r\n-  BroadcastTimeout ：服务20s未完成\r\n\r\n**其实这几个方面的根本原因就是在主线程做了耗时操作，在处理ANR时可以使用traceview查看方法耗时以便修复。**\r\n\r\n<!--more-->\r\n\r\n## ANR分析\r\n\r\n 在Android系统上，如果发生ANR，Logcat会产生对应的日志和一个trace文件，\r\n\r\n分析ANR原因主要是分析这两个信息。 \r\n\r\n### Logcat\r\n\r\n从网上找了段anr的Logcat信息看下：\r\n\r\n```\r\n07-20 15:36:58.711  1000  1520  1597 E ActivityManager: ANR in com.xxxx.moblie (com.xxxx.moblie\/.ui.MainActivity) (进程名)\r\n07-20 15:36:58.711  1000  1520  1597 E ActivityManager: PID: 1480 (进程pid)\r\n07-20 15:36:58.711  1000  1520  1597 E ActivityManager: Reason: Input dispatching timed out (AppWindowToken{da8f666 token=Token{5501f51 ActivityRecord{15c5c78 u0 com.xxxx.moblie\/.ui.MainActivity t3862}}}, Waiting because no window has focus but there is a focused application that may eventually add a window when it finishes starting up.)\r\n07-20 15:36:58.711  1000  1520  1597 E ActivityManager: Load: 0.0 \/ 0.0 \/ 0.0 (Load表明是1分钟,5分钟,15分钟CPU的负载)\r\n07-20 15:36:58.711  1000  1520  1597 E ActivityManager: CPU usage from 20ms to 20286ms later (2018-07-20 15:36:36.170 to 2018-07-20 15:36:56.436):\r\n07-20 15:36:58.711  1000  1520  1597 E ActivityManager:   42% 6774\/pressure: 41% user + 1.4% kernel \/ faults: 168 minor\r\n07-20 15:36:58.711  1000  1520  1597 E ActivityManager:   34% 142\/kswapd0: 0% user + 34% kernel\r\n07-20 15:36:58.711  1000  1520  1597 E ActivityManager:   31% 1520\/system_server: 13% user + 18% kernel \/ faults: 58724 minor 1585 major\r\n07-20 15:36:58.711  1000  1520  1597 E ActivityManager:   13% 29901\/com.ss.android.article.news: 7.7% user + 6% kernel \/ faults: 56007 minor 2446 major\r\n07-20 15:36:58.711  1000  1520  1597 E ActivityManager:   13% 32638\/com.android.quicksearchbox: 9.4% user + 3.8% kernel \/ faults: 48999 minor 1540 major\r\n07-20 15:36:58.711  1000  1520  1597 E ActivityManager:   11% (CPU的使用率)1480\/com.xxxx.moblie: 5.2%(用户态的使用率) user + (内核态的使用率) 6.3% kernel \/ faults: 76401 minor 2422 major\r\n07-20 15:36:58.711  1000  1520  1597 E ActivityManager:   8.2% 21000\/kworker\/u16:12: 0% user + 8.2% kernel\r\n07-20 15:36:58.711  1000  1520  1597 E ActivityManager:   0.8% 724\/mtd: 0% user + 0.8% kernel \/ faults: 1561 minor 9 major\r\n07-20 15:36:58.711  1000  1520  1597 E ActivityManager:   8% 29704\/kworker\/u16:8: 0% user + 8% kernel\r\n07-20 15:36:58.711  1000  1520  1597 E ActivityManager:   7.9% 24391\/kworker\/u16:18: 0% user + 7.9% kernel\r\n07-20 15:36:58.711  1000  1520  1597 E ActivityManager:   7.1% 30656\/kworker\/u16:14: 0% user + 7.1% kernel\r\n07-20 15:36:58.711  1000  1520  1597 E ActivityManager:   7.1% 9998\/kworker\/u16:4: 0% user + 7.1% kernel\r\n```\r\n\r\n从上面Logcat信息中，可以提取到几个关键信息，：\r\n\r\n·ANR IN：发生ANR的具体类。\r\n\r\n·PID：发生ANR的进程，系统在此时会生成trace文件，当前的时间点也是发生ANR的具体时间，以及生成trace文件的时间。\r\n\r\n·Reason：当前ARN的类型以及导致ANR的原因。\r\n\r\n·CPU usage：CPU的使用情况，在日志中CPU usage有两个时间点，第一个是发生ANR前的CPU使用情况，第二个是发生ANR后的CPU使用情况。\r\n\r\n从Logcat中除了能看出在哪个类发生ANR以及ANR的类型，具体的原因主要还是看CPU的使用情况\r\n\r\n如果CPU使用少，说明主线程可能阻塞，如果IOwait很高，说明可能是由于主线程进行耗时的I\/O操作造成的。\r\n\r\n但是Logcat不一定保证在发生ANR时可以拿到，并且ANR的原因复杂。这时候我们可以分析traces.txt，\r\n\r\n这个文件保存在\/data\/anr\/traces.txt。\r\n\r\n### trace.txt\r\n\r\n在Android Studio上提供了一个分析trace文件的工具：Analyze Stacktrace。\r\n\r\nAnalyze Stacktrace可以更直观地分析导致ANR的原因。\r\n\r\nAnalyze Stacktrace使用方法如下：\r\n\r\n1）在Android Studio的工具栏中，选择Analyze→Analyze Stacktrace，打开Analyze Stacktrace工具窗口。\r\n\r\n2）将traces.txt中的内容复制到窗口，单击Normalize按钮，生成Thread Dump列表，左边为所有线程列表，\r\n\r\n右边为选中线程的具体信息。\r\n\r\n3）如果某个线程被标红，说明此线程被堵塞了，然后在右边的详细信息中查看堵塞的具体原因。\r\n\r\n## 找出ANR\r\n\r\n上面的分析是在ANR出现后我们需要做的，\r\n\r\n那么在开发过程中我们如何尽量避免ANR？\r\n\r\n通过Android系统提供的工具可以帮助我们及时发现这些问题：\r\n\r\n### StrictMode\r\n\r\n```kotlin\r\nStrictMode.setThreadPolicy(StrictMode.ThreadPolicy.Builder()\r\n                                       .detectDiskReads()\r\n                                       .detectDiskWrites()\r\n                                       .detectNetwork()\r\n                                       .build())\r\n```\r\n\r\n### Traceview\r\n\r\n\r\n\r\n# 0x02 Crash\r\n\r\n## Java Crash监控\r\n\r\n人无完人，同样我们也不可能一次写出完美的程序。如果异常不能避免，那我们除了做好必要的减少异常措施，还要实现一套良好的异常捕获机制，以便研发人员及时收集异常信息进行修复。\r\n\r\n关于未知异常捕获，Android系统为我们提供了一个类：`UncaughtExceptionHandler`。\r\n\r\n```java\r\npackage com.example.jenson.myapplication;\r\n\r\nimport android.content.Context;\r\nimport android.os.Build;\r\n\/**\r\n * Created by jenson on 2017\/9\/26.\r\n *\/\r\n\r\npublic class CrashHandler implements Thread.UncaughtExceptionHandler {\r\n    private Thread.UncaughtExceptionHandler mDefaultHandler;\r\n    private static CrashHandler mInstance;\r\n    private Context mContext;\r\n\r\n    private CrashHandler() {\r\n    }\r\n\r\n    \/**\r\n     * 获取CrashHandler实例\r\n     *\/\r\n    public static synchronized CrashHandler getInstance() {\r\n        if (null == mInstance) {\r\n            mInstance = new CrashHandler();\r\n        }\r\n        return mInstance;\r\n    }\r\n\r\n    public void init(Context context) {\r\n        mContext = context;\r\n        mDefaultHandler = Thread.getDefaultUncaughtExceptionHandler();\r\n        \/\/设置该CrashHandler为系统默认的\r\n        Thread.setDefaultUncaughtExceptionHandler(this);\r\n    }\r\n\r\n\r\n    @Override\r\n    public void uncaughtException(Thread t, Throwable e) {\r\n        if (!handleException(e) && mDefaultHandler != null) {\r\n            \/\/如果自己没处理交给系统处理\r\n            mDefaultHandler.uncaughtException(t, e);\r\n        } else {\r\n            \/\/自己处理\r\n        }\r\n\r\n    }\r\n\r\n    \/**\r\n     * 收集错误信息.发送到服务器\r\n     *\r\n     * @return 处理了该异常返回true, 否则false\r\n     *\/\r\n    private boolean handleException(Throwable ex) {\r\n        if (ex == null) {\r\n            return false;\r\n        }\r\n        \/\/收集设备参数信息\r\n        \/\/发送到服务器\r\n        return true;\r\n    }\r\n}\r\n\r\n```\r\n\r\n在Application中调用`CrashHandler.getInstance().init(this)`。\r\n\r\n## Native Crash监控\r\n\r\nLinux发生Crash时也会生成dump文件，在Linux中，信号量不光是一种常见IPC机制，也负责系统异常和中断。\r\n\r\nAndroid系统基于Linux内核，所以如果我们可以捕捉异常信号并处理相应函数就可以了。\r\n\r\n关于Native Crash监控可以参考：\r\n\r\n[Android 平台 Native 代码的崩溃捕获机制及实现]( https:\/\/cloud.tencent.com\/developer\/article\/1071749 )\r\n\r\n\r\n\r\n# 0x03 提高代码质量\r\n\r\n代码质量和稳定性一样，都是很宽泛的话题，市面介绍如何编写高质量代码的书籍也很多。\r\n\r\n但是由于程序员之间水平不同、人员变动、项目时间紧凑等原因，导致代码质量下降是难免的。\r\n\r\n为了解决这个问题引入**代码审查**和**重构**是十分必要的。\r\n\r\n## 代码审查\r\n\r\n到了这一步，有一个www问题：when（什么时候审查）、who(谁来审查) 、what(审查什么)\r\n\r\n### 何时审查\r\n\r\n如果是开发进度中进行审查，可以只审查基础模块、新手代码和修改过的模块。\r\n\r\n基础模块譬如公共的网络模块、图片模块等。\r\n\r\n关于核心业务模块也是一个审查点。\r\n\r\n### 谁来审查\r\n\r\n一般来说可以不用固定审查模式，譬如结对审查、模块负责人审查、团队审查可以定期交替执行。\r\n\r\n### 审查什么\r\n\r\n团队内部在审查之前确定好目标要审查哪些东西？譬如设计思想、代码风格、业务逻辑等。\r\n\r\n不要流于形式、漫无目的，这样只会浪费时间，没有实际意义。\r\n\r\n关于代码风格，可以使用阿里的java规范插件。\r\n\r\n参考http:\/\/www.techug.com\/post\/code-review-2.html\r\n\r\n## 代码扫描\r\n\r\n静态代码分析是指通过分析或检查源代码的语法、结构、过程、接口等来检查程序的正确性，找出代码隐藏的错误\r\n\r\n和缺陷，比如参数类型不匹配、错误的递归、线程安全、非法计算，以及可能出现的空指针引用等。 \r\n\r\nJava项目常用静态扫描工具有：Lint、FindBugs、CheckStyle和PMD。\r\n\r\n![静态扫描工具对比](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/%E9%9D%99%E6%80%81%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7%E5%AF%B9%E6%AF%94.png)"
  },
  {
    "title" : "浅谈Android性能优化系列(4)之耗电优化",
    "created_time" : "2017-09-26 18:26:54",
    "body" : "# 0x00 前言\r\n\r\n作为移动设备，电池重要性不言而喻，设备没有电那就真的只能拿来砸核桃了。所以作为开发者的我们，为了给用户带来更好的体验，耗电优化一直是我们撇不开的话题。\r\n\r\n# 0x01 为什么耗电\r\n\r\n![屏幕快照 2017-03-23 下午2.51.24.png](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/%E7%94%A8%E6%88%B7app%E8%80%97%E7%94%B5.png)\r\n\r\n通过上图先把用户-电量这一流程抽象出来，\r\n\r\n设备的耗电和硬件本身无关，根本原因在于对硬件的使用，耗电越严重说明对硬件使用的越频繁。\r\n\r\n<!-- more -->\r\n\r\n先看下移动设备元件耗电大户有哪些：\r\n![fullsizerender.jpg](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/%E8%80%97%E7%94%B5%E6%A8%A1%E5%9D%97%E6%AF%94%E4%BE%8B%E5%9B%BE.png)\r\n\r\n# 0x02 屏幕\r\n\r\n屏幕是耗电最大元件之一，但是用户要和app交互就要点亮屏幕，有人可能会觉得屏幕的明暗是用户自己根据喜好设定的，我们无可奈何。其实不然，在有些时候是可以通过UI的设计来减少屏幕电能消耗的。\r\n\r\n在这之前我们先来看下目前常用手机屏幕材质：LCD和LED(OLED)。\r\n\r\n- LCD概述\r\n  LCD又名液晶显示屏，屏幕由成千上万液晶分子负责像素显示，并通过背光来将其照亮。所以说每个像素点都使用了同一个光源，每个像素消耗的电量是相同的。\r\n\r\n- LED概述\r\n  LED每个屏幕像素都可以看成是一个LED灯，由RGB三种颜色共同呈现，不同颜色能量消耗也各不相同。黑色不使用任何颜色，不消耗能量，白色相反使用了所有颜色且亮度高，所以能量消耗也更多。\r\n\r\n  \r\n\r\n  \r\n\r\n  **优化方案：较暗的颜色比明亮的颜色更节能，所以在很多留白的地方可以考虑使用偏暗的色调，当然这要在不影响用户体验的前提下。**\r\n\r\n# 0x03 网络\r\n\r\n参考[浅谈Android性能优化系列(3)之网络优化](http:\/\/www.jensondev.me\/2017\/09\/26\/%E6%B5%85%E8%B0%88Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%B3%BB%E5%88%97-4-%E4%B9%8B%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96\/)\r\n\r\n# 0x04 CPU\r\n\r\n当应用退到后台运行时， 尽量减少应用的主动运行。\r\n\r\n锁屏、 灭屏、 程序 放置后台时，释放或停止Android涉 及耗电的服务。\r\n\r\n当检测到CPU时间片消耗异常时， 深入线程分析： \r\n\r\n通过获取运行过程中线程的CPU时间片消耗， 去抓取消耗时间片异常的线程， 通过线程去定位相应代码逻辑。\r\n\r\n使用**traceview**，定位CPU占用率异常的方法。\r\n\r\n## 位移替代除法\r\n\r\n浮点运算比整数运算相对更消耗cpu时间片，相应耗电也就增加，因而在编码过程尽量减少浮点运算，\r\n\r\n例如使用位移代替除法。\r\n\r\n## 动画释放\r\n\r\n对于动画效果比较炫的界面， 灭屏后CPU占用率仍然很高，\r\n\r\n最可能的原因就是动画没有及时释放。   \r\n\r\n## 避免wakelock不正确使用\r\n\r\nwakelock可以唤醒设备也可以阻止设备休眠。\r\n\r\n在PowerManager类中谷歌已经声明了：\r\n\r\n这个类会影响设备电量，除非必须，否则尽量不要使用该类，同时使用完毕要尽快释放。\r\n\r\nwankelock有几种类型，在使用时注意选择正确地类型。\r\n\r\n降低对系统的唤醒频率， 使用partial wake lock代替full wake lock， \r\n\r\n因为屏幕的亮起， 也会消耗手机电量。\r\n\r\n在注册后，也要注意及时释放，否则锁的持有时间会被一直计算到电量消耗中。  \r\n\r\n无论是间接还是直接 的，否则会让CPU 无法休眠， 导致严重的耗电问题。\r\n\r\n### 注意兼容wakeLock\r\n\r\nWakeLock有一个接口setReferenceCounted， 用来设置WakeLock的计数机制， \r\n\r\n官方默认为计数：true为计数， false为不计数。 \r\n\r\n所谓计数即每一个acquire必须对应一个release； \r\n\r\n不计数则是无论有多少个acquire， 一个release就可以释放。\r\n\r\n虽然官方说默认是计数的， 但是有的第三方ROM做了修改， 使默认是不计数的。\r\n\r\n所以在使用时注意查看并设置好兼容性问题。\r\n\r\n### 间接引用wakeLock\r\n\r\n在调用音视频API时，看似我们只是简单调用了Media某些功能，\r\n\r\n但是深入API分析会发现其源码内部一些地方间接使用了wakeLock。\r\n\r\n所以如果在退入后台后音视频资源没有及时释放，也就间接导致wakeLock一直注册中。\r\n\r\n## JobScheduler\r\n\r\n很多时候为了满足我们的需求而没有考虑cpu的感受，\r\n\r\n为了执行1s中的数据去唤醒cpu，但实际却消耗了约两分钟的电量。\r\n\r\n为此谷歌在5.0系统下提供了JobScheduler组件，使用场景：\r\n\r\n必要不紧急，可延迟执行的任务，比如数据块更新，bug日志上报。\r\n\r\n耗电大的任务，如备份在充电时执行。\r\n\r\n## Doze模式\r\n\r\nDoze模式通过限制应用访问网络及其他一些操作频率，从而减少cpu开销达到省电目的。\r\n\r\n在6.0系统上未连接电源、屏幕关闭就会进入Doze模式。\r\n\r\n但是为了不影响应用正常工作，系统还会周期性退出Doze，\r\n\r\n在退出期间去执行那些被挂起的任务，这个时间窗口称作维护窗口。\r\n\r\n# 0x05 其他优化\r\n\r\n## 传感器\r\n\r\n每个传感器都有最大信号频率，开发者在使用传感器时要设置合适的采样频率。\r\n\r\n最后在使用完成后一定要进行注销，否则激活的传感器会一直进行检测，造成cpu负载和电量消耗。\r\n\r\n为了耗电优化干的这些活用户感知不到，但是如果不去优化，肆意使用，那用户就很容易感知到了。"
  },
  {
    "title" : "浅谈Android性能优化系列(3)之网络优化",
    "created_time" : "2017-09-26 18:00:31",
    "body" : "# 0x00 前言\r\n\r\n无线网络主要是WIFI和移动运营商网络，通常情况下使用移动网络要比WIFI耗电要多一些。\r\n\r\n# 0x01 无线状态机\r\n\r\n### 移动网络\r\n\r\n移动网络数据传输有3种状态：\r\n\r\n<!-- more -->\r\n\r\n**Full power**：高功率状态，网络激活，允许设备以最大传输速率进行传输。\r\n\r\n**Low power**：低功率状态，传输速率低于15kbps，耗电是Full Power状态的一半，一般不能直接从程序中进入该\r\n\r\n状态，而是由Full Power状态降级进入。\r\n\r\n**Standby**：空闲状态，没有数据连接需要传输，耗电最少。\r\n\r\n这三种状态有一个转换流程：\r\n\r\n![mobile_radio_state_machine.png](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/mobile_radio_state_machine.png)\r\n\r\n\r\n\r\n> 可以看出，三种状态耗电不同，要使耗电最低应该尽量保持状态在空闲或低功率下。\r\n>\r\n> 从空闲状态转换到高功率状态需要2s，从低功率状态转换到高功率状态需要1.5s。\r\n>\r\n> 应用中每创建一个网络连接，网络射频都会转到高功率状态，数据传输完毕降回低功率状态，\r\n>\r\n> 降回过程需要5s，这5s耗电量保持在高功率状态，低功率降回到空闲状态需要12s，\r\n>\r\n> 期间一直保持低功率状态。所以每次的数据传输都将导致将近20s电量的消耗。\r\n\r\n### WIFI网络\r\n\r\nWIFI在active状态下有4种模式：低功率、高功率、低传输、高传输。\r\n\r\n当从低(高)功率状态传输数据时，WIFI会暂时进入相应地低(高)传输状态，一旦数据传输完毕就回到初始状态。\r\n\r\n> WIFI耗电是受包率(每秒接收和发送的数据包)和网速因素影响的。\r\n>\r\n> 如果因素良好，即网络良好时，数据传输的很快，所以WIFI的高功率状态维持时间很短。\r\n>\r\n> 这也就是说移动网络耗电高于WIFI耗电，因为同样的数据大小传输时，\r\n>\r\n> 移动网络固定状态转换就需要近20s的电量消耗。\r\n\r\n\r\n\r\n通过上面了解网络连接过程，应该心里有了大概的优化建议。\r\n\r\n# 0x02 网络优化方案：\r\n\r\n优化从**减少请求大小**和**减少请求次数**两方面着手。\r\n\r\n### 压缩文本文件\r\n\r\n不管发送还是请求数据，在数据传输过程中使用gzip将数据进行压缩。经过压缩的数据需要更短的时间传输即可完成，这样是无线所处的高功率状态时间更短，从而减少了耗电。\r\n\r\n### 精简文本文件\r\n\r\n精简是另外一个缩小文本文件的方式。精简过程就是去掉文本文件中所有只具有方便阅读\r\n\r\n作用的格式（比如空格、制表符和注释），进而使文件变小。   \r\n\r\n```html\r\n<html>  \r\n  <title> A Sample Page<\/title> \r\n  <body> \r\n \t with some sample text \r\n\t\t<--do more here--> \r\n\t<\/body> \r\n<\/html>\r\n```\r\n\r\n精简后\r\n\r\n```html\r\n<html><title> A Sample Page<\/title><body> with some sample text \t\t\t<--do more here--><\/body><\/html>\r\n```\r\n\r\n### 图片\r\n\r\n#### 根据显示大小从服务器获取图片\r\n\r\n请求一个图片时，客户端提供一个分辨率大小，服务器根据分辨率把裁剪缩放后的图片给客户端返回。\r\n\r\n也可以使用Android端使用Bitmap.Option自行获取缩放的图片。\r\n\r\n#### 压缩图片\r\n\r\n图片适用的有损压缩率取决于图片的用途。 对缩略图而言，压缩率可以更高，\r\n\r\n因为它们本身就很小，很难发现有粒子或像素变化。  可以采用webp格式\r\n\r\n#### 去掉图片元数据\r\n\r\n当用数码相机拍照片时， 文件里很可能有与照片相关的元数据（包括设备名称、设备设置\r\n\r\n以及拍摄地点等信息）。\r\n\r\n照片编辑软件也会给图片增加一些元数据。\r\n\r\n 除非 App 是讨论照片拍摄方法和编辑技巧的摄影 App， \r\n\r\n否则你可以去掉照片上所有相关的元数据，将这些几字节到几十千字节不等的元数据保存在其他地方，\r\n\r\n这样不会损坏发送给用户的图片的质量。  \r\n\r\n### 文件缓存。\r\n\r\n把经常使用的文件缓存到本地，如头像icon、好友信息等。以后可以直接从本地读取缓存减少网络请求次数。\r\n\r\n### 分组连接\r\n\r\n移动网络下最好批量执行网络请求，利用一次高功率状态执行尽可能多的事情，\r\n\r\n从而减少频繁间隔请求导致状态转换消耗更多电量。\r\n\r\n例如版本检查和日志上传这些可以分配在同一时间段请求。\r\n\r\n再比如获取数据时，一次获取多页数据。\r\n\r\n### 网络判断\r\n\r\n根据不同的网络状态执行不同的逻辑。\r\n\r\n如果在移动网络状态下推迟非紧急请求，在连接到wifi时执行请求。\r\n\r\n在WiFi和移动网络不同状态时执行同一套逻辑的不同数据量请求。"
  },
  {
    "title" : "浅谈Android性能优化系列(5)之UI优化",
    "created_time" : "2017-09-26 18:30:30",
    "body" : "# 0x00 前言\r\n\r\n研究显示，0-100ms的延迟会让用户感知到瞬时的卡顿，100-300ms的延迟会让用户感觉迟缓，\r\n\r\n300-1000ms的延迟让用户感觉“手机卡死了”，1000ms以上的延迟会让用户想要去干别的事情，\r\n\r\n由此可见保持UI流畅的重要性。\r\n\r\n造成卡顿的原因是什么呢？\r\n\r\n大概了解Android系统显示原理后可以知道，\r\n\r\n造成卡顿根本原因有3个方面：\r\n\r\n- UI太复杂\r\n\r\n  UI过于复杂，导致即使其他条件完备，但是CPU和GPU加班加点也干不完\r\n\r\n- 主线程太忙\r\n\r\n  看看主线程是否有执行耗时操作(网络\/IO\/密集计算)。StrictMode是个不错的工具类。\r\n\r\n- CPU太忙\r\n\r\n  在做UI绘制任务同时，后台还在一直抢占CPU时间片。\r\n\r\n# 0x01 优化到什么程度\r\n\r\n如今屏幕刷新频率大都是60FPS，就是说每帧绘制只要16ms，\r\n\r\n即保证你的UI页面在16ms内绘制渲染完成，就会让用户感觉到体验是流畅的，\r\n\r\n所以我们需要做的就是确保我们的APP页面渲染小于16ms。\r\n\r\n\r\n\r\n<!-- more -->\r\n\r\n\r\n\r\n# 0x02 如何优化\r\n\r\n## 布局优化\r\n\r\n### 减少xml布局层级\r\n\r\nxml布局最终会被解析成view tree。\r\n\r\n解析过程就是树的遍历过程，其复杂度和层级成正相关性。\r\n\r\n>通过Lint扫描配置 TooDeepLayout和TooManyViews两个地方，最终扫描出布局太深、控件太多有问题的布局文件。\r\n>\r\n>通过Hierarchy  View检测布局测量、布局、绘制耗时，优化黄色和红色控件。\r\n\r\n### Merge的使用\r\n\r\nMerge是合并的意思，使用Merge合并子元素和父View，而Merge本身可以被忽略。使用Merge的场合：\r\n\r\nxml布局中，根元素是FrameLayout时；\r\n\r\n自定义View中，父元素尽量是FrameLayout或者LinearLayout；\r\n\r\n>Merge不能乱用：\r\n>\r\n>Merge只能用在xml布局根元素；\r\n>\r\n>使用Merge加载一个布局时，必须制定一个ViewGroup作为其父元素，并且设置attachToRoot参数为True（inflate(int,ViewGroup,boolean)）；\r\n>\r\n>不能在ViewStub中使用Merge标签，原因就是ViewStub的inflate方法中没有attachToRoot的设置\r\n\r\n### 合理使用RelativeLayout和LinearLayout\r\n\r\nRelativeLayout一定程度上可以减少布局层级，但是其对子View测量次数多于LinearLayout。\r\n\r\n所以综合考虑：\r\n\r\n> 如果层级较多情况下，使用RelativeLayout能减少层级的话，\r\n>\r\n> 优先使用RelativeLayout以便保持界面扁平化；\r\n>\r\n> 如果层级相同的情况下优先使用LinearLayout，这样能减少子View多次测量。\r\n\r\n### ViewStub提高加载速度\r\n\r\nViewStub默认不可见不占位置，\r\n\r\n如果在特定情况下才显示某些布局，可以使用ViewStub。\r\n\r\n显示ViewStub有两种方法：ViewStub.inflate()和ViewStub.setVisibility(View.Visible)；\r\n\r\n> 使用ViewStub注意：\r\n>\r\n> Viewstub只能加载一次，之后该对象引用会被置空；\r\n>\r\n> Viewstub只能用来加载一个布局文件，而不是某个View\r\n>\r\n> Viewstub中不能嵌套Merge\r\n\r\n### include实现view复用\r\n\r\n对于在多个页面都会使用的公共布局诸如Title栏或导航栏，提取出来通过使用inlucde引入，\r\n\r\n这样只需要维护一份代码即可。\r\n\r\n## 避免过度绘制\r\n\r\n### 什么是过度绘制\r\n\r\n过度绘制是说屏幕上某一像素在同一帧时间内被绘制多次。\r\n\r\n在UI布局中如果不可见的部分UI也在进行绘制，这会导致浪费多余的CPU和GPU资源。\r\n\r\n### 引起过度绘制原因\r\n\r\nxml布局中控件重叠且都设置了背景或图片\r\n\r\n自定义View，onDraw方法中同一区域绘制了多次\r\n\r\n### 如何避免过度绘制\r\n\r\n#### 布局优化\r\n\r\n移除xml中非必须背景，或根据条件设置\r\n\r\n移除window默认背景\r\n\r\n按需设置占位背景图\r\n\r\n#### 自定义View优化\r\n\r\n在自定义 View中可以通过 `canvas.clipRect()`来帮助系统识别那些可见的区域 。\r\n\r\n这个方法可以指定一块矩形区域 ，只有在这个区域内才会被绘制 ，其他的区域会被忽视 。\r\n\r\n `canvas.clipRect()`可以很好地帮助那些有多组重叠组件的自定义View来控制显示的区域 。\r\n\r\n `canvas.clipRect()`方法还可以帮助节约CPU与GPU资源 ，\r\n\r\n在 `canvas.clipRect()`区域之外的绘制指令都不会被执行 ，\r\n\r\n那些部分内容在矩形区域内的组件 ，仍然会得到绘制 ，\r\n\r\n并且可以使用`canvas.clipRect()`来判断是否没和某个矩形相交 ，\r\n\r\n从而跳过那些非矩形区域内的绘制操作 。\r\n\r\n## 合理使用动画\r\n\r\n动画对于提高视觉感官舒适度很有帮助，\r\n\r\n对于IO等耗时操作给予适当的动画提示在一定程度上提高用户体验。\r\n\r\n> Android系统3.0开始提供了属性动画，在使用动画时优先考虑属性动画，\r\n>\r\n> 因为属性动画不但效果更多，性能也大大提高，减少了很多重绘。\r\n>\r\n> 虽然属性动画减少重绘，但是重绘仍然存在，\r\n>\r\n> 如果要再次提升性能，可以使用硬件加速。\r\n>\r\n> 如果怕硬件加速引发一些其他问题，\r\n>\r\n> 可以在动画执行前设置 ：View的LayerType为LAYER_TYPE_HARDWARE。\r\n>\r\n> 然后在动画结束后设置：View的LayerType为NONE。  \r\n\r\n## UI线程避免耗时操作\r\n\r\nAndroid4.0以后在UI线程执行网络操作会出现` NetworkOnMainThreadException `。\r\n\r\n所以这里主要检测I\/O和计算密集型任务。\r\n\r\n通过`StrictMode`和`TraceView`可以方便的检测耗时方法。\r\n\r\n## UI频繁绘制时减少后台其他操作\r\n\r\n这里主要指在列表滑动过程中暂停数据的下载。\r\n\r\n待停止滑动后再去请求网络。"
  },
  {
    "title" : "浅谈Android性能优化系列(6)之内存优化",
    "created_time" : "2017-09-26 18:35:54",
    "body" : "# 0x00 前言\r\n\r\n内存从状态上来说只有已使用和未使用两种。\r\n\r\n所以内存优化也从这两方面下手：\r\n\r\n保证已使用内存的顺利回收，\r\n\r\n保证未使用内存的合理申请。\r\n\r\n\r\n\r\n<!-- more -->\r\n\r\n\r\n\r\n# 0x01 顺利回收已使用内存\r\n\r\n## Java对象生命周期\r\n\r\n- 创建阶段\r\n\r\n  申请内存空间，构造对象并初始化相关属性值\r\n\r\n- 使用阶段\r\n\r\n  根据对象应用调用相关方法完成业务逻辑。\r\n\r\n  对象至少被一个强引用持有，除非对象创建时显示声明使用软引用、弱引用和虚引用。\r\n\r\n- 不可见阶段\r\n\r\n  当一个对象处于不可见阶段时，说明程序本身不再持有该对象的任何强引用，当然对象还是存在着的。\r\n\r\n- 不可达阶段\r\n\r\n  对象处于不可达阶段是指该对象不再被任何强引用所持有。GC会发现对象已不可达\r\n\r\n- 收集阶段\r\n\r\n  当垃圾回收器发现该对象已经处于“不可达阶段”\r\n\r\n  并且垃圾回收器已经对该对象的内存空间重新分配做好准备时，则对象进入了“收集阶段”。\r\n\r\n- 终结阶段\r\n\r\n  当对象执行完finalize()方法后仍然处于不可达状态时，则该对象进入终结阶段。\r\n\r\n  在该阶段，等待垃圾回收器对该对象空间进行回收。\r\n\r\n- 对象空间重新分配阶段\r\n\r\n  若垃圾回收器对该对象的所占用的内存空间进行回收或者再分配，则该对象彻底消失，\r\n\r\n  这个阶段称之为“对象空间重新分配阶段”。\r\n\r\n以上是Java对象生命周期的简要介绍，要保证内存顺利回收，\r\n\r\n正确使用Java对象生命周期很重要，如果不能及时回收，我们就称之为“发生了内存泄露”。\r\n\r\n>在不可见阶段，程序本身不再持有对象强引用，\r\n>\r\n>但对象仍可能被JVM等系统下的某些已装载的静态变量或线程或JNI等强引用持有着，\r\n>\r\n>这些特殊的强引用被称为”GC root”。\r\n>\r\n>存在着这些GC root会导致对象的内存泄露情况，无法被回收。\r\n\r\n\r\n![垃圾回收.jpeg](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/gc%20root.png)\r\n\r\n图中灰色的孤立无援的对象对于GC Roots来说不可达，会被回收。\r\n\r\n知道了内存泄露会影响回收，下面说下哪些方面会导致内存泄露\r\n\r\n## 引起内存泄露的情况\r\n\r\n### 资源没有适时关闭\r\n\r\nsqlite的cursor、读写文件使用的File文件流等在使用完后没有及时关闭。\r\n\r\n虽然cursor会在系统回收时自动关闭，但是这样效率较低。\r\n\r\n对于资源对象使用还是应该养成良好习惯，使用完毕close并置空。\r\n\r\n### 注册对象未注销\r\n\r\n在Android中主要是指注册的广播在Activity销毁时反注销。\r\n\r\n在Activity中如果有使用的观察者模式在生命周期发生变化时根据需求注销。\r\n\r\n在Activity中使用的各类传感器(光线、重力等)在页面销毁时及时注销，\r\n\r\n否则不光导致内存泄露还会因为传感器频繁的采样导致耗电及cpu的占用。\r\n\r\n### 使用static修饰变量\r\n\r\n这里只说一点，被static修饰的变量可以认为是直接被GC Roots引用了，那你就知道其生命周期有多长了。\r\n\r\n这时候你如果用static 修饰Bitmap、View、Context和Activity等后果有多严重了吧。\r\n\r\n### 非静态内部类的静态实例\r\n\r\n先看几行代码：\r\n\r\n```java\r\npublic class MainActivity extends AppCompatActivity {\r\npublic static People people;\r\n\t @Override\r\n \tprotected void onCreate(Bundle savedInstanceState) {\r\n  \t\t super.onCreate(savedInstanceState);\r\n  \t\t setContentView(R.layout.activity_main);\r\n  \t\t people = new People();\r\n \t}\r\n\t class  People{\r\n  \t\t int age ;\r\n  \t\t String name ;\r\n \t}\r\n}\r\n```\r\n\r\n非静态内部类People持有外部类即当前Activity的引用，\r\n\r\n而该非静态内部类实例又是static修饰的，导致Activity一直被持有而不得释放，\r\n\r\n最终导致Activity所包含的view不能释放，如果viewtree中包含多图片，那泄露的内存是很大的。\r\n\r\n### Handler\r\n\r\n众所周知handler用来发送和处理消息回调的。\r\n\r\nhandler导致泄露主要是handler实例是作为非静态匿名内部类方式创建，\r\n\r\n并且MessageQueue队列中有未处理消息，这时如果退出Activity，\r\n\r\nMessageQueue中还有Message，而Message持有handler实例，\r\n\r\nhandler实例作为非静态内部类持有Activity引用，最终的连锁反应导致Activity泄露。\r\n\r\n>handler引起的内存泄露一般是临时性的，\r\n>\r\n>因为消息队列里的Message在延时到时间或者某一情况激活后还是会执行的，\r\n>\r\n>除非你是故意搞事情。\r\n>\r\n>创建handler时最好使用静态内部类，\r\n>\r\n>同时在Activity退出时执行 `handler.removeCallbacksAndMessages(null);`清空队列消息\r\n\r\n### Webview\r\n\r\nwebview的使用总是会莫名的出现各种问题或泄露。\r\n\r\n#### 反射解决\r\n\r\n高手在民间，有网友用反射解决掉了引用造成的内存泄漏。\r\n\r\n```java\r\npublic void setConfigCallback(WindowManager windowManager) {\r\n    try {\r\n        Field field = WebView.class.getDeclaredField(\"mWebViewCore\");\r\n        field = field.getType().getDeclaredField(\"mBrowserFrame\");\r\n        field = field.getType().getDeclaredField(\"sConfigCallback\");\r\n        field.setAccessible(true);\r\n        Object configCallback = field.get(null);\r\n\r\n        if (null == configCallback) {\r\n            return;\r\n        }\r\n\r\n        field = field.getType().getDeclaredField(\"mWindowManager\");\r\n        field.setAccessible(true);\r\n        field.set(configCallback, windowManager);\r\n    } catch(Exception e) {\r\n    }\r\n}\r\n```\r\n\r\n在Activity生命周期中调用：\r\n\r\n```java\r\npublic void onCreate(Bundle savedInstanceState) {\r\n    super.onCreate(savedInstanceState);\r\n\t\t setConfigCallback((WindowManager)getApplicationContext().getSystemService(Context.WINDOW_SERVICE));\r\n}\r\n\r\npublic void onDestroy() {\r\n    setConfigCallback(null);\r\n    super.onDestroy();\r\n}\r\n```\r\n\r\n这种操作并不适用所有Android系统，有些版本更新较大可能不适用了。\r\n\r\n#### web进程\r\n\r\n用独立进程来解决内存问题， 独立进程在Android框架下非常简单， \r\n\r\n在官网Androidmanifest的＜activity＞介绍中， 讲解了有关android： process属性的设置，\r\n\r\n 一旦设置了这个属性， 这个Activity的启动就会被投射到一个你所命名的进程当中， \r\n\r\n最后在Activity的onDestory函数中退出进程，这样即可基本上终结此类泄漏。  \r\n\r\n如果需要交互使用aidl。\r\n\r\n### 容器中的对象未清理对象\r\n\r\nAndroid中使用的容器最多的就是List和Map。\r\n\r\n用来存储对象集合，如果对象集合和页面相关，那么在退出页面时注意清空集合。\r\n\r\n同时不要使用static修饰集合。\r\n\r\n# 0x02 合理申请未使用内存\r\n\r\n上面说完了如何保证GC顺利回收，现在来讲讲要最小使用内存应该怎么做：\r\n\r\n## 慎用自动封装\r\n\r\n来几行代码尝尝：\r\n\r\n```\r\n      Integer num=0;\r\n      for (int i=0;i<100;i++) {\r\n          num+=i;\r\n      }\r\n```\r\n\r\nJava基本数据类型是有自动装箱机制的。\r\n\r\n每次执行循环都会发生一次装箱操作创建一个Integer对象，造成内存消耗。\r\n\r\n包括其他基本数据类型都有可能造成这种情况。\r\n\r\n为了减少自动装箱，对于一些类已经有了相关的优化类，\r\n\r\n譬如Java8中的Stream，有对应的IntStream、LongStream等。\r\n\r\n## 内存复用\r\n\r\n### 视图复用\r\n\r\n在ListView中使用ViewHolder复用item组件，一方面节省内存，一方面提高滑动流畅性。都用过不多介绍。\r\n\r\n### 使用对象池\r\n\r\n看过Handler、Looper、Message、MessageQueue这一套消息循环源码的同志应该知道里面的Message使用了对象池模式。\r\n\r\n> 对象池类似线程池， 首先初始化一个固定大小池子，每次创建对象时候先去池子中找有没有，\r\n>\r\n> 如果有直接取出，如果没有new出来使用后还到池子里。这样便可达到对象复用的目的。\r\n>\r\n> 对象池模式适用于那些频繁使用创建的对象，\r\n>\r\n> 比如一个聊天app，里面对象最多的恐怕就是聊天信息(每条聊天信息对应一个信息对象)。\r\n>\r\n> 都知道对象的创建是很耗费时间和内存的，没事不要new着玩。\r\n>\r\n> 如果每条消息都创建一个对象，那可想而知该APP的性能。\r\n\r\n对象池的使用也很简单，少量代码即可完成：\r\n\r\n\r\n```Java\r\npublic class People {\r\nprivate static final Pools.SynchronizedPool<People> sPool = new Pools.SynchronizedPool<People>(20);\/\/需要维持对象的数量\r\nint age;\r\nString name;\r\n  \r\n  public static People obtain() {\r\n    People instance = sPool.acquire();\r\n    return (instance != null) ? instance : new People();\r\n  }\r\n  public void recycle() {\r\n     sPool.release(this);\r\n  }\r\n}\r\n```\r\n\r\n> 注意：对象申请(obtain)和释放(recycle)成对出现，使用一个对象后一定要释放还给对象池。\r\n\r\n### Bitmap复用\r\n\r\n如果设置了options.inBitmap属性，以后再使用带有该options参数的decode方法加载图片资源时，\r\n\r\ndecode会尝试重用已存在的位图内存，这样节省了加载和分配的时间，同时也节省了内存空间。\r\n\r\n> 该属性从3.0开始引进，低版本不支持inBitmap，\r\n>\r\n> 4.4系统之前只能重用大小相同的内存区域，\r\n>\r\n> 4.4以后可以重用任何比所需内存小的区域。\r\n>\r\n> 具体使用可参考[官网](https:\/\/developer.android.com\/topic\/performance\/graphics\/manage-memory.html)。\r\n\r\n## 纯色规则形状背景用Color Res代替图片\r\n\r\n经常遇到一些按钮背景是纯色显示，比如选中状态背景变为纯灰，\r\n\r\n但是设计已经发来了切图用还是不用？大声say NO！\r\n\r\n如果背景使用图片来显示，那背景每个像素都要绘制。\r\n\r\n假设一个分辨率为100x100的图片，占用4通道。\r\n\r\n那该图片内存占用就是100x100x4 =4万Byte≈40KB；\r\n\r\n但是如果使用`android:background=\"@color\/colorAccent\"`引用color值的方式，\r\n\r\n由于是纯色，只需渲染一个像素而其他像素复用这个像素值即可。\r\n\r\n这样只需要4Byte即完成了背景设置。\r\n\r\n## 选择合适数据类型\r\n\r\n### 使用ArrayMap替换HashMap\r\n\r\nHashMap是一个散列链表，稀疏阵列导致内存稍大，\r\n\r\n而ArrayMap提供了和HashMap一样的功能，但是避免了内存过度开销。\r\n\r\n在以下两个场景考虑优先使⽤ArrayMap：\r\n\r\n- 当对象的数⽬⾮常⼩(1000以内)，但是访问特别多，或者删除和插⼊频率不⾼时。\r\n\r\n- 当有映射容器，有映射发⽣，并且所有映射的容器也是ArrayMap时。  \r\n\r\n### 枚举替身来了\r\n\r\nJDK1.5就支持了枚举类型，使用Enum关键字定义。\r\n\r\n使用枚举类型很多时候出于参数类型安全迫不得已作出的选择。\r\n\r\n   ```java\r\n  public String  getValue(int type){\r\n            switch (type) {\r\n                case 1:\r\n                    break;\r\n                case 2:\r\n                    break;\r\n                case 3:\r\n                    break;\r\n                default:\r\n                    throw new IllegalArgumentException(\"不合法参数\");\r\n            }\r\n    return \"\";\r\n    }\r\n   ```\r\n\r\n试想一下如果一个函数的参数为int type，函数处理时只用到了1，2，3三种值，\r\n\r\n如果是其他值就抛出异常，这无疑增加了程序的不稳定性，\r\n\r\n按以前此时最好的解决办法就是参数改为枚举类型，增加了限定也就提高了稳定性。\r\n\r\n但是枚举类型就是一把双刃剑，增加安全同时也大大增加了内存占用,尤其是在移动设备上，\r\n\r\n资源有限更应该注意内存节省。\r\n\r\n谷歌或许考虑到了这些问题，在提供的注解包里添加了注解方式检查类型安全，\r\n\r\n目前支持int和String两种，看下使用方式：\r\n\r\n\r\n```Java\r\n\/\/1、先声明需要的类型常量值\r\npublic static final int TYPE_1 = 1;\r\npublic static final int TYPE_2 = 2;\r\n\/\/2、创建注解接口同时把上一步声明的常量囊括到这里\r\n@IntDef({TYPE_1,TYPE_2})\r\n@Retention(RetentionPolicy.SOURCE)\r\npublic @interface _TYPE{\r\n    \r\n}\r\n\/\/3、在函数参数中增加 注解接口名称\r\npublic String getValue(@_TYPE int type){\r\n    switch (type) {\r\n        case 1:\r\n            break;\r\n        case 2:\r\n            break;\r\n    }\r\n    return \"\";\r\n}\r\n```\r\n\r\n经过上面的步骤，再调用getValue()函数时如果传入其他int则报错编译不通过，这样通过注解就增加了安全性：\r\n\r\n![屏幕快照 2017-03-29 下午7.13.32.png](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/intdef.png)\r\n\r\n## 图片内存\r\n\r\n⼀张图片（BitMap） 占⽤的内存=图片长度×图片宽度×单位像素占⽤的字节数\r\n\r\n  单位像素占用内存数由图片质量决定，\r\n\r\n一个普通图片有红绿蓝和透明4个通道，每个通道8bit(1字节)，所以一个像素4个字节。\r\n\r\n一个600x600的图片，占用内存：600x600x4=1406KB=1.37m\r\n\r\n可见未经优化的图片占用内存非常大的。\r\n\r\n### 设置位图规格\r\n\r\nAndroid位图格式有ARGB_8888、ARGB_565、ARGB_4444、\r\n\r\n最⾼的是RGB_8888， 也就是系统默认的位图格式， \r\n\r\n其他⼏种都减⼩了位图通道位， 可以减少内存开销并提升图⽚显⽰的性能  \r\n\r\n在一些场景下可以适当降低图片质量，采用ARGB_565：\r\n\r\n- 显⽰局部图⽚， ⽐如列表中的⼩图⽚。\r\n\r\n- ⼩屏幕⼿机或者对图⽚质量要求不⾼的场景， 可以使⽤RGB_565， \r\n\r\n  但实际上是， 根据应⽤开发经验， 不需要Alpha通道。\r\n\r\n  如果需要更⼩的格式， 但又需要透明通道， 可以尝试ARGB_4444图像格式。 \r\n\r\n  它减少了⼀半的数据， 但保留了透明通道， 视觉差异变化较⼤，\r\n\r\n   ⼀般⽤于⽤户头像， 特别是圆⾓的头像， 可以尝试使⽤ARGB_4444看看。 \r\n\r\n### inSampleSize\r\n\r\n\r\n\r\n###   inScaled， inDensity和inTargetDensity"
  },
  {
    "title" : "求解1到n中1的个数",
    "created_time" : "2017-07-28 00:11:31",
    "body" : "# 0x00 前言\r\n\r\n注意一点的是不管有几位数，每位都要检查是否为1.\r\n\r\n\r\n\r\n# 0x01 暴力实现\r\n\r\n最简单暴力的方法就是直接遍历判断：\r\n\r\n```java\r\n\t\/**\r\n\t * 暴力求解1-n中有多少个1\r\n\t * \r\n\t * @param value\r\n\t * @return\r\n\t *\/\r\n\tpublic static int getOne(int value) {\r\n\t\tint result = 0;\r\n\t\tfor (int i = 1; i <= value; i++) {\r\n\t\t\tint val = i;\r\n\t\t\twhile (val == 1 || val >= 10) {\r\n\t\t\t\tresult += val % 10 == 1 ? 1 : 0;\r\n\t\t\t\tval \/= 10;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n```\r\n\r\n打印`\t\tSystem.out.println(getOne(11));`结果为4。正确\r\n\r\n<!-- more -->\r\n\r\n# 0x02 递归实现\r\n\r\n\r\n\r\n```java\r\n\tpublic static int getOnes(int value, int count) {\r\n\t\tif (value == 1) {\r\n\t\t\treturn ++count;\r\n\t\t} else {\r\n\t\t\t\/\/ 计算当前数不为1时，所有位包含1的个数。\r\n\t\t\tint val = value;\r\n\t\t\twhile (val == 1 || val >= 10) {\r\n\t\t\t\tcount += val % 10 == 1 ? 1 : 0;\r\n\t\t\t\tval \/= 10;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn getOnes(--value, count);\r\n\t}\r\n```\r\n\r\n\r\n\r\n# 0x003 其他思想\r\n\r\n本段内容来自[简书](http:\/\/www.jianshu.com\/p\/ce709a24bd22)：\r\n\r\n1. 此位大于1，这一位上1的个数有 ([n \/ 10 ^ (b + 1) ] + 1) * 10^b\r\n2. 此位等于0，为 ([n \/ 10^(b+1) ] ) * 10^b\r\n3. 此位等于1，在0的基础上加上n mod 10^b + 1\r\n\r\n举个例子，我们来分析 N=30143 的情况：\r\n\r\n1. 由于3>1,则个位上出现1的次数为(3014+1)*1\r\n2. 由于4>1,则十位上出现1的次数为(301+1)*10\r\n3. 由于1=1，则百位上出现1次数为30*100+(43+1)\r\n4. 由于千位为0，则千位上出现1次数为3*1000\r\n\r\n仔细观察，不难明白其中的道理。以百位为例：100到199共有100个1，而除以100以后位30，所以共有30个100到199，这就构成了300 * 100。最后，当对于千位和万位为0的情况，还有100到143这44个数，所以总共为30*100 + 43 + 1。同样，不难理解，对于十位，有10到19共10个1，共有301个百位以上不为0的情况，最后加上百位以上都是0的情况，则为 （301+1）* 10。\r\n\r\n至于代码按规律如何实现，暂时没有思考"
  },
  {
    "title" : "如何知道下载好的aosp版本？",
    "created_time" : "2017-04-21 20:55:54",
    "body" : "下载源码时执行的是\r\n\r\n```\r\nrepo init -u git:\/\/mirrors.ustc.edu.cn\/aosp\/platform\/manifest\r\n\r\n```\r\n\r\n没有写上分支然后就直接同步了，下载完了不知道版本是多少。\r\n在\r\n\r\n```\r\n找到 build\/make\/core\/version_defaults.mk文件打开\r\n搜索 PLATFORM_SDK_VERSION\r\n找到了   PLATFORM_SDK_VERSION := 25\r\nsdk版本知道了晓得原来是最新的7.1\r\n```"
  },
  {
    "title" : "设计一个有获取元素最小值getMin的栈",
    "created_time" : "2017-05-17 16:24:42",
    "body" : "# 0x00 前言\r\n\r\n栈可以看成一个瓶子，只有一个口，另一端被封底。这样数据进出都只能从一个口经过。这样就导致的一个直接结果就是数据FILO问题。要找到栈中最小数据，单靠一个栈不能完成，需要外部提供辅助。\r\n\r\n# 0x01 分析\r\n\r\n\r\n\r\n一个存好数据的栈，要从里面找到最小数值，不可避免的要把数据出栈，然后进行对比。这时有个问题就来了，找到最小数值后，其他数据还有用吗？换句话说，其他数据还要不要了？如果不要的话，比较完成后不用再次存储，如果要德话，比较期间还要注意数据的保存。这里注意要分这两种情况来考虑。\r\n\r\n<!-- more -->\r\n\r\n# 0x02 不要其他数据的实现\r\n\r\n既然不需要其他数据，那就直接把数据弹出栈就好了，每次弹栈时对比临时值，如果当前弹栈数据比临时值大则直接弹栈，否则就把值赋给临时值。\r\n\r\n```\r\npublic class StackMin {\r\n\tprivate Stack<Integer> stack = new Stack<>();\r\n\r\n\tpublic int getStackMin() {\r\n\t\tint min = 0;\r\n\t\twhile (!stack.isEmpty()) {\r\n\t\t\tint current = stack.pop();\r\n\t\t\tif (min != 0) {\r\n\t\t\t\tif (min > current) {\r\n\t\t\t\t\tmin = current;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tmin = current;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn min;\r\n\t}\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tStackMin stackMin = new StackMin();\r\n\t\tstackMin.stack.push(9);\r\n\t\tstackMin.stack.push(5);\r\n\t\tstackMin.stack.push(2);\r\n\t\tstackMin.stack.push(7);\r\n\t\tSystem.out.println(stackMin.getStackMin());\r\n\t}\r\n}\r\n\r\n```\r\n\r\n这里代码只实现了getStackMin方法，栈的其他方法就直接定义一个方法后直接调用Stack方法即可。\r\n\r\n# 0x03 需要其他数据的实现\r\n\r\n如果要保留栈的数据，那最直接的想法是在弹栈比较期间，把弹出栈的数据顺路给入道一个新的栈中，这里相比上面，需要多一个栈即可实现。\r\n\r\n```\r\npublic class StackMin {\r\n\tprivate Stack<Integer> stack = new Stack<>();\r\n\tprivate Stack<Integer> backUp = new Stack<>();\/\/备份栈\r\n\r\n\tpublic int getStackMin() {\r\n\t\tint min = 0;\r\n\t\twhile (!stack.isEmpty()) {\r\n\t\t\tint current = stack.pop();\r\n\t\t\tif (min != 0) {\r\n\t\t\t\tif (min > current) {\r\n\t\t\t\t\tmin = current;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tmin = current;\r\n\t\t\t}\r\n\t\t\tbackUp.push(current);\/\/弹出栈时进入备份栈\r\n\t\t}\r\n\t\treturn min;\r\n\t}\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tStackMin stackMin = new StackMin();\r\n\t\tstackMin.stack.push(9);\r\n\t\tstackMin.stack.push(5);\r\n\t\tstackMin.stack.push(2);\r\n\t\tstackMin.stack.push(7);\r\n\t\tSystem.out.println(stackMin.getStackMin());\r\n\t}\r\n}\r\n\r\n```"
  },
  {
    "title" : "使用sychronized注意事项",
    "created_time" : "2017-08-10 21:43:15",
    "body" : "# 0x00 前言\r\n\r\nJava编程中多线程并发是一个举足轻重的模块，所以加深对这一块的理解是很有必要的。\r\n\r\n# 0x01锁定对象而非函数或代码块 \r\n\r\n- 当sychronized修饰实例方法时，锁定的是调用该方法的对象\r\n\r\n  如下代码：\r\n\r\n  ```java\r\n  class Text{\r\n    public sychronized void method1(){\r\n    }\r\n  }\r\n  ```\r\n\r\n- 当sychronized锁定this时，锁定的也是当前对象\r\n\r\n  ```java\r\n  class Text{\r\n    public void method2(){\r\n      sychronized(this){ \r\n      }\r\n    }\r\n  }\r\n  ```\r\n\r\n  <!-- more -->\r\n\r\n  既然锁定的是对象，也就意味着调用该函数的线程A会获得该对象lock，同样的，线程B在调用该对象的函数时也要获得该对象的lock，但是该对象的lock此时被线程A持有，所以线程B就要处于阻塞状态，直到lock被线程A释放。**\r\n\r\n  看看下面代码有何问题：\r\n\r\n  ```java\r\n  static class TThread extends Thread {\r\n  \t\tprivate int key;\r\n\r\n  \t\tpublic TThread(int key) {\r\n  \t\t\tthis.key = key;\r\n  \t\t}\r\n\r\n  \t\t@Override\r\n  \t\tpublic void run() {\r\n  \t\t\tgo(this.key);\r\n  \t\t}\r\n\r\n  \t\tpublic synchronized void go(int key) {\r\n  \t\t\twhile (true) {\r\n  \t\t\t\tSystem.out.println(key);\r\n  \t\t\t\ttry {\r\n  \t\t\t\t\tThread.currentThread().sleep(1000);\r\n  \t\t\t\t} catch (InterruptedException e) {\r\n  \t\t\t\t\te.printStackTrace();\r\n  \t\t\t\t}\r\n  \t\t\t}\r\n  \t\t}\r\n  \t}\r\n\r\n  \tstatic class SecondThread extends Thread {\r\n  \t\tTThread tt;\r\n\r\n  \t\tpublic SecondThread(TThread tt) {\r\n  \t\t\tthis.tt = tt;\r\n  \t\t}\r\n\r\n  \t\t@Override\r\n  \t\tpublic void run() {\r\n  \t\t\tthis.tt.go(3);\r\n  \t\t}\r\n  \t}\r\n\r\n  \tpublic static void main(String[] args) {\r\n  \t\tTThread t1 = new TThread(1);\r\n  \t\tt1.start();\r\n  \t\tSecondThread st = new SecondThread(t1);\r\n  \t\tst.start();\r\n  \t\tTThread t2 = new TThread(2);\r\n  \t\tt2.start();\r\n  \t}\r\n  ```\r\n\r\n  上述代码会打印1和2，但是却不会打印3。因为synchronized锁定的是线程对象，而t1和t2是两个不同的对象，所以可以并发执行。而实例st中run方法实际执行的是t1的同步方法，因而1和3不会同时打印。\r\n\r\n  **另一方面，既然是锁定对象，意味着每个对象都有自己的lock，如果是同一个类的不同实例在多个线程间调用时，仍然会并发执行。**\r\n\r\n# 0x02 锁定类Class对象\r\n\r\n- 当sychronized修饰static方法时，锁定的是该class的Class对象\r\n\r\n  ```java\r\n  class Text{\r\n    public sychronized static void method1(){\r\n    }\r\n  }\r\n  ```\r\n\r\n- 当sychronized锁定xx.class时，锁定的也是该class的Class对象\r\n\r\n  ```java\r\n  class Text{\r\n    public void method2(){\r\n      sychronized(Text.class){\r\n      }\r\n    }\r\n  }\r\n  ```\r\n\r\n  如下代码有何问题：\r\n\r\n  ```java\r\n  \tstatic class TThread extends Thread {\r\n\r\n  \t\t@Override\r\n  \t\tpublic void run() {\r\n  \t\t\tgo1();\r\n  \t\t}\r\n\r\n  \t\tprivate synchronized void go1() {\r\n  \t\t\twhile (true) {\r\n  \t\t\t\tSystem.out.println(1);\r\n  \t\t\t\ttry {\r\n  \t\t\t\t\tThread.currentThread().sleep(1000);\r\n  \t\t\t\t} catch (InterruptedException e) {\r\n  \t\t\t\t\te.printStackTrace();\r\n  \t\t\t\t}\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\tpublic synchronized static void go2() {\r\n  \t\t\twhile (true) {\r\n  \t\t\t\tSystem.out.println(2);\r\n  \t\t\t\ttry {\r\n  \t\t\t\t\tThread.currentThread().sleep(1000);\r\n  \t\t\t\t} catch (InterruptedException e) {\r\n  \t\t\t\t\te.printStackTrace();\r\n  \t\t\t\t}\r\n  \t\t\t}\r\n  \t\t}\r\n  \t}\r\n\r\n  \tpublic static void main(String[] args) {\r\n  \t\tTThread t1 = new TThread();\r\n  \t\tt1.start();\r\n  \t\tt1.go2();\r\n  \t}\r\n  ```\r\n\r\n  go1函数是实例函数，go2是类函数。尽管上述两个函数都声明为synchronized，它们并非线程安全的。因为两个线程获取的是不同的lock。\r\n\r\n  因此上述代码执行时，打印1和2交替执行。\r\n\r\n  **时刻注意对象锁和类锁的区分，不要为了实现某些数据同步而同时使用两种方法。因为这两种方法获取的是不同的锁**\r\n\r\n# 0x03 避免因权限导致锁无效\r\n\r\n直接看如下代码有何问题：\r\n\r\n```java\r\n\tpublic int[] intArr = new int[10];\r\n\r\n\tpublic synchronized void addArr(int[] arr) {\r\n\t\tint len = intArr.length;\r\n\t\tif (len == arr.length) {\r\n\t\t\tfor (int i = 0; i < len; i++) {\r\n\t\t\t\tintArr[i] += arr[i];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tpublic synchronized void subtrackArr(int[] arr) {\r\n\t\tint len = intArr.length;\r\n\t\tif (len == arr.length) {\r\n\t\t\tfor (int i = 0; i < len; i++) {\r\n\t\t\t\tintArr[i] -= arr[i];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n```\r\n\r\n上面代码是线程安全的吗？\r\n\r\n当然不是。虽然两个实例方法实现了线程同步，但是还有其他漏洞。\r\n\r\n首先要明白同步的目的是保证**intArr**的准确性。但是因为该实例属性权限是**public**状态。这导致无须通过同步方法，也能修改数组。所以应该修改权限为私有状态。\r\n\r\n**有时看似添加了同步方法就以为万无一失了，但是就因为权限开放导致线程安全没有生效**\r\n\r\n# 0x04 避免无谓的同步导致性能降低\r\n\r\n看看如下代码正确吗：\r\n\r\n```Java\r\n\tprivate int[] arr1;\r\n\tprivate int[] arr2;\r\n\tprivate int[] arr3;\r\n\tprivate int[] arr4;\r\n\r\n\tpublic synchronized void method1() {\r\n\t\t\/\/ 操作arr1和arr2\r\n\t}\r\n\r\n\tpublic synchronized void method2() {\r\n\t\t\/\/ 操作arr1和arr2\r\n\t}\r\n\r\n\tpublic synchronized void method3() {\r\n\t\t\/\/ 操作arr3和arr4\r\n\t}\r\n\r\n\tpublic synchronized void method4() {\r\n\t\t\/\/ 操作arr3和arr4\r\n\t}\r\n```\r\n\r\n上述操作无疑是线程安全的，但是这种方法同步带来了很大的性能问题。\r\n\r\n因为同步所以互斥，这也就决定了四个方法不能并发，但是逻辑上，method1和method2由于都操作了arr1和arr2，所以应该互斥，但是不应该和method3、method4互斥。\r\n\r\n但是现在的结果是操作arr1和arr2的时候就不能操作arr3和arr4。造成了性能下降。\r\n\r\n要避免这种情况可以缩小锁范围，**创建专门的对象锁以替代方法所属对象的锁**\r\n\r\n如下修改：\r\n\r\n```java\r\n\tprivate int[] arr1;\r\n\tprivate int[] arr2;\r\n\tprivate int[] arr3;\r\n\tprivate int[] arr4;\r\n\tprivate byte[] lock1 = new byte[0];\r\n\tprivate byte[] lock2 = new byte[0];\r\n\r\n\tpublic void method1() {\r\n\t\t\/\/ 操作arr1和arr2\r\n\t\tsynchronized (lock1) {\r\n\t\t}\r\n\t}\r\n\r\n\tpublic void method2() {\r\n\t\t\/\/ 操作arr1和arr2\r\n\t\tsynchronized (lock1) {\r\n\t\t}\r\n\t}\r\n\r\n\tpublic void method3() {\r\n\t\t\/\/ 操作arr3和arr4\r\n\t\tsynchronized (lock2) {\r\n\t\t}\r\n\t}\r\n\r\n\tpublic void method4() {\r\n\t\t\/\/ 操作arr3和arr4\r\n\t\tsynchronized (lock2) {\r\n\t\t}\r\n\t}\r\n```\r\n\r\n# 0x05 避免多个锁顺序不同导致死锁\r\n\r\n要避免死锁首先要知道什么是死锁，以及死锁如何发生得。\r\n\r\n**线程A申请一个对象锁，但是对象锁被线程B持有了，而线程B申请的对象锁又被线程A持有了，这样导致两个线程分别阻塞了对方，这就是死锁。**\r\n\r\n死锁是如何形成的？\r\n\r\n**死锁一般是由于多个锁对象在不同的线程中获取对象锁顺序不同造成的**\r\n\r\n看如下代码：\r\n\r\n```java\r\n\tstatic class TT {\r\n\t\tpublic void method1(int[] arr1, int[] arr2) {\r\n\t\t\t\/\/ 操作arr1和arr2\r\n\t\t\tsynchronized (arr1) {\r\n\t\t\t\tsynchronized (arr2) {\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tTT tt = new TT();\r\n\t\tint[] arr1 = new int[10];\r\n\t\tint[] arr2 = new int[10];\r\n\t\ttt.method1(arr1, arr2);\r\n\t\ttt.method1(arr2, arr1);\r\n\r\n\t}\r\n```\r\n\r\n在method1的方法调用中，因为两个数组参数的顺序调换，导致了多线程情况下获取对象锁顺序不同，导致死锁发生。\r\n\r\n如何解决死锁？\r\n\r\n**一种简单的方法就是保证不同线程中多个锁对象获取锁的顺序是相同的。**"
  },
  {
    "title" : "数学归纳法",
    "created_time" : "2017-05-16 14:08:56",
    "body" : "# 什么是数学归纳法\r\n\r\n数学归纳法就是证明一个命题在自然数范围内成立\r\n\r\n这里命题也可以当成是断言。\r\n\r\n比如断言自然数n，nx2为偶数。\r\n\r\n<!-- more -->\r\n\r\n# 求储蓄罐里的钱\r\n\r\n有一个空储蓄罐，\r\n\r\n第一天，往里面存1元钱；\r\n\r\n第二天，往里面存2元钱；\r\n\r\n第三天，往里面存3元钱；\r\n\r\n第四天，往里面存4元钱；\r\n\r\n。\r\n\r\n。\r\n\r\n。\r\n\r\n每天都存钱，第一百天时储蓄罐里一共有多少钱？\r\n\r\n这个问题如何求解呢？其实最直接的方法就是从1开始加，一直加到100，但是这种暴力求解效率极差。\r\n\r\n 德国9岁孩子高斯也遇到了同样问题，但是他却马上得出了答案。\r\n\r\n他是这么考虑的：\r\n\r\n1+2+3…+100顺序计算结果和100+99+98...+1这样的逆序结果是一样的。\r\n\r\n这样的话，顺序的1+逆序的100，顺序的2+逆序的99，顺序的3+逆序的98，这样最后结果是100个101相加 = 100x101 = 10100 。因为逆序和顺序相等，所以这个和是2倍的顺序，所以顺序的和为10100\/2 =5050。最终得出1加到100的和为5050。\r\n\r\n高斯据此得出以下公式：\r\n\r\n1+2+3…+100 = （100+1）x100\/2；\r\n\r\n当然上面只是求1到100的和，那如果要求1到1000，到10000呢，公式是不是仍然成立？\r\n\r\n高斯断言：对于任意自然数n：1+2+3…+n = （n+1)xn\/2都成立；\r\n\r\n接下来要证明高斯的断言是否成立。\r\n\r\n# 数学归纳法证明\r\n\r\n最简单的数学归纳法是证明当n等于任意一个自然数时断言成立，证明包括两步：\r\n\r\n1.证明n=1时，断言p(1)成立\r\n\r\n2.证明n=k为任何自然数时，若p(k)成立，则p(k+1)也成立。\r\n\r\n\r\n\r\n由此，关于高斯公式的证明如下：\r\n\r\n1.当n=1时， 1 = （1+1）x1\/2 = 1，高斯公式成立；\r\n\r\n2.当n=k时，1+2+...+k = (k+1)xk\/2 成立;\r\n\r\n3.当n=k+1时，证明1+2+...+k+(k+1) = ((k+1)+1)x(k+1)\/2成立；\r\n\r\n因为2成立，所以3中公式代入后：\r\n\r\n (k+1)xk\/2+（k+1） = ((k+1)+1)x(k+1)\/2\r\n\r\n（k+1）x（k+2）\/2 =  （k+1）x（k+2）\/2 \r\n\r\n左右两边相等，\r\n\r\n得出结论：对于自然数n，断言p(n)都成立。\r\n\r\n\r\n\r\n# 为什么数学归纳法只证明两步就成立了\r\n\r\n\r\n\r\n1.证明断言p(1)成立，也就是n=1成立；\r\n\r\n2.通过p(m)成立推导出p(m+1)也成立。\r\n\r\n3.根据上面结论，p(1+1)也就是p(2)成立；\r\n\r\n4.p(2+1)也就是p(3)成立；\r\n\r\n5.p(3+1)也就是p(4)成立；\r\n\r\n6.循环推导，最终推导出值为n时p(n)成立。"
  },
  {
    "title" : "四个人过桥问题",
    "created_time" : "2017-05-11 15:55:37",
    "body" : "有甲乙丙丁4个人要过桥，他们都在桥一端，他们只有17分钟时间过桥。时间在晚上，过桥需要用到手电筒，而且手电筒必须来回都用到且手电筒不能扔来扔去，一次只能有2个人同时过桥。每个人走路速度不同，甲过桥需要1分钟，乙过桥需要2分钟，丙过桥需要5分钟，丁过桥需要10分钟。两个人一起走路，速度决定于走的慢的那个。请你给这四人规划合适的搭配过桥。\r\n\r\n<!-- more -->\r\n\r\n\r\n\r\n看到这道题脑子第一想法是：5和10分钟不能分开，如果分开，这俩人就占了15分钟。然而刚让这俩一起过桥，然后就让5分钟的哥们拿着手电筒回来了~~~一脸懵逼试了好几种都没有通过。后来发现我又被自己看问题角度给局限住了，每2个人过桥后，就一直一门心思的让刚过来的2个人中的一个人送手电筒返回，其实送手电筒的这个人只要在同一岸边的就行。说到这里，答案以及开始浮出水面了：\r\n\r\n\r\n\r\n| 步骤              | A    | B    |\r\n| --------------- | ---- | ---- |\r\n| ①甲和乙一起过河，花费2分钟  | 丙丁   | 甲乙   |\r\n| ②甲带手电筒返回，花费1分钟  | 甲丙丁  | 乙    |\r\n| ③丙和丁一起过河，花费10分钟 | 甲    | 乙丙丁  |\r\n| ④乙带手电筒返回，花费2分钟  | 甲乙   | 丙丁   |\r\n| ⑤甲和乙一起过河，花费2分钟  |      | 甲乙丙丁 |\r\n\r\n\r\n\r\n上面5个步骤刚好四人全部过桥，花费时间17分钟，当然②中也可以由乙带手电筒返回，不过④要由甲带手电筒。这样也是17分钟，其他时间应该是大于17分钟的。\r\n\r\n> 其实这道题和农夫过河一样，都不难，只要看问题时，眼界要能钻进问题角落深入分析，又能抽出眼界，站在一定高度俯视问题全局。\r\n\r\n\r\n\r\n网上据说这道题在西雅图一个有名软件公司的考官面试时也出过这道题，怎么样你答对了吗？"
  },
  {
    "title" : "算法查找之二分查找",
    "created_time" : "2017-05-03 22:52:40",
    "body" : "# 实现目标\r\n\r\n查看24是否在数组{ 8，14，24，28，30，31，32 }中，\r\n\r\n如果在数组中则返回数组元素下标，否则返回-1 。\r\n\r\n数组下标从0开始，查找24时最终返回下标2。\r\n\r\n<!-- more -->\r\n\r\n# 实现分析\r\n\r\n- 说明\r\n\r\n  二分法前提是数组是有序的；\r\n\r\n  要查找的数我们称为关键值\r\n\r\n- 阐述实现\r\n\r\n  在一个有序数组中二分查找一个数，数组长度为n。\r\n\r\n  1、设置左右下标变量：left，right，初始时left为0，right为n-1。\r\n\r\n  2、求出中间下标，得到中间数\r\n\r\n  3、如果中间数等于关键值则直接返回下标，\r\n\r\n  ​\t如果中间数大于关键值则 right为中间下标-1\r\n\r\n  ​\t如果中间数小于关键值则 left为中间下标+1\r\n\r\n  4、如果未结束，则重复步骤2和3，重复的前提是不管left和right的值\t\t\t如何改变，都要保证left<right。\r\n\r\n- 阐述转换通用代码\r\n\r\n  步骤1：` int left=0,right =n-1;`\r\n\r\n  步骤4中说重复2和3步，说明这是一个循环，循环条件是left<right，\r\n\r\n  所以使用` while(left<right)`\r\n\r\n\r\n\r\n# 代码实现\r\n\r\n```\r\n\tpublic static int binarySearch(int[] arr, int key) {\r\n\t\tint left = 0, right = arr.length - 1;\r\n\t\twhile (left < right) {\r\n\t\t\tint mid = (left + right) >> 1;\r\n\t\t\tif (arr[mid] == key) {\r\n\t\t\t\treturn mid;\r\n\t\t\t} else if (arr[mid] > key) {\r\n\t\t\t\tright = mid - 1;\r\n\t\t\t} else {\r\n\t\t\t\tleft = mid + 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn -1;\r\n\t}\r\n```"
  },
  {
    "title" : "算法排序之归并",
    "created_time" : "2017-10-17 22:05:51",
    "body" : "# 0x00 前言\r\n\r\n归并排序也叫合并排序，基于分治思想。\r\n\r\n# 0x01 实现\r\n\r\n```java\r\npublic class MergeSort {\r\n\r\n\t\/**\r\n\t * 合并\r\n\t * \r\n\t * @param arr\r\n\t * @param low\r\n\t * @param high\r\n\t * @param mid\r\n\t *\/\r\n\tpublic static void merge(int[] arr, int low, int high, int mid) {\r\n\t\tint[] tmp = new int[high - low + 1];\r\n\t\tint i = low, j = mid + 1, k = 0;\r\n\t\twhile (i <= mid && j <= high) {\r\n\t\t\tif (arr[i] <= arr[j]) {\r\n\t\t\t\ttmp[k++] = arr[i++];\r\n\t\t\t} else {\r\n\t\t\t\ttmp[k++] = arr[j++];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\twhile (i <= mid) {\r\n\t\t\ttmp[k++] = arr[i++];\r\n\t\t}\r\n\t\twhile (j <= high) {\r\n\t\t\ttmp[k++] = arr[j++];\r\n\t\t}\r\n\r\n\t\tk = 0;\r\n\t\twhile (low <= high) {\r\n\t\t\tarr[low++] = tmp[k++];\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static void mergeSort(int[] arr, int low, int high) {\r\n\t\tif (low < high) {\r\n\t\t\tint mid = (low + high) >> 1;\r\n\t\t\tmergeSort(arr, low, mid);\r\n\t\t\tmergeSort(arr, mid + 1, high);\r\n\t\t\tmerge(arr, low, high, mid);\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tint[] arr_sort = { 156, 141, 35, 94, 88, 61, 111 };\r\n\t\tmergeSort(arr_sort, 0, arr_sort.length - 1);\r\n\t\tConstant.printArr(arr_sort);\r\n\t}\r\n}\r\n\r\n```\r\n\r\n<!--more-->\r\n\r\n# 算法复杂度\r\n\r\n当n=1时，T(n) = 1 ;\r\n\r\n当n>1时，T(n) = 2T(n\/2)+n;\r\n\r\nT(n) = 2(2T(n\/4)+n\/2)+n\r\n\r\n​\t=4T(n\/4)+2n\r\n\r\n​\t=8T(n\/8)+3n\r\n\r\n​\t=16T(n\/16)+4n\r\n\r\n​\t=2^xT(n\/2^x)+xn\r\n\r\n当数列切分到1时不可切分，此时T(1)=T(n\/2^x)，所以n=2^x，所以x=logn\r\n\r\nT(n) = nT(1)+logn *n;\r\n\r\n由于T(1) = 1,所以T(n) = n+lognO(n)；如果n较大时，lognO(n)>n，所以T(n)=  O(nlogn);"
  },
  {
    "title" : "算法排序之交换排序",
    "created_time" : "2017-05-03 21:04:13",
    "body" : "# 实现目标\r\n\r\n本例中希望通过交换排序，使得数组最终按非递减顺序排列。\r\n\r\n数组初始值为：{ 156, 141, 35, 94, 88, 61, 111 }\r\n\r\n数组最终值为：{ 35, 61, 88, 94, 111, 141, 156 }\r\n\r\n<!-- more -->\r\n\r\n# 实现分析\r\n\r\n- 说明\r\n\r\n  希望数组按非递减顺序排列，我们可以得到两点消息：1、数组中可能会有重复的元素，所以才说是非递减。2、排序后第一个元素是最小值 ，最后一个元素是最大值。\r\n\r\n- 阐述实现\r\n\r\n  第一轮，第一个元素分别与后面的每个元素比较，如果大于后面的元素则进行交换，把较小值交换到第一个元素位置，本轮结束后的第一个元素就是数组中最小值。\r\n\r\n  第二轮，由于第一轮的第一个元素已经求出了最小值，所以第二轮从第二个元素开始，与后面的每个元素分别比较，如果大于后面的元素则进行交换，把较小值交换到第二个元素位置，本轮结束后的第二个元素就是数组中倒数第二小的值。\r\n\r\n  以此类推，进行n-1轮比较，n为数组长度。之所以是n-1轮而不是n轮，是因为第i轮的i个元素要和后面的元素进行比较，如果是n轮，它本身就是最后的元素，不需要比较了。\r\n\r\n- 阐述转换通用代码\r\n\r\n  交换方法提取：\r\n\r\n  ```\r\n  void swap(int[] arr, int i,int j){\r\n    int tmp = arr[i];\r\n    arr[i] = arr[j];\r\n    arr[j] = tmp ;\r\n  }\r\n  ```\r\n\r\n  第一轮：\r\n\r\n  ```\r\n  int i=0；\r\n  for(int j=i+1;j<n;j++){\r\n    if(arr[i]>arr[j]){\r\n      swap(arr,i,j);\r\n    }\r\n  }\r\n  ```\r\n\r\n  第二轮：\r\n\r\n  ```\r\n  int i=1；\r\n  for(int j=i+1;j<n;j++){\r\n    if(arr[i]>arr[j]){\r\n      swap(arr,i,j);\r\n    }\r\n  }\r\n  ```\r\n\r\n  每轮遍历出一个当前未排序中最小值，以此类推，遍历n-1轮：\r\n\r\n  ```\r\n  for(int i=0;i<n-1;i++){\r\n    \r\n  }\r\n  ```\r\n\r\n  ​\r\n\r\n\r\n\r\n# 代码实现\r\n\r\n```\r\n\tpublic static void swapSort(int[] arr) {\r\n\t\tint length = arr.length;\r\n\t\tfor (int i = 0; i < length-1 ; i++) {\r\n\t\t\tfor (int j = i + 1; j < length; j++) {\r\n\t\t\t\tif (arr[i] >  arr[j]) {\r\n\t\t\t\t\tint tmp = arr[i];\r\n\t\t\t\t\tarr[i] = arr[j];\r\n\t\t\t\t\tarr[j] = tmp;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n```"
  },
  {
    "title" : "算法排序之快速排序",
    "created_time" : "2017-05-16 18:21:50",
    "body" : "# 实现目标\r\n\r\n本例中希望通过快速排序，使得数组最终按非递减顺序排列。\r\n\r\n数组初始值为：{ 156, 141, 35, 94, 88, 61, 111 }\r\n\r\n数组最终值为：{ 35, 61, 88, 94, 111, 141, 156 }\r\n\r\n<!-- more -->\r\n\r\n# 实现分析\r\n\r\n快排是根据分治思想，\r\n\r\n①选取一个基数，\r\n\r\n②将无序数组分为大小两个数组，其中一个数组值全都比基数小，另一个数组值全都比基数大。\r\n\r\n③然后将这两个数组分别再次分组，递归重复①②的步骤直到每个拆分后的数组不可再分割为止。也就是说最后每个元素单独为一个数组为止。\r\n\r\n④最后得出数组就是排序好的。\r\n\r\n\r\n\r\n# 代码实现\r\n\r\n```\r\n\tpublic static int partition3(int[] arr, int low, int high) {\r\n\t\tint i, j;\r\n\t\ti = low;\r\n\t\tint base = arr[i];\r\n\t\tfor (j = i + 1; j <= high; j++) {\r\n\t\t\tif (arr[j] < base) {\r\n\t\t\t\ti++;\r\n\t\t\t\tswap(arr, i, j);\r\n\t\t\t}\r\n\t\t}\r\n\t\tswap(arr, low, i);\r\n\t\treturn i;\r\n\t}\r\n\r\n\t\/**\r\n\t*交换数组中两个值\r\n\t**\/\r\n\tpublic static void swap(int[] arr, int i, int j) {\r\n\t\tif (i != j) {\r\n\t\t\tint tmp = arr[i];\r\n\t\t\tarr[i] = arr[j];\r\n\t\t\tarr[j] = tmp;\r\n\t\t}\r\n\t}\r\n\r\n\t\/**\r\n\t*right为数组最大下标而不是数组长度\r\n\t**\/\r\n\tpublic static void quickSort(int[] arr, int left, int right) {\r\n\t\tif (left < right) {\r\n\t\t\tint piv = partition3(arr, left, right);\r\n\t\t\tquickSort(arr, left, piv - 1);\r\n\t\t\tquickSort(arr, piv + 1, right);\r\n\t\t}\r\n\r\n\t}\r\n```"
  },
  {
    "title" : "算法之朴素模式匹配",
    "created_time" : "2017-05-25 15:49:26",
    "body" : "# 0x00 前言\r\n\r\n不论英文还是中文，在看文章时经常会遇到查找某个单词或字组的时候，把一篇文章看作是一个大的字符串，要查找的内容作为子串，这种在大串中查找子串的操作叫做串的模式匹配。\r\n\r\n我们知道了这种行为叫串的模式匹配，但我们不清楚的是到底如何匹配，具体的操作是什么？\r\n\r\n# 0x01 我如何操作\r\n\r\n在我看来要从大串中寻找子串，最直接的方法就是从大串起始位置开始，挨个字符比对，如果存在子串总会找出来。这种简单直接的方法称为 **朴素的模式匹配算法**\r\n\r\n<!-- more -->\r\n\r\n# 0x02 代码实现\r\n\r\n如果借用字符串截取操作，直接实现子串的查找就比较方便：\r\n\r\n```\r\n\tpublic static int index(String s, String t, int pos) {\r\n\t\tint m = s.length();\r\n\t\tint n = t.length();\r\n\t\twhile (pos <= (m - n + 1)) {\r\n\t\t\tString sub = s.substring(pos, n);\r\n\t\t\t\/\/直接在对比位置截取和子串相同长度的一个串来和子串对比\r\n\t\t\tif (t.equals(sub)) {\r\n\t\t\t\treturn pos;\r\n\t\t\t} else {\r\n\t\t\t\tpos++;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn 0;\r\n\t}\r\n```"
  },
  {
    "title" : "为什么我在工作线程刷新UI没报错？",
    "created_time" : "2017-04-21 20:55:54",
    "body" : ">从做Android开发以来就一直被灌输“只能在主线程刷新UI”的思想，但是这两天发现个问题，在onCreate中创建工作线程并刷新UI没有报错。代码是这样的：\r\n\r\n```\r\n    @Override\r\n    protected void onCreate(Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n        setContentView(R.layout.activity_main);\r\n       final TextView tv = (TextView) findViewById(R.id.sample_text);\r\n       new Thread(new Runnable() {\r\n           @Override\r\n           public void run() {\r\n               tv.setText(\"来自\"+Thread.currentThread().getName()+\"线程的更新\");\r\n           }\r\n       }).start();\r\n    }\r\n```\r\n<!-- more -->\r\n\r\n期待已久的crash没有出现，反而页面是这样显示的：\r\n\r\n![屏幕快照 2017-03-26 下午7.14.46.png](http:\/\/upload-images.jianshu.io\/upload_images\/1796052-7be6319d0fc94867.png?imageMogr2\/auto-orient\/strip%7CimageView2\/2\/w\/1240)\r\n不禁让人陷入深思···\r\n![思考.jpg](http:\/\/upload-images.jianshu.io\/upload_images\/1796052-8a0ce88639c31d1d.jpg?imageMogr2\/auto-orient\/strip%7CimageView2\/2\/w\/1240)\r\n\r\n第一步，分析问题原因。以前工作线程刷新UI会出现异常并提示只能在UI线程刷新UI。所以假设有个地方(函数)会在刷新UI前判断当前线程是不是主线程，那么现在问题就是验证下是否真的存在这么个地方。问题是从setText引起的，那就从这里出发看看。\r\n点进去看下发现又调用了其重载函数：\r\n```\r\n    @android.view.RemotableViewMethod\r\n    public final void setText(CharSequence text) {\r\n        setText(text, mBufferType);\r\n    }\r\n```\r\n继续深入发现这个方法代码挺多的，但是不用过于关注细节，粗略浏览下不难发现前面大部分代码大多是对text文本格式的一些处理判断，无关刷新UI，直到            checkForRelayout()方法执行，从名字看是“从新布局”，根据view绘制流程测量、布局、绘制，那布局完了不是就绘制刷新了吗？所以决定去checkForRelayout方法看看。\r\n\r\n```\r\n    private void setText(CharSequence text, BufferType type,\r\n                         boolean notifyBefore, int oldlen) {\r\n        if (text == null) {\r\n            text = \"\";\r\n        }\r\n\r\n        \/\/ If suggestions are not enabled, remove the suggestion spans from the text\r\n        if (!isSuggestionsEnabled()) {\r\n            text = removeSuggestionSpans(text);\r\n        }\r\n\r\n        if (!mUserSetTextScaleX) mTextPaint.setTextScaleX(1.0f);\r\n\r\n        if (text instanceof Spanned &&\r\n            ((Spanned) text).getSpanStart(TextUtils.TruncateAt.MARQUEE) >= 0) {\r\n            if (ViewConfiguration.get(mContext).isFadingMarqueeEnabled()) {\r\n                setHorizontalFadingEdgeEnabled(true);\r\n                mMarqueeFadeMode = MARQUEE_FADE_NORMAL;\r\n            } else {\r\n                setHorizontalFadingEdgeEnabled(false);\r\n                mMarqueeFadeMode = MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS;\r\n            }\r\n            setEllipsize(TextUtils.TruncateAt.MARQUEE);\r\n        }\r\n\r\n        int n = mFilters.length;\r\n        for (int i = 0; i < n; i++) {\r\n            CharSequence out = mFilters[i].filter(text, 0, text.length(), EMPTY_SPANNED, 0, 0);\r\n            if (out != null) {\r\n                text = out;\r\n            }\r\n        }\r\n\r\n        if (notifyBefore) {\r\n            if (mText != null) {\r\n                oldlen = mText.length();\r\n                sendBeforeTextChanged(mText, 0, oldlen, text.length());\r\n            } else {\r\n                sendBeforeTextChanged(\"\", 0, 0, text.length());\r\n            }\r\n        }\r\n\r\n        boolean needEditableForNotification = false;\r\n\r\n        if (mListeners != null && mListeners.size() != 0) {\r\n            needEditableForNotification = true;\r\n        }\r\n\r\n        if (type == BufferType.EDITABLE || getKeyListener() != null ||\r\n                needEditableForNotification) {\r\n            createEditorIfNeeded();\r\n            Editable t = mEditableFactory.newEditable(text);\r\n            text = t;\r\n            setFilters(t, mFilters);\r\n            InputMethodManager imm = InputMethodManager.peekInstance();\r\n            if (imm != null) imm.restartInput(this);\r\n        } else if (type == BufferType.SPANNABLE || mMovement != null) {\r\n            text = mSpannableFactory.newSpannable(text);\r\n        } else if (!(text instanceof CharWrapper)) {\r\n            text = TextUtils.stringOrSpannedString(text);\r\n        }\r\n\r\n        if (mAutoLinkMask != 0) {\r\n            Spannable s2;\r\n\r\n            if (type == BufferType.EDITABLE || text instanceof Spannable) {\r\n                s2 = (Spannable) text;\r\n            } else {\r\n                s2 = mSpannableFactory.newSpannable(text);\r\n            }\r\n\r\n            if (Linkify.addLinks(s2, mAutoLinkMask)) {\r\n                text = s2;\r\n                type = (type == BufferType.EDITABLE) ? BufferType.EDITABLE : BufferType.SPANNABLE;\r\n\r\n                \/*\r\n                 * We must go ahead and set the text before changing the\r\n                 * movement method, because setMovementMethod() may call\r\n                 * setText() again to try to upgrade the buffer type.\r\n                 *\/\r\n                mText = text;\r\n\r\n                \/\/ Do not change the movement method for text that support text selection as it\r\n                \/\/ would prevent an arbitrary cursor displacement.\r\n                if (mLinksClickable && !textCanBeSelected()) {\r\n                    setMovementMethod(LinkMovementMethod.getInstance());\r\n                }\r\n            }\r\n        }\r\n\r\n        mBufferType = type;\r\n        mText = text;\r\n\r\n        if (mTransformation == null) {\r\n            mTransformed = text;\r\n        } else {\r\n            mTransformed = mTransformation.getTransformation(text, this);\r\n        }\r\n\r\n        final int textLength = text.length();\r\n\r\n        if (text instanceof Spannable && !mAllowTransformationLengthChange) {\r\n            Spannable sp = (Spannable) text;\r\n\r\n            \/\/ Remove any ChangeWatchers that might have come from other TextViews.\r\n            final ChangeWatcher[] watchers = sp.getSpans(0, sp.length(), ChangeWatcher.class);\r\n            final int count = watchers.length;\r\n            for (int i = 0; i < count; i++) {\r\n                sp.removeSpan(watchers[i]);\r\n            }\r\n\r\n            if (mChangeWatcher == null) mChangeWatcher = new ChangeWatcher();\r\n\r\n            sp.setSpan(mChangeWatcher, 0, textLength, Spanned.SPAN_INCLUSIVE_INCLUSIVE |\r\n                       (CHANGE_WATCHER_PRIORITY << Spanned.SPAN_PRIORITY_SHIFT));\r\n\r\n            if (mEditor != null) mEditor.addSpanWatchers(sp);\r\n\r\n            if (mTransformation != null) {\r\n                sp.setSpan(mTransformation, 0, textLength, Spanned.SPAN_INCLUSIVE_INCLUSIVE);\r\n            }\r\n\r\n            if (mMovement != null) {\r\n                mMovement.initialize(this, (Spannable) text);\r\n\r\n                \/*\r\n                 * Initializing the movement method will have set the\r\n                 * selection, so reset mSelectionMoved to keep that from\r\n                 * interfering with the normal on-focus selection-setting.\r\n                 *\/\r\n                if (mEditor != null) mEditor.mSelectionMoved = false;\r\n            }\r\n        }\r\n\r\n        if (mLayout != null) {\r\n            checkForRelayout();\r\n        }\r\n\r\n        sendOnTextChanged(text, 0, oldlen, textLength);\r\n        onTextChanged(text, 0, oldlen, textLength);\r\n\r\n        notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_TEXT);\r\n\r\n        if (needEditableForNotification) {\r\n            sendAfterTextChanged((Editable) text);\r\n        }\r\n\r\n        \/\/ SelectionModifierCursorController depends on textCanBeSelected, which depends on text\r\n        if (mEditor != null) mEditor.prepareCursorControllers();\r\n    }\r\n```\r\n\r\n找到checkForRelayout方法查看：\r\n\r\n```\r\n    private void checkForRelayout() {\r\n        \/\/ If we have a fixed width, we can just swap in a new text layout\r\n        \/\/ if the text height stays the same or if the view height is fixed.\r\n\r\n        if ((mLayoutParams.width != LayoutParams.WRAP_CONTENT ||\r\n                (mMaxWidthMode == mMinWidthMode && mMaxWidth == mMinWidth)) &&\r\n                (mHint == null || mHintLayout != null) &&\r\n                (mRight - mLeft - getCompoundPaddingLeft() - getCompoundPaddingRight() > 0)) {\r\n            \/\/ Static width, so try making a new text layout.\r\n\r\n            int oldht = mLayout.getHeight();\r\n            int want = mLayout.getWidth();\r\n            int hintWant = mHintLayout == null ? 0 : mHintLayout.getWidth();\r\n\r\n            \/*\r\n             * No need to bring the text into view, since the size is not\r\n             * changing (unless we do the requestLayout(), in which case it\r\n             * will happen at measure).\r\n             *\/\r\n            makeNewLayout(want, hintWant, UNKNOWN_BORING, UNKNOWN_BORING,\r\n                          mRight - mLeft - getCompoundPaddingLeft() - getCompoundPaddingRight(),\r\n                          false);\r\n\r\n            if (mEllipsize != TextUtils.TruncateAt.MARQUEE) {\r\n                \/\/ In a fixed-height view, so use our new text layout.\r\n                if (mLayoutParams.height != LayoutParams.WRAP_CONTENT &&\r\n                    mLayoutParams.height != LayoutParams.MATCH_PARENT) {\r\n                    invalidate();\r\n                    return;\r\n                }\r\n\r\n                \/\/ Dynamic height, but height has stayed the same,\r\n                \/\/ so use our new text layout.\r\n                if (mLayout.getHeight() == oldht &&\r\n                    (mHintLayout == null || mHintLayout.getHeight() == oldht)) {\r\n                    invalidate();\r\n                    return;\r\n                }\r\n            }\r\n\r\n            \/\/ We lose: the height has changed and we have a dynamic height.\r\n            \/\/ Request a new view layout using our new text layout.\r\n            requestLayout();\r\n            invalidate();\r\n        } else {\r\n            \/\/ Dynamic width, so we have no choice but to request a new\r\n            \/\/ view layout with a new text layout.\r\n            nullLayouts();\r\n            requestLayout();\r\n            invalidate();\r\n        }\r\n    }\r\n```\r\n发现不管是if还是else，都要执行invalidate()，那就进去看看，一路进展比较顺利，好像离真理更进一步了。经过连续的三连调跳转到了invalidateInternal方法：\r\n\r\n```\r\n public void invalidate() {\r\n        invalidate(true);\r\n    }\r\n\r\n    \/**\r\n     * This is where the invalidate() work actually happens. A full invalidate()\r\n     * causes the drawing cache to be invalidated, but this function can be\r\n     * called with invalidateCache set to false to skip that invalidation step\r\n     * for cases that do not need it (for example, a component that remains at\r\n     * the same dimensions with the same content).\r\n     *\r\n     * @param invalidateCache Whether the drawing cache for this view should be\r\n     *            invalidated as well. This is usually true for a full\r\n     *            invalidate, but may be set to false if the View's contents or\r\n     *            dimensions have not changed.\r\n     *\/\r\n    void invalidate(boolean invalidateCache) {\r\n        invalidateInternal(0, 0, mRight - mLeft, mBottom - mTop, invalidateCache, true);\r\n    }\r\n\r\n   void invalidateInternal(int l, int t, int r, int b, boolean invalidateCache,\r\n            boolean fullInvalidate) {\r\n        if (mGhostView != null) {\r\n            mGhostView.invalidate(true);\r\n            return;\r\n        }\r\n\r\n        if (skipInvalidate()) {\r\n            return;\r\n        }\r\n\r\n        if ((mPrivateFlags & (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)) == (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)\r\n                || (invalidateCache && (mPrivateFlags & PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID)\r\n                || (mPrivateFlags & PFLAG_INVALIDATED) != PFLAG_INVALIDATED\r\n                || (fullInvalidate && isOpaque() != mLastIsOpaque)) {\r\n            if (fullInvalidate) {\r\n                mLastIsOpaque = isOpaque();\r\n                mPrivateFlags &= ~PFLAG_DRAWN;\r\n            }\r\n\r\n            mPrivateFlags |= PFLAG_DIRTY;\r\n\r\n            if (invalidateCache) {\r\n                mPrivateFlags |= PFLAG_INVALIDATED;\r\n                mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;\r\n            }\r\n\r\n            \/\/ Propagate the damage rectangle to the parent view.\r\n            final AttachInfo ai = mAttachInfo;\r\n            final ViewParent p = mParent;\r\n            if (p != null && ai != null && l < r && t < b) {\r\n                final Rect damage = ai.mTmpInvalRect;\r\n                damage.set(l, t, r, b);\r\n                p.invalidateChild(this, damage);\r\n            }\r\n\r\n            \/\/ Damage the entire projection receiver, if necessary.\r\n            if (mBackground != null && mBackground.isProjected()) {\r\n                final View receiver = getProjectionReceiver();\r\n                if (receiver != null) {\r\n                    receiver.damageInParent();\r\n                }\r\n            }\r\n\r\n            \/\/ Damage the entire IsolatedZVolume receiving this view's shadow.\r\n            if (isHardwareAccelerated() && getZ() != 0) {\r\n                damageShadowReceiver();\r\n            }\r\n        }\r\n    }\r\n```\r\n重点看invalidateChild()这个方法，方法里面有do while循环，每次循环出当前view的parent，最后一次循环返回的parent时ViewRootImpl类实例：\r\n\r\n```\r\n public final void invalidateChild(View child, final Rect dirty) {\r\n        ViewParent parent = this;\r\n\r\n        final AttachInfo attachInfo = mAttachInfo;\r\n        if (attachInfo != null) {\r\n            \/\/ If the child is drawing an animation, we want to copy this flag onto\r\n            \/\/ ourselves and the parent to make sure the invalidate request goes\r\n            \/\/ through\r\n            final boolean drawAnimation = (child.mPrivateFlags & PFLAG_DRAW_ANIMATION)\r\n                    == PFLAG_DRAW_ANIMATION;\r\n\r\n            \/\/ Check whether the child that requests the invalidate is fully opaque\r\n            \/\/ Views being animated or transformed are not considered opaque because we may\r\n            \/\/ be invalidating their old position and need the parent to paint behind them.\r\n            Matrix childMatrix = child.getMatrix();\r\n            final boolean isOpaque = child.isOpaque() && !drawAnimation &&\r\n                    child.getAnimation() == null && childMatrix.isIdentity();\r\n            \/\/ Mark the child as dirty, using the appropriate flag\r\n            \/\/ Make sure we do not set both flags at the same time\r\n            int opaqueFlag = isOpaque ? PFLAG_DIRTY_OPAQUE : PFLAG_DIRTY;\r\n\r\n            if (child.mLayerType != LAYER_TYPE_NONE) {\r\n                mPrivateFlags |= PFLAG_INVALIDATED;\r\n                mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;\r\n            }\r\n\r\n            final int[] location = attachInfo.mInvalidateChildLocation;\r\n            location[CHILD_LEFT_INDEX] = child.mLeft;\r\n            location[CHILD_TOP_INDEX] = child.mTop;\r\n            if (!childMatrix.isIdentity() ||\r\n                    (mGroupFlags & ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) {\r\n                RectF boundingRect = attachInfo.mTmpTransformRect;\r\n                boundingRect.set(dirty);\r\n                Matrix transformMatrix;\r\n                if ((mGroupFlags & ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) {\r\n                    Transformation t = attachInfo.mTmpTransformation;\r\n                    boolean transformed = getChildStaticTransformation(child, t);\r\n                    if (transformed) {\r\n                        transformMatrix = attachInfo.mTmpMatrix;\r\n                        transformMatrix.set(t.getMatrix());\r\n                        if (!childMatrix.isIdentity()) {\r\n                            transformMatrix.preConcat(childMatrix);\r\n                        }\r\n                    } else {\r\n                        transformMatrix = childMatrix;\r\n                    }\r\n                } else {\r\n                    transformMatrix = childMatrix;\r\n                }\r\n                transformMatrix.mapRect(boundingRect);\r\n                dirty.set((int) (boundingRect.left - 0.5f),\r\n                        (int) (boundingRect.top - 0.5f),\r\n                        (int) (boundingRect.right + 0.5f),\r\n                        (int) (boundingRect.bottom + 0.5f));\r\n            }\r\n\r\n            do {\r\n                View view = null;\r\n                if (parent instanceof View) {\r\n                    view = (View) parent;\r\n                }\r\n\r\n                if (drawAnimation) {\r\n                    if (view != null) {\r\n                        view.mPrivateFlags |= PFLAG_DRAW_ANIMATION;\r\n                    } else if (parent instanceof ViewRootImpl) {\r\n                        ((ViewRootImpl) parent).mIsAnimating = true;\r\n                    }\r\n                }\r\n\r\n                \/\/ If the parent is dirty opaque or not dirty, mark it dirty with the opaque\r\n                \/\/ flag coming from the child that initiated the invalidate\r\n                if (view != null) {\r\n                    if ((view.mViewFlags & FADING_EDGE_MASK) != 0 &&\r\n                            view.getSolidColor() == 0) {\r\n                        opaqueFlag = PFLAG_DIRTY;\r\n                    }\r\n                    if ((view.mPrivateFlags & PFLAG_DIRTY_MASK) != PFLAG_DIRTY) {\r\n                        view.mPrivateFlags = (view.mPrivateFlags & ~PFLAG_DIRTY_MASK) | opaqueFlag;\r\n                    }\r\n                }\r\n\r\n                parent = parent.invalidateChildInParent(location, dirty);\r\n                if (view != null) {\r\n                    \/\/ Account for transform on current parent\r\n                    Matrix m = view.getMatrix();\r\n                    if (!m.isIdentity()) {\r\n                        RectF boundingRect = attachInfo.mTmpTransformRect;\r\n                        boundingRect.set(dirty);\r\n                        m.mapRect(boundingRect);\r\n                        dirty.set((int) (boundingRect.left - 0.5f),\r\n                                (int) (boundingRect.top - 0.5f),\r\n                                (int) (boundingRect.right + 0.5f),\r\n                                (int) (boundingRect.bottom + 0.5f));\r\n                    }\r\n                }\r\n            } while (parent != null);\r\n        }\r\n    }\r\n```\r\n现在查看ViewRootImpl类的invalidateChildInParent()方法：\r\n\r\n```\r\n    @Override\r\n    public ViewParent invalidateChildInParent(int[] location, Rect dirty) {\r\n        checkThread();\r\n        if (DEBUG_DRAW) Log.v(TAG, \"Invalidate child: \" + dirty);\r\n\r\n        if (dirty == null) {\r\n            invalidate();\r\n            return null;\r\n        } else if (dirty.isEmpty() && !mIsAnimating) {\r\n            return null;\r\n        }\r\n\r\n        if (mCurScrollY != 0 || mTranslator != null) {\r\n            mTempRect.set(dirty);\r\n            dirty = mTempRect;\r\n            if (mCurScrollY != 0) {\r\n                dirty.offset(0, -mCurScrollY);\r\n            }\r\n            if (mTranslator != null) {\r\n                mTranslator.translateRectInAppWindowToScreen(dirty);\r\n            }\r\n            if (mAttachInfo.mScalingRequired) {\r\n                dirty.inset(-1, -1);\r\n            }\r\n        }\r\n\r\n        final Rect localDirty = mDirty;\r\n        if (!localDirty.isEmpty() && !localDirty.contains(dirty)) {\r\n            mAttachInfo.mSetIgnoreDirtyState = true;\r\n            mAttachInfo.mIgnoreDirtyState = true;\r\n        }\r\n\r\n        \/\/ Add the new dirty rect to the current one\r\n        localDirty.union(dirty.left, dirty.top, dirty.right, dirty.bottom);\r\n        \/\/ Intersect with the bounds of the window to skip\r\n        \/\/ updates that lie outside of the visible region\r\n        final float appScale = mAttachInfo.mApplicationScale;\r\n        final boolean intersected = localDirty.intersect(0, 0,\r\n                (int) (mWidth * appScale + 0.5f), (int) (mHeight * appScale + 0.5f));\r\n        if (!intersected) {\r\n            localDirty.setEmpty();\r\n        }\r\n        if (!mWillDrawSoon && (intersected || mIsAnimating)) {\r\n            scheduleTraversals();\r\n        }\r\n\r\n        return null;\r\n    }\r\n```\r\n方法块的第一行好像就是我们要找的验证线程的地方checkThread()，而该方法内容也很简单，看到抛出的异常就很熟悉了：\r\n\r\n```\r\n    void checkThread() {\r\n        if (mThread != Thread.currentThread()) {\r\n            throw new CalledFromWrongThreadException(\r\n                    \"Only the original thread that created a view hierarchy can touch its views.\");\r\n        }\r\n    }\r\n```\r\n第二步，验证线程地方已经找到了，假设得到了证实，那么为什么该有的异常没有出现呢？现在再次假设是不是因为某些原因导致checkThread()没有执行呢？\r\n\r\n有人可能会问会不会是mThread == Thread.currentThread()？其实这是不可能的 ，先看下mThread赋值：\r\n\r\n```\r\n    public ViewRootImpl(Context context, Display display) {\r\n        mContext = context;\r\n        mWindowSession = WindowManagerGlobal.getWindowSession();\r\n        mDisplay = display;\r\n        mBasePackageName = context.getBasePackageName();\r\n\r\n        mDisplayAdjustments = display.getDisplayAdjustments();\r\n\r\n        mThread = Thread.currentThread();\r\n```\r\nViewRootImpl类实例化是在Activity启动时的主线程创建的，所以mThread是主线程实例，而checkThread()中的Thread.currentThread()，最初是由textView.setText()调用的一系列方法栈，并且setText是在子线程调用。\r\n\r\n继续刚才的假设，不过现在要逆推回去，checkThread()方法没有执行，可以认为ViewRootImpl的invalidateChildInParent()方法没有执行，它又是在ViewGroup中invalidateChild()方法里的do while中调用，要使do while不被调用，继续往上看，如果attachInfo为null，进不去if语句块也就不会执行checkThread()了，这是第一个可能的原因。记录下，继续逆推。\r\n\r\nView中的invalidateInternal()方法：\r\n\r\n```\r\n      \/\/ Propagate the damage rectangle to the parent view.\r\n            final AttachInfo ai = mAttachInfo;\r\n            final ViewParent p = mParent;\r\n            if (p != null && ai != null && l < r && t < b) {\r\n                final Rect damage = ai.mTmpInvalRect;\r\n                damage.set(l, t, r, b);\r\n                p.invalidateChild(this, damage);\r\n            }\r\n```\r\n根据判断条件，如果p即mParent或者ai即mAttachInfo 任一为null，都不会执行invalidateChild，这是第二个可能原因，这里的ai和第一个原因的attachInfo是一样的，所以第一个原因可能忽略，精力关注在第二个原因上。\r\n\r\n>现在的关注点是实例p和ai是什么时候创建的，有没有为null的现象？\r\n\r\n```\r\n     final AttachInfo ai = mAttachInfo;\r\n```\r\n而mAttachInfo是在View的dispatchAttachedToWindow()方法中赋值的：\r\n\r\n```\r\n void dispatchAttachedToWindow(AttachInfo info, int visibility) {\r\n        \/\/System.out.println(\"Attached! \" + this);\r\n        mAttachInfo = info;\r\n}\r\n```\r\nView的dispatchAttachedToWindow()方法是在ViewRootImpl中的performTraversals()方法调用，这个方法是遍历View Tree\r\n\r\n```\r\n private void performTraversals() {\r\n        \/\/ cache mView since it is used so much below...\r\n        final View host = mView;\r\n        ·······\r\n        host.dispatchAttachedToWindow(mAttachInfo, 0);\r\n\r\n```\r\n可见View中的mAttachInfo来自ViewrootImpl的mAttachInfo，而ViewrootImpl的mAttachInfo是在其构造方法中被赋值的：\r\n\r\n```\r\n\r\n    public ViewRootImpl(Context context, Display display) {\r\n        mContext = context;\r\n        mWindowSession = WindowManagerGlobal.getWindowSession();\r\n        mDisplay = display;\r\n        mBasePackageName = context.getBasePackageName();\r\n\r\n        mDisplayAdjustments = display.getDisplayAdjustments();\r\n\r\n        mThread = Thread.currentThread();\r\n        mLocation = new WindowLeaked(null);\r\n        mLocation.fillInStackTrace();\r\n        mWidth = -1;\r\n        mHeight = -1;\r\n        mDirty = new Rect();\r\n        mTempRect = new Rect();\r\n        mVisRect = new Rect();\r\n        mWinFrame = new Rect();\r\n        mWindow = new W(this);\r\n        mTargetSdkVersion = context.getApplicationInfo().targetSdkVersion;\r\n        mViewVisibility = View.GONE;\r\n        mTransparentRegion = new Region();\r\n        mPreviousTransparentRegion = new Region();\r\n        mFirst = true; \/\/ true for the first time the view is added\r\n        mAdded = false;\r\n        mAttachInfo = new View.AttachInfo(mWindowSession, mWindow, display, this, mHandler, this);\r\n       \r\n    }\r\n```\r\n\r\n之前说了ViewRootImpl实例是在Activity启动时创建的，现在看看具体是启动的什么时候:在向window添加view的时候即：WindowManagerGlobal的addView方法中创建ViewrootImpl实例：\r\n\r\n```\r\n public void addView(View view, ViewGroup.LayoutParams params,\r\n            Display display, Window parentWindow) {\r\n        if (view == null) {\r\n            throw new IllegalArgumentException(\"view must not be null\");\r\n        }\r\n        if (display == null) {\r\n            throw new IllegalArgumentException(\"display must not be null\");\r\n        }\r\n        if (!(params instanceof WindowManager.LayoutParams)) {\r\n            throw new IllegalArgumentException(\"Params must be WindowManager.LayoutParams\");\r\n        }\r\n\r\n        final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams)params;\r\n        if (parentWindow != null) {\r\n            parentWindow.adjustLayoutParamsForSubWindow(wparams);\r\n        } else {\r\n            \/\/ If there's no parent and we're running on L or above (or in the\r\n            \/\/ system context), assume we want hardware acceleration.\r\n            final Context context = view.getContext();\r\n            if (context != null\r\n                    && context.getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.LOLLIPOP) {\r\n                wparams.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;\r\n            }\r\n        }\r\n\r\n        ViewRootImpl root;\r\n        View panelParentView = null;\r\n\r\n        synchronized (mLock) {\r\n            \/\/ Start watching for system property changes.\r\n            if (mSystemPropertyUpdater == null) {\r\n                mSystemPropertyUpdater = new Runnable() {\r\n                    @Override public void run() {\r\n                        synchronized (mLock) {\r\n                            for (int i = mRoots.size() - 1; i >= 0; --i) {\r\n                                mRoots.get(i).loadSystemProperties();\r\n                            }\r\n                        }\r\n                    }\r\n                };\r\n                SystemProperties.addChangeCallback(mSystemPropertyUpdater);\r\n            }\r\n\r\n            int index = findViewLocked(view, false);\r\n            if (index >= 0) {\r\n                if (mDyingViews.contains(view)) {\r\n                    \/\/ Don't wait for MSG_DIE to make it's way through root's queue.\r\n                    mRoots.get(index).doDie();\r\n                } else {\r\n                    throw new IllegalStateException(\"View \" + view\r\n                            + \" has already been added to the window manager.\");\r\n                }\r\n                \/\/ The previous removeView() had not completed executing. Now it has.\r\n            }\r\n\r\n            \/\/ If this is a panel window, then find the window it is being\r\n            \/\/ attached to for future reference.\r\n            if (wparams.type >= WindowManager.LayoutParams.FIRST_SUB_WINDOW &&\r\n                    wparams.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {\r\n                final int count = mViews.size();\r\n                for (int i = 0; i < count; i++) {\r\n                    if (mRoots.get(i).mWindow.asBinder() == wparams.token) {\r\n                        panelParentView = mViews.get(i);\r\n                    }\r\n                }\r\n            }\r\n\r\n            root = new ViewRootImpl(view.getContext(), display);\r\n\r\n            view.setLayoutParams(wparams);\r\n\r\n            mViews.add(view);\r\n            mRoots.add(root);\r\n            mParams.add(wparams);\r\n        }\r\n\r\n        \/\/ do this last because it fires off messages to start doing things\r\n        try {\r\n            root.setView(view, wparams, panelParentView);\r\n        } catch (RuntimeException e) {\r\n            \/\/ BadTokenException or InvalidDisplayException, clean up.\r\n            synchronized (mLock) {\r\n                final int index = findViewLocked(view, false);\r\n                if (index >= 0) {\r\n                    removeViewLocked(index, true);\r\n                }\r\n            }\r\n            throw e;\r\n        }\r\n    }\r\n\r\n```\r\n\r\n而调用addView()方法是在ActivityThread类的handleResumeActivity()方法：\r\n\r\n```\r\n\r\n    final void handleResumeActivity(IBinder token,\r\n            boolean clearHide, boolean isForward, boolean reallyResume) {\r\n        \/\/ If we are getting ready to gc after going to the background, well\r\n        \/\/ we are back active so skip it.\r\n        unscheduleGcIdler();\r\n        mSomeActivitiesChanged = true;\r\n\r\n        \/\/ TODO Push resumeArgs into the activity for consideration\r\n        ActivityClientRecord r = performResumeActivity(token, clearHide);\r\n\r\n        if (r != null) {\r\n            final Activity a = r.activity;\r\n\r\n            if (localLOGV) Slog.v(\r\n                TAG, \"Resume \" + r + \" started activity: \" +\r\n                a.mStartedActivity + \", hideForNow: \" + r.hideForNow\r\n                + \", finished: \" + a.mFinished);\r\n\r\n            final int forwardBit = isForward ?\r\n                    WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0;\r\n\r\n            \/\/ If the window hasn't yet been added to the window manager,\r\n            \/\/ and this guy didn't finish itself or start another activity,\r\n            \/\/ then go ahead and add the window.\r\n            boolean willBeVisible = !a.mStartedActivity;\r\n            if (!willBeVisible) {\r\n                try {\r\n                    willBeVisible = ActivityManagerNative.getDefault().willActivityBeVisible(\r\n                            a.getActivityToken());\r\n                } catch (RemoteException e) {\r\n                }\r\n            }\r\n            if (r.window == null && !a.mFinished && willBeVisible) {\r\n                r.window = r.activity.getWindow();\r\n                View decor = r.window.getDecorView();\r\n                decor.setVisibility(View.INVISIBLE);\r\n                ViewManager wm = a.getWindowManager();\r\n                WindowManager.LayoutParams l = r.window.getAttributes();\r\n                a.mDecor = decor;\r\n                l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;\r\n                l.softInputMode |= forwardBit;\r\n                if (a.mVisibleFromClient) {\r\n                    a.mWindowAdded = true;\r\n                    wm.addView(decor, l);\r\n                }\r\n\r\n            \/\/ If the window has already been added, but during resume\r\n            \/\/ we started another activity, then don't yet make the\r\n            \/\/ window visible.\r\n            } else if (!willBeVisible) {\r\n                if (localLOGV) Slog.v(\r\n                    TAG, \"Launch \" + r + \" mStartedActivity set\");\r\n                r.hideForNow = true;\r\n            }\r\n\r\n            \/\/ Get rid of anything left hanging around.\r\n            cleanUpPendingRemoveWindows(r);\r\n\r\n            \/\/ The window is now visible if it has been added, we are not\r\n            \/\/ simply finishing, and we are not starting another activity.\r\n            if (!r.activity.mFinished && willBeVisible\r\n                    && r.activity.mDecor != null && !r.hideForNow) {\r\n                if (r.newConfig != null) {\r\n                    if (DEBUG_CONFIGURATION) Slog.v(TAG, \"Resuming activity \"\r\n                            + r.activityInfo.name + \" with newConfig \" + r.newConfig);\r\n                    performConfigurationChanged(r.activity, r.newConfig);\r\n                    freeTextLayoutCachesIfNeeded(r.activity.mCurrentConfig.diff(r.newConfig));\r\n                    r.newConfig = null;\r\n                }\r\n                if (localLOGV) Slog.v(TAG, \"Resuming \" + r + \" with isForward=\"\r\n                        + isForward);\r\n                WindowManager.LayoutParams l = r.window.getAttributes();\r\n                if ((l.softInputMode\r\n                        & WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)\r\n                        != forwardBit) {\r\n                    l.softInputMode = (l.softInputMode\r\n                            & (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION))\r\n                            | forwardBit;\r\n                    if (r.activity.mVisibleFromClient) {\r\n                        ViewManager wm = a.getWindowManager();\r\n                        View decor = r.window.getDecorView();\r\n                        wm.updateViewLayout(decor, l);\r\n                    }\r\n                }\r\n                r.activity.mVisibleFromServer = true;\r\n                mNumVisibleActivities++;\r\n                if (r.activity.mVisibleFromClient) {\r\n                    r.activity.makeVisible();\r\n                }\r\n            }\r\n\r\n            if (!r.onlyLocalRequest) {\r\n                r.nextIdle = mNewActivities;\r\n                mNewActivities = r;\r\n                if (localLOGV) Slog.v(\r\n                    TAG, \"Scheduling idle handler for \" + r);\r\n                Looper.myQueue().addIdleHandler(new Idler());\r\n            }\r\n            r.onlyLocalRequest = false;\r\n\r\n            \/\/ Tell the activity manager we have resumed.\r\n            if (reallyResume) {\r\n                try {\r\n                    ActivityManagerNative.getDefault().activityResumed(token);\r\n                } catch (RemoteException ex) {\r\n                }\r\n            }\r\n\r\n        } else {\r\n            \/\/ If an exception was thrown when trying to resume, then\r\n            \/\/ just end this activity.\r\n            try {\r\n                ActivityManagerNative.getDefault()\r\n                    .finishActivity(token, Activity.RESULT_CANCELED, null, false);\r\n            } catch (RemoteException ex) {\r\n            }\r\n        }\r\n    }\r\n```\r\n\r\n看到上面的方法有些人心里可能有底儿了，handleResumeActivity()方法是不是让Activity回调onResume？如果是的话一切就都明了了，因为ViewrootImpl是在onReume期间创建，而AttachInfo是在ViewRootImpl实例化时创建，我们的工作线程是在onCreate时刷新UI的，那时候还没有实例化AttachInfo，导致mAttachInfo为null，最终if条件判断失败没有进入。然而这一切都是在YY，实践才是检验真理的唯一标准，动起来：\r\n\r\n看到这一行代码```\r\nActivityClientRecord r = performResumeActivity(token, clearHide);\r\n```微微一笑，点进去看看，\r\n\r\n```\r\n    public final ActivityClientRecord performResumeActivity(IBinder token,\r\n            boolean clearHide) {\r\n        ActivityClientRecord r = mActivities.get(token);\r\n        if (localLOGV) Slog.v(TAG, \"Performing resume of \" + r\r\n                + \" finished=\" + r.activity.mFinished);\r\n        if (r != null && !r.activity.mFinished) {\r\n            if (clearHide) {\r\n                r.hideForNow = false;\r\n                r.activity.mStartedActivity = false;\r\n            }\r\n            try {\r\n                r.activity.mFragments.noteStateNotSaved();\r\n                if (r.pendingIntents != null) {\r\n                    deliverNewIntents(r, r.pendingIntents);\r\n                    r.pendingIntents = null;\r\n                }\r\n                if (r.pendingResults != null) {\r\n                    deliverResults(r, r.pendingResults);\r\n                    r.pendingResults = null;\r\n                }\r\n                r.activity.performResume();\r\n    \r\n                EventLog.writeEvent(LOG_ON_RESUME_CALLED,\r\n                        UserHandle.myUserId(), r.activity.getComponentName().getClassName());\r\n    \r\n                r.paused = false;\r\n                r.stopped = false;\r\n                r.state = null;\r\n                r.persistentState = null;\r\n            } catch (Exception e) {\r\n                if (!mInstrumentation.onException(r.activity, e)) {\r\n                    throw new RuntimeException(\r\n                        \"Unable to resume activity \"\r\n                        + r.intent.getComponent().toShortString()\r\n                        + \": \" + e.toString(), e);\r\n                }\r\n            }\r\n        }\r\n        return r;\r\n    }\r\n```\r\n代码很短，很容易提取有用信息：``` r.activity.performResume();```在进去看看：\r\n\r\n```\r\n\r\n    final void performResume() {\r\n        performRestart();\r\n    \r\n        mFragments.execPendingActions();\r\n    \r\n        mLastNonConfigurationInstances = null;\r\n    \r\n        mCalled = false;\r\n        \/\/ mResumed is set by the instrumentation\r\n        mInstrumentation.callActivityOnResume(this);\r\n        if (!mCalled) {\r\n            throw new SuperNotCalledException(\r\n                \"Activity \" + mComponent.toShortString() +\r\n                \" did not call through to super.onResume()\");\r\n        }\r\n    \r\n        \/\/ Now really resume, and install the current status bar and menu.\r\n        mCalled = false;\r\n    \r\n        mFragments.dispatchResume();\r\n        mFragments.execPendingActions();\r\n    \r\n        onPostResume();\r\n        if (!mCalled) {\r\n            throw new SuperNotCalledException(\r\n                \"Activity \" + mComponent.toShortString() +\r\n                \" did not call through to super.onPostResume()\");\r\n        }\r\n    }\r\n```\r\n看到```mInstrumentation```这个属性就能感觉到越来越接近SDK API层了，看看它的```callActivityOnResume()```方法做了什么：\r\n\r\n```\r\n    public void callActivityOnResume(Activity activity) {\r\n        activity.mResumed = true;\r\n        activity.onResume();\r\n        \r\n        if (mActivityMonitors != null) {\r\n            synchronized (mSync) {\r\n                final int N = mActivityMonitors.size();\r\n                for (int i=0; i<N; i++) {\r\n                    final ActivityMonitor am = mActivityMonitors.get(i);\r\n                    am.match(activity, activity, activity.getIntent());\r\n                }\r\n            }\r\n        }\r\n    }\r\n```\r\n\r\n一行```activity.onResume();```已经水落石出。\r\n回到handleResumeActivity代码中，我精简下：\r\n\r\n```\r\n final void handleResumeActivity(IBinder token,\r\n            boolean clearHide, boolean isForward, boolean reallyResume) {\r\n   \/\/这里是最终回调Activity的onResume()方法\r\n        ActivityClientRecord r = performResumeActivity(token, clearHide);\r\n\/\/省略若干\r\n        if (r != null) {\r\n            final Activity a = r.activity;\r\n            final int forwardBit = isForward ?\r\n            WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0;\r\n            boolean willBeVisible = !a.mStartedActivity;\r\n    \r\n            if (r.window == null && !a.mFinished && willBeVisible) {\r\n                r.window = r.activity.getWindow();\r\n                View decor = r.window.getDecorView();\r\n                decor.setVisibility(View.INVISIBLE);\r\n                ViewManager wm = a.getWindowManager();\r\n                WindowManager.LayoutParams l = r.window.getAttributes();\r\n                a.mDecor = decor;\r\n                l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;\r\n                l.softInputMode |= forwardBit;\r\n                if (a.mVisibleFromClient) {\r\n                    a.mWindowAdded = true;\r\n\/\/这里是调用WindowManagerGlobal的addView()方法最终实例化ViewRootImpl，进而实例化AttachInfo\r\n                    wm.addView(decor, l);\r\n                }\r\n       \r\n            } else if (!willBeVisible) {\r\n                if (localLOGV) Slog.v(\r\n                    TAG, \"Launch \" + r + \" mStartedActivity set\");\r\n                r.hideForNow = true;\r\n            }\r\n        }\r\n    }\r\n```\r\n\r\n\r\n另外关于阅读源码问题，win下当然使用SourceInsight不二选，如果是在mac下可以参考我的[osx下如何使用SublimeText阅读Android系统源码](http:\/\/www.jianshu.com\/p\/c295d2729ecf).。\r\n```"
  },
  {
    "title" : "为什么相对布局比线性布局性能低",
    "created_time" : "2017-07-19 10:53:28",
    "body" : "# 0x00 前言\r\n\r\nUI优化原则之一：如果使用线性布局和相对布局的层级一样，那么优先使用线性布局。\r\n\r\n经常说出这个原则的时候就会顺便被问到为什么。为了避免尴尬还是抽时间把源码大概看了一下。\r\n\r\n<!-- more -->\r\n\r\n# 0x01 View绘制流程简述 \r\n\r\n看过源码的应该知道，View的绘制是从`ViewRootImpl.performTraversals()`方法开始的。\r\n\r\n先后经历`performMeasure`、`performLayout`和`performDraw`三个阶段，就是常说的测量、布局和绘制。\r\n\r\n- performMeasure会调用根View的measure，进而调用onMeasure方法\r\n- performLayout调用根View的layout，进而调用onLayout方法\r\n- performDraw调用根View的draw，进而调用onDraw方法\r\n\r\n鉴于两个都是ViewGroup，所以可以忽略onDraw\r\n\r\n有对比才有伤害，要比较这两个布局性能，要先看看这两个布局分别在onMeasure，onLayout都做了什么。\r\n\r\n# 0x02 LinearLayout分析\r\n\r\nLinearLayout的onMeasure方法内容很简单，就是判断方向然后分别调用:\r\n\r\n```java\r\n   @Override\r\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\r\n        if (mOrientation == VERTICAL) {\r\n            measureVertical(widthMeasureSpec, heightMeasureSpec);\r\n        } else {\r\n            measureHorizontal(widthMeasureSpec, heightMeasureSpec);\r\n        }\r\n    }\r\n```\r\n\r\n那就随便看看`measureVertical`方法里面干了些什么：\r\n\r\n```Java\r\n        \/\/ See how tall everyone is. Also remember max width.\r\n        for (int i = 0; i < count; ++i) {\r\n            final View child = getVirtualChildAt(i);\r\n\r\n            if (child == null) {\r\n                mTotalLength += measureNullChild(i);\r\n                continue;\r\n            }\r\n\r\n            if (child.getVisibility() == View.GONE) {\r\n               i += getChildrenSkipCount(child, i);\r\n               continue;\r\n            }\r\n\r\n            if (hasDividerBeforeChildAt(i)) {\r\n                mTotalLength += mDividerHeight;\r\n            }\r\n\r\n            LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();\r\n\r\n            totalWeight += lp.weight;\r\n            \r\n            if (heightMode == MeasureSpec.EXACTLY && lp.height == 0 && lp.weight > 0) {\r\n                \/\/ Optimization: don't bother measuring children who are going to use\r\n                \/\/ leftover space. These views will get measured again down below if\r\n                \/\/ there is any leftover space.\r\n                final int totalLength = mTotalLength;\r\n                mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);\r\n                skippedMeasure = true;\r\n            } else {\r\n                int oldHeight = Integer.MIN_VALUE;\r\n\r\n                if (lp.height == 0 && lp.weight > 0) {\r\n                    \/\/ heightMode is either UNSPECIFIED or AT_MOST, and this\r\n                    \/\/ child wanted to stretch to fill available space.\r\n                    \/\/ Translate that to WRAP_CONTENT so that it does not end up\r\n                    \/\/ with a height of 0\r\n                    oldHeight = 0;\r\n                    lp.height = LayoutParams.WRAP_CONTENT;\r\n                }\r\n\r\n                \/\/ Determine how big this child would like to be. If this or\r\n                \/\/ previous children have given a weight, then we allow it to\r\n                \/\/ use all available space (and we will shrink things later\r\n                \/\/ if needed).\r\n                measureChildBeforeLayout(\r\n                       child, i, widthMeasureSpec, 0, heightMeasureSpec,\r\n                       totalWeight == 0 ? mTotalLength : 0);\r\n\r\n                if (oldHeight != Integer.MIN_VALUE) {\r\n                   lp.height = oldHeight;\r\n                }\r\n\r\n                final int childHeight = child.getMeasuredHeight();\r\n                final int totalLength = mTotalLength;\r\n                mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin +\r\n                       lp.bottomMargin + getNextLocationOffset(child));\r\n\r\n                if (useLargestChild) {\r\n                    largestChildHeight = Math.max(childHeight, largestChildHeight);\r\n                }\r\n            }\r\n\r\n            \/**\r\n             * If applicable, compute the additional offset to the child's baseline\r\n             * we'll need later when asked {@link #getBaseline}.\r\n             *\/\r\n            if ((baselineChildIndex >= 0) && (baselineChildIndex == i + 1)) {\r\n               mBaselineChildTop = mTotalLength;\r\n            }\r\n\r\n            \/\/ if we are trying to use a child index for our baseline, the above\r\n            \/\/ book keeping only works if there are no children above it with\r\n            \/\/ weight.  fail fast to aid the developer.\r\n            if (i < baselineChildIndex && lp.weight > 0) {\r\n                throw new RuntimeException(\"A child of LinearLayout with index \"\r\n                        + \"less than mBaselineAlignedChildIndex has weight > 0, which \"\r\n                        + \"won't work.  Either remove the weight, or don't set \"\r\n                        + \"mBaselineAlignedChildIndex.\");\r\n            }\r\n\r\n            boolean matchWidthLocally = false;\r\n            if (widthMode != MeasureSpec.EXACTLY && lp.width == LayoutParams.MATCH_PARENT) {\r\n                \/\/ The width of the linear layout will scale, and at least one\r\n                \/\/ child said it wanted to match our width. Set a flag\r\n                \/\/ indicating that we need to remeasure at least that view when\r\n                \/\/ we know our width.\r\n                matchWidth = true;\r\n                matchWidthLocally = true;\r\n            }\r\n\r\n            final int margin = lp.leftMargin + lp.rightMargin;\r\n            final int measuredWidth = child.getMeasuredWidth() + margin;\r\n            maxWidth = Math.max(maxWidth, measuredWidth);\r\n            childState = combineMeasuredStates(childState, child.getMeasuredState());\r\n\r\n            allFillParent = allFillParent && lp.width == LayoutParams.MATCH_PARENT;\r\n            if (lp.weight > 0) {\r\n                \/*\r\n                 * Widths of weighted Views are bogus if we end up\r\n                 * remeasuring, so keep them separate.\r\n                 *\/\r\n                weightedMaxWidth = Math.max(weightedMaxWidth,\r\n                        matchWidthLocally ? margin : measuredWidth);\r\n            } else {\r\n                alternativeMaxWidth = Math.max(alternativeMaxWidth,\r\n                        matchWidthLocally ? margin : measuredWidth);\r\n            }\r\n\r\n            i += getChildrenSkipCount(child, i);\r\n        }  \r\n```\r\n\r\n这个方法主要是for循环中通过`measureChildBeforeLayout`测量子View高度，把每次测量的高度都累加到`mTotalLength`。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 0x03 RelativeLayout分析\r\n\r\n看看RelativeLayout的onMeasure方法：\r\n\r\n```java\r\n       View[] views = mSortedHorizontalChildren;\r\n        int count = views.length;\r\n\r\n        for (int i = 0; i < count; i++) {\r\n            View child = views[i];\r\n            if (child.getVisibility() != GONE) {\r\n                LayoutParams params = (LayoutParams) child.getLayoutParams();\r\n                int[] rules = params.getRules(layoutDirection);\r\n\r\n                applyHorizontalSizeRules(params, myWidth, rules);\r\n                measureChildHorizontal(child, params, myWidth, myHeight);\r\n\r\n                if (positionChildHorizontal(child, params, myWidth, isWrapContentWidth)) {\r\n                    offsetHorizontalAxis = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        views = mSortedVerticalChildren;\r\n        count = views.length;\r\n        final int targetSdkVersion = getContext().getApplicationInfo().targetSdkVersion;\r\n\r\n        for (int i = 0; i < count; i++) {\r\n            View child = views[i];\r\n            if (child.getVisibility() != GONE) {\r\n                LayoutParams params = (LayoutParams) child.getLayoutParams();\r\n                \r\n                applyVerticalSizeRules(params, myHeight);\r\n                measureChild(child, params, myWidth, myHeight);\r\n                if (positionChildVertical(child, params, myHeight, isWrapContentHeight)) {\r\n                    offsetVerticalAxis = true;\r\n                }\r\n\r\n                if (isWrapContentWidth) {\r\n                    if (isLayoutRtl()) {\r\n                        if (targetSdkVersion < Build.VERSION_CODES.KITKAT) {\r\n                            width = Math.max(width, myWidth - params.mLeft);\r\n                        } else {\r\n                            width = Math.max(width, myWidth - params.mLeft - params.leftMargin);\r\n                        }\r\n                    } else {\r\n                        if (targetSdkVersion < Build.VERSION_CODES.KITKAT) {\r\n                            width = Math.max(width, params.mRight);\r\n                        } else {\r\n                            width = Math.max(width, params.mRight + params.rightMargin);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (isWrapContentHeight) {\r\n                    if (targetSdkVersion < Build.VERSION_CODES.KITKAT) {\r\n                        height = Math.max(height, params.mBottom);\r\n                    } else {\r\n                        height = Math.max(height, params.mBottom + params.bottomMargin);\r\n                    }\r\n                }\r\n\r\n                if (child != ignore || verticalGravity) {\r\n                    left = Math.min(left, params.mLeft - params.leftMargin);\r\n                    top = Math.min(top, params.mTop - params.topMargin);\r\n                }\r\n\r\n                if (child != ignore || horizontalGravity) {\r\n                    right = Math.max(right, params.mRight + params.rightMargin);\r\n                    bottom = Math.max(bottom, params.mBottom + params.bottomMargin);\r\n                }\r\n            }\r\n        }\r\n```\r\n\r\n第一个for循环中`measureChildHorizontal`方法实现如下：\r\n\r\n```Java\r\n     int childWidthMeasureSpec = getChildMeasureSpec(params.mLeft,\r\n                params.mRight, params.width,\r\n                params.leftMargin, params.rightMargin,\r\n                mPaddingLeft, mPaddingRight,\r\n                myWidth);\r\n        int maxHeight = myHeight;\r\n        if (mMeasureVerticalWithPaddingMargin) {\r\n            maxHeight = Math.max(0, myHeight - mPaddingTop - mPaddingBottom -\r\n                    params.topMargin - params.bottomMargin);\r\n        }\r\n        int childHeightMeasureSpec;\r\n        if (myHeight < 0 && !mAllowBrokenMeasureSpecs) {\r\n            if (params.height >= 0) {\r\n                childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(\r\n                        params.height, MeasureSpec.EXACTLY);\r\n            } else {\r\n                \/\/ Negative values in a mySize\/myWidth\/myWidth value in RelativeLayout measurement\r\n                \/\/ is code for, \"we got an unspecified mode in the RelativeLayout's measurespec.\"\r\n                \/\/ Carry it forward.\r\n                childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);\r\n            }\r\n        } else if (params.width == LayoutParams.MATCH_PARENT) {\r\n            childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(maxHeight, MeasureSpec.EXACTLY);\r\n        } else {\r\n            childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(maxHeight, MeasureSpec.AT_MOST);\r\n        }\r\n        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);\r\n```\r\n\r\n\r\n\r\n第二个for循环中`measureChild`实现如下：\r\n\r\n```Java\r\nint childWidthMeasureSpec = getChildMeasureSpec(params.mLeft,\r\n                params.mRight, params.width,\r\n                params.leftMargin, params.rightMargin,\r\n                mPaddingLeft, mPaddingRight,\r\n                myWidth);\r\n        int childHeightMeasureSpec = getChildMeasureSpec(params.mTop,\r\n                params.mBottom, params.height,\r\n                params.topMargin, params.bottomMargin,\r\n                mPaddingTop, mPaddingBottom,\r\n                myHeight);\r\n        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);\r\n```\r\n\r\n两个for循环中都执行了`child.measure(childWidthMeasureSpec, childHeightMeasureSpec);`这意味着子View测量执行了两遍。\r\n\r\n为什么RelativeLayout要测量两遍？\r\n\r\n> 因为RelativeLayout并不像LinearLayout那样有着方向单一性。RelativeLayout的灵活性就在于允许纵横双向的，这样view直接不仅横向依赖，还有纵向依赖，每个方向都要测量一遍。导致性能略差。"
  },
  {
    "title" : "为什么Android中很多int常量使用十六进制表示",
    "created_time" : "2017-07-19 10:12:21",
    "body" : "# 0x00 前言\r\n\r\n在Java或者Android中，发现很多涉及框架和源码地方，很多int常量都是使用十六进制表示的，而不是我们日常开发中直接使用我们最熟悉的十进制。这是为什么呢？换个问法，这样做有什么好处呢？\r\n\r\n```java\r\n    public static final int FLAG_DEBUG_TRIAGED_MISSING = 0x00000100;\r\n    public static final int FLAG_IGNORE_EPHEMERAL = 0x00000200;\r\n    public static final int FLAG_ACTIVITY_NO_HISTORY = 0x40000000;\r\n    public static final int FLAG_ACTIVITY_NEW_TASK = 0x10000000;\r\n    public static final int FLAG_ACTIVITY_MULTIPLE_TASK = 0x08000000;\r\n    public static final int FLAG_ACTIVITY_CLEAR_TASK = 0X00008000;\r\n    public static final int FLAG_ACTIVITY_TASK_ON_HOME = 0X00004000;\r\n\r\n```\r\n\r\n<!-- more -->\r\n\r\n猜测可能的原因：\r\n\r\n①为了美观\r\n\r\n②为了方便位运算\r\n\r\n③关于①我是瞎说的\r\n\r\n既然多采用十六进制，那就先简单看看什么是十六进制\r\n\r\n# 0x01 十六进制简单介绍\r\n\r\n以0x或0X开头，使用数字0~9及字符A~F表示16个可能的值，这种进制方式一般称为十六进制。\r\n\r\n一个int占4个字节，32位。\r\n\r\n十六进制中0xF最大，二进制表示：1111，用4位即可表示出来，所以在用十六进制表示int时，通常0x后面跟8位数字\/字符，这样就可以表示满一个int值。也就是前言中所看到的。\r\n\r\n# 0x02 发现规律\r\n\r\n通过前言中的代码可以发现基本上频繁出现的只有1，2，4，8几个数字而其他位置都是0占位。为什么会出现这种情况呢？\r\n\r\n首先把上面的十六进制转换成二进制看一下：\r\n\r\n`0x00000100`转换二进制`0001 0000 0000`\r\n\r\n`0x00000200`转换二进制`0010 0000 0000` \r\n\r\n`0X00004000`转换二进制`0100 0000 0000 0000`\r\n\r\n`0X00008000`转换二进制`1000 0000 0000`\r\n\r\n转换后可以发现，1，2，4，8这几个值很特殊，在二进制中表示这几个数时都只要某一位为1，其他位用0占位即可表示。\r\n\r\n换句话说，二进制的4位表示十六进制中的一个数字，而这4位中若只有其中一位为1的话，那么可能的值情况为1=2º，2=2¹，4=2²，8=2³。\r\n\r\n\r\n\r\n这样做有什么好处呢？\r\n\r\n# 0x03 这样做的好处\r\n\r\n- 拿位移来说因为只有一个数字带值，其他都是0占位，位移时大脑中快速把十六进制转为二进制然后补0位即可。\r\n\r\n  拿0x200来说，换算二进制我只要把2用二进制0010在大脑中展示出来，然后后面跟8个0就换算完成。如果0x200>>1,右移1位，相当于1后面的9个0被砍掉一个，左边高位补0。\r\n\r\n  二进制表示由`0010 0000 0000`变成了`0001 0000 000`。值由512变成了256，可见右移1位相当于除以2。前面十六进制和二进制转换是在大脑中完成，转换到十进制我是笔算的，可能这是采用十六进制表示int原因之一吧。\r\n\r\n  同样左移思路也是如此。\r\n\r\n- 位与&\/位或|\r\n\r\n  位与\/位或是对参与运算的数的二进制进行位与\/位或。\r\n\r\n  位与&：两数二进制对应位均为1时结果才为1，其余为0\r\n\r\n  位或|：两数二进制对应位有一个为1时，结果位就为1\r\n\r\n  在源码和框架中，很多时候需要存储一些状态组合，比如：\r\n\r\n  ```java\r\n     public Intent addFlags(int flags) {\r\n          mFlags |= flags;\r\n          return this;\r\n      }\r\n  ```\r\n\r\n  最后在一些地方会根据状态组合的不同值来做出不同的响应。这时使用1，2，4，8这种格式的十六进制就很方便，因为不同的状态值只是在二进制的不同位上用1标记而已。这样最后可以根据mFlags的值二进制有多少位为1，基本就能判断有多少种状态。当然这里说的是位或。"
  },
  {
    "title" : "详解设计模式之单例模式",
    "created_time" : "2017-04-21 22:22:50",
    "body" : "# 1、什么是单例?\r\n\r\n单例顾名思义就是单个实例。日常工作都是自由的通过构造方法创建对象的，所以听到单例时，我们应该意识到其下是暗含了2层意思的，①构造方法不在为你所用，你不需要知道如何创建对象。②我会给你提供获取实例的方法，不需要你自己动手创建。\r\n\r\n![单例示意图.png](http:\/\/upload-images.jianshu.io\/upload_images\/1796052-fc54578715942157.png?imageMogr2\/auto-orient\/strip%7CimageView2\/2\/w\/1240)\r\n\r\n不清楚uml类关系的请移步[UML--类图详解](http:\/\/www.jianshu.com\/p\/bf23234d5d2b)\r\n\r\n<!-- more -->\r\n\r\n# 2、\b什么情况下使用单例?\r\n\r\n当你需要内存中只有一个对象的时候。\r\n\r\n# 3、为什么使用单例？\r\n\r\n单例保证了内存中数据的唯一性，同时也降低了内存的开销。\r\n# 4、\b如何实现单例？\r\n\r\n在1中了解到两层含义后，对我们创建单例类是有帮助的，总结下就是：①私有化构造方法  ②对外提供获取实例方法\r\n\r\n## 饿汉式\r\n\r\n所谓饿汉式，就是在类加载的时候就迫不及待的创建对象，等到调用获取实例方法直接拿到对象返回即可。\r\n看实现代码：\r\n\r\n```java\r\npublic class HungarySingleton {\r\n\tprivate static HungarySingleton intance = new HungarySingleton();\r\n\t\r\n\tprivate HungarySingleton(){\r\n\t\t\r\n\t}\r\n\tpublic static HungarySingleton getInstance(){\r\n\t\treturn intance;\r\n\t}\r\n}\r\n```\r\n*懒汉式是最简单的单例模式，在类加载的时候就实例化，避免了多线程问题的同时保证了实例唯一性。缺点是即使不需要时候也会被实例，会占用内存。所以推荐在实例占用内存不多的情况下使用，否则请使用下面几种方式。*\r\n\r\n## 懒汉式\r\n\r\n懒汉式，就是在首次调用的时候才会创建实例，相比饿汉式，延迟了初始化。\r\n\r\n```java\r\npublic class LayzySingleton {\r\n\tprivate static LayzySingleton instance = null;\r\n\r\n\tprivate LayzySingleton() {\r\n\r\n\t}\r\n\tpublic LayzySingleton getInstatnce() {\r\n\t\tif (null == instance) {\r\n\t\t\tinstance = new LayzySingleton();\r\n\t\t}\r\n\t\treturn instance;\r\n\t}\r\n}\r\n```\r\n上面代码有个问题，就是在多线程调用中会有产生多个实例的隐患，所以需要使用线程同步：\r\n\r\n```java\r\npublic class LayzySingleton {\r\n\tprivate static LayzySingleton instance = null;\r\n\r\n\tprivate LayzySingleton() {\r\n\r\n\t}\r\n\tpublic synchronized LayzySingleton getInstatnce() {\r\n\t\tif (null == instance) {\r\n\t\t\tinstance = new LayzySingleton();\r\n\t\t}\r\n\t\treturn instance;\r\n\t}\r\n}\r\n```\r\n*synchronized的加入虽然解决了多实例的隐患，但是又带来了性能低下的问题，因为我们只需要在首次创建对象时让同步产生作用即可，其后的调用无需同步，现在只要是调用该方法就同步，看来还需要改进*\r\n下面使用双重校验加锁(DCL)：\r\n\r\n```java\r\npublic class LayzySingleton {\r\n\tprivate static LayzySingleton instance = null;\r\n\r\n\tprivate LayzySingleton() {\r\n\r\n\t}\r\n\tpublic  LayzySingleton getInstatnce() {\r\n\t\tif (null == instance) {\r\n\t\t\tsynchronized(LayzySingleton.class){\r\n\t\t\t\tif (null == instance) {\r\n\t\t\t\t\tinstance = new LayzySingleton();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn instance;\r\n\t}\r\n}\r\n```\r\n现在多线程问题解决了，性能也得到优化了是不是双重校验加锁就完美了呢？\r\nNO~\r\n在Java并发编程中的指令重排序中有讲到双重校验加锁失效问题。\r\n要禁止指令重排序需要使用volatile修饰变量\r\n\r\n\r\n```java\r\n\tprivate volatile static LayzySingleton instance = null;\r\n```\r\n\r\n## 静态内部类\r\n\r\n如果觉得饿汉式占内存，懒汉式又要考虑多线程问题，那么可以使用静态内部类可能是你想要的：\r\n\r\n```java\r\npublic class Singleton {\r\n\t\r\n\tprivate Singleton(){\r\n\t\t\r\n\t}\r\n\tpublic Singleton getInstance(){\r\n\t\treturn Holder.instance;\r\n\t}\r\n\tprivate class Holder{\r\n\t\tprivate  static final  Singleton instance = new Singleton();\r\n\t}\r\n}\r\n```\r\n*静态内部类避免了加载Singleton类时就初始化问题，只有在调用getInstance时才会致使Holder类被加载并初始化，同时也避免了线程安全问题和性能问题，推荐使用此方法。*\r\n\r\n## 枚举式\r\n\r\n如果觉得上面的还是麻烦，可以使用枚举单例，\r\n代码实现：\r\n\r\n```java\r\npublic enum EnumSingleton {\r\n\t\r\n\tINSTANCE ;\r\n\t\r\n\tint num = 33;\r\n\tString config = \"jenson\";\r\n\t\r\n\tpublic void doSomething(){\r\n\t\t\r\n\t}\r\n}\r\n```\r\n*枚举单例也可以有属性可以有方法，重要的是枚举默认就是线程安全的。*"
  },
  {
    "title" : "详解设计模式之简单工厂模式",
    "created_time" : "2017-04-21 22:22:50",
    "body" : "####1、什么是简单工厂模式？\r\n把一些相关类的对象的创建封装在另一个类中，这样在上层的客户端不需要明白相关类对象是如何创建的，只需要调用另一个类的相关方法获取实例即可。另一个类就是所说的工厂类。为了避免每次使用工厂时都创建工厂实例，获取相关类实例的方法一般使用静态方法，所以简单工厂一般也叫静态工厂。\r\n\r\n####2、\b什么时候使用工厂模式？\r\n当你要对上层隐藏一些对象从而达到解耦的效果时可以使用简单工厂。\r\n\r\n<!-- more -->\r\n\r\n####3、\b如何使用工厂模式？\r\n- 先看下不使用模式如何创建接口实例\r\n\r\n![不使用模式.png](http:\/\/upload-images.jianshu.io\/upload_images\/1796052-6f2ed596ea68547b.png?imageMogr2\/auto-orient\/strip%7CimageView2\/2\/w\/1240)\r\n汽车接口代码：\r\n```\r\npublic interface CarApi {\r\n\tpublic void run();\r\n}\r\n```\r\n起亚汽车实现代码：\r\n\r\n```\r\npublic class KiaImpl implements CarApi {\r\n\r\n\t@Override\r\n\tpublic void run() {\r\n\t\t\/\/ TODO Auto-generated method stub\r\n\t\tSystem.out.println(\"起亚跑起来\");\r\n\t}\r\n\r\n}\r\n```\r\n客户端代码：\r\n\r\n\r\n```\r\npublic class Client {\r\n\tpublic static void main(String[] args) {\r\n\t\tCarApi carApi = new KiaImpl();\r\n\t\tcarApi.run();\r\n\t}\r\n}\r\n```\r\n如上，不使用模式的时候，客户端不仅依赖接口，更知道了接口的实现类是KiaImpl。要知道Java面向接口编程就是为了封装隔离，达到解耦模块的目的。这里虽然使用了接口，但是充其量只用到了其多态，至于封装隔离还是没影的事儿。\r\n- 看下使用简单工厂是如何实现的\r\n\r\n![使用模式.png](http:\/\/upload-images.jianshu.io\/upload_images\/1796052-cc51abbba4547d5b.png?imageMogr2\/auto-orient\/strip%7CimageView2\/2\/w\/1240)\r\n汽车接口和起亚实现代码如上不变，宝马实现代码如下：\r\n\r\n```\r\npublic class BmwImpl implements CarApi {\r\n\r\n\t@Override\r\n\tpublic void run() {\r\n\t\t\/\/ TODO Auto-generated method stub\r\n\t\tSystem.out.println(\"宝马跑起来\");\r\n\t}\r\n\r\n}\r\n```\r\n汽车工厂代码如下：\r\n\r\n```\r\npublic class CarFactory {\r\n\tpublic static CarApi getCar(int type) {\r\n\t\tCarApi car;\r\n\t\tif (type == 0) {\r\n\t\t\tcar = new KiaImpl();\r\n\t\t} else {\r\n\t\t\tcar = new BmwImpl();\r\n\t\t}\r\n\t\treturn car;\r\n\t}\r\n}\r\n```\r\n客户端代码如下：\r\n\r\n```\r\n public class Client {\r\n\tpublic static void main(String[] args) {\r\n\/\/\t\tCarApi carApi = new KiaImpl();\r\n\/\/\t\tcarApi.run();\r\n\t\tCarApi kia = CarFactory.getCar(0);\r\n\t\tkia.run();\r\n\t\tCarApi bmw = CarFactory.getCar(1);\r\n\t\tbmw.run();\r\n\t}\r\n}\r\n```\r\n\r\n通过客户端代码可知，把实现类封装在工厂后，客户端只需要调用工厂静态方法就能拿到实现类实例，而不需要知道这些实现类是如何创建实现的，达到了解耦的目的。\r\n\r\n有一点要注意：如果接口有多个实现类，在工厂中如何确定想要获取哪个实例？这时就要在静态方法中传入参数，这时客户端就要知道参数类型代表的意思。所以此时底层要向上层暴露一些信息以供使用。"
  },
  {
    "title" : "详解设计模式之责任链模式",
    "created_time" : "2017-05-10 12:36:14",
    "body" : "# 说在前面的话\r\n\r\n责任链模式也叫职责链，抛开设计模式不谈，单看“责任链”这三个字，关注点一下子就放到了“链”字上了。链即锁链、链条，像链子一样环环相扣的东西。比如我们数据结构中的链表，当前对象持有下一个对象的地址。同样，设计模式中的责任链也是如此，任务一环套一环，环环相扣。\r\n\r\n<!-- more -->\r\n\r\n# 面试流程分析\r\n\r\n作为技术人员离职再就业少不了要面试的，那么我们就拿面试流程来细说。假设面试流程分为三步：组长面试，CTO面试，HR终面，一共三面。\r\n\r\n## 不考虑其他任何方面的优化，一个人的面试如何实现？\r\n\r\n```\r\n\t\/\/面试类\r\n\tstatic class Viewer {\r\n\t\tpublic void interview(int level) {\r\n\r\n\t\t\tif (0 == level) {\/\/ 组长面试\r\n\t\t\t\t\/\/ TODO\r\n\t\t\t} else if (1 == level) {\/\/ CTO面试\r\n\t\t\t\t\/\/ TODO\r\n\t\t\t} else if (2 == level) {\/\/ HR终面\r\n\t\t\t\t\/\/ TODO\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n```\r\n\r\n```\r\n\t\/\/客户端\r\n\tpublic static void main(String[] args) {\r\n\r\n\t\tViewer viewer = new Viewer();\r\n\t\tviewer.interview(0);\r\n\t\tviewer.interview(1);\r\n\t\tviewer.interview(2);\r\n\r\n\t}\r\n```\r\n\r\n从上面实现方式可以看出，面试方法，如果要面试三次，那么客户端要调用三次，面试方法interview中对level判断，不同级别有不同人面试，如果以后增加四面，那么就要修改interview方法。\r\n\r\n另外每次的面试 `viewer.interview` 都在客户端调用，但是按照正常流程组长面试完，如果觉得可以，应该流程传递到CTO哪里了，CTO谈完了觉得技术良好，最后交给HR谈待遇，流程抽象提取后是这样：\r\n\r\n\r\n\r\n![屏幕快照 2017-05-10 下午4.21.27](详解设计模式之责任链模式\/屏幕快照 2017-05-10 下午4.21.27.png)\r\n\r\n这不就是开头说的“链”吗？\r\n\r\n## 下面看看用链如何实现面试的：\r\n\r\n\r\n\r\n先定义一个链接口来控制面试流程：\r\n\r\n```\r\npublic interface Chain {\r\n\r\n\t\/**\r\n\t * 面试方法\r\n\t * \r\n\t * @param level\r\n\t *\/\r\n\tvoid interview();\r\n\r\n\t\/**\r\n\t * 是否通过\r\n\t * \r\n\t * @return\r\n\t *\/\r\n\tboolean isCross();\r\n\r\n\t\/**\r\n\t * 下一个面试官\r\n\t * \r\n\t * @param chain\r\n\t *\/\r\n\tvoid next(Chain chain);\r\n}\r\n```\r\n\r\n然后定义组长Grouper、CTO、HR三个面试官类实现Chain接口。\r\n\r\n```\r\n\tstatic class Grouper implements Chain {\r\n\t\tprivate Chain next = null;\r\n\r\n\t\t@Override\r\n\t\tpublic void interview() {\r\n\t\t\t\/\/ TODO Auto-generated method stub\r\n\r\n\t\t\tif (isCross() && next != null) {\r\n\t\t\t\tSystem.out.println(\"组长面试通过\");\r\n\t\t\t\tnext.interview();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic boolean isCross() {\r\n\t\t\t\/\/ TODO Auto-generated method stub\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic void next(Chain chain) {\r\n\t\t\t\/\/ TODO Auto-generated method stub\r\n\t\t\tthis.next = chain;\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tstatic class CTO implements Chain {\r\n\t\tprivate Chain next = null;\r\n\r\n\t\t@Override\r\n\t\tpublic void interview() {\r\n\t\t\t\/\/ TODO Auto-generated method stub\r\n\t\t\tif (isCross() && next != null) {\r\n\t\t\t\tSystem.out.println(\"CTO面试通过\");\r\n\t\t\t\tnext.interview();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic boolean isCross() {\r\n\t\t\t\/\/ TODO Auto-generated method stub\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic void next(Chain chain) {\r\n\t\t\t\/\/ TODO Auto-generated method stub\r\n\t\t\tthis.next = chain;\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tstatic class HR implements Chain {\r\n\t\tprivate Chain next = null;\r\n\r\n\t\t@Override\r\n\t\tpublic void interview() {\r\n\t\t\t\/\/ TODO Auto-generated method stub\r\n\t\t\tSystem.out.println(\"HR面试通过\");\r\n\t\t\tif (isCross() && next != null) {\r\n\t\t\t\tnext.interview();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic boolean isCross() {\r\n\t\t\t\/\/ TODO Auto-generated method stub\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic void next(Chain chain) {\r\n\t\t\t\/\/ TODO Auto-generated method stub\r\n\r\n\t\t}\r\n\r\n\t}\r\n```\r\n\r\n然后看看客户端调用：\r\n\r\n```\r\n\tpublic static void main(String[] args) {\r\n\t\tGrouper grouper = new Grouper();\r\n\t\tCTO cto = new CTO();\r\n\t\tHR hr = new HR();\r\n\t\tgrouper.next(cto);\r\n\t\tcto.next(hr);\r\n\t\tgrouper.interview();\r\n\t}\r\n```\r\n\r\n通过` grouper.next(cto);`和`cto.next(hr);` 设置完链式关系，最后只要通过`grouper.interview();` 调用一次面试就可以了。因为grouper最为链首，其中存储了下一个链元素next。只要条件达成（本次面试通过），则自动执行下一个任务，这就是任务链的好处。\r\n\r\n可能还有一个疑问：`grouper.next(cto);` 等流程还是在客户端设置的，这无疑要增加了客户端对底层这些类的认知度。\r\n\r\n其实完全可以把这些细节隐藏在底层的。比如我们把流程在Grouper构造方法中设置：\r\n\r\n```\r\n\t\tpublic Grouper() {\r\n\t\t\tCTO cto = new CTO();\r\n\t\t\tHR hr = new HR();\r\n\t\t\tnext(cto);\r\n\t\t\tcto.next(hr);\r\n\t\t}\r\n```\r\n\r\n这时客户端是如此的简洁：\r\n\r\n```\r\n\tpublic static void main(String[] args) {\r\n\t\tGrouper grouper = new Grouper();\r\n\t\tgrouper.interview();\r\n\t}\r\n```\r\n\r\n其实上面的一般方法还有其他的实现方法，但是无疑常见的实现要么耦合性较强，要么需要客户端对底层认知度高。\r\n\r\n说了半天，现在来步入主题看看到底什么是责任链\r\n\r\n\r\n\r\n# 责任链模式\r\n\r\n- 模式出现意图\r\n\r\n  让多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象串成一条链，并沿着链传递请求，直到有一个对象处理它或者处理完毕为止。\r\n\r\n\r\n\r\n- 责任链uml图\r\n\r\n![屏幕快照 2017-05-10 下午5.17.19](详解设计模式之责任链模式\/屏幕快照 2017-05-10 下午5.17.19.png)"
  },
  {
    "title" : "向上取整、向下取整和素数",
    "created_time" : "2017-09-19 17:09:52",
    "body" : "# 0x00 前言\r\n\r\n在看算法书时看到几个数学上的定义：向上取整、向下取整和素数。\r\n\r\n不知道这几个定义就难以理解文章意思。所以查了资料后做个记录，防止下次还不会。\r\n\r\n<!-- more -->\r\n\r\n# 0x01 解释\r\n\r\n- 素数\r\n\r\n  这个在初高中时候就学过，因为素数就是质数的别称，质数就是只能被1和数字本身整除的数。\r\n\r\n  ​\r\n\r\n- 向上取整、向下取整\r\n\r\n  向上取整、向下取整的前提是要先有个基数整数\r\n\r\n  比如数列1，3，4，6，7，9，11，以6为基数，其向下取整为4，向上取整为7\r\n\r\n  **对基数x向下取整为小于等于x的最大整数，对基数x向上取整为大于等于x的最小整数**"
  },
  {
    "title" : "字符串前的r和u",
    "created_time" : "2017-08-06 16:55:54",
    "body" : "# 前言\r\n\r\n在看python代码时经常看到这样的代码\r\n\r\n```python\r\nprint(r\"aa\\nbb\")\r\nprint(u\"aa\\nbb\")\r\n```\r\n\r\n字符串使用时直接引用就好了，前面的r和u这两个前缀是什么鬼？有什么作用？\r\n\r\n纸上得来终觉浅，绝知此事要躬行。\r\n\r\n要了解r和u的作用还是实际操作来看看。\r\n\r\n<!-- more -->\r\n\r\n# 说明\r\n\r\n- r的作用\r\n\r\n  首先看看r的作用，执行如下代码看看结果：\r\n\r\n  ```python\r\n  print(\"aa\\nbb\")\r\n  print(r\"aa\\nbb\")\r\n  ```\r\n\r\n  打印结果是这样子：\r\n\r\n  ```\r\n  aa\r\n  bb\r\n  aa\\nbb\r\n  ```\r\n\r\n  第一个打印，**\\n**把字符串截开了，而第二个打印是全部打印。\r\n\r\n  在python中，**\\n**是换行符作用。所以第一个打印才是正常的。\r\n\r\n  第二个打印中的**r作用就是取消字符串中的转移字符的作用，让其老老实实作为一个普通字符串**。\r\n\r\n  接下来看看u的作用：\r\n\r\n- u的作用\r\n\r\n  u表示将后面跟的字符串以unicode格式存储，否则会使用源文件的默认编码格式来编码字符串"
  },
  {
    "title" : "Android studio Git提示Push rejected: Push to origin\/master was rejected",
    "created_time" : "2017-08-25 13:27:03",
    "body" : "# 0x00 前言\r\n\r\n最近做一个IPTV项目，由于经常和历史记录做对比或者实现新思路不行而还原，所以要把项目添加到Git。\r\n\r\n但是当用Android studio push的时候出现异常信息：\r\n\r\n```\r\nPush rejected: Push to origin\/master was rejected\r\nGit Pull Failed: fatal: refusing to merge unrelated histories\r\n\r\n```\r\n\r\n因为刚创建的Git remote仓库初始化时顺带创建了一个read.me文件，\r\n\r\n而本地已经add过了。\r\n\r\n<!-- more -->\r\n\r\n# 0x01 解决\r\n\r\n因为Android studio可以执行的命令有限（或者还未发现新天地），所以cd到项目目录执行\r\n\r\n```\r\ngit pull origin master --allow-unrelated-histories\r\n```\r\n\r\n即可。"
  },
  {
    "title" : "Android本地广播",
    "created_time" : "2017-09-14 17:50:05",
    "body" : "# 0x00 前言\r\n\r\n在android开发中广播作为四大组件之一，其重要性不言而喻。虽然重要但使用却是极其简单，\r\n\r\n通常我们的使用无非就是`sendBroadCast`和继承BroadCastReceiver重写`onReceive`方法。\r\n\r\n如果多想想其实这种做法是存在安全隐患的，比如我们发送的广播是全局性的，那么有被其他程序截获泄露的风险，同样的我们广播接收器也是全局性的，垃圾应用也有可能不停发送垃圾广播。\r\n\r\n对于这种安全隐患如何避免呢？\r\n\r\n**Google为我们提供了本地广播服务：`LocalBroadcastManager`对广播进行管理。让我们发出的广播只在应用内传递，且广播接收器也只接收来自本应用的广播。**\r\n\r\n<!-- more -->\r\n\r\n# 0x01 使用\r\n\r\n`LocalBroadcastManager`在SDK22版本添加在v4包中。\r\n\r\n\r\n\r\n## 实例化\r\n\r\n```java\r\nprivate LocalBroadcastManager manager;\r\n\r\nmanager.getInstance(Context context)\r\n```\r\n\r\n\r\n\r\n## 本地发送广播\r\n\r\n```java\r\nprivate LocalBroadcastManager manager;\r\n\r\nmanager.sendBroadcast(intent);\r\n```\r\n\r\n\r\n\r\n## 本地注册广播\r\n\r\n```java\r\nprivate LocalBroadcastManager manager;\r\n\r\nmanager.registerReceiver(receiver,filter)\r\n```\r\n\r\n\r\n\r\n## 本地取消广播\r\n\r\n```java\r\nprivate LocalBroadcastManager manager;\r\n\r\nmanager.unregisterReceiver(receiver)\r\n```"
  },
  {
    "title" : "Android各版本新功能及区别",
    "created_time" : "2017-07-26 13:17:15",
    "body" : "#  0x00 前言\r\n\r\nAndroid版本更新快，版本越来越越多，兼容性也就要越来越注意，注意各个版本新加了哪些功能，哪些功能和API对开发有帮助，都要心里有个数\r\n\r\n\r\n\r\n# 0x01 Android8.0 \r\n\r\nwaiting...\r\n\r\n\r\n\r\n# 0x02 Android 7.0 Nougat\r\n\r\n- 引入了一个新的而且非常需要的多任务处理功能 — 多窗口支持。\r\n\r\n- **通知增强** 通知界面直接回复等\r\n\r\n- 进一步的低耗电模式Doze 增强版\r\n\r\n- 删除了三个常用隐式广播 — `CONNECTIVITY_ACTION`、`ACTION_NEW_PICTURE` 和`ACTION_NEW_VIDEO` \r\n\r\n  ​<!-- more -->\r\n\r\n# 0x03 Android 6.0 Marshmallow\r\n\r\n- **引入了一种新的权限模式 运行时权限检查**\r\n\r\n  对于以 Android 6.0（API 级别 23）或更高版本为目标平台的应用，请务必在运行时检查和请求权限。要确定您的应用是否已被授予权限，请调用新增的 `checkSelfPermission()` 方法。要请求权限，请调用新增的 `requestPermissions()` 方法。即使您的应用并不以 Android 6.0（API 级别 23）为目标平台，您也应该在新权限模式下测试您的应用。\r\n\r\n- 取消支持 Apache HTTP 客户端\r\n\r\n  Android 6.0 版移除了对 Apache HTTP 客户端的支持。如果您的应用使用该客户端，并以 Android 2.3（API 级别 9）或更高版本为目标平台，请改用 `HttpURLConnection` 类。此 API 效率更高，因为它可以通过透明压缩和响应缓存减少网络使用，并可最大限度降低耗电量。要继续使用 Apache HTTP API，您必须先在 `build.gradle`文件中声明以下编译时依赖项：\r\n\r\n  ```\r\n  android {\r\n      useLibrary 'org.apache.http.legacy'\r\n  }\r\n  ```\r\n\r\n- **低电耗模式和应用待机模式：Doze模式**\r\n\r\n- **新的通知构建方法**\r\n\r\n  移除了 `Notification.setLatestEventInfo()` 方法。请改用 `Notification.Builder` 类来构建通知。要重复更新通知，请重复使用 `Notification.Builder` 实例。调用 `build()` 方法可获取更新后的 `Notification` 实例。\r\n\r\n  `adb shell dumpsys notification` 命令不再打印输出您的通知文本。请改用 `adb shell dumpsys notification --noredact` 命令打印输出 notification 对象中的文本。\r\n\r\n- **Android 密钥库变更**\r\n\r\n  从此版本开始，[Android 密钥库提供程序](https:\/\/developer.android.com\/training\/articles\/keystore.html)不再支持 DSA。但仍支持 ECDSA。\r\n\r\n  停用或重置安全锁定屏幕时（例如，由用户或设备管理员执行此类操作时），系统将不再删除需要闲时加密的密钥，但在上述事件期间会删除需要闲时加密的密钥。\r\n\r\n  ​\r\n\r\n# 0x04 Android 5.0 Lollipop\r\n\r\n- **引入了Material Design并提供了UI工具包**\r\n\r\n- **把ART模式作为默认的运行模式**\r\n\r\n- Android 5.0 中的通知更醒目、更便于访问并且可配置程度更高。\r\n\r\n- Android 5.0 还引入了 Android 扩展包 (AEP)，支持 OpenGL ES 3.1\r\n\r\n- Android 5.0 引入了全新的 Camera API\r\n\r\n- 在 Android 5.0 中，新增的倾斜检测器传感器有助于改善受支持设备上的 Activity 识别\r\n\r\n- 新增的 **Job Scheduling** API 允许通过将作业推迟到稍后或指定条件下（如设备充电或连入 WLAN 时）运行来优化电池寿命。\r\n\r\n  新增的 `dumpsys batterystats` 命令可生成**电池使用情况统计信息**，可通过它了解整个系统的耗电情况，以及了解应用对设备电池的影响。\r\n\r\n\r\n\r\n# 0x05 Android 4.4 Jelly Bean\r\n\r\n- Android 4.4 针对硬件传感器批处理引入平台支持\r\n\r\n- **全屏沉浸模式**\r\n\r\n  Android 4.4 添加了新的全屏沉浸模式，让您可以在手机和平板电脑上创建从一个边缘延伸到另一个边缘的全出血 UI，**隐藏所有系统 UI**，例如状态栏和导航栏。它适用于鲜艳的视觉内容，例如照片、视频、地图、书本和游戏。\r\n\r\n  在新模式中，系统 UI 保持隐藏状态，即使在用户与您的应用或游戏交互时 - 您可以从屏幕上的任何位置（甚至在系统栏占据的其他位置）捕获触摸事件。这是您在应用或游戏中创建更大、更加丰富和更加沉浸式的 UI 并减少视觉分散的绝佳方式。\r\n\r\n  为确保用户在全屏沉浸模式中始终能轻松、一致地访问系统 UI， Android 4.4 支持新的手势。现在，在沉浸模式中，从屏幕顶部或底部边缘滑动手指可以显示系统 UI。\r\n\r\n  要返回沉浸模式，用户可以触摸栏界限之外的屏幕或等待一小段时间，让栏自动隐藏。为提供一致的用户体验，新的手势还与之前隐藏状态栏的方法配合使用。\r\n\r\n- 安全增强功能\r\n\r\n  SELinux（强制模式）\r\n  Android 4.4 将其 SELinux 配置从“permissive”更新为“enforcing”。这意味着，在具有强制政策的 SELinux 域中，将阻止潜在的政策违规行为。\r\n\r\n  改进加密算法\r\n  Android 添加了对另外两种加密算法的支持，进一步提升了其安全性。已向密钥库提供程序添加椭圆曲线数字签名算法 (ECDSA) 支持，从而提升了数字签名的安全性，适用于应用签名或数据连接等场景。实现 Scrypt 密钥派生函数，以保护用于全磁盘加密的加密密钥。\r\n\r\n- 内存使用率分析工具procstats\r\n\r\n- Android 4.4 包含新的开发者选项：设备内存状态和分析\r\n\r\n  Settings > Developer options > Process stats\r\n\r\n- **可重复使用的位图，参考[inBitmap](https:\/\/developer.android.com\/reference\/android\/graphics\/BitmapFactory.Options.html#inBitmap)**"
  },
  {
    "title" : "Android关于Activity生命周期误解",
    "created_time" : "2017-05-05 11:03:36",
    "body" : "两个Activity  A和B，先启动A，通过A打开B，在关闭B，这时候两个Activity的生命周期分别是如何执行的？\r\n\r\n我的答案是：\r\n\r\nA启动时\r\n\r\n`A onCreate onStart onResume`\r\n\r\n点击启动B之后\r\n\r\n`\tA onPause onStop, B onCreate onStart onResume`\r\n\r\nB关闭之后\r\n\r\n` B onPause onStop onDestory ,A onRestart onStart onResume`\r\n\r\n<!-- more -->\r\n\r\n但是想的太简单了，我以为的并不是我以为的。下面是打印的生命周期执行：\r\n\r\n```\r\n05-05 11:01:33.801 5494-5494\/com.example.jenson.myapplication I\/MainActivity: onCreate\r\n05-05 11:01:33.801 5494-5494\/com.example.jenson.myapplication I\/MainActivity: onStart\r\n05-05 11:01:33.801 5494-5494\/com.example.jenson.myapplication I\/MainActivity: onResume\r\n05-05 11:01:33.861 5494-5542\/com.example.jenson.myapplication I\/OpenGLRenderer: Initialized EGL, version 1.4\r\n05-05 11:01:46.391 5494-5494\/com.example.jenson.myapplication I\/MainActivity: onPause\r\n05-05 11:01:46.411 5494-5494\/com.example.jenson.myapplication I\/FirstActivity: onCreate\r\n05-05 11:01:46.411 5494-5494\/com.example.jenson.myapplication I\/FirstActivity: onStart\r\n05-05 11:01:46.411 5494-5494\/com.example.jenson.myapplication I\/FirstActivity: onResume\r\n05-05 11:01:46.691 5494-5494\/com.example.jenson.myapplication I\/MainActivity: onStop\r\n05-05 11:02:20.641 5494-5494\/com.example.jenson.myapplication I\/ViewRootImpl: WindowInputEventReceiver onInputEvent!! KeyCode is 4, action is 0\r\n05-05 11:02:20.641 5494-5494\/com.example.jenson.myapplication I\/ViewRootImpl: WindowInputEventReceiver onInputEvent!! KeyCode is 4, action is 1\r\n05-05 11:02:20.651 5494-5494\/com.example.jenson.myapplication I\/FirstActivity: onPause\r\n05-05 11:02:20.651 5494-5494\/com.example.jenson.myapplication I\/MainActivity: onRestart\r\n05-05 11:02:20.651 5494-5494\/com.example.jenson.myapplication I\/MainActivity: onStart\r\n05-05 11:02:20.651 5494-5494\/com.example.jenson.myapplication I\/MainActivity: onResume\r\n05-05 11:02:20.871 5494-5494\/com.example.jenson.myapplication I\/FirstActivity: onStop\r\n05-05 11:02:20.871 5494-5494\/com.example.jenson.myapplication I\/FirstActivity: onDestroy\r\n```\r\n\r\n> 记住一点：启动一个新Activity，先把自己onPause，然后等新Activity启动成功即onResume后再onStop，关闭当前Activity时，还是先把自己onPause，下一帧的Activity(相对于Activity栈来说)执行恢复onResume，然后自己再执行onStop、onDestory\r\n\r\n虽然知道了真相，但是现在还不清楚为什么要这样设计，，有时间还要看看这里的源码，mark下。"
  },
  {
    "title" : "Android获取IP",
    "created_time" : "2017-09-25 20:11:03",
    "body" : "# 0x00 前言\r\n\r\n学过计算机网络的都知道，计算机IP地址分为内网IP和外网IP。\r\n\r\n在Android中API只提供了获取内网IP的方法，那如何获取外网IP呢？要解决这个问题要借助于服务器或者提供该服务的网站了。\r\n\r\n# 0x01 内网IP\r\n\r\nAndroid系统提供了获取内网IP的API，下面看如何使用API实现：\r\n\r\n```java\r\n    \/**\r\n     * 获取本地ip地址\r\n     *\r\n     * @return\r\n     *\/\r\n    public static String getHostIP() {\r\n        String hostIp = null;\r\n        try {\r\n            Enumeration nis = NetworkInterface.getNetworkInterfaces();\r\n            InetAddress ia = null;\r\n            while (nis.hasMoreElements()) {\r\n                NetworkInterface ni = (NetworkInterface) nis.nextElement();\r\n                Enumeration<InetAddress> ias = ni.getInetAddresses();\r\n                while (ias.hasMoreElements()) {\r\n                    ia = ias.nextElement();\r\n                    if (ia instanceof Inet6Address) {\r\n                        continue;\/\/ skip ipv6\r\n                    }\r\n                    String ip = ia.getHostAddress();\r\n                    if (!\"127.0.0.1\".equals(ip)) {\r\n                        hostIp = ia.getHostAddress();\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        } catch (SocketException e) {\r\n            e.printStackTrace();\r\n        }\r\n        return hostIp;\r\n\r\n    }\r\n```\r\n\r\n<!--more-->\r\n\r\n\r\n\r\n# 0x02 外网IP\r\n\r\n由于Android系统没有提供获取外网IP的API，所以只能通过间接的方法获取。了解Http原理的都知道，客户端向服务器发送请求时会携带MAC和IP地址，而这里的IP地址就是客户端的外网IP。所以服务器接收到请求后可以得知客户端外网IP，如果服务器把客户端外网IP给我们返回，这样就达到了间接获取外网IP的方法。\r\n\r\n所以目前的问题是我们只要找到一些提供返回IP地址服务的网站就可以了。\r\n\r\n介绍2个返回IP地址的网站：\r\n\r\n淘宝`http:\/\/ip.taobao.com\/service\/getIpInfo2.php?ip=myip`\r\n\r\n和\r\n\r\n搜狐`http:\/\/pv.sohu.com\/cityjson?ie=utf-8`\r\n\r\n淘宝返回的结果值为：\r\n\r\n```json\r\n{\"code\":0,\"data\":{\"country\":\"\\u4e2d\\u56fd\",\"country_id\":\"CN\",\"area\":\"\\u534e\\u5317\",\"area_id\":\"100000\",\"region\":\"\\u5317\\u4eac\\u5e02\",\"region_id\":\"110000\",\"city\":\"\\u5317\\u4eac\\u5e02\",\"city_id\":\"110100\",\"county\":\"\",\"county_id\":\"-1\",\"isp\":\"\\u9e4f\\u535a\\u58eb\",\"isp_id\":\"1000143\",\"ip\":\"113.47.141.3\"}}\r\n```\r\n\r\n搜狐返回的结果值为：\r\n\r\n```json\r\nvar returnCitySN = {\"cip\": \"113.47.141.3\", \"cid\": \"110000\", \"cname\": \"北京市\"};\r\n```\r\n\r\n代码实现：\r\n\r\n```java\r\n    \/**\r\n     * 获取外网IP地址\r\n     *\r\n     * @return\r\n     *\/\r\n    public static String getNetIp() {\r\n        URL infoUrl = null;\r\n        InputStream inStream = null;\r\n        String line = \"\";\r\n        try {\r\n            infoUrl = new URL(\"http:\/\/pv.sohu.com\/cityjson?ie=utf-8\");\r\n            URLConnection connection = infoUrl.openConnection();\r\n            HttpURLConnection httpConnection = (HttpURLConnection) connection;\r\n            int responseCode = httpConnection.getResponseCode();\r\n            if (responseCode == HttpURLConnection.HTTP_OK) {\r\n                inStream = httpConnection.getInputStream();\r\n                BufferedReader reader = new BufferedReader(new InputStreamReader(inStream, \"utf-8\"));\r\n                StringBuilder strber = new StringBuilder();\r\n                while ((line = reader.readLine()) != null)\r\n                    strber.append(line + \"\\n\");\r\n                inStream.close();\r\n                \/\/ 从反馈的结果中提取出IP地址\r\n                int start = strber.indexOf(\"{\");\r\n                int end = strber.indexOf(\"}\");\r\n                String json = strber.substring(start, end + 1);\r\n                if (json != null) {\r\n                    try {\r\n                        JSONObject jsonObject = new JSONObject(json);\r\n                        line = jsonObject.optString(\"cip\");\r\n                    } catch (JSONException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                }\r\n                return line;\r\n            }\r\n        } catch (MalformedURLException e) {\r\n            e.printStackTrace();\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n        return line;\r\n    }\r\n```"
  },
  {
    "title" : "Android进程和线程",
    "created_time" : "2017-04-27 20:36:13",
    "body" : "# 进程\r\n\r\n一般情况下，进程是应用程序的单元，一个应用对应一个进程同时对应一个主线程。但是通过设置 `android:process`，可以使原本一个应用中的组件运行在多个进程中。\r\n\r\n> 如果进程名称设置为“:remote”，那么这个进程的名字是包名+设置的名字，以冒号开头的进程属于私有进程，其他应用的组件不能和它跑在一个进程。如果进程名设置是完整的(\"非冒号开头\")，则属于全局进程，其他应用可以通过shareUID方式和它共享一个进程。\r\n\r\n\r\n\r\n<!-- more -->\r\n\r\n# 进程优先级分类\r\n\r\n根据进程的优先级可以分为五级，\r\n\r\n- 前台进程\r\n\r\n  用户当前操作所必需的进程。如果一个进程满足以下任一条件，即视为前台进程：\r\n  ​\t托管用户正在交互的 Activity（已调用 Activity 的 onResume() 方法）\r\n  ​\t托管某个 Service，后者绑定到用户正在交互的 Activity\r\n  ​\t托管正在“前台”运行的 Service（服务已调用 startForeground()）\r\n  ​\t托管正执行一个生命周期回调的 Service（onCreate()、onStart() 或 onDestroy()）\r\n  ​\t托管正执行其 onReceive() 方法的 BroadcastReceiver\r\n  通常，在任意给定时间前台进程都为数不多。只有在内存不足以支持它们同时继续运行这一万不得已的情况下，系统才会终止它们。 此时，设备往往已达到内存分页状态，因此需要终止一些前台进程来确保用户界面正常响应。\r\n\r\n- 可见进程\r\n\r\n  没有任何前台组件、但仍会影响用户在屏幕上所见内容的进程。 如果一个进程满足以下任一条件，即视为可见进程：\r\n  ​\t托管不在前台、但仍对用户可见的 Activity（已调用其 onPause() 方法）。例如，如果前台 Activity 启动了一个对话框，允许在其后显示上一 Activity，则有可能会发生这种情况。\r\n  ​\t托管绑定到可见（或前台）Activity 的 Service。\r\n  可见进程被视为是极其重要的进程，除非为了维持所有前台进程同时运行而必须终止，否则系统不会终止这些进程。\r\n\r\n- 服务进程\r\n\r\n  正在运行已使用 startService() 方法启动的服务且不属于上述两个更高类别进程的进程。尽管服务进程与用户所见内容没有直接关联，但是它们通常在执行一些用户关心的操作（例如，在后台播放音乐或从网络下载数据）。因此，除非内存不足以维持所有前台进程和可见进程同时运行，否则系统会让服务进程保持运行状态。\r\n\r\n- 后台进程\r\n\r\n  包含目前对用户不可见的 Activity 的进程（已调用 Activity 的 onStop() 方法）。这些进程对用户体验没有直接影响，系统可能随时终止它们，以回收内存供前台进程、可见进程或服务进程使用。 通常会有很多后台进程在运行，因此它们会保存在 LRU （最近最少使用）列表中，以确保包含用户最近查看的 Activity 的进程最后一个被终止。如果某个 Activity 正确实现了生命周期方法，并保存了其当前状态，则终止其进程不会对用户体验产生明显影响，因为当用户导航回该 Activity 时，Activity 会恢复其所有可见状态。 有关保存和恢复状态的信息，请参阅 Activity文档。\r\n\r\n- 空进程\r\n\r\n  不含任何活动应用组件的进程。保留这种进程的的唯一目的是用作缓存，以缩短下次在其中运行组件所需的启动时间。 为使总体系统资源在进程缓存和底层内核缓存之间保持平衡，系统往往会终止这些进程。\r\n\r\n# 线程\r\n\r\n线程可以看作是一个轻量级的进程，在Android中启动应用时系统会为APP创建一个UI线程，Android UI是非线程安全的。\r\n\r\n在Android开发中注意两点：\r\n\r\n①不能在UI线程以外的其他线程操作UI，否则异常。\r\n\r\n②不能阻塞UI线程，否则ANR。\r\n\r\n当然在某些特殊条件下，非UI线程操作 UI没有报错，参考我的[[为什么我在工作线程刷新UI没报错？](http:\/\/www.jensondev.me\/2017\/04\/21\/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%9C%A8%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E5%88%B7%E6%96%B0UI%E6%B2%A1%E6%8A%A5%E9%94%99\/)] 。\r\n\r\nAndroid 提供了几种途径来从其他线程访问 UI 线程。 以下列出了几种有用的方法：\r\n\r\nActivity.runOnUiThread(Runnable)\r\nView.post(Runnable)\r\nView.postDelayed(Runnable, long)"
  },
  {
    "title" : "浅谈Android性能优化系列工具篇之MAT使用",
    "created_time" : "2017-11-09 07:41:54",
    "body" : "# 说在前面的话\r\n\r\n关于Android内存优化可参见我的另一篇文章[[Android性能优化之内存优化](http:\/\/www.jenson.top\/post\/32\/)]。Android性能优化中内存优化可谓重中之重，而内存泄露又是Android内存优化的重灾区。重灾区就要重拳出击，整治内存泄露，Mat是必备的利器。\r\n\r\n<!-- more -->\r\n\r\n# 关于Mat\r\n\r\nMat，全面Memory Analyzer Tool，Java内存分析工具。注意一点，Mat是由eclipse社区维护，所以如果使用Android studio开发的话，需要单独下载，[官方通道](http:\/\/www.eclipse.org\/mat\/downloads.php)。我用的是mac版，后面也会使用mac版来分析。\r\n\r\n# Mat使用\r\n\r\n注意：我的测试app包名为：com.example.jenson.myapplication\r\n\r\n在eclipse中集成了Mat，可以直接拿来使用，而使用Android studio时。这两个是分开的，所以我们要先导出dump文件。\r\n\r\n## Android studio导出dump文件\r\n\r\n打开Android Monitor窗口，![dump生成按钮](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/dump%E7%94%9F%E6%88%90%E6%8C%89%E9%92%AE.png)\r\n\r\n点击圆圈中的按钮，过几秒中会自动生成一个dump文件，然后自动打开如下图的窗口：![自动生成的dump文件](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84dump%E6%96%87%E4%BB%B6.png\r\n\r\n\r\n\r\n## 导出标准dump文件\r\n\r\n在Heap Snapshot下的几个文件就是自动生成的dump文件，但是这不是标准的dump文件，所以需要选择文件右键导出标准dump文件，保存到一个目录下：\r\n\r\n![导出标准dump文件](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/%E5%AF%BC%E5%87%BA%E6%A0%87%E5%87%86dump%E6%96%87%E4%BB%B6.png)\r\n\r\n\r\n\r\n\r\n\r\n## Mat打开标准dump文件\r\n\r\n使用Mat，菜单open File选择刚才导出的dump文件，经过分析后回显示如下所示的项目：\r\n\r\n![打开标准文件](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/%E6%89%93%E5%BC%80%E6%A0%87%E5%87%86%E6%96%87%E4%BB%B6.png)\r\n\r\n\r\n\r\n![图2](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-27%20%E4%B8%8B%E5%8D%882.21.48.png)\r\n\r\n\r\n\r\nMat从多角度提供了内存分析，其中包括Histogram、Dominator Tree、Leak Suspects和Top consumers等。\r\n\r\noverview是一个概况图，把内存的消耗以饼状图形式显示出来，鼠标在每个饼块区域划过或者点击，就会在Inspector栏目显示这块区域的相关信息。\r\n\r\nLeak Suspectss是一个关于内存泄露猜想的饼图，Problem Suspect 1是泄露猜想的描述。看我这里说的像是字节数组，这么大的数组难不成是图片，要知道图片在内存中就是以字节数组形式存在的。\r\n\r\n平常内存分析比较常用的还是Histogram、Dominator Tree。\r\n\r\n## 开始分析内存\r\n\r\n这里我们使用Histogram进行分析，切换到Histogram页面。这个页面主要有4个列，Class Name、Objects、Shallow Heap和Retained Heap。其中Class Name是全类名，Objects是这个类的对象实例个数。Shallow Heap是对象本身占用内存大小，非数组的常规对象，本身内存占用很小，所以这个对泄露分析作用不大。Retained Heap指当前对象大小和当前对象能直接或间接引用的对象大小的总和。这个栏目是分析重点。\r\n\r\n内存分析是分析的整个系统的内存泄露，而我们只要查找我们APP的内存泄露情况。这无疑增加了很多工作，不过幸亏Histogram支持正则表达式查找，在Regex中输入我们的包名进行过滤，直奔和我们APP有关的内存泄露：\r\n\r\n![包名过滤](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/%E5%8C%85%E5%90%8D%E8%BF%87%E6%BB%A4.png)\r\n\r\n过滤后就显示了我们APP相关内存信息，按Retained Heap大小排列下，发现Student和MainActivity这两个类问题比较大。但是MainActivity的Objects数量为1，而Student的为130，看起来Student问题更严重，所以先从Student入手：\r\n\r\n首先看下是哪里的引用导致了Student不能被GC回收。![GC Root](http:\/\/othg5ggzi.bkt.clouddn.com\/GC%20Root.png)\r\n\r\n右键使用Merge Shortest Paths to GC Roots显示距GC Root最短路径，当然选择过程中要排除软引用和弱引用，因为这些标记的一般都是可以被回收的。进入结果页查看：\r\n\r\n![结果页面](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/%E7%BB%93%E6%9E%9C%E9%A1%B5%E9%9D%A2.png)\r\n\r\n啧啧，原来Student不能被回收竟然就是这个MainActivity搞的鬼，可以看到这个类里面有个students集合里面存放的正式不能回收的Student对象。\r\n\r\n看代码：\r\n\r\n```\r\n    static List<Student> students=new ArrayList<>();\r\n    static final String tag=\"MainActivity\";\r\n    @Override\r\n    protected void onCreate(Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n        setContentView(R.layout.activity_main);\r\n        sample_text = (TextView) findViewById(R.id.sample_text);\r\n        TestNative testNative = new TestNative();\r\n        sample_text.setText(testNative.stringFromJNI());\r\n        for (int i = 0; i < 10; i++) {\r\n\r\n            Student student = new Student(\"jenson\" + i, i);\r\n            students.add(student);\r\n        }\r\n    }\r\n```\r\n\r\n原来不能被回收是因为用static修饰了students集合。这导致其生命周期边长，在Activity销毁时，仍然存在。问题找到了，去掉static完成内存泄露修复。\r\n\r\n# 结束语\r\n\r\nMAT功能不止于此，还有很多实用有趣的功能等着我们自己去探索。"
  },
  {
    "title" : "Android网络框架okhttp执行流程分析",
    "created_time" : "2017-05-10 00:58:46",
    "body" : "# 说在前面的话\r\n\r\nAndroid开发中，网络框架okhttp可以说是越来越风光，Android4.4的源码中可以看到HttpURLConnection已经替换成OkHttp，能够被谷歌认可，足见okhttp的强大之处了。既如此还有什么理由不去深入理解下它呢？很惭愧，这么好的东西以前一直处于简单调用，今天有时间把流程看了一下，简单总结了下执行请求时的大概流程作为备忘。\r\n\r\n<!-- more -->\r\n\r\n# 执行流程\r\n\r\n![流程](Android网络框架执行流程分析\/流程.png)"
  },
  {
    "title" : "Android源码下载",
    "created_time" : "2017-04-21 20:55:54",
    "body" : "# 说在前面的话\r\nwin系统的笔记本过年回来就没有带回北京。最近打算看看Android源码，所以需要在mac中从新下载。\r\n# 从官网下载\r\n下载Android源码首先想到的就是[官网](https:\/\/source.android.com\/source\/downloading.html)\r\n按照指示要先安装repo。但是在执行\r\n```\r\ncurl https:\/\/storage.googleapis.com\/git-repo-downloads\/repo > ~\/bin\/repo\r\n```\r\n\r\n时候就出现异常\r\n\r\n```\r\ncurl https:\/\/storage.googleapis.com\/git-repo-downloads\/repo > ~\/bin\/repo\r\n  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\r\n                                 Dload  Upload   Total   Spent    Left  Speed\r\n  0     0    0     0    0     0      0      0 --:--:--  0:01:14 --:--:--    0\r\ncurl: (7) Failed to connect to storage.googleapis.com port 443: Operation timed out\r\n```\r\n\r\n<!-- more -->\r\n\r\n搜索了下异常发现很早就有这个问题，比如[这里](https:\/\/github.com\/npm\/npm\/issues\/10037)\r\n但是好像没什么好的解决方法。网传有其他地址可以使用，但是没有继续浪费时间了，不能一条路走到黑。\r\n\r\n# 使用国内资源\r\n国外太麻烦，毕竟只是想看源码，不想在下载方面浪费太多精力。所以把想法转战到国内的源上。\r\n分享2个源，[科大源](https:\/\/lug.ustc.edu.cn\/wiki\/mirrors\/help\/aosp#已有仓库如何改用科大源)和[清大源](https:\/\/mirrors.tuna.tsinghua.edu.cn\/help\/AOSP\/)\r\n其中我选择使用的是科大源，打开页面看到初始同步有两个方法，方法1毕竟简单，下载一个打好的包，自己repo sync。方法2还是要下载repo，而且如果中途断掉还要从头下载，所以果断选了方法1，直接使用迅雷下载tar包还是很快的。\r\n不到一个小时下载完成，解压后打开aosp文件夹发现没有文件，因为是.开头的，都是隐藏文件，显示后如图：\r\n![屏幕快照 2017-03-16 下午1.55.14.png](http:\/\/upload-images.jianshu.io\/upload_images\/1796052-a48a38e120b53440.png?imageMogr2\/auto-orient\/strip%7CimageView2\/2\/w\/1240)\r\n执行\r\n```\r\n\/Users\/jenson\/Downloads\/aosp\/.repo\/repo\/repo sync\r\n```\r\n\r\n同步\r\n\r\n![屏幕快照 2017-03-16 下午2.08.54.png](http:\/\/upload-images.jianshu.io\/upload_images\/1796052-185f5625074cf187.png?imageMogr2\/auto-orient\/strip%7CimageView2\/2\/w\/1240)\r\n\r\n\r\n# 如何修改已经init的repo\r\n如果想下载其他版本的源码，但是repo已经初始化过，\r\n如果再次执行repo init xxx会提示 :\r\n```\r\nYour identity is: jenson <xxx@foxmail.com>\r\nIf you want to change this, please re-run 'repo init' with --config-name\r\nrepo has been initialized in \/Users\/jenson\/Downloads\/aosp\r\n```\r\n\r\n上面意思是如果要修改init，需要重新运行repo init +新的url +config\r\n这时会自动修改配置并初始化:\r\n\r\n```\r\n\/Users\/jenson\/Downloads\/aosp\/.repo\/repo\/repo init -u https:\/\/aosp.tuna.tsinghua.edu.cn\/platform\/manifest -b android-6.0.1_r58  --config\r\n```"
  },
  {
    "title" : "bytes和str转换",
    "created_time" : "2017-08-13 16:27:54",
    "body" : "# 前言\r\n\r\n日常开发中很多时候要用到bytes和str的互相转换，每次都查浪费时间。干脆整理一次记在脑子里。\r\n\r\n# bytes转str\r\n\r\n- 默认解码 bytes.decode()\r\n- gbk方式解码 bytes.decode(‘gbk’)\r\n\r\n# str转bytes\r\n\r\n- utf8方式编码 str.encode(encoding=\"utf-8\")\r\n- gbk方式编码 str.encode(encoding=\"gbk\")"
  },
  {
    "title" : "CSS浮动float引起布局错乱",
    "created_time" : "2017-09-12 21:09:42",
    "body" : "# 0x00 前言\r\n\r\nhtml默认是流式布局从上到下，但是使用float后可以让当前标签跳出流式布局限制，但同时下面的标签可能会和float标签产生重叠情况，如下：\r\n\r\n\r\n\r\n![css浮动引起重叠](http:\/\/othg5ggzi.bkt.clouddn.com\/css%E6%B5%AE%E5%8A%A8%E5%BC%95%E8%B5%B7%E9%87%8D%E5%8F%A0.png)\r\n\r\n图中可以看到表单和右边的导航栏重叠了造成布局混乱。\r\n\r\n<!-- more -->\r\n\r\n# 0x00 解决\r\n\r\n如果由CSS浮动造成的布局重叠混乱，可以在浮动标签下新建一个空div：\r\n\r\n```html\r\n<div class=\"clear\"><\/div>\r\n```\r\n\r\n给该div设置样式：\r\n\r\n```css\r\n .clear {\r\n            clear: both;\r\n        }\r\n```\r\n\r\n最终显示结果如图：\r\n\r\n![css浮动错乱修复](http:\/\/othg5ggzi.bkt.clouddn.com\/css%E6%B5%AE%E5%8A%A8%E4%BF%AE%E5%A4%8D.png)\r\n\r\n如果不想使用clear方法也可以使用多个空div+` text-align: right; `属性"
  },
  {
    "title" : "Gradle和Gradle Plugin之间对应关系",
    "created_time" : "2017-08-03 17:36:16",
    "body" : "# 前言\r\n\r\n每次Android studio版本升级经常会造成Gradle和Gradle plugin版本不兼容问题。进而又会引发其他一些列问题，简直让人泪奔。搞得真的是想去转python的心都有了。\r\n\r\n说归说，遇到问题还是要解决。如果知道了Gradle和plugin版本对应兼容关系，那就少了很多麻烦。\r\n\r\n经过查找，就目前版本情况，对应关系已经找出来了。\r\n\r\n# 对应关系\r\n\r\n| Plugin version | Required Gradle version |\r\n| -------------- | ----------------------- |\r\n| 1.0.0 - 1.1.3  | 2.2.1 - 2.3             |\r\n| 1.2.0 - 1.3.1  | 2.2.1 - 2.9             |\r\n| 1.5.0          | 2.2.1 - 2.13            |\r\n| 2.0.0 - 2.1.2  | 2.10 - 2.13             |\r\n| 2.1.3 - 2.2.3  | 2.14.1+                 |\r\n| 2.3.0+         | 3.3+                    |"
  },
  {
    "title" : "Java wait，notify和notifyAll使用分析",
    "created_time" : "2017-07-21 13:00:51",
    "body" : "# 0x00 前言\r\n\r\n提起多线程想当然的就会想到`synchronized` 。但是`synchronized`只能用于线程同步，如果是线程交替执行(生产者\/消费者)，`synchronized`也无能为力了。这时wait，notify和notifyAll派上用场了。\r\n\r\n# 0x01 它们只是Object里的方法\r\n\r\n点开源码发现这三个方法只是object里面的方法，和多线程有神马关系呢？我相信不止我一个人曾经有过这个疑问。\r\n\r\n不只是object里的方法，而且还都是native方法。这是Java有意为之。因为Java设计之初就是要每个对象都有一个监控锁(Monitor)。而wait，notify和notifyAll三个方法也必须要在当前线程已经持有监控锁状态下才能执行，否则就会报`java.lang.IllegalMonitorStateException`。\r\n\r\n<!-- more -->\r\n\r\n# 0x02 怎么知道线程是否持有状态锁\r\n\r\n线程同步原理就是利用了锁的互斥，所以在`synchronized`代码块内能确定是持有锁的。也就是说wait，notify和notifyAll方法需要在`synchronized`代码块内使用。\r\n\r\n具体来说有三种方式：\r\n\r\n- 同步对象方法持有锁\r\n\r\n  ```java\r\n  \tpublic synchronized void sync_1() {\r\n  \t} \r\n  ```\r\n\r\n- 同步静态方法持有锁\r\n\r\n  ```java\r\n  \tpublic static synchronized void sync_2() {\r\n  \t}\r\n  ```\r\n\r\n  ​\r\n\r\n- 同步代码块持有锁\r\n\r\n  ```java\r\n  \tpublic  void sync_3() {\r\n  \t\tsynchronized(lock){\r\n  \t\t}\r\n  \t}\r\n  ```\r\n\r\n# 0x03 三个方法都有什么用\r\n\r\n- wait后会让当前线程处于阻塞状态\r\n\r\n  能调用wait是因为当前线程持有Monitor，但是调用wait后，当前线程会释放锁，给予其他线程执行的机会。\r\n\r\n- notify会唤醒一个因为该对象阻塞的线程\r\n\r\n  同样notify能正常调用是因为当前线程持有锁，当notify执行后会唤醒其他阻塞线程，但是那些阻塞线程并不会立即执行，因为Monitor被notify线程持有。被唤醒的线程要等`synchronized`代码块执行完毕释放Monitor后才能执行。\r\n\r\n- notifyAll会唤醒所有因为该对象阻塞的线程\r\n\r\n  同notify。\r\n\r\n# 0x04 使用示例\r\n\r\n```java\r\n\tpublic static void main(String[] args) {\r\n\t\tThread t1 = new Thread(new Runnable() {\r\n\t\t\t@Override\r\n\t\t\tpublic void run() {\r\n\t\t\t\tSystem.out.println(\"start-t1\");\r\n\t\t\t\tsynchronized (lock) {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tSystem.out.println(\"t1等待唤醒\");\r\n\t\t\t\t\t\tlock.wait();\r\n\t\t\t\t\t} catch (Exception e) {\r\n\t\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tSystem.out.println(\"t1被唤醒持有锁\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tThread t2 = new Thread(new Runnable() {\r\n\t\t\t@Override\r\n\t\t\tpublic void run() {\r\n\t\t\t\tSystem.out.println(\"start-t2\");\r\n\t\t\t\ttry {\r\n\t\t\t\t\tThread.currentThread().sleep(3000);\r\n\t\t\t\t} catch (InterruptedException e1) {\r\n\t\t\t\t\te1.printStackTrace();\r\n\t\t\t\t}\r\n\t\t\t\tsynchronized (lock) {\r\n\t\t\t\t\tlock.notify();\/\/ 唤醒\r\n\t\t\t\t\tSystem.out.println(\"t2持有锁，唤醒t1\");\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tThread.currentThread().sleep(3000);\r\n\t\t\t\t\t} catch (InterruptedException e) {\r\n\t\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tSystem.out.println(\"t2休眠3s\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t\tt1.start();\r\n\t\tt2.start();\r\n\t}\r\n```\r\n\r\n执行结果如下：\r\n\r\nstart-t2\r\nstart-t1\r\nt1等待唤醒\r\nt2持有锁，唤醒t1\r\nt2休眠3s\r\nt1被唤醒持有锁\r\n\r\n在t2中调用notify唤醒t1后，t2又休眠了3s钟，期间t1仍然没有执行，可见确实如上所说，唤醒的线程要在notify线程释放Monitor后才能执行。"
  },
  {
    "title" : "Java参数到底是值传递还是引用传递",
    "created_time" : "2017-08-10 13:55:54",
    "body" : "# 0x00前言\r\n\r\n基本类型是值传递，引用类型是引用传递，在此前很长的一段时间内，我一直是这么认为的！\r\n\r\n然鹅，这个错误的想法竟然伴随多年，仿佛多年的Java白学了。\r\n\r\n<!-- more -->\r\n\r\n# 0x01 说明\r\n\r\n**其实Java中参数的传递都是byValue方式传递**。\r\n\r\n讲道理先通过虚拟机机制来说明下：\r\n\r\n![讲道理](http:\/\/othg5ggzi.bkt.clouddn.com\/%E8%AE%B2%E9%81%93%E7%90%86.jpg)\r\n\r\n\r\n\r\n虚拟机在内存中有一块区域叫Java栈，也叫虚拟机栈。栈里面装的是什么？\r\n\r\n栈中存放的是栈帧，栈帧里面又装的是什么？是局部变量表、操作数栈和方法返回地址等信息。\r\n\r\n其实一个Java线程运行时就会产生一个Java栈，每次的方法调用就会产生一个栈帧入栈，方法执行完毕则出栈。其中栈帧中的局部变量表存储的是参数和局部变量信息。\r\n\r\n当方法执行完毕，栈帧出栈内存就会被释放，如果引用类型的参数是直接把函数外的引用直接传递过来，那么出栈时，岂不是连函数外的这个变量也一同给释放掉了吗？\r\n\r\n所以为了避免这种情况发生，**引用类型的参数传递，只是对引用类型值的一个拷贝。**\r\n\r\n就是说**函数外的变量和参数是两个不同的变量，只是它们指向的地址是一样的**：\r\n\r\n![参数引用类型传递](http:\/\/othg5ggzi.bkt.clouddn.com\/%E5%8F%82%E6%95%B0%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%BC%A0%E9%80%92.png)\r\n\r\n\r\n\r\n说到底，引用类型也躲不过值传递的命运。\r\n\r\n下面用示例来验证下外部变量和参数是两个不同的变量：\r\n\r\n# 0x02 示例\r\n\r\n```Java\r\npublic class ReTest {\r\n\tstatic void setStu(Student stu, int x) {\r\n      \tSystem.out.println(\"改变前stu变量：\"+stu+\"##x值：\"+x);\r\n\t\tstu = new Student(\"lisi\", 21);\r\n\t\tx=20;\r\n\t\tSystem.out.println(\"stu变量：\"+stu+\"##x值：\"+x);\r\n\t}\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tStudent p = new Student(\"jenson\", 10);\r\n\t\tint i = 10;\r\n\t\tSystem.out.println(\"改变前p变量：\"+p+\"##i值：\"+i);\r\n\t\tsetStu(p, i);\r\n\t\tSystem.out.println(\"改变后p变量：\"+p+\"##i值：\"+i);\r\n\t}\r\n\r\n\tstatic class Student {\r\n\t\tint age;\r\n\t\tString name;\r\n\r\n\t\tStudent(String name, int age) {\r\n\t\t\tthis.age = age;\r\n\t\t\tthis.name = name;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n```\r\n\r\n代码很简单，打印结果如下：\r\n\r\n```\r\n改变前p变量：thread.ReTest$Student@7852e922##i值：10\r\n改变前stu变量：thread.ReTest$Student@7852e922##x值：10\r\nstu变量：thread.ReTest$Student@4e25154f##x值：20\r\n改变后p变量：thread.ReTest$Student@7852e922##i值：10\r\n```\r\n\r\n参考打印结果可以发现：\r\n\r\n**基本类型是值传递，而引用类型为Student变量p和参数stu是两个不同的变量但指向同一块内存，在函数setStu中给参数stu从新赋值时，不影响变量p的引用。证明了参数stu是p变量的一个值拷贝。**"
  },
  {
    "title" : "Java知识点",
    "created_time" : "2017-06-30 18:51:23",
    "body" : "# 字符串\r\n\r\n1、==对基本数据类型来说比较的是值是否相等，但对于引用类型来说，其和equals医院，比较的都是对象地址，前提是equals没有被重写。\r\n\r\n```java\r\n\t\tString c = \"c\";\r\n\t\tfinal String c1 = \"c\";\r\n\t\tString s0 = \"a\" + \"b\" + c1;\r\n\t\tString s1 = \"a\" + \"b\" + c;\r\n\t\tString s2 = \"a\" + \"b\" + \"c\";\r\n\t\tString s3 = \"abc\";\r\n\t\tSystem.out.println(s0 == s3);\/\/true\r\n\t\tSystem.out.println(s1 == s3);\/\/false\r\n\t\tSystem.out.println(s2 == s3);\/\/true\r\n```\r\n\r\n<!-- more -->\r\n\r\n根据Java编译时优化方案，s2中加号的三个值都为固定常量，所以s2在编译时也被认为是常量，即编译期就确定了s2的值，并且和s3一样，所以打印true\r\n\r\n在s1中，a和b的值是常量，但是c属于局部变量，而且也没有谁指定c这个值是不可变的。既然是可变量，导致s1也被编译期认为是不确定值，\r\n\r\n接下来s0，a和b不用说了都是常量，而c1虽然和c一样也是局部变量，但是c1有finla修饰，明确告诉编译器明面上我是一个局部变量，但是同时我的值是不可变的，final修饰了，现在不变，将来也不会改变，所以编译器在编译期确定了s0 的值。所以把s0也作为常量和s3一样，都在常量池\r\n\r\n***编译器优化要在编译期能确定的值得情况下进行，而能确定值的只能是在常量池中的内容。***\r\n\r\n2、string.intern()，当字符串调用这个方法时，都会拿着当前字符串的值去常量池中找，如果找到则返回常量池这个常量地址，否则在常量池创建一个常量并把字符串填进去，然后返回创建的地址。当然这是在JDK1.6情况下，在1.7及以后会有不同\r\n\r\n```java\r\n\t\tString c = \"c\";\r\n\t\tfinal String c1 = \"c\";\r\n\t\tString s0 = \"a\" + \"b\" + c1;\r\n\t\tString s1 = \"a\" + \"b\" + c;\r\n\t\tString s2 = \"a\" + \"b\" + \"c\";\r\n\t\tString s3 = \"abc\";\r\n\t\tSystem.out.println(s0 == s3);\r\n\t\tSystem.out.println(s1.intern() == s3);\/\/true\r\n\t\tSystem.out.println(s2 == s3);\r\n```\r\n\r\n***由于intern()需要去常量池中做字符串比较，而常量池又很可能有多个常量，所以一般来说intern()效率并不高***"
  },
  {
    "title" : "Java字符串压缩去重",
    "created_time" : "2017-05-03 17:42:06",
    "body" : "# 说在前面的话\r\n\r\n去一家公司面试，开始就一道笔试题，做对了就继续，做不对就不用往下面了。内容是读取文件内容并压缩内容去重，压缩去重意思是如果内容为ABBCCCCAA压缩后字符串显示为A1B2C3A2。以此类推。其实这道题不难，但是我脑子转悠慢，读取文件和遍历字符做出来了，但是其余的没有做出了，或者说大概思路对了，但是卡在某一个点。总之有点废物就是了。。\r\n\r\n<!-- more -->\r\n\r\n# 我的做法\r\n\r\n```\r\n\tpublic static String compress(String str){\r\n\t\tStringBuffer mystr = new StringBuffer();\r\n\t\t\/\/我这里是从0开始的\r\n\t\tint count = 0;\r\n\t\t\/\/而这也是初始为0，这样的设置导致下面判断时候一直\r\n\t\t\/\/无所适从，对于何时该给count++，\r\n\t\t\/\/何时该给mystr.append有点混乱\r\n\t\tchar last = 0;\r\n\t\tint length = str.length();\r\n\t\tfor(int i=0;i<length;i++){\r\n\t\t\tchar c = str.charAt(i);\r\n\t\t\tif(last!=c){\r\n\t\t\t\tlast = c;\r\n\t\t\t\tcount++;\r\n\t\t\t\tmystr.append(last);\r\n\t\t\t\tmystr.append(count);\r\n\t\t\t}else{\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn mystr.toString();\r\n\t}\r\n```\r\n\r\n# 正确地做法\r\n\r\n- 直接使用string做法\r\n\r\n  ```\r\n  public String compressBad (String str)  \r\n  {  \r\n      String mystr = \" \";  \r\n      int count = 1;  \r\n      char last = str.charAt(0);  \r\n      for (int i = 1; i < str.length(); i++)  \r\n      {  \r\n          if (last == str.charAt(i))  \r\n          {  \r\n              count++;  \r\n          }  \r\n          else  \r\n          {  \r\n              mystr += last + count;  \r\n              last = str.charAt(i);  \r\n              count = 1;                \r\n          }  \r\n      }  \r\n      return mystr += last + count;  \r\n  }  \r\n  ```\r\n\r\n  ​\r\n\r\n\r\n\r\n- 使用StringBuffer\r\n\r\n  ```\r\n  \tpublic static  String compressBetter(String str) {\r\n  \t\tStringBuffer mystr = new StringBuffer();\r\n  \t\tint count = 1;\r\n  \t\t\/\/取出第一个字符作为比较字符\r\n  \t\tchar last = str.charAt(0);\r\n  \t\tfor (int i = 1; i < str.length(); i++) {\r\n  \t\t\t\/\/如果当前字符和之前的字符相同，说明是重复的，\r\n  \t\t\t\/\/直接在数量值+1；\r\n  \t\t\tif (last == str.charAt(i)) {\r\n  \t\t\t\tcount++;\r\n  \t\t\t} else {\r\n  \t\t\t\t\/\/如果不相同，说明开始了一个新的字符，\r\n  \t\t\t\t\/\/这时要做的只有两件事：\r\n  \t\t\t\t\/\/1、结束上格字符计数并添加字符串，\r\n  \t\t\t\tmystr.append(last);\r\n  \t\t\t\tmystr.append(count);\r\n  \t\t\t\t\/\/2、2、开始新的字符计数\r\n  \t\t\t\tlast = str.charAt(i);\r\n  \t\t\t\tcount = 1;\r\n  \t\t\t}\r\n  \t\t}\r\n  \t\t\/\/最后一个字符计数并显示\r\n  \t\tmystr.append(last);\r\n  \t\tmystr.append(count);\r\n  \t\treturn mystr.toString();\r\n  \t}\r\n  ```\r\n\r\n  ​\r\n\r\n# 感想\r\n\r\n作为IT从业者，大部分时间都在写业务逻辑，很多基本功已经近乎荒废了，这是非常不可取的。眼光放长远些，我们的技术不应该局限于某一种语言，而应该把重心放在跨语言的那些通用技术。比如：操作系统、算法和数据结构、网络及设计模式重构思想等，这些东西在任何语言中都会用到而且也会是重点。"
  },
  {
    "title" : "Linux命令行大全笔记",
    "created_time" : "2017-09-25 20:41:28",
    "body" : "# 0x00 前言\r\n\r\n本章是关于**Linux命令行大全**的读书笔记，随读随记。\r\n\r\n# 0x01 第1章 shell是什么\r\n\r\n- sh最初是Unix shell程序，bash是sh的增强版\r\n- shell是一个接收由键盘输入的命令，并将命令传递给操作系统来执行的程序。\r\n- `date`显示当前系统时间和日期\r\n- `df`查看磁盘驱动器当前可用空间\r\n- `cal`查看当月日历\r\n- `free`查看可用内存\r\n- `exit`退出终端\r\n\r\n<!--more-->\r\n\r\n# 0x02 第2章 导航\r\n\r\n- `pwd`查看当前工作目录\r\n\r\n- `cd`更改目录\r\n\r\n  **.**代表工作目录，**..**代表工作目录的父目录\r\n\r\n  `cd -`将工作目录变为上一个工作目录，**这里的上一个是历史的上一个目录，而不是父级目录**，就是说通过**该命令可以实现2个目录之间来回切换**。\r\n\r\n- `ls`列出目录内容\r\n\r\n# 0x03 第3章 Linux系统\r\n\r\n**命令完整格式：command -options  arguments。命令后面还可以使用选项和参数来进行限定，以精细达到所需结果**\r\n\r\n- `ls`列出目录内容\r\n\r\n  **选项区分大小写**\r\n\r\n  |  选项  |       长选项        |                    含义                    |\r\n  | :--: | :--------------: | :--------------------------------------: |\r\n  |  -a  |      --all       |           列出所有文件，包括以点号开头的隐藏文件            |\r\n  |  -d  |   --directory    | 通常如果指定了一个目录，ls会列出目录中的内容而不是目录本身，此选项与-l结合使用，可查看目录详细信息，而不是目录中内容。 |\r\n  |  -F  |    --classify    |      选项会在每个所列出的名字后面加上类型指示符，如果是目录加斜杠      |\r\n  |  -h  | --human-readable |       以长格式列出，以人们可读的方式而不是字节数来显示文件大小       |\r\n  |  -l  |                  |                使用长格式显示结果                 |\r\n  |  -r  |    --reverse     |          以相反的顺序显示结果，ls通常按字母升序显示          |\r\n  |  -S  |                  |                按文件大小对结果排序                |\r\n  |  -t  |                  |                 按修改时间排序                  |\r\n\r\n  ​\r\n\r\n- `file`确定文件类型\r\n\r\n  输入命令`file _config.yml`\r\n\r\n  结果`_config.yml: UTF-8 Unicode text, with CRLF line terminators`\r\n\r\n- `less`查看文件内容\r\n\r\n  |    命令    |  功能  |\r\n  | :------: | :--: |\r\n  |  pageup  | 向下翻页 |\r\n  | pagedown | 向上翻页 |\r\n  |   上箭头    | 上一行  |\r\n  |   下箭头    | 下一行  |\r\n  |    q     |  退出  |\r\n\r\n- 符号链接又叫软链接或symlink\r\n\r\n\r\n\r\n\r\n\r\n# 0x04 第4章 操作文件与目录\r\n\r\n- `cp`复制文件和目录\r\n\r\n  `cp item1 item2`将单个文件或目录item1复制到文件或目录item2中\r\n\r\n  `cp item1 item2 item3 dir`将多个项目复制到一个目录dir中\r\n\r\n- `mv`移动或重命名文件和目录\r\n\r\n  和cp用法基本一致\r\n\r\n- `mkdir`创建目录\r\n\r\n  `mkdir dir1`创建单个dir1目录\r\n\r\n  `mkdir dir1 dir2 dir3`创建多个目录\r\n\r\n- `rm`删除文件和目录\r\n\r\n  **注意：当rm与通配符一起使用时，要仔细检查内容，可使用ls命令与通配符配合使用进行测试，这时将显示要删除的文件。紧接着使用rm替换ls，避免不恰当的删除造成不可挽回的后果。因为一旦使用rm命令，就彻底的删除了**\r\n\r\n  ​\r\n\r\n- `in`创建硬链接和符号链接\r\n\r\n\r\n\r\n# 0x05 第五章"
  },
  {
    "title" : "Mac版eclipse中每次重启电脑后字体自动变小",
    "created_time" : "2017-04-22 18:50:50",
    "body" : "如题每次开机后打开eclipse时，发现上次调好的字体又变小了。每次都这样，比较影响心情。今天决定把这个问题解决掉。\r\n\b网友的做法是：\r\n打开 应用程序\/Eclipse.app\/Contents\/Eclipse\/eclipse.ini 文件中，\r\n把文中“-Dorg.eclipse.swt.internal.carbon.smallFonts”删掉。\r\n这样可以避免Eclipse里面的字体奇怪地自动变小。。\r\n\r\n发现很久以前就存在这个问题，不过当时的fix方法和最新的不一样。\r\n[传送通道](http:\/\/t-machine.org\/index.php\/2011\/08\/21\/fix-eclipses-fonts-on-os-x\/)\r\n\r\n但是上面的2方法好像对我来说没有效果(我只试了第一种)。后来在偏好设置里发现Theme为mac时使用的是Reduced Palette这个选项，我好奇的把选项改为了Default。然后点了确认再调整好需要的字体并重启。然后真的没有再恢复小字体了。\r\n\r\n![屏幕快照 2017-03-08 下午12.04.34.png](http:\/\/upload-images.jianshu.io\/upload_images\/1796052-3ea1ef0bbc0ed211.png?imageMogr2\/auto-orient\/strip%7CimageView2\/2\/w\/1240)"
  },
  {
    "title" : "Mac系统下载文本都是打开都是乱码",
    "created_time" : "2017-07-29 18:58:43",
    "body" : "# 前言\r\n\r\n系统升级后出现个问题，就是所有下载的文本文档打开时都出现了异常：\r\n\r\n![文本打开异常](http:\/\/othg5ggzi.bkt.clouddn.com\/%E6%96%87%E6%9C%AC%E6%89%93%E5%BC%80%E5%BC%82%E5%B8%B8.png)\r\n\r\n\r\n\r\n\r\n\r\n# 解决\r\n\r\n在文本编辑的偏好中进行设置即可：\r\n\r\n![文本编辑偏好设置](http:\/\/othg5ggzi.bkt.clouddn.com\/%E6%96%87%E6%9C%AC%E7%BC%96%E7%A0%81%E8%AE%BE%E7%BD%AE.png)"
  },
  {
    "title" : "Mac系统中希捷移动硬盘NTFS格式只能读",
    "created_time" : "2017-08-01 01:03:05",
    "body" : "# 前言\r\n\r\n今天Mac系统更新完成后，希捷移动硬盘突然只能读不能写了。\r\n\r\n\r\n\r\n\r\n\r\n# 解决\r\n\r\nMac默认不支持NTFS格式，所以要想兼容需要安装[Paragon驱动](http:\/\/www.seagate.com\/cn\/zh\/support\/downloads\/item\/ntfs-driver-for-mac-os-master-dl\/)。\r\n\r\n- 在开始安装前，确保硬盘连接至电脑。\r\n- 双击您下载的 **NTFS_for_Mac_14.0.456.dmg** 文件。\r\n- 按照屏幕提示完成安装。\r\n- 重启后即可读写硬盘"
  },
  {
    "title" : "Mac下配置adb",
    "created_time" : "2017-07-13 21:10:42",
    "body" : "# 0x00 前言\r\n\r\nMac和windows一样，如果要在终端命令行全局使用非系统命令，需要手动把命令环境配置到指定文件中，具体操作就是把命令文件所属路径配置到.bash_profile里面。\r\n\r\n# 0x01 分别找到双方路径\r\n\r\n## 找到adb\r\n\r\n我是通过Android studio中的idk location找到SDK位置`\/Users\/jenson\/Library\/Android\/sdk` .\r\n\r\n\r\n\r\n<!-- more -->\r\n\r\n## 找到.bash_profile\r\n\r\n- 使用命令行`cd $home` 进入home路径下，\r\n\r\n- 因为mac下以点开头的文件为隐藏文件，所以使用`ls -al` 查看所有文件，查看列表是否有.bash_profile文件，\r\n\r\n- 如果没有，使用`touch .bash_profile` 创建，如果有则执行命令`open -e .bash_profile` 使用文本编辑器打开文件，\r\n\r\n- 在下面按格式添加SDK路径：\r\n\r\n  ```\r\n  export PATH=\/Users\/jenson\/Library\/Android\/sdk\/platform-tools:$PATH\r\n  export PATH=\/Users\/jenson\/Library\/Android\/sdk\/tools:$PATH\r\n  ```\r\n\r\n  ​\r\n\r\n## open -e .bash_profile提示open命令不存在\r\n\r\n通过Finder根据路径找到.bash_profile文件，编辑添加\r\n\r\n```\r\nexport PATH=\"\/usr\/bin:\/bin:\/usr\/sbin:\/sbin\"\r\nexport PATH=\"\/usr\/local\/bin:\/usr\/local\/sbin:$PATH\"\r\n```"
  },
  {
    "title" : "Mac终端光标变成粗体",
    "created_time" : "2017-07-01 13:46:51",
    "body" : "打开终端偏好设置，勾选 竖条，闪动光标\r\n\r\n![设置光标](Mac终端光标变成粗体\/设置光标.png)"
  },
  {
    "title" : "No resource identifier found for attribute 'roundIcon' in package 'and",
    "created_time" : "2017-08-04 11:37:39",
    "body" : "# 前言\r\n\r\nAndroid studio更新到2.3后创建项目时就出现了这个问题，我只要降低版本就出现编译异常信息：\r\n\r\n`No resource identifier found for attribute 'roundIcon' in package 'android'Ask Question`。\r\n\r\n这个**roundIcon**真是害人匪浅。\r\n\r\n而且也是感受到了天下文章一大抄的说法所言非虚。。\r\n\r\n只要搜出来的说法都是删掉`roundIcon`那个属性即可。\r\n\r\n可是我和其他网友都遇到了另一个问题：删除后再编译又会自动给添加上，而编译版本已经改为了5.0。\r\n\r\n<!-- more -->\r\n\r\n# 解决\r\n\r\n- 简单做法\r\n\r\n如果只是因为没有为最新系统功能做好适配工作。那么可以把**targetSdkVersion**降回到所需版本，但保留**compileSdkVersion 26**编译版本最新。这是最简单做法，但是可能有一些过时API需要进行版本判断。\r\n\r\n- 我还想降低compileSdkVersion为20\r\n\r\n  当把**compileSdkVersion**降为20的时候，再次编译项目就出现了`Error:(11) No resource identifier found for attribute 'roundIcon' in package 'android'`。\r\n\r\n  这时想到还有构建版本还是26.0.0，然后也改为20.0.0了。再次编译\r\n\r\n  这时候仍然有异常，但是信息变了：`Error:The SDK Build Tools revision (20.0.0) is too low for project ':app'. Minimum required is 25.0.0\r\n  <a href=\"fix.build.tools.version\">Update Build Tools version and sync project<\/a><br><a href=\"openFile:\/Users\/jenson\/AndroidStudioProjects\/CanvasTest\/app\/build.gradle\">Open File<\/a>`。\r\n\r\n  这是一个好兆头，说明我们的对手变了。我现在要做的就是让项目认可低版本的bt(build tool)。\r\n\r\n  这条异常是由：Gradle sync发出的。所以异常和Gradle有关，那现在问题矛头指向Gradle，而Gradle又有Gradle版本和插件版本，\r\n\r\n  **会不会是版本太新缘故，毕竟谷歌老喜欢搞新花样，所以现在的想法是回退到一个合适的版本。**\r\n  目前版本是**gradle-3.3-all**和**com.android.tools.build:gradle:2.3.3**\r\n\r\n  现在使用**gradle-3.0-all**和**com.android.tools.build:gradle:2.2.0**\r\n\r\n  从新编译时出现了如下弹窗：\r\n\r\n  ![gradle版本升级弹窗](http:\/\/othg5ggzi.bkt.clouddn.com\/gradle%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7%E6%8F%90%E7%A4%BA%E5%BC%B9%E7%AA%97.png)\r\n\r\n\r\n\r\n​\t说明两个版本在匹配范围内，获得初步成功，但是编译完成时再次提示了**roundIcon**，然后这次把**属性删掉**，同时**clean project**。\r\n\r\n然后又出现了如下异常信息：\r\n\r\nError:In <declare-styleable> ConstraintSet, unable to find attribute android:elevation\r\n\r\n这可能是由于把compileSdkVersion设置20，有点太低了得缘故。\r\n\r\n既然如此，干脆一不做二不休，进入布局文件把**android.support.constraint.ConstraintLayout**布局替换为其他布局。同时删除该类用到的一些属性，譬如：\r\n\r\n```\r\napp:layout_constraintBottom_toBottomOf=\"parent\"\r\napp:layout_constraintLeft_toLeftOf=\"parent\"\r\napp:layout_constraintRight_toRightOf=\"parent\"\r\napp:layout_constraintTop_toTopOf=\"parent\"\r\n```\r\n\r\n斩草要除根，把依赖包也干脆去掉：\r\n\r\n删除**compile 'com.android.support.constraint:constraint-layout:1.0.2'**\r\n\r\n\r\n\r\n最最最后clean project，各种build后没有终于恢复正常了。。。。\r\n\r\n\r\n\r\n> 提示：每次升级前注意下当前Gradle版本是多少，对应的Plugin版本又是多少，如果升级后有问题，可以方便的回退。\r\n\r\n\r\n\r\ngradle本地：\r\n\r\n```\r\ndistributionUrl=file:\/Users\/jenson\/.gradle\/wrapper\/dists\/gradle-3.0-all.zip\r\n```"
  },
  {
    "title" : "osx下如何使用SublimeText阅读Android系统源码",
    "created_time" : "2017-04-22 18:55:54",
    "body" : ">以前用win系统时使用sourceinsight阅读源码方便至极，但是自从换到mac下，尝试了很多方法很多工具，比如understand、比如vscode、比如wine下安装sourceinsight。总是有各种问题，所以这次尝试使用SublimeText\r\n\r\n平时使用Sublimetext都是打开单个文件，这次要导入几万个文件，这在一些ide中称为project。同样在Sublime中也是如此。\r\n\r\n#### 1. 创建工程\r\n\r\n　　Project > Add Folder to Project 选择源码目录即可\r\n　　这时在\b窗口左边栏中将出现刚刚添加的文件目录，如果还需要添加其他目录，则重复这一操作即可。\r\n\r\n<!-- more -->\r\n\r\n#### 2. 保存工程\r\n\r\n　　Project > Save Project As\r\n　　点击保存后Sublime Text将自动生成两个文件：\r\nproject_name.sumlime-project：包含工程定义，该文件会被记录到版本控制里。\r\nproject_name.sublim-workspace：包含了用户的工程数据，例如打开的文件和修改等，该文件不会被记录到版本控制里。\r\n　　在*.sublime-project文件中，你可以定义工程配置。例如你可以定义多个目录路径，或者哪些目录或文件需要排除在外。例如：\r\n　　以上*.sublime-project文件中定义了两个目录，而“name”标签是该目录在Sublime Text的\b左边栏中显示的名字。通过定义“name”，你可以将一些长路径或者名字很长的目录以更简洁的名称显示在\b左边栏中。\r\n\r\n#### 3、添加索引\r\n\r\n- 安装Package Control插件\r\n  1.打开控制台\r\n       方法1：View->show console \r\n       方法2：ctrl+~\r\n    2.输入代码：\r\n  python2.x代码:\r\n\r\n```\r\nimport urllib2,os;pf='Package Control.sublime-package';ipp=sublime.installed_packages_path();os.makedirs(ipp) if not os.path.exists(ipp) else None;open(os.path.join(ipp,pf),'wb').write(urllib2.urlopen('http:\/\/sublime.wbond.net\/'+pf.replace(' ','%20')).read())  \r\n```\r\npython3.x代码：\r\n\r\n```\r\nimport urllib.request,os;pf='Package Control.sublime-package';ipp=sublime.installed_packages_path();os.makedirs(ipp) if not os.path.exists(ipp) else None;open(os.path.join(ipp,pf),'wb').write(urllib.request.urlopen('http:\/\/sublime.wbond.net\/'+pf.replace(' ','%20')).read())\r\n```\r\n- 安装CTags\r\n  - 1. 首先 Preference -> Browser Packages... 查看是否已经安装了CTags Package，如果没有则继续下面步骤\r\n  - 2. Preference -> Package control, 输入“install package”，它会找出你可以安装的插件，在列表中选择ctag插件进行安装\r\n\r\n   - 3.创建索引\r\n\r\n![屏幕快照 2017-03-22 下午2.55.23.png](http:\/\/upload-images.jianshu.io\/upload_images\/1796052-38f35a1199d9e85a.png?imageMogr2\/auto-orient\/strip%7CimageView2\/2\/w\/1240)\r\n\r\n#### 4、异常处理\r\n\r\n- 期间出现Package Control:There are no packages available for installation弹窗提示\r\n  选择Preference->Browser Packages打开文件夹后\r\n  删除Package Control目录、删除User目录下相关Package Control名称文件等，再次安装。\r\n- ctag rebuild时弹窗异常如图：\r\n\r\n![屏幕快照 2017-03-22 下午3.01.14.png](http:\/\/upload-images.jianshu.io\/upload_images\/1796052-ad6b9e4b667a7b5b.png?imageMogr2\/auto-orient\/strip%7CimageView2\/2\/w\/1240)\r\n\r\n这是因为我们还没有安装和配置ctags\r\n下载ctags-5.8.tar.gz解压并编译，依次执行如下命令：\r\n\r\n`tar xzvf ctags-5.8.tar.gz`\r\n\r\n`cd ctags-5.8`\r\n\r\n`.\/configure`\r\n\r\n`make`\r\n\r\n`sudo make install`\r\n\r\n打开Preference ->Package settings->ctags->settings-user和settings-default\r\n把default中的配置全部复制到user中，然后改一下command配置项，为ctags的可执行文件路径\/usr\/local\/bin\/ctags（可以通过which ctags命令查看ctags路径）\r\n#### 5、快捷键\r\n- 修改跳转\r\n  默认函数跳转：Ctrl+shift+左键; 跳转返回：Ctrl+shift+右键。修改方法：\r\n   Perference->Package Settings->CTags->Mouse Binding Default->复制到Mouse Binding User，把里面的\"ctrl+shift\"，修改为“command”，这样就可以用“command+左键”跳转了：\r\n\r\n```\r\n        Command+P：查找文件\r\n        Command+R：查找方法\r\n        Command+左键：文件或函数跳转        \r\n        Command+右键：返回文件或函数跳转的原始位置\r\n```\r\n\r\n至此Android源码项目创建完成并创建索引，代码跳转也反应迅速。\r\n参考：https:\/\/jingyan.baidu.com\/article\/48206aeafba820216ad6b3f5.html"
  },
  {
    "title" : "osx下pip3安装matplotlib时 The following required packages can not be built",
    "created_time" : "2017-04-22 18:55:54",
    "body" : "'The following required packages can not be built: * freetype'\r\n出现这个提示，乍一看以为没有安装freetype的原因，后来找其安装方法。使用brew install freetype  ，有提示already installed。然后又看了很多文章，照着改了很多都没有办法。后来胡乱一通查找看到了这个[问答](http:\/\/stackoverflow.com\/questions\/12363557\/matplotlib-install-failure-on-mac-osx-10-8-mountain-lion)\r\n```\r\nI think the other answers are on the right track, but I encountered this same problem and can attest that:\r\nbrew install pkg-config\r\nbrew install freetype\r\npip install matplotlib\r\n```\r\n上面意思说这哥们遇到过同样的问题，下面的能解决。所以试了下```brew install pkg-config```然后自动安装了，因为freetype已经提示安装了。最后又安装了一次```pip3 install matplotlib```成功了"
  },
  {
    "title" : "WireShark the capture session could not be initiated (you don't have",
    "created_time" : "2017-08-03 19:07:11",
    "body" : "# 前言\r\n\r\n异常信息如下：**the capture session could not be initiated (you don't have permission to capture on that device)**\r\n\r\n在WireShark启动后，选择网卡设备时，出现这个异常。\r\n\r\n\r\n\r\n# 解决\r\n\r\n由于是Mac系统，所以直接终端窗口命令行解决：\r\n\r\n**sudo chmod 777 \/dev\/bpf***。"
  },
  {
    "title" : "WordCloud不显示中文只显示方框问题",
    "created_time" : "2017-07-29 18:59:36",
    "body" : "# 前言\r\n\r\n在用词云展示时，发现其他能正常运行，但是启动后的图像中都是方框，后来查找到原因是因为词云默认只支持英文。\r\n\r\n如果要支持中文需要自己设置支持中文的字体\r\n\r\n# 解决方案\r\n\r\n```python\r\nmy_wordcloud = WordCloud(font_path='\/Library\/Fonts\/Songti.ttc').generate(wl_space_split)\r\n\r\n```\r\n\r\n手动设置宋体字体，最终就能正常显示了"
  },
  {
    "title" : "图片本地打开显示正常但页面打开是倒了的",
    "created_time" : "2017-10-31 07:16:27",
    "body" : "# 0x00 前言\r\n\r\n一个宽小于高的图片，在本地打开时显示正常，但是在页面中**img**标签中打开时自动旋转了90度。\r\n\r\n这就导致竖着拍出来的照片不能正常显示就很难看。\r\n\r\n这是因为图片的 EXIF 里标记了旋转 `Rotate 90 CW`\r\n\r\n# 0x01 解决\r\n\r\n由于采用的是七牛云图床，而七牛云给了解决方法：**在链接后添加 imageMogr2\/auto-orient 参数，即可根据原图EXIF信息自动旋正**\r\n\r\n[七牛云图片高级处理](https:\/\/developer.qiniu.com\/dora\/manual\/1270\/the-advanced-treatment-of-images-imagemogr2)"
  },
  {
    "title" : "浅谈Android性能优化系列工具篇之Battery Historian电量检测工具使用",
    "created_time" : "2017-11-08 16:28:31",
    "body" : "# 前言\r\n\r\nBattery Historian是谷歌开放的电量检测工具，目前发布2个版本：首个版本是由python编写，但是在2015年谷歌IO大会发布的Battery Historian2.0版本使用Go重写，新版本提供的信息更全面。\r\n\r\n去[Google的github项目](https:\/\/github.com\/google\/battery-historian)下载Battery Historian。\r\n\r\n# 准备\r\n\r\n## 电池重置\r\n\r\n使用命令`adb shell dumpsys batterystats --reset`重置电池\r\n\r\n**电池重置的目的是为了让下次电量统计时从当前时间开始，而不是从最初开机或上次充满电(具体何时开始不清楚)。**\r\n\r\n## 开启全部wakelock\r\n\r\n使用命令`adb shell dumpsys batterystats --enable full-wake-history`开启全部wakelock\r\n\r\n# 导出统计数据\r\n\r\n接下来应该断开设备的充电连接，对我们的app进行各种操作，等操作完成重新连接设备，然后进行电量统计。\r\n\r\n其实电量统计系统已经为我们做了，我们要做的就是把电量统计信息以文件形式导出到我们的电脑。\r\n\r\n老版本的导出命令为：`adb shell dumpsys batterystats > out.txt `。\r\n\r\n`adb shell dumpsys batterystats > 包名 > out.txt `得到给定的app相关的电量消耗信息\r\n\r\n新版本的导出命令为：` adb bugreport out.zip`，也可以使用`adb bugreport > out.txt`。\r\n\r\n新版本同样也可以统计指定APP\r\n\r\n导出的out.txt文件在你命令行执行时的所属目录。\r\n\r\n### 异常1\r\n\r\n这里我出现一个异常：当前SDK最新版本为7.0(25)，而我的手机系统版本为5.0，\r\n\r\n所以使用命令行：**adb bugreport > report.txt**时出现了如下异常：\r\n\r\n**Failed to get bugreportz version, which is only available on devices running Android 7.0 or later.**\r\n\r\n这是由于SDK版本太新了，既然手机系统不能升级，那就只好把SDK降级，\r\n\r\n其实这里只是使用了plantform下的adb命令，所以从新下载**platform-tools**即可。\r\n\r\n我下载和手机系统版本一致的platform-tools，然后解压。\r\n\r\n使用新下载的platform-tools的adb命令执行`adb bugreport > out.txt`时提示没有设备。\r\n\r\n### 异常2\r\n\r\n又使用**adb devices**查看列表仍然没有。重启adb也没用效果。\r\n\r\n因为我的是Mac设备，所以命令行执行`system_profiler SPUSBDataType`时会显示一系列外接设备信息，找到你的Android设备，复制Vendor ID。\r\n\r\n进入你下载的低版本**platform-tools**文件夹下，修改或创建**adb_usb.ini**文件，把刚才复制的Vendor ID粘贴到这里。\r\n\r\n再次执行**adb devices**就可以查看到设备列表了。\r\n\r\n然后再次执行`adb bugreport > out.txt`就会产生一个设备耗能统计信息文件。\r\n\r\n### 注意\r\n\r\n导出电量统计数据是一个持续输出的过程，就是说如果你不手动停止，那会一直统计。\r\n\r\n所以看到文件中已经写入内容后就可以CTRL+C了。\r\n\r\n# 数据可视化\r\n\r\n我们得到的是一个可读性很差的txt文件，接下来就是把out.txt文件转为方便我们可视化的图表信息html\r\n\r\n**老版本**使用命令`python historian.py out.txt > out.html`，其中**historian.py**在我们前言中下载的项目中scripts目录下。\r\n\r\n转换后的页面如图：\r\n\r\n![historian01](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/historian-01.png)\r\n\r\n![historian02](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/historian-02.png)\r\n\r\n![historian03](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/historian-03.png)\r\n\r\n\r\n\r\n**注意：刚打开html时可能页面只显示Battery Historian analysis for bugreport.txt，看不到其他内容，是因为页面正在分析txt，耐心等待下，不要关闭页面。**\r\n\r\n图中垂直白线每个间隔在我这里表示半分钟，\r\n\r\nbattery_level（ 剩余电量）\r\n鼠标悬停在 battery_level 变化处，显示剩余电量，以及距上次 battery_level 变化的间隔\r\n\r\nplugged（连接）\r\n电量来源（类似于上面的电量信息）。\r\n\r\nscreen（屏幕）\r\n屏幕开启的时长。\r\n\r\ntop（上栏）\r\n列举了当前屏幕上显示的进程\r\n\r\nsync（同步）\r\n处理与服务器的同步。\r\n\r\nwake_lock\r\n\r\nrunning（运行）\r\n游戏时，电话一直在后台运行。\r\n\r\n wake_lock_in（唤醒锁）\r\n可以看到哪些进程正在运行，以及所引起的 WakeLock 或 Alarm。在这张截图中，游\r\n戏音频控制进程多次调用 WakeLock（ 播放不同的示例音乐引发了将近 2000 次音频\r\nWakeLock）。同时也可以看到屏幕 WakeLock。\r\n\r\nJob\t后台的工作，比如服务service的运行\r\n\r\nwifi\r\n\r\nwifi_full_lock\r\n\r\nwifi_scan（WIFI扫描）\r\n\r\nwifi_running（WIFI运行状态）\r\n\r\n我这里一条全是绿，说明一直在连接WIFI使用中\r\n\r\n\r\n\r\nwifi_suppl（ Wi-Fi状态）\r\n\r\n\r\nwifi_signal_strength（ Wi-Fi信号强度）\r\n图 3-8 中，有 Wi-Fi 信号被检测到——尽管 Wi-Fi 已经被关闭，但由于高级 Wi-Fi 设置，\r\n也会一直搜索 Wi-Fi 信号。\r\n\r\nphone_signal_strength（无线网络信息 ）\r\n显示信号变化（有差、中、好 三种）。\r\n\r\naudio\r\n\r\nfg\r\n这里指的是前台应用。前台程序很少被销毁来释放内存。即使关闭屏幕，我们也可以看\r\n到 Facebook 客户端在前台处理收到的信息。\r\n\r\nstatus（状态）\r\n正在放电（与充电状态相对应）。\r\n\r\nhealth（健康）\r\n电池健康状态，来自电池管理器 API。\r\n\r\nplug（连接状态）\r\n设备是否接通电源。\r\n\r\n\r\n\r\n**通过上面的数据展示可以看出各个硬件耗电信息，根据相关信息和自己APP的相关设置，看哪些是不该出现的硬件使用而执行了，那这就是该优化的地方。比如在wake_lock_in横条中，左半部分红色竖条还是比较均匀的，但是到了右半部分，红条多了很多而且同一时间有多个wakelock发生了，这些都是需要的吗？不是的话就要想办法优化了。**\r\n\r\n# 结尾\r\n\r\n这里使用的一直是Battery Historian1.0，新版本的由于是GO语言重新的，所以需要安装Go的环境，有时间在尝试下。\r\n\r\n新版本内容也更丰富，页面有四个标签：SystemStats（系统统计）、 Historian 2.0、 Historian（ legacy） 和 App Stats（应用程序统计）。"
  },
  {
    "title" : "猫扑素数",
    "created_time" : "2017-11-14 06:33:28",
    "body" : "# 前言\r\n\r\n关于**猫扑素数**，首先我有2个定义不明白：\r\n\r\n什么是素数？\r\n\r\n怎么才算猫扑素数？\r\n\r\n或许弄清这两个问题就方便下手了。\r\n\r\n# 素数\r\n\r\n说素数不懂，但是换个说法，质数，应该很多人就明白了。\r\n\r\n百科里这样定义：*质数*（prime number）又称*素数*，有无限个。*质数*定义为在大于1的自然数中，除了1和它本身以外不再有其他因数，这样的数称为*质数*。\r\n\r\n这样一下子就明朗起来了，质数的定义在中学就学过了。\r\n\r\n3，5，7是质数，9不是，所以可以认为质数一定是奇数，但是奇数不一定是质数。\r\n\r\n# 猫扑素数\r\n\r\n关于猫扑素数的来源没有在网络上找到，不知道为什么起了个这样名字。\r\n\r\n所以只能强制记住以2开头，后面根若干个3的如23，233，23333这样的就是猫扑素数。\r\n\r\n不过233333不是，因为233333=353x661。\r\n\r\n# 实现\r\n\r\n\r\n\r\n```python\r\nimport math\r\n\r\n\r\ndef isPrime(value):\r\n    \"\"\"\r\n    是否为素数\r\n    :param value:\r\n    :return:\r\n    \"\"\"\r\n    isPrime = True\r\n    if value < 2:\r\n        isPrime = False\r\n    else:\r\n        sq = int(math.sqrt(value))\r\n        for i in range(2, sq):\r\n            if (value % i == 0):\r\n                isPrime = False\r\n                break\r\n    return isPrime\r\n\r\n\r\ndef isMop(value):\r\n    \"\"\"\r\n    是否为猫扑素数\r\n    :param value:\r\n    :return:\r\n    \"\"\"\r\n    if value < 10:\r\n        return value == 2\r\n    else:\r\n        if value % 10 == 3:\r\n            return isMop(int(value \/ 10))\r\n        else:\r\n            return False\r\n\r\n\r\ndef numIsMop(value):\r\n    if isMop(value):\r\n        if isPrime(value):\r\n            print(value)\r\n\r\n\r\nfor i in range(1, 1000000):\r\n    numIsMop(i)\r\n```\r\n\r\n打印结果为：\r\n\r\n```\r\n2\r\n23\r\n233\r\n2333\r\n23333\r\n```"
  },
  {
    "title" : "Log工具封装Tag显示类方法和行数",
    "created_time" : "2017-11-28 15:29:25",
    "body" : "```java\r\n​​​import android.text.TextUtils;\r\nimport android.util.Log;\r\n\r\n\/**\r\n * 二次封装的log打印工具\r\n *\/\r\npublic class LogUtils {\r\n\r\n\tpublic static String customTagPrefix = \"\";\r\n\r\n\tprivate LogUtils() {\r\n\t}\r\n\r\n\tpublic static boolean allowD = true;\r\n\tpublic static boolean allowE = true;\r\n\tpublic static boolean allowI = true;\r\n\tpublic static boolean allowV = true;\r\n\tpublic static boolean allowW = true;\r\n\tpublic static boolean allowWtf = true;\r\n\r\n\tpublic static LogListener logListener;\/\/如果要处理Log信息，实现listener即可\r\n\r\n\t\/**\r\n\t * @Description log输出监听（简易观察者）\r\n\t *\/\r\n\tpublic interface LogListener {\r\n\r\n\t\tvoid handleLog( String level, String tag, String content );\r\n\t}\r\n  \r\n    public static StackTraceElement getCurrentStackTraceElement() {\r\n        return Thread.currentThread().getStackTrace()[4];\r\n    }\r\n  \r\n\tprivate static String generateTag( StackTraceElement caller ) {\r\n\t\tString tag = \"%s[%s, %d]\";\r\n\t\tString callerClazzName = caller.getClassName();\r\n\t\tcallerClazzName = callerClazzName.substring(\r\n\t\t\t\tcallerClazzName.lastIndexOf( \".\" ) + 1 );\r\n\t\ttag = String.format( tag, callerClazzName, caller.getMethodName(), caller.getLineNumber() );\r\n\t\ttag = TextUtils.isEmpty( customTagPrefix ) ?\r\n\t\t\t\ttag :\r\n\t\t\t\tcustomTagPrefix + \":\" + tag;\r\n\t\treturn tag;\r\n\t}\r\n\r\n\tpublic static void d( String content ) {\r\n\t\tif (!allowD)\r\n\t\t\treturn;\r\n\t\tStackTraceElement caller = getCurrentStackTraceElement();\r\n\t\tString tag = generateTag( caller );\r\n\t\tLog.d( tag, content );\r\n\t\thandleLog( \"d\", tag, content );\r\n\t}\r\n\r\n\tpublic static void d( String content, Throwable tr ) {\r\n\t\tif (!allowD)\r\n\t\t\treturn;\r\n\t\tStackTraceElement caller = getCurrentStackTraceElement();\r\n\t\tString tag = generateTag( caller );\r\n\t\tLog.d( tag, content, tr );\r\n\t}\r\n\r\n\tpublic static void e( String content ) {\r\n\t\tif (!allowE)\r\n\t\t\treturn;\r\n\t\tStackTraceElement caller = getCurrentStackTraceElement();\r\n\t\tString tag = generateTag( caller );\r\n\t\tLog.e( tag, content );\r\n\t\thandleLog( \"e\", tag, content );\r\n\t}\r\n\r\n\tpublic static void e( String content, Throwable tr ) {\r\n\t\tif (!allowE)\r\n\t\t\treturn;\r\n\t\tStackTraceElement caller = getCurrentStackTraceElement();\r\n\t\tString tag = generateTag( caller );\r\n\t\tLog.e( tag, content, tr );\r\n\t}\r\n\r\n\tpublic static void i( String content ) {\r\n\t\tif (!allowI)\r\n\t\t\treturn;\r\n\t\tStackTraceElement caller = getCurrentStackTraceElement();\r\n\t\tString tag = generateTag( caller );\r\n\t\tLog.i( tag, content );\r\n\t\thandleLog( \"i\", tag, content );\r\n\t}\r\n\r\n\tpublic static void i( String content, Throwable tr ) {\r\n\t\tif (!allowI)\r\n\t\t\treturn;\r\n\t\tStackTraceElement caller = getCurrentStackTraceElement();\r\n\t\tString tag = generateTag( caller );\r\n\t\tLog.i( tag, content, tr );\r\n\t}\r\n\r\n\tpublic static void v( String content ) {\r\n\t\tif (!allowV)\r\n\t\t\treturn;\r\n\t\tStackTraceElement caller = getCurrentStackTraceElement();\r\n\t\tString tag = generateTag( caller );\r\n\t\tLog.v( tag, content );\r\n\t\thandleLog( \"v\", tag, content );\r\n\t}\r\n\r\n\tpublic static void v( String content, Throwable tr ) {\r\n\t\tif (!allowV)\r\n\t\t\treturn;\r\n\t\tStackTraceElement caller = getCurrentStackTraceElement();\r\n\t\tString tag = generateTag( caller );\r\n\t\tLog.v( tag, content, tr );\r\n\t}\r\n\r\n\tpublic static void w( String content ) {\r\n\t\tif (!allowW)\r\n\t\t\treturn;\r\n\t\tStackTraceElement caller = getCurrentStackTraceElement();\r\n\t\tString tag = generateTag( caller );\r\n\t\tLog.w( tag, content );\r\n\t\thandleLog( \"w\", tag, content );\r\n\t}\r\n\r\n\tpublic static void w( String content, Throwable tr ) {\r\n\t\tif (!allowW)\r\n\t\t\treturn;\r\n\t\tStackTraceElement caller = getCurrentStackTraceElement();\r\n\t\tString tag = generateTag( caller );\r\n\t\tLog.w( tag, content, tr );\r\n\t}\r\n\r\n\tpublic static void w( Throwable tr ) {\r\n\t\tif (!allowW)\r\n\t\t\treturn;\r\n\t\tStackTraceElement caller = getCurrentStackTraceElement();\r\n\t\tString tag = generateTag( caller );\r\n\t\tLog.w( tag, tr );\r\n\t}\r\n\r\n\tpublic static void wtf( String content ) {\r\n\t\tif (!allowWtf)\r\n\t\t\treturn;\r\n\t\tStackTraceElement caller = getCurrentStackTraceElement();\r\n\t\tString tag = generateTag( caller );\r\n\t\tLog.wtf( tag, content );\r\n\t\thandleLog( \"wtf\", tag, content );\r\n\t}\r\n\r\n\tpublic static void wtf( String content, Throwable tr ) {\r\n\t\tif (!allowWtf)\r\n\t\t\treturn;\r\n\t\tStackTraceElement caller = getCurrentStackTraceElement();\r\n\t\tString tag = generateTag( caller );\r\n\t\tLog.wtf( tag, content, tr );\r\n\t}\r\n\r\n\tpublic static void wtf( Throwable tr ) {\r\n\t\tif (!allowWtf)\r\n\t\t\treturn;\r\n\t\tStackTraceElement caller = getCurrentStackTraceElement();\r\n\t\tString tag = generateTag( caller );\r\n\t\tLog.wtf( tag, tr );\r\n\t}\r\n\r\n\t\/**\r\n\t * 处理Log信息\r\n\t *\r\n\t * @param level\r\n\t * @param tag\r\n\t * @param content\r\n\t *\/\r\n\tprivate static void handleLog( String level, String tag, String content ) {\r\n\t\tif (null != logListener) {\r\n\t\t\tlogListener.handleLog( level, tag, content );\r\n\t\t}\r\n\t}\r\n}\r\n```"
  },
  {
    "title" : "《Android移动性能实战》优化点总结",
    "created_time" : "2018-11-16 08:14:19",
    "body" : "## 前言\r\n\r\n下面是对《Android移动性能实战》一书的知识点总结：常见App场景的性能优化知识点，\r\n\r\n\r\n出乎意料的是这本书是由测试部门人员写出来的，书中也有提到一些问题点开发人员无从下手，是由测试人员发现问题所在，不得不感慨有一种测试叫别人家的测试。\r\n\r\n## IO性能优化\r\n\r\n\r\n\r\n### 缓存重复读取的系统文件\r\n\r\n> 每次打开、 关闭或者读\/写文件， 操作系统都需要从用户态到内核态的切\r\n> 换， 这种状态的切换本身是很消耗性能的， 所以为了提高文件的读\/写效率， 就需要尽\r\n> 量减少用户态和内核态的切换。 使用缓存可以避免重复读\/写， 对于需要多次访问的数\r\n> 据， 在第一次取出数据时， 将数据放到缓存中， 下次再访问这些数据时， 就可以从缓\r\n> 存中取出来 \r\n\r\n读取系统文件诸如*\/proc\/cpuinfo*时，使用变量进行信息缓存，防止每次需要该信息时都进行文件读取，须知每次读取都是一次IO操作\r\n\r\n### SharePreference优化\r\n\r\n> Android系统中使用SharedPreferences文件来保存数据非常方便， 在需\r\n> 要保存数据的地方调用commit就可以， 但是很多开发同学可能并不知道每调用一次\r\n> commit（） ， 就会对应一次文件的打开和关闭， 从而造成因commit（） 方法的随意调\r\n> 用而导致文件的重复打开和关闭 \r\n>\r\n> 使用apply替代commit，apply是异步操作，commit是同步操作。\r\n\r\n\r\n\r\n### 严禁主线程中进行IO操作\r\n\r\n> 随机读\/写是相对顺序读\/写而言的， 在读取或者写入的时候\r\n> 随机地产生offset。 但为什么随机读\/写会如此之慢呢？\r\n> 1． 随机读会失去预读（read-ahead） 的优化效果。\r\n> 2． 随机写相对于顺序写除了产生大量的失效页面之外， 更重要的是增加了触\r\n> 发“写入放大”效应的概率。\r\n> 那么“写入放大”又是什么呢？ 下面我们来介绍第二个概念： “写入放大”效应。\r\n> “写入放大”效应\r\n> 当数据第一次写入时， 由于所有的颗粒都为已擦除状态， 所以数据能够以页为最\r\n> 小单位直接写入进去。 当有新的数据写入需要替换旧的数据时， 主控制器将把新的数\r\n> 据写入到另外的空白闪存空间上（已擦除状态） ， 然后更新逻辑LBA地址来指向到新\r\n> 的物理FTL地址。 此时， 旧的地址内容就变成了无效的数据， 但主控制器并没执行擦\r\n> 除操作而是会标记对应的“页”为无效。 当磁盘需要在上述无效区域进行再次写入的\r\n> 话， 为了得到空闲空间， 闪存必须先复制该“块”中所有的有效“页”到新的“块”里， 并\r\n> 擦除旧“块”后， 才能写入。 （进一步学习， 可参见：\r\n> http： \/\/bbs.pceva.com.cn\/forum.php？ mod=viewthread＆action=printable＆tid=8277。 ）\r\n> 比如， 现在写入一个4KB的数据， 最坏的情况就是， 一个块里已经没有干净空间\r\n> 了， 但是恰好有一个“页”的无效数据可以擦除， 所以主控就把所有的数据读出来， 擦\r\n> 除块， 再加上这个4KB新数据写回去。 回顾整个过程， 其实只想写4KB的数据， 结果\r\n> 造成了整个块（512KB） 的写入操作。 同时带来了原本只需要简单地写4KB的操作变\r\n> 成了“闪存读取（512KB） -＞缓存改（4KB） -＞闪存擦除（512KB） -＞闪存写入\r\n> （512KB） ”， 这造成了延迟大大增加， 速度慢是自然的。 这就是所谓的“写入放\r\n> 大”（Write Amplification） 问题。\r\n\r\n### 合理使用ByteArrayOutputStream \r\n\r\n> 进行对象缓存时会用到ObjectOutputStream，在序列化磁盘时， 会把内存中的每\r\n> 个对象保存到磁盘， 在保存对象的时候， 每个数据成员会带来一次I\/O操作， 意味着多少个对象就带来多少次IO操作，同样也带来严重的性能问题。可以多套一层，在ObjectOutputStream上面再封装一个输出流ByteArrayOutputStream，先将对象序列化后的信息写到缓存区中， 然后再一次性地写到磁盘上 。\r\n\r\n\r\n\r\n### 解压文件优化\r\n\r\n> 如果ZIP文件已保存在磁盘中， 且解压ZIP中的所有文件， 建议用ZipFile， 效率较\r\n> ZipInputStream提升15％~27％。\r\n> 仅解压ZIP中间的某些文件， 建议用ZipFile。\r\n> 如果ZIP没有在磁盘上或者顺序解压一小部分文件， 又或ZIP文件目录遭到损坏，\r\n> 建议用ZipInputStream。 \r\n\r\n### 表优化\r\n\r\n> 首次安装的表为空时， 不要去做无谓的查询操作。\r\n> 对于覆盖安装， 在表已经存在的情况下， 可以使用INSERT OR REPLACE语\r\n> 句来完成插入。 \r\n\r\n\r\n\r\n### 数据库重复打开优化\r\n\r\n> 因为打开数据库比较耗时， 如app_plugin_download.db的两次耗时分别为80ms和\r\n> 120ms。 每次打开数据库， 同时会有一些I\/O操作。 getWriteableDatabase的注释也明确\r\n> 说明该方法比较耗时， 不能在主线程进行。 \r\n>\r\n> 看一下SQLiteDatabase的源码， getWriteableDatabase（） 方法的注释说明： 一旦\r\n> 打开数据库， 该连接就会被缓存， 以供下次使用， 只有当真正不需要时， 调用close关\r\n> 闭即可 。\r\n>\r\n> 数据库在打开后， 先不要关闭， 在应用程序退出时再关闭。 \r\n\r\n### AUTOINCREMENT 不要随便用\r\n\r\n- 问题\r\n\r\n> 一条插入语句耗时平均在\r\n> 60ms+， SQL语句为： INSERT INTO events（timestamp， content， status，\r\n> send_count） VALUES （1445916309639， test， 1， 100） ，\r\n> 可以看到这条插入语句非常简单， 仅仅是插入3个整形和一个简单的字符串。 而\r\n> 一般的插入操作最多也就十几ms。 \r\n\r\n- 解释\r\n\r\n> AUTOINCREMENT其实就是“自增长”， 这个关键字只会出现在INTEGER\r\n> PRIMARY KEY后面， 而INTEGER PRIMARY KEY就是“主键”， 下面先来了解一下主\r\n> 键。\r\n> SQLite表的每行都有一个行号， 行号用64位带有符号的整型数据表示。 SQLite支\r\n> 持使用默认的列名ROWID、 _ROWID_和OID来访问行号。 同时， 如果表里某一列指\r\n> 定为INTEGER PRIMARY KEY类型， 那么这一列和ROWID是等价的。 也就是说， 如\r\n> 果你指定某一列为主键， 访问该列其实就是访问行号。\r\n\r\n- 行号是如何生成的？\r\n\r\n  对于刚创建的表来说， 行号默认是从1开始的， 如果在插入数据时明确指定行\r\n  号， 则会将数据插入对应的行， 如果没有指定行号， 则SQLite会选择比当前已用行号\r\n  大1的行来进行插入。 如果当前已用行号已达到最大值， 数据库引擎会尝试寻找当前\r\n  表里面没有使用的行号， 如果没有找到可用的行号， 就会出现SQLITE_FULL错误。\r\n  小结： 如果你没有删除过数据， 并且没有指定最大值的行号， 行号选择算法可以\r\n  保证行号是递增且唯一的。 但是如果你有删除数据或者使用了最大行号， 之前删除的\r\n  行号可能被复用， 并不能保证插入数据的行号是严格递增的。\r\n\r\n- 主键加了AUTOINCREMENT， 会有什么变化？\r\n  上面提到， AUTOINCREMENT只能用来修饰主键， 主键在被“自增长”修饰之\r\n  后， 会略微有些区别。\r\n  （1） 数据库引擎选择的行号会比所有之前用过的行号都大， 即使数据被删除，\r\n  行号也不会被复用， 可以保证行号严格单调递增。\r\n  （2） 如果行号的最大值被用过， 那么在插入新数据时， 会报SQLITE_FULL错\r\n  误。\r\n\r\n- 小结：\r\n\r\n  AUTOINCREMENT的作用是保证主键是严格单调递增的。\r\n    AUTOINCREMENT实现原理\r\n    SQLite创建一个叫sqlite_sequence的内部表来记录该表使用的最大的行号。 如果指\r\n    定使用AUTOINCREMENT来创建表， 则sqlite_sequence也随之创建。 UPDATE、\r\n    INSERT和DELETE语句可能会修改sqlite_sequence的内容。 因为维护sqlite_sequence表\r\n    带来的额外开销将会导致INSERT的效率降低 。所以除非必要，平时大多情况下不需要使用AUTOINCREMENT。\r\n\r\n### Bitmap解码\r\n\r\n> 4.4之前的系统，decodeFile源码里面读磁盘用的是\r\n> BufferedInputStream， 并且Buffer大小为DECODE_BUFFER_SIZE = 16×1024， 这也就\r\n> 是为什么在4.3系统decode大小为12KB的图片， 只需要读一次磁盘就可以的原因 。\r\n>\r\n> 4.4之后的系统，decodeFile里面去掉了缓冲区\r\n>\r\n> 解码Bitmap不要使用decodeFile， 因为在Android 4.4以上系统效率不高。\r\n> 解码Bitmap使用decodeStream， 同时传入的文件流为BufferedInputStream。\r\n> decodeResource同样存在性能问题， 请用decodeResourceStream。 \r\n\r\n\r\n\r\n## 内存优化\r\n\r\n### 内部类持有外部类Activity引用\r\n\r\n> 内部类有个特殊成员`this$0`为外部类的引用。通过它可以访问外部类变量，\r\n>\r\n> 但是如果内部类泄漏，由于其持有外部类引用，同时就导致了外部类Activity泄漏，进而造成view泄漏。\r\n>\r\n> 解决方案为：在Activity关闭时，解除内部类和外部类的引用。\r\n>\r\n> 1.将内部类定义为static\r\n>\r\n> 2.用static的变量引用匿名内部类的实例或将匿名内部类的实例化操作放到外部类的静态方法中\r\n\r\n### WifiManager 造成的泄漏\r\n\r\n> 把getSystemService（Context.WIFI_SERVICE） ； 修改为以下代码：\r\n> getApplicationContext（） .getSystemService（Context.WIFI_SERVICE） ；\r\n> 同样的情况也发生在AudioManager等服务上， 比如要判断当前是耳机模式或者外\r\n> 放模式， 一样会产生这样的问题， 所以都应该使用\r\n> getApplicationContext（） .getSystemService来获取服务实例。 \r\n\r\n### 避免webview泄漏使用独立进程\r\n\r\n> 用独立进程来解决内存问题， 独立进程在Android框架下非常简单， 在官网App\r\n> manifest的＜activity＞介绍中， 讲解了有关android： process属性的设置， 一旦设置了\r\n> 这个属性， 这个Activity的启动就会被投射到一个你所命名的进程当中， 最后在\r\n> Activity的onDestory函数中， 退出进程， 这样即可基本上终结此类泄漏。 \r\n\r\n- 网络大牛反射解决内存泄漏问题\r\n\r\n> “反射”得到WebView的内核， 然后再通\r\n> 过“反射”从内核的xxx变量中得到窗口管理器回调配置， 最后把一个空的窗口管理者赋\r\n> 给它， 来替代原先的那个。 这样就打断了底层的引用联调， 成功地解决了WebView内\r\n> 核造成的上层Activity泄漏。 但重点是作者最后补充了一句： 这并不能适用于所有的\r\n> Android系统， 因为它们的WebView内核字段差异很大。\r\n> 推荐将“反射”作为一种“补丁”来解决系统问题， 并且鼓励使用。 但是将它用在内\r\n> 存问题的解决上， 笔者还是建议大家持谨慎态度， 因为这并不是解决内存问题的正确\r\n> 道路， 正确理解组件本身， 正确调用接口， 给出正确参数， 采用正确调用顺序， 这才\r\n> 是真正解决内存的根本问题所在 \r\n>\r\n>\r\n\r\n### Timer及时停止避免泄漏\r\n\r\n```kotlin\r\nif(timer !=null){\r\n    timer.cancle();\r\n    timer=null;\r\n}\r\n```\r\n\r\n\r\n\r\n### 延时器postDelay及时remove\r\n\r\n> 开发人员在调用postDelayed方法时， 塞入了延时回调内类Runable， 但在Activity销毁的时候， \r\n>\r\n> 并没有调用removeCallbacks移除掉这个内类， 以至于导致泄漏。\r\n> 注意： 延时器的泄漏特征在于其根部通常是一个以主线程为GC ROOT的\r\n> MessageQueue， 这也是它与定时器泄漏最显著的区别。 \r\n\r\n\r\n\r\n### Bitmap解码配置RGB_565\r\n\r\n> 对于没有给定BitmapFactory.Options参数而直接调用图片解码函数的情况，\r\n> Android系统会默认使用ARGB_8888。 通过官方文档， 可以知道RGB_565每个像素占\r\n> 用的内存只有ARGB_8888的一半（RGB_565每个像素使用2字节， ARGB_8888每个像\r\n> 素使用4字节）  。对于非高清(如列表展示)图来说使用RGB_565即可。\r\n\r\n\r\n\r\n>\r\n>\r\n> 缩略图， 用户感官上认为它就不应该是一张高清图片， 如果需要详细查看， 可以\r\n> 通过“点入”操作。 没有透明效果， 因为RGB_565不解码透明通道内容， 因此会造成透\r\n> 明效果丢失（但是同样依赖于透明通道的圆角图片效果， 倒可以使用RBG_565配合\r\n> BitmapShader实现） 。 \r\n\r\n\r\n\r\n### Bitmap大图获取使用inSampleSize \r\n\r\n\r\n\r\n### 图片资源放到适合的drawable目录\r\n\r\nAndroid在加载这些图片前， 会先一步得到当前设备的显示密度， 然后到相匹配的\r\ndrawable目录去寻找图片资源。 但是如果开发人员并没有按照官方推荐的方式， 每个\r\nres\/drawable目录下都放置图片的话， Android会按照当前设备显示密度就“近”获取图片\r\n资源， 然后将其所在的目录所代表的密度与当前设备密度相比， 以这个比例来缩放图\r\n片， 以得到一张“合适”的图片（有对应图片就不用缩放， 这也是上面官网说“好”性能\r\n的原因） 。\r\n比如， 一张备显图片只放置在mdpi目录， 而当前的设备显示器为480dpi的超超高\r\n密屏， 这时Android就会按照3倍大小缩放这张图片， 将它加载入内存。\r\n这样是非常危险的， 如果有一张800×480图片放置在ldpi目录， 展示在480dpi的超\r\n超高密屏上时， 会在内存中产生一张3200×1920的巨大图片。 \r\n\r\n> 抓不准该放到那个目录的图片， 就尽量问设计人员要高品质图片然后往高密度目\r\n> 录下放， 这样在低密屏上“放大倍数”是小于1的， 在保证画质的前提下， 内存也是可控\r\n> 的。\r\n> 拿不准的图片， 使用Drawable.createFromStream替换getResources（） .getDrawable\r\n> 来加载， 这样就可以绕过Android以上的这套默认适配法则 \r\n\r\n\r\n\r\n\r\n\r\n### 内存复用\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 网络优化\r\n\r\n\r\n\r\n### webview缓存的坑\r\n\r\nandroid的WebVeiw的缓存策略会在\/data\/data\/应用package下生成database与cache\r\n两个文件夹， database可以存放多个数据库文件， 数据库中保存的是请求的url 。\r\n\r\n> HTTP Request的Cache-Control可以\r\n> 是no-cache、 no-store、 max-age、 max-stale、 min-fresh、 no-transform、 only-if-cached以\r\n> 及cache-extension， HTTP Response的Cache-Control为public、 private、 no-cache、 no\u0002transform、 must-revalidate、 proxy-revalidate、 max-age、 s-m axage以及cache\u0002extension。 这些Cache策略进行部分说明如下。\r\n> public： 响应可以在任何缓存区缓存。\r\n> private： 对单个用户的整个或部分响应消息， 不能在共享缓存区缓存。\r\n> no-cache： 请求或者响应不使用缓存。\r\n> no-store： 如果在请求中使用， 则该请求和对应的响应都不使用缓存， 如果在响应\r\n> 中使用， 则该响应和其对应的请求都不使用cache。\r\n> max-age： 资源在客户端的最大生命周期。\r\n> max-stale： 客户端可以接收生存期大于当前时间的响应。 \r\n\r\n> 在完成了缓存请求资源后， 还需要在客户端程序发送HTTP请求时指定该请求的\r\n> 响应资源可以从缓存中获取， 否则， 即使缓存中有对应的响应资源， 客户端也不会使\r\n> 用， 会重新通过网络下载一遍， 这涉及客户端发送HTTP请求时的缓存模式， 客户端\r\n> 可以指定5种缓存模式， 分别如下。\r\n> LOAD_CACHE_ONLY： 不使用网络， 只读取本地缓存数据。\r\n> LOAD_DEFAULT： 根据Cache-Control决定是否从网络上取数据。\r\n> LOAD_CACHE_NORMAL： API level17中已经废弃， 从API level 11开始作用同\r\n> LOAD_DEFAULT模式。\r\n> LOAD_NO_CACHE： 不使用缓存， 只从网络获取数据。\r\n> LOAD_CACHE_ELSE_NETWORK： 只要本地有， 无论是否过期， 或者NO\u0002CACHE， 都使用缓存中的数据。 \r\n\r\n### 开启压缩\r\n\r\n> 对请求的可压缩数据开启压缩，以减少流量消耗和等待时间\r\n\r\n\r\n\r\n### 传送数据优化\r\n\r\n> 这里优化也包括服务端滑动窗口大小。\r\n>\r\n> 服务器的RcvBuffer决定着滑动窗口的大小， 因此可以增大RcvBuffer来增加滑动窗口的大小 \r\n\r\n\r\n\r\n## CPU优化\r\n\r\n在经典的性能问题中， 一般我们会说两种问题： 一种是I\/O密集型问题， 另外一种\r\n就是CPU密集型的问题。 I\/O的问题在前面的磁盘、 网络部分已经介绍过了， 剩下的就\r\n是CPU了。 CPU问题无非分为以下三类。\r\nCPU资源冗余使用\r\n关于这个问题， 可以是算法太糙， 明明可以遍历一次的却遍历两次， 主要出现在\r\n查找、 排序、 删除等环节； 也可以是没有cache， 明明解码过一次的图片还重复解码。\r\n还有， 明明使用int就足够， 偏偏要用long， 导致CPU的运算压力多出4倍。\r\nCPU资源争抢\r\n资源争抢也有几种经典情况。\r\n（1） 抢主线程的CPU资源。 这是最常见的问题， 关键是主线程起码在Android 6.0\r\n版之前， 没有renderthread的时候， 其繁忙程度就决定了是否会引发用户的卡顿问题。\r\n最经典的例子就是主线程的Handler优化。\r\n（2） 抢音视频的CPU资源。 跟主线程的情况不同， 音视频编解码本身就消耗了\r\n大量的CPU资源， 同时音视频编解码对于解码的速度是有硬要求的， 达不到就会有产\r\n生播放流畅度的问题， 试想下， 听歌的时候总卡， 是不是很难受。 所以最常见的一种\r\n情况就是CPU满负载， 除了在耗电上有非常恶劣的影响外， 还会让音视频没有足够的\r\n资源保持流畅播放。 怎么办？ 通过两点挪走压垮骆驼的稻草： 第一、 排除非核心业务\r\n的消耗， 如下面说的QQ音乐的案例， 还有贴耳检测的频率控制； 第二、 优化自身的\r\n性能消耗， 把CPU负载转化为GPU负载， 最经典的就是利用renderscript来处理视频中\r\n的影像信息。\r\n（3） 大家平等， 相互抢。 前面两点都有主次之分， 强弱之别， 但是如果是QQ相\r\n册， 我开了20个线程做图片解码， 那就是相互抢， 我们曾经就遇到过这样的问题， 效\r\n果就是导致图片的显示速度非常慢。 这简直就是三个和尚没水喝的典型案例。 因此按\r\n照核心数、 控制线程数还是很有道理的。\r\nCPU资源利用率低\r\nCPU就是速度与负载的博弈， 用得多会耗电、 会卡顿， 用得少也会有问题， 像启\r\n动、 界面切换、 音视频编解码这些场景， 为了保证其速度， 不好好利用CPU， 真对不\r\n起核心数的不断飙升。 而导致无法充分利用CPU的因素， 除了前面说的磁盘和网络I\/O\r\n外， 还有锁操作、 sleep等。 其中锁的优化， 一般在锁的范围上， 主要是尽可能地缩减\r\n范围 \r\n\r\n通过查看`“cat\/sys\/devices\/system\/cpu\/cpu0\/cpufreq\/scaling_cur_freq” `来判断CPU是否降频\r\n\r\n\r\n\r\n\r\n\r\n## 电量优化\r\n\r\n使用`adb shell dumpsys power`命令， 查看系统中存在的WakeLock信息 \r\n\r\n> 每台手机都会有power_profile.xml。 PowerProfile， 在手机厂家出ROM的时候， Android\r\n> 官方建议厂商通过下面介绍的PowerMonitor之类的工具来测试每个硬件模块的耗电情\r\n> 况， 并配置好power_profile.xml文件。 这里必须强调一下， PowerProfile不像某些瞎扯\r\n> 的网文所说， 改变它能改变耗电， 因为它仅仅是一个为了让Android系统能通过硬件调\r\n> 用频率和强度来计算耗电的配置而已。 虽然很多厂商提供的这个文件基本乱配， 但是\r\n> 我们从文件的内容还是可以知道Android官方认为耗电的硬件都有什么？ 如图5-1所\r\n> 示， 我们从文件中可以提取出几个考量耗电的硬件， 包括CPU、 Wi-Fi、 Radio（数据\r\n> 网络） 、 Sensor（感应器） 、 BlueTooth（蓝牙） 、 Screen（屏幕） 、 GPS， 还有其实\r\n> 不属于硬件模块的视频和音频的耗电。 \r\n\r\n\r\n\r\n### 避免无谓的wifiscan\r\n\r\n> 获取了几台手机的PowerProfile， 发现WIFISCAN设置在220mA左右， 而\r\n> SCREENFULL的设置也就是160~300mA， 可见Wi-Fi扫描是一个可以比拟屏幕耗电的\r\n> 过程， 因此在理论上用户黑屏状态下， 完全不应该进行Wi-Fi扫描。 \r\n\r\n### 避免无谓的RTC_WAKEU \r\n\r\n> （1）使用AlarmManager时一定要考虑到多种情况， 尤其是要充分考虑网络变\r\n> 动、 用户登录状态改变等场景。\r\n> （2） 如果有多个功能需要通过AlarmManager实现时， 最好能够将多个功能合并\r\n> 到一个AlarmManager的广播接收函数中实现（在函数中调用多个功能） 。 尤其是当这\r\n> 几个功能的唤醒周期、 异常处理逻辑比较相近时， 一定要放在一起实现， 后续维护也\r\n> 会更加方便。 \r\n\r\n### 避免无谓的动画效果\r\n\r\n> 对于动画效果比较炫的界面， 灭屏后CPU占用率仍然很高， 最可能的原因就是动\r\n> 画没有及时释放。\r\n> 监听灭屏以及亮屏的广播， 在灭屏的时候停止动画绘制； 亮屏的时\r\n> 候， 恢复动画的绘制 \r\n\r\n### 避免间接调用wakeLock没有及时释放\r\n\r\n> 对于使用Media框架音视频功能时，虽然在我们的代码中没有手动调用wakeLock，但是框架会间接调用。\r\n>\r\n> 所以在退入后台时，对于暂未使用的音视频功能需要手动释放资源。\r\n\r\n\r\n\r\n### 避免wakeLock计数的坑\r\n\r\n> 有时候调用了wakeLock.release()；方法并没有释放wakeLock。\r\n>\r\n> 这是因为WakeLock有一个函数setReferenceCounted， 用来设置WakeLock的计数机制， 官方默认为计数。 true为计数， false为不计数。 \r\n>\r\n> 所谓计数即每一个acquire必须对应一个release； 不计数则是无论\r\n> 有多少个acquire， 一个release就可以释放。 \r\n>\r\n> 虽然官方说默认是计数的， 但是有的第三方ROM做了修改， 使默认是不计数的（开发人员就是拿到了这种手机） 。  \r\n>\r\n> 所以对于计数的机器最终结局方案为：\r\n>\r\n> 获取wakeLock后设置为不计数：wakeLock.setReferenceCounted(false);\r\n>\r\n>"
  },
  {
    "title" : "关于反射入门",
    "created_time" : "2019-01-03 04:00:44",
    "body" : "### 反射相关类\r\n\r\n在Java中一些情况下我们需要访问某些类的对象的属性、方法等，但是没有权限这么做，这时就需要反射了。\r\n\r\n和反射相关的类有如下一些：\r\n\r\njava.lang.Class一一类的创建：\r\njava.lang.reflect. Constructor一一反射类中构造方法；\r\njava.lang.re flect.Field一一反射属性；\r\njava.lang.reflect.Method一一反射方法；\r\njava.lang.reflect.Modifier 访问修饰符的信息。 \r\n\r\n### 反射常用方法\r\n\r\n示例代码：\r\n\r\n```java\r\npublic class People {\r\n    private static final String DATA = \"2019\";\r\n    String name;\r\n    int age;\r\n\r\n\r\n    public static void play() {\r\n        System.out.println(\"play\");\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public int getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(int age) {\r\n        this.age = age;\r\n    }\r\n\r\n    public People() {\r\n    }\r\n\r\n    public People(String name, int age) {\r\n        this.name = name;\r\n        this.age = age;\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n#### 获取Class\r\n\r\n- Class.forName\r\n- People.class\r\n- people.getClass\r\n\r\n\r\n\r\n#### 调用构造方法创建对象\r\n\r\nclass只能调用无参构造，\r\n\r\n```java\r\n Class clzz = Class.forName(\"People\");\r\n Object object = clzz.newInstance();\r\n People people = (People) object;\r\n\r\n```\r\n\r\n如果要调用有参构造需要获取Constructor：\r\n\r\n```java\r\n Class clzz = Class.forName(\"People\");\r\n Class<?>[] types = {String.class, int.class};\r\n Constructor constructor = clzz.getDeclaredConstructor(types);\r\n Object object = constructor.newInstance(\"jenson\", 30);\r\n```\r\n\r\n\r\n\r\n#### 调用方法\r\n\r\n- 调用实例方法\r\n\r\n\r\n\r\n  ```java\r\n  Class clzz = Class.forName(\"People\");\r\n  Object object = clzz.newInstance();\r\n  Method method = clzz.getDeclaredMethod(\"setName\", String.class);\r\n  method.setAccessible(true);\r\n  Object[] arg = {\"jenson\"};\r\n  method.invoke(object, arg);\r\n  ```\r\n\r\n  调用实例方法时，在invoke的第一个参数一定是类的实例，第二个参数是正常调用方法时所传递的参数\r\n\r\n- 调用静态方法\r\n\r\n\r\n\r\n  ```java\r\n  Class clzz = Class.forName(\"People\");\r\n  Method method = clzz.getDeclaredMethod(\"play\");\r\n  method.setAccessible(true);\r\n  method.invoke(null);\r\n  ```\r\n\r\n  调用静态方法时，invoke参数的对象实例为null即可，静态方法隶属于类，而不是某个对象\r\n\r\n#### 设置\/获取属性\r\n\r\n- 设置属性\r\n\r\n\r\n\r\n  ```java\r\n  Class clzz = Class.forName(\"People\");\r\n  Object object = clzz.newInstance();\r\n  Field field = clzz.getDeclaredField(\"name\");\r\n  field.setAccessible(true);\r\n  field.set(object, \"Jenson\");\r\n  ```\r\n\r\n  设置对象属性时，`field.set`方法首个参数一定是要修改对象，第二个参数为属性值\r\n\r\n- 获取属性\r\n\r\n\r\n\r\n  ```java\r\n  Class clzz = Class.forName(\"People\");\r\n  Object object = clzz.newInstance();\r\n  Field field = clzz.getDeclaredField(\"name\");\r\n  field.setAccessible(true);\r\n  field.set(object, \"史密斯\");\r\n  field.get(object)\r\n  ```\r\n\r\n  获取对象属性时，`field.get`方法参数是要从哪个对象获取属性值。\r\n\r\n### JOOR\r\n\r\n#### 介绍\r\n\r\nGit地址：https:\/\/github.com\/jOOQ\/jOOR\r\n\r\n一般反射的使用无非就是调用构造函数创建对象，设置\/获取属性值，调用实例方法、静态方法。\r\n\r\n但是使用上述的方法实现功能时，感觉还是让人凌乱，有没有一种封装好的框架可以让反射变得简单易用？\r\n\r\nJOOR就是这么一个框架，其核心类只有`Reflect.java`和`ReflectException.java`两个类\r\n\r\n由于只有2个文件，所以一般使用时直接把这两个文件拖到项目中使用即可，无需添加项目依赖。\r\n\r\n#### 使用\r\n\r\n日常使用主要接触`Reflect.java`类，其中主要方法有：\r\n\r\n- on 包裹一个类或实例，和上面的“获取class”一节对应\r\n- create调用构造函数创建对象\r\n- call 方法调用包括静态方法\r\n- set 设置属性值\r\n- get 获取属性值\r\n\r\n下面看看如何使用JOOR重写上面示例：\r\n\r\n```java\r\n\/\/调用无参构造\r\nReflect reflect = Reflect.on(People.class).create()\r\n\/\/设置属性值\r\nreflect.set(\"name\", \"jenson\").set(\"age\", 30);\r\nPeople people = reflect.get();\r\nSystem.out.println(people.getName() + \"####\" + people.getAge());\/\/jenson####30\r\n\/\/获取属性值\r\nreflect.get(\"name\")；\r\n\/\/调用实例方法\r\nreflect.call(\"setName\", \"Jenson\").call(\"setAge\", 30);\r\n\/\/调用静态方法\r\nReflect.on(People.class).call(\"play\");\r\n\r\nObject[] arg = {\"jenson\", 30};\r\n\/\/调用有参构造\r\nReflect reflect = Reflect.on(People.class).create(arg);\r\n```\r\n\r\n#### 问题\r\n\r\n即便如此好用的JOOR也不是完美的，其创建之初只是针对Java，在Android开发中使用时，遇到Final字段时会出现异常。\r\n\r\n看看`Reflect.java`设置属性值源码:\r\n\r\n```java\r\n public Reflect set(String name, Object value) throws ReflectException {\r\n        try {\r\n            Field field = field0(name);\r\n\r\n            if ((field.getModifiers() & Modifier.FINAL) == Modifier.FINAL) {\r\n                try {\r\n                    Field modifiersField = Field.class.getDeclaredField(\"modifiers\");\r\n                    modifiersField.setAccessible(true);\r\n                    modifiersField.setInt(field, field.getModifiers() & ~Modifier.FINAL);\r\n                }\r\n\r\n                \/\/ [#48] E.g. Android doesn't have this field\r\n                catch (NoSuchFieldException ignore) {}\r\n            }\r\n\r\n            field.set(object, unwrap(value));\r\n            return this;\r\n        }\r\n        catch (Exception e) {\r\n            throw new ReflectException(e);\r\n        }\r\n    }\r\n```\r\n\r\n从源码可以看出，如果set的是final字段则会执行`Field.class.getDeclaredField(\"modifiers\")`\r\n\r\n这在Java项目中是没有问题，因为Field类中有该属性存在：`private int  modifiers;`\r\n\r\n如果在Android项目中，Field类没有该属性：\r\n\r\n```java\r\n    public int getModifiers() {\r\n        return accessFlags & 0xffff;  \/\/ mask out bits not used by Java\r\n    }\r\n```\r\n\r\n在Android中使用了`accessFlags`。\r\n\r\n经过测试，要解决这个问题，在Android项目中，注释掉判断`final`那段代码就可以了：\r\n\r\n```java\r\n    public Reflect set(String name, Object value) throws ReflectException {\r\n        try {\r\n            Field field = field0(name);\r\n\r\n\/\/            if ((field.getModifiers() & Modifier.FINAL) == Modifier.FINAL) {\r\n\/\/                try {\r\n\/\/                    Field modifiersField = Field.class.getDeclaredField(\"modifiers\");\r\n\/\/                    modifiersField.setAccessible(true);\r\n\/\/                    modifiersField.setInt(field, field.getModifiers() & ~Modifier.FINAL);\r\n\/\/                }\r\n\/\/\r\n\/\/                \/\/ [#48] E.g. Android doesn't have this field\r\n\/\/                catch (NoSuchFieldException ignore) {}\r\n\/\/            }\r\n\r\n            field.set(object, unwrap(value));\r\n            return this;\r\n        }\r\n        catch (Exception e) {\r\n            throw new ReflectException(e);\r\n        }\r\n    }\r\n```"
  },
  {
    "title" : "进程保活之一个像素",
    "created_time" : "2019-01-14 15:29:34",
    "body" : "### 前言\r\n\r\n代码使用Kotlin编写\r\n\r\n做进程保活时应该从2个大的方面考虑：\r\n\r\n- 提升进程优先级 使其不容易被杀掉\r\n- 在进程被杀掉后想尽方法使其重启\r\n\r\n我们这里要采用的一像素保活属于提升进程优先级方法。\r\n\r\n这里说明下，进程保活，我们保活的进程要是轻量级进程，譬如接收服务端推送的push进程，一方面保证即时通讯提高用户体验，另一方面push进程一般不会占用大量内存，更容易存活。\r\n\r\n一般没必要对主进程做保活。\r\n\r\n既然要对一个push进程做保活，所以一像素Activity也要在push进程。\r\n\r\n### 创建push进程Service和Activity\r\n\r\n#### 创建push进程Service\r\n\r\n清单中配置如下：\r\n\r\n```xml\r\n <activity\r\n                android:process=\":push\"\r\n                android:name=\".OnePxLiveActivity\"\r\n                android:theme=\"@style\/OnePX\">\r\n        <\/activity>\r\n\r\n        <service\r\n                android:process=\":push\"\r\n                android:name=\".MsgPushService\"\r\n                android:enabled=\"true\"\r\n                android:exported=\"true\">\r\n        <\/service>\r\n```\r\n\r\n#### 创建一像素Activity\r\n\r\n```kotlin\r\nclass OnePxLiveActivity : Activity() {\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        window.setGravity(Gravity.LEFT or Gravity.TOP)\r\n        val params = window.attributes\r\n        params.width = 1\r\n        params.height = 1\r\n        window.attributes = params\r\n        Util.setOnePxActivity(this)\r\n        logD(\"一个像素页面onCreate\")\r\n    }\r\n\r\n    override fun onDestroy() {\r\n        super.onDestroy()\r\n        logD(\"一个像素页面onDestroy\")\r\n    }\r\n\r\n    override fun onResume() {\r\n        super.onResume()\r\n        logD(\"一个像素页面onResume\")\r\n\r\n    }\r\n\r\n    override fun onPause() {\r\n        super.onPause()\r\n        logD(\"一个像素页面onPause\")\r\n\r\n    }\r\n\r\n    override fun onStop() {\r\n        super.onStop()\r\n        logD(\"一个像素页面onStop\")\r\n\r\n    }\r\n}\r\n```\r\n\r\n在Style.xml中添加主题设置为：\r\n\r\n```xml\r\n    <style name=\"OnePX\">\r\n        <item name=\"android:windowBackground\">@android:color\/transparent<\/item>\r\n        <item name=\"android:windowFrame\">@null<\/item>\r\n        <item name=\"android:windowNoTitle\">true<\/item>\r\n        <item name=\"android:windowIsFloating\">true<\/item>\r\n        <item name=\"android:backgroundDimEnabled\">false<\/item>\r\n        <item name=\"android:windowContentOverlay\">@null<\/item>\r\n        <item name=\"android:windowIsTranslucent\">true<\/item>\r\n        <item name=\"android:windowAnimationStyle\">@null<\/item>\r\n        <item name=\"android:windowDisablePreview\">true<\/item>\r\n    <\/style>\r\n```\r\n\r\n#### 创建Service\r\n\r\n```kotlin\r\nclass MsgPushService : Service() {\r\n    override fun onBind(intent: Intent): IBinder? {\r\n        return null\r\n    }\r\n\r\n    override fun onDestroy() {\r\n        super.onDestroy()\r\n    }\r\n\r\n    override fun onCreate() {\r\n        super.onCreate()\r\n        logD(\"MsgPushService--onCreate\")\r\n    \r\n    }\r\n}\r\n```\r\n\r\npush进程的Activity和Service都已经创建完成，\r\n\r\n下面应该分析什么情况下开启、什么情况下关闭一像素Activity\r\n\r\n这里我们监听广播：\r\n\r\n当屏幕关屏时开启一像素Activity，\r\n\r\n当亮屏时关闭一像素Activity。\r\n\r\n这里一像素Activity必须要关闭的，否则解锁后，由于该Activity的在栈顶，但是该Activity又是透明，导致用户能够看到下层其他App(或桌面)但是却无法操作。\r\n\r\n使用动态注册广播权限更高，所以把广播注册写在Service中。\r\n\r\n### Service中添加屏幕广播监听\r\n\r\n#### 添加广播权限\r\n\r\n```xml\r\n    <uses-permission android:name=\"android.permission.RECEIVE_USER_PRESENT\"\/>\r\n```\r\n\r\n#### Service中注册\/反注册广播\r\n\r\n```kotlin\r\nclass MsgPushService : Service() {\r\n    private val receiver = ScreenStateReceiver()\r\n\r\n    override fun onBind(intent: Intent): IBinder? {\r\n        return null\r\n    }\r\n\r\n    override fun onDestroy() {\r\n        super.onDestroy()\r\n        unregisterReceiver(receiver)\r\n    }\r\n\r\n    override fun onCreate() {\r\n        super.onCreate()\r\n        logD(\"MsgPushService--onCreate\")\r\n        val intentFilter = IntentFilter()\r\n        intentFilter.addAction(Intent.ACTION_SCREEN_OFF)\r\n        intentFilter.addAction(Intent.ACTION_SCREEN_ON)\r\n        registerReceiver(receiver, intentFilter)\r\n    }\r\n\r\n}\r\n\r\nprivate class ScreenStateReceiver() : BroadcastReceiver() {\r\n\r\n    override fun onReceive(context: Context?, intent: Intent?) {\r\n        if (intent?.action == Intent.ACTION_SCREEN_ON) {\r\n            \/\/亮屏\r\n        } else if (intent?.action == Intent.ACTION_SCREEN_OFF) {\r\n            \/\/关屏\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n监听广播已经添加完成，接下来需要在接收广播地方根据是亮屏还是关屏做出相应的操作\r\n\r\n### 添加广播事件处理\r\n\r\n#### 抽象关屏、亮屏方法到接口\r\n\r\n```kotlin\r\ninterface IScreenStateListener {\r\n    \/**\r\n     * 开屏\r\n     *\/\r\n    fun screenOn()\r\n\r\n    \/**\r\n     * 锁屏\r\n     *\/\r\n    fun screenOff()\r\n\r\n}\r\n```\r\n\r\n#### 广播事件中添加接口回调\r\n\r\n修改`ScreenStateReceiver`构造方法添加参数：`IScreenStateListener`：\r\n\r\n```kotlin\r\nprivate class ScreenStateReceiver(var listener: IScreenStateListener) : BroadcastReceiver() {\r\n\r\n    override fun onReceive(context: Context?, intent: Intent?) {\r\n        if (intent?.action == Intent.ACTION_SCREEN_ON) {\r\n            listener.screenOn()\r\n        } else if (intent?.action == Intent.ACTION_SCREEN_OFF) {\r\n            listener.screenOff()\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\n所以在Service变量处创建广播对象时也要修改：\r\n\r\n```kotlin\r\n private val receiver = ScreenStateReceiver(object : IScreenStateListener {\r\n        override fun screenOn() {\r\n            \/\/开屏关闭一像素页面\r\n        }\r\n\r\n        override fun screenOff() {\r\n            \/\/锁屏启动一像素页面\r\n        }\r\n    })\r\n```\r\n\r\n现在还差最后一步就是封装启动和关闭一像素Activity方法：\r\n\r\n#### 一像素Activity封装\r\n\r\n```kotlin\r\nclass Util {\r\n\r\n    companion object {\r\n        private lateinit var actRef: SoftReference<Activity>\r\n\r\n        fun setOnePxActivity(activity: Activity) {\r\n            actRef = SoftReference(activity)\r\n        }\r\n\r\n        fun startOnePxActivity(context: Context) {\r\n            val intent = Intent(context, OnePxLiveActivity::class.java)\r\n            intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK\r\n            context.startActivity(intent)\r\n        }\r\n\r\n        fun finishOnePxActivity() {\r\n            actRef?.let {\r\n                actRef.get()?.let { activity -> activity.finish() }\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\n其中方法`setOnePxActivity`是在一像素Activity启动后调用设置的。\r\n\r\n方法封装完成后，在`IScreenStateListener`回调中修改为：\r\n\r\n```kotlin\r\n private val receiver = ScreenStateReceiver(object : IScreenStateListener {\r\n        override fun screenOn() {\r\n            \/\/开屏关闭一像素页面\r\n            Util.finishOnePxActivity()\r\n        }\r\n\r\n        override fun screenOff() {\r\n            \/\/锁屏启动一像素页面\r\n            Util.startOnePxActivity(applicationContext)\r\n        }\r\n    })\r\n\r\n```\r\n\r\n\r\n\r\n现在整体流程已经全部完成，\r\n\r\n测试的话只要点击按钮启动该Service即可，然后关屏、亮屏进行操作看看打印是否成功：\r\n\r\n![Log打印](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/%E4%B8%80%E5%83%8F%E7%B4%A0%E4%BF%9D%E6%B4%BB%E6%89%93%E5%8D%B0.png)\r\n其中关屏时Avtivity执行到onStop，当亮屏时执行onDestory。"
  },
  {
    "title" : "关于代理模式介绍",
    "created_time" : "2019-01-15 10:46:20",
    "body" : "### 前言\r\n\r\n**代码实现为Kotlin**\r\n\r\n代理模式就是控制对某个对象的访问。\r\n\r\n通过代理对象间接访问被代理的对象，从而在真正调用被代理对象前做一些其他操作。\r\n\r\n所以代理对象和被代理对象实现同一接口，且代理对象持有被代理对象的引用。\r\n\r\n代理模式分为静态代理和动态代理。\r\n\r\n### 静态代理\r\n\r\n每为一个类型添加静态代理，都要创建一个代理类型，\r\n\r\n优点是通俗易懂，但缺点更明显：造成代理类过多，冗余\r\n\r\n示例：\r\n\r\n定义一个开会接口:\r\n\r\n```kotlin\r\ninterface IMeeting {\r\n    fun meet()\r\n}\r\n```\r\n\r\n老板和秘书分别实现接口:\r\n\r\n```kotlin\r\n\/**\r\n * 老板\r\n *\/\r\nclass Manager : IMeeting {\r\n    override fun meet() {\r\n        Log.e(\"IMeeting\", \"老板开会\")\r\n    }\r\n\r\n}\r\n\r\n\/**\r\n * 秘书\r\n *\/\r\nclass SecretaryProxy(private var manager: Manager) : IMeeting {\r\n    override fun meet() {\r\n        Log.e(\"IMeeting\", \"代理调用\")\r\n        manager.meet()\r\n    }\r\n}\r\n```\r\n\r\n代理处理：\r\n\r\n```kotlin\r\nclass MainActivity : Activity() {\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_main)\r\n        val manager = Manager()\r\n        \/\/静态代理\r\n        val secretaryProxy = SecretaryProxy(manager)\r\n        secretaryProxy.meet()\r\n    }\r\n}\r\n```\r\n\r\n很容易发现，如果此时创建一个Student类，那么要代理就要再创建一个学生代理类StudentProxy，代理方法不同，但逻辑类似。为了避免代码冗余，Java提供了动态代理。\r\n\r\n\r\n\r\n### 动态代理\r\n\r\n动态代理使用Proxy类的`newProxyInstance `方法，涉及三个参数：\r\n\r\n```java\r\n    public static Object newProxyInstance(ClassLoader loader,\r\n                                          Class<?>[] interfaces,\r\n                                          InvocationHandler h)\r\n```\r\n\r\n`loader`为被代理对象的类加载器\r\n\r\n`interfaces`为被代理对象的类继承的接口，数组形式\r\n\r\n`h`为动态代理核心，通常要继承`InvocationHandler`重写`invoke`方法：\r\n\r\n```kotlin\r\nclass ProxyHandler(var target: Any) : InvocationHandler {\r\n    override fun invoke(proxy: Any?, method: Method?, args: Array<out Any>?): Any? {\r\n        return null\r\n    }\r\n}\r\n```\r\n\r\n其中构造函数中的`target`为被代理的对象。\r\n\r\n`invoke`函数中`proxy`为创建的代理对象，\r\n\r\n`invoke`函数中`method`为要执行的函数\r\n\r\n`invoke`函数中`args`为执行函数所需的参数\r\n\r\n动态代理实现为：\r\n\r\n```kotlin\r\nclass ProxyHandler(var target: Any) : InvocationHandler {\r\n\r\n    override fun invoke(proxy: Any?, method: Method?, args: Array<out Any>?): Any? {\r\n        Log.e(\"IMeeting\", \"代理开始\")\r\n        Log.e(\"IMeeting\", \"代理方法：${method?.name}\")\r\n        val result = method?.invoke(target)\r\n        Log.e(\"IMeeting\", \"代理结束\")\r\n        return result\r\n    }\r\n}\r\n```\r\n\r\n```kotlin\r\nclass MainActivity : Activity() {\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_main)\r\n        val manager = Manager()\r\n        \/\/动态代理\r\n        val proxy = Proxy.newProxyInstance(\r\n            manager.javaClass.classLoader,\r\n            manager.javaClass.interfaces,\r\n            ProxyHandler(manager)\r\n        ) as IMeeting\r\n        proxy.meet()\r\n    }\r\n}\r\n```"
  },
  {
    "title" : "Kotlin动态代理method.invoke异常",
    "created_time" : "2019-01-16 09:26:02",
    "body" : "### 前言\r\n\r\n在使用Kotlin做动态代理时候，重写`InvocationHandler`类的`invoke`方法时，\r\n\r\n执行`method.invoke`过程中一直出现异常。\r\n\r\n异常日志可能有多种情况：\r\n\r\n如果没有参数时，信息如下：\r\n\r\n**java.lang.IllegalArgumentException: wrong number of arguments\r\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)**\r\n\r\n有参数时，信息根据参数类型可能有不同，如下：\r\n\r\n**argument 1 has type android.os.IBinder, got java.lang.Object[]**\r\n\r\n意思就是参数没有对上。\r\n\r\n\r\n\r\n### 解决\r\n\r\n`invoke`方法中第二个参数为可变长参，在Java中使用***...***表示\r\n\r\n> Kotlin 的可变参数与 Java 类似，但语法略有不同：\r\n> Kotlin 在该类型之后不会再使用 三个点，而是在参数上使用 `vararg` 修饰符 。\r\n> Kotlin 和 Java 之间的另 一 个区别是，当需要传递的参数己经包装在数组中时，\r\n> 调用该函数的语法 ，在 Java 中，可以按原样传递数组，而 Kotlin 则要求你显式地解\r\n> 包数组，以便每个数组元素在函数中能作为单独的参数来调用 。 \r\n\r\n从技术的角度来讲，这个功能被称为展开运算符，而使用的时候，不过是在对应的参数前面放一个`*`:\r\n\r\n```kotlin\r\nfun main(args: Array<String〉）｛\r\n\tval list = listOf(\"args:\",*args)\r\n\tprintln(list)\r\n}\r\n```\r\n\r\n\r\n\r\n当然使用`*`解包的前提是`args`不为空，\r\n\r\n而在动态代理中代码如下：\r\n\r\n```kotlin\r\nclass ProxyHandler(var target: Any) : InvocationHandler {\r\n\r\n    override fun invoke(proxy: Any?, method: Method?, args: Array<out Any>?): Any? {\r\n        Log.e(\"invoke\", \"代理开始\")\r\n        Log.e(\"invoke\", \"代理方法：${method?.name}\")\r\n        var result = method?.invoke(target, args)\r\n        Log.e(\"invoke\", \"代理结束\")\r\n        return result\r\n    }\r\n}\r\n```\r\n\r\n可见动态代理中`args`是Nullable的，所以不能直接解包，\r\n\r\n这里引入了Elvis运算符`?:`\r\n\r\n如果运算符左侧为null则返回右侧，否则返回左侧，\r\n\r\n修改后的动态代理代码如下：\r\n\r\n```kotlin\r\nclass ProxyHandler(var target: Any) : InvocationHandler {\r\n\r\n    override fun invoke(proxy: Any?, method: Method?, args: Array<out Any>?): Any? {\r\n        Log.e(\"invoke\", \"代理开始\")\r\n        Log.e(\"invoke\", \"代理方法：${method?.name}\")\r\n        var result = method?.invoke(target, *(args ?: emptyArray()))\r\n        Log.e(\"invoke\", \"代理结束\")\r\n        return result\r\n    }\r\n}\r\n```"
  },
  {
    "title" : "Kotlin协程入门",
    "created_time" : "2019-03-14 11:49:41",
    "body" : "### 协程介绍\r\n\r\n#### 协程支持添加\r\n\r\nKotlin基础库中没有包含协程库，所以使用协程库需要单独添加。\r\n\r\nAndroid项目添加协程支持：\r\n\r\n- 项目的build.gradle文件中添加协程版本\r\n\r\n  ```groovy\r\n  buildscript {\r\n      ext.kotlin_version = '1.3.20'\r\n      ext.anko_version = '0.10.8'\r\n      ext.coroutine_version = '1.1.1'\r\n      repositories {\r\n          jcenter()\r\n          google()\r\n      }\r\n      dependencies {\r\n          classpath 'com.android.tools.build:gradle:3.1.3'\r\n          classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\"\r\n      }\r\n  }\r\n  ```\r\n\r\n  \r\n\r\n- 在模块中添加协程库依赖\r\n\r\n  ```groovy\r\n  dependencies {\r\n      implementation fileTree(dir: 'libs', include: ['*.jar'])\r\n      implementation \"org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version\"\r\n      implementation \"org.jetbrains.kotlinx:kotlinx-coroutines-core:$coroutine_version\"\r\n      implementation \"org.jetbrains.kotlinx:kotlinx-coroutines-android:$coroutine_version\"\r\n  }\r\n  ```\r\n\r\n  \r\n\r\n#### 协程启动方式\r\n\r\n##### runBlocking()\r\n\r\n一般用在main方法和单元测试。阻塞线程直到协程运行完毕。\r\n\r\n```kotlin\r\nfun main() = runBlocking {\r\n}\r\n```\r\n\r\n##### launch()\r\n\r\n只返回Job对象，无法自定义返回对象。\r\n\r\n```kotlin\r\n    val job = GlobalScope.launch {\r\n    }\r\n```\r\n\r\n##### async()\r\n\r\n返回Deferred<T>泛型对象，允许自定义返回对象，适用于带返回结果的请求。\r\n\r\n```kotlin\r\n val deff = GlobalScope.async<People> {\r\n        val p = People()\r\n        return@async p\r\n    }\r\n```\r\n\r\n\r\n\r\n### 协程生命周期\r\n\r\n协程和线程一样是有生命周期的，\r\n\r\n协程这里介绍6种生命周期及状态(《Learning Concurrency in Kotlin》一书中说有5中，而《mastering-high-performance-kotlin》和《hands-design-patterns-kotlin》两本书中介绍说有6种，多出`Completing `：Waiting to finish executing children before completing )\r\n\r\nDeferred继承于Job，所以其生命周期是一致的。\r\n\r\n#### NEW\r\n\r\n创建job对象但没有执行。\r\n\r\n正常情况使用launch创建job后自动运行了，\r\n要让其不自动运行可使用 ：` CoroutineStart.LAZY`，\r\n\r\n##### 如何运行延迟的Job：\r\n\r\n通过 `start()`或`join()`方法执行job：\r\n\r\n```kotlin\r\nval job = GlobalScope.launch(start = CoroutineStart.LAZY) {\r\n}\r\njob.start()\r\n\/\/job.join()\r\n```\r\n\r\n#### Active\r\n\r\n调用`start()`方法后处于Active状态。\r\n\r\n#### Cancelling\r\n\r\n调用cancel()方法后，但是没有取消完成，取消是需要时间的，该状态介于Active和Cancelled，可以认为这是一个瞬时状态。\r\n\r\n##### 如何取消Job：\r\n\r\n| job.cancel()                              |                                                        |\r\n| ----------------------------------------- | ------------------------------------------------------ |\r\n| job.cancel(cause = Exception(\"Timeout!\")) |                                                        |\r\n| job.cancelAndJoin()                       | 像名字说的那样，取消运行并且阻塞当前协程直到完成取消。 |\r\n\r\n#### Cancelled\r\n\r\n完成取消，成功取消的Job也可以看成是Completed\r\n\r\n#### Completeing\r\n\r\nDeferred获得结果完成计算前。\r\n\r\n#### Completed\r\n\r\n执行完成。\r\n\r\n任何已停止的job都可以看成是completed。\r\n它适用于任何正常结束、取消或异常结束情况。\r\n由此可见，cancelled 状态可以看成是completed的一个子状态。\r\n\r\n### 挂起函数\r\n\r\n`suspend`修饰的方法为挂起函数\r\n\r\n挂起函数只能被其他挂起函数调用，不能直接在普通函数中调用，否则编译不过。\r\n\r\n挂起函数能直接调用其他挂起函数 比如delay()，不需要再包裹内部协程，使代码整洁、易读。\r\n\r\n### 协程上下文\r\n\r\n就像Android运行期间有Context上下文，协程运行期间也有上下文叫：`CoroutineContext`。\r\n\r\n这是一个接口，有很多实现类。比如CoroutineDispatcher、CoroutineExceptionHandler。\r\n\r\n#### Dispatcher\r\n\r\n协程可以看成是轻量级线程。一个线程可以运行多个协程，这就需要调度器来负责调度控制。\r\n\r\n| 常量使用               | 描述                 |\r\n| ---------------------- | -------------------- |\r\n| Dispatcher.Default     | 默认调度器           |\r\n| Dispatchers.Main       | 适用于Android UI线程 |\r\n| Dispatchers.Unconfined |                      |\r\n| Dispatchers.IO         |                      |\r\n\r\n\r\n\r\n##### CommonPool\r\n\r\ncommonPool是一个由FrameWork自动创建的计算密集型线程池。它的最大数量是cpu核心数减一。\r\n现在，它作为默认的调度器使用。\r\n\r\n要使用默认调度器，只要不设置新的调度器就可以。\r\n\r\n##### Unconfined\r\n\r\n这个调度器会使协程运行在当前线程，除非到达了第一个挂起点。\r\n挂起后，会在挂起时调用的挂起计算所使用的线程中恢复协程。\r\n\r\n##### Single thread context\r\n\r\n这个调度器确保在任何时候，协程都运行在一个指定线程。\r\n可使用`newSingleThreadContext(name=\"xxx\")`创建该调度器：\r\n\r\n```kotlin\r\nprivate val single = newSingleThreadContext(\"single\")\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_main)\r\n        GlobalScope.launch(context = single) {\r\n        }\r\n    }\r\n```\r\n\r\n\r\n\r\n##### Thread pool\r\n\r\n这个调度器持有一个线程池，开始和恢复的协程都会运行在线程池中可用的线程。\r\n运行时环境负责决定哪个线程可用，也决定如何分配负载，作为程序员的我们不需要考虑其他工作。\r\n\r\n```kotlin\r\nprivate val dispatcher = newFixedThreadPoolContext(4, \"myPool\")\r\n\r\n   override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_main)\r\n        GlobalScope.launch(context = dispatcher) {\r\n        }\r\n    }\r\n```\r\n\r\n\r\n\r\n#### 异常处理\r\n\r\n有代码的地方就有异常，Kotlin协程出现异常时并不会导致其所在线程整体崩溃，其影响范围只是出现异常所在协程本身。\r\n\r\n关于异常Job和Deferred有不同的处理方式：`Job直接抛出异常，而Deferred则吞噬异常`，由于异常吞噬所以如果没有良好的异常处理手段，异常信息不会抛出到log造成难以调试的结果。\r\n\r\n##### Deferred吞噬异常\r\n\r\nJob：\r\n\r\n```kotlin\r\n val job = GlobalScope.launch {\r\n        TODO()\r\n    }\r\n```\r\n\r\n直接抛出异常：\r\n\r\nException in thread \"DefaultDispatcher-worker-1\" kotlin.NotImplementedError: An operation is not implemented.\r\n\r\nDeferred：\r\n\r\n```kotlin\r\n    val deff = GlobalScope.async<People> {\r\n        TODO()\r\n    }\r\n```\r\n\r\n则执行成功：Process finished with exit code 0，其异常信息被封装在返回值中而不会被捕获并打印出来。\r\n\r\n##### Deferred抛出异常\r\n\r\n通过Deferred的 await() 方法可以使其直接抛出异常：\r\n\r\n```Kotlin\r\nval deff = GlobalScope.async<People> {\r\n        TODO()\r\n    }\r\n deff.await()\r\n```\r\n\r\n##### getCancellationException()获取异常信息\r\n\r\n取消一个job后，可以通过getCancellationException()方法获取cancel信息。\r\n这个函数会返回CancellationException，如果设置了的话，通过它可以获取造成cancel异常的原因。\r\n\r\n代码如下：\r\n\r\n```kotlin\r\njob.cancel(cause = Exception(\"Tired of waiting\"))\/\/设置cancel的异常信息\r\nval cancellation = job.getCancellationException()\r\ncancellation.cause \/\/ Exception(\"Tired of waiting\")\r\n```\r\n\r\n##### invokeOnCompletion()获取异常信息\r\n\r\n通过调用job的invokeOnCompletion()方法，获取异常信息。\r\n\r\n```kotlin\r\n GlobalScope.launch {\r\n        TODO(\"没有实现\")\r\n    }.invokeOnCompletion { cause: Throwable? -> cause?.let { println(cause.message) } }\r\n```\r\n\r\n\r\n\r\n##### 设置CoroutineExceptionHandler\r\n\r\n协程上下文另一个重要用途是定义未捕获异常行为。可以通过CoroutineExceptionHandler创建这种上下文。\r\n\r\n```kotlin\r\nval exceptionHandler = CoroutineExceptionHandler { _: CoroutineContext, throwable: Throwable ->\r\n        println(\"Job cancelled due to ${throwable.message}\")\r\n    }\r\nGlobalScope.launch(context = exceptionHandler) {\r\n        TODO(\"Not Implemented!\")\r\n}\r\n```\r\n\r\n\r\n\r\n#### 混合上下文\r\n\r\n上面可以知道通过设置协程的`context`参数可以设置调度器和异常处理。但是如果两者都想设置怎么办，设置完了之后又想从中移除某个又如何？\r\n\r\nKotlin为我们提供了`Combining contexts`和`Separating contexts`,可以说是考虑很周到了。\r\n\r\n##### 组合上下文\r\n\r\n使用+操作符组合多个context为一个多功能混合context：\r\n\r\n比如设置一个单线程调度器和异常处理：\r\n\r\n```kotlin\r\n    val singleThreadContext = newSingleThreadContext(\"single\")\r\n    val exceptionHandlerContext = CoroutineExceptionHandler { _: CoroutineContext, throwable: Throwable ->\r\n        println(\"Job cancelled due to ${throwable.message}\")\r\n    }\r\n\/\/使用+号 Combining contexts\r\n    val context = singleThreadContext + exceptionHandlerContext\r\n    GlobalScope.launch(context = context) {\r\n        TODO(\"Not Implemented!\")\r\n    }\r\n```\r\n\r\n\r\n\r\n##### 分离上下文\r\n\r\n通过`CoroutineContext.minusKey`移除指定上下文：\r\n\r\n```Kotlin\r\n    \/\/接上面内容\r\n    val lastContext = context.minusKey(singleThreadContext.key)\r\n\r\n```\r\n\r\n\r\n\r\n### 协程间通信--Channel\r\n\r\n由于共享内存状态，所以多线程是比较难理解也比较容易出错的地方，为此Kotlin提供了Channel代替共享内存帮助我们编写协程高并发代码。\r\n\r\n通道是并发代码之间安全通信的工具。它们允许并发代码通过发送信息进行通信。\r\n通道可以看成是不同协程间安全发送和接受信息的管道，不管他们运行在哪个线程。\r\n\r\n#### 无缓冲通道\r\n\r\n##### RendezvousChannel\r\n\r\n目前唯一一个无缓冲通道是RendezvousChannel。这个通道实现类没有缓冲，所以调用send()后将会挂起直到接收者使用通道调用receive()。\r\n\r\n该类为internal修饰，只有其模块可见，我们只能通过Channel基类创建其实例。\r\n\r\n创建实例：\r\n\r\n```kotlin\r\n    val channel = Channel<Int>()\r\n    val channel = Channel<Int>(0)\r\n    val channel = Channel<Int>(Channel.RENDEZVOUS)\r\n```\r\n\r\n\r\n\r\n#### 有缓冲通道\r\n\r\n##### LinkedListChannel\r\n\r\n无限(Int.MAX_VALUE)缓冲的通道。当通道中数据量达到缓冲区大小时，这个通道会挂起发送者代码。\r\n\r\n创建实例：\r\n\r\n```kotlin\r\n    val channel = Channel<Int>(Channel.UNLIMITED)\r\n```\r\n\r\n\r\n\r\n##### ArrayChannel\r\n\r\n缓冲大小介于0到Int.MAX_VALUE-1，当元素数量达到缓冲大小时会挂起sender。\r\n可以通过调用Channel为其设置一个小于Int最大值的正数作为参数来实例化数组通道。\r\n当缓冲满的时候会挂起sender，当有至少一组数据被接受时候会恢复。\r\n\r\n创建实例：\r\n\r\n```kotlin\r\n    val channel = Channel<Int>(22)\r\n```\r\n\r\n\r\n\r\n##### ConflatedChannel\r\n\r\n这是第三种类型的缓冲通道。\r\n\r\n这种通道只有一个元素大小的缓冲，当发送一个新元素时，上一个元素就会丢失，发送的元素丢了也没关系。\r\n这也就意味着发送者永远不会被挂起。\r\n\r\n创建实例：\r\n\r\n```kotlin\r\n    val channel = Channel<Int>(Channel.CONFLATED)\r\n```\r\n\r\n#### 发送通道常用方法\r\n\r\n##### channel.isClosedForSend\r\n\r\n##### channel.isFull \r\n\r\n##### channel.send(1)\r\n\r\n##### channel.offer(2)\r\n\r\n非挂起函数，允许你在某些情况下通过通道发送元素。\r\n这个offer()函数接受一个元素尝试加入到队列 并返回boolean值或根据通道状态抛出异常。\r\n\r\n如果通道关闭，offer()出现异常：\r\n\r\n如果缓冲满了，offer会返回false：\r\n\r\n如果通道打开并且没有充满，offer()会把元素添加到队列。\r\n这是唯一一种像通道添加元素而又不挂起的方法。\r\n\r\n#### 接收通道常用方法\r\n\r\n##### channel.isClosedForReceive\r\n\r\n##### channel.receive()\r\n\r\n##### channel.isEmpty\r\n\r\n\r\n\r\n### Thread Confinement, Actors, and Mutexes\r\n\r\n#### Thread Confinement\r\n\r\n线程限制意味着限制访问共享状态的所有协程，以便它们在单个线程上执行。\r\n也就是说状态不再是线程间共享的了：只有一个线程允许修改状态。\r\n\r\n```kotlin\r\nvar counter = 0\r\nval context = newSingleThreadContext(\"counter\")\r\nfun asyncIncrement(by: Int) = async(context) {\r\n    for (i in 0 until by) {\r\n    counter++\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n#### Actor\r\n\r\nActor这个东西不太明白如何翻译过来。不过通过源码可以看到：\r\n\r\nActor是协程和Channel的组合体：其返回值是SendChannel，block中有个ReceiveChannel。\r\n\r\n其他协程通过返回值的SendChannel发送消息，而后block中的ReceiveChannel接收消息并做处理：\r\n\r\n```kotlin\r\nvar counter = 0\r\n\r\nval sendChannel = GlobalScope.actor<Int> {\r\n    for (i in channel) {\r\n        counter++\r\n    }\r\n}\r\n\r\nfun asyncIncrement(by: Int) = GlobalScope.async {\r\n    for (i in 0 until by) {\r\n        sendChannel.send(1)\r\n    }\r\n}\r\n\r\nfun main() = runBlocking {\r\n    asyncIncrement(2000)\r\n    asyncIncrement(1000)\r\n    delay(3000)\r\n    println(\"counter==${counter}\")\r\n    delay(2000)\r\n}\r\n```\r\n\r\n\r\n\r\n#### Mutexes\r\n\r\n互斥是指一种同步机制，它保证一次只有一个协程可以执行一段代码。\r\n\r\nKotlin互斥最重要的特性是它们没有阻塞：等待执行的协程将暂停，直到它们获得锁并执行代码块为止。 \r\n\r\n`withLock`使用：\r\n\r\n```kotlin\r\nval mutex = Mutex()\r\nvar counter = 0\r\n\r\nfun asyncIncrement(by: Int) = GlobalScope.async {\r\n    for (i in 0 until by) {\r\n       mutex.withLock {\r\n           counter++\r\n       }\r\n    }\r\n}\r\n\r\nfun main() = runBlocking {\r\n    asyncIncrement(2000)\r\n    asyncIncrement(1000)\r\n    delay(3000)\r\n    println(\"counter==${counter}\")\r\n    delay(2000)\r\n}\r\n```\r\n\r\n如果想要更灵活的控制，可以使用`lock() `和`unLock()`。\r\n\r\n\r\n\r\n#### Volatile \r\n\r\n为了强制让更新对其他线程立即可见，我们可以使用注解@Volatile："
  },
  {
    "title" : "Android JNI知识点",
    "created_time" : "2019-03-22 10:10:17",
    "body" : "### JNI介绍\r\n\r\nJNI 是 Java Native Interface 的缩写，译为 Java 本地接口，是 Java 与其他语言通信的桥\r\n梁。 所以说白了，有了JNI可以通过Java调用C\/C++，当然也可以通过C\/C++回调Java，这是JNI两个主要功能。那下面分别从这两方面说下JNI如何实现调用的。\r\n\r\n### Java调用C\/C++\r\n\r\n既然Java要调用C\/C++，那么Java如何根据native方法找到对应的so库函数呢？\r\n\r\n常规想法就是需要定义一套规则，根据这套规则使能根据native方法找到唯一与之对应的so库函数。\r\n\r\n规则如下：根据native方法及相关信息生成固定模式的本地实现函数名称\r\n\r\n```\r\nJNIEXPORT 返回值类型 JNICALL Java_类全名_方法名(JNIEnv *env, jobject instance,参数列表){\r\n    \r\n}\r\n```\r\n\r\n这套规则我们称为静态注册。\r\n\r\n#### 静态注册\r\n\r\n静态注册方法有固定的实现步骤：\r\n\r\n##### 声明native方法并编译\r\n\r\n声明native方法：\r\n\r\n```java\r\npublic class Tes {\r\n    public native int add(int a, int b);\r\n    public native void getStr_FromJNI();\r\n}\r\n```\r\n\r\nKotlin中使用`external`声明jni方法：\r\n\r\n```kotlin\r\nclass Tes {\r\n    external fun getStr_FromJNI(): String\r\n    external fun add(a: Int, b: Int): Int\r\n}\r\n```\r\n\r\n\r\n\r\n编译类文件：\r\n\r\n`javac Tes.java`\r\n\r\n编译完成后生成了Tes.class文件\r\n\r\n##### 生成头文件\r\n\r\n命令行定位到class文件，执行`javah Tes`生成头文件：\r\n\r\n> Android Studio 3.x版本中声明native方法后会飘红，这时候直接fix即可自动创建头文件，免去命令行生成这一步\r\n\r\n```c\r\n#include <jni.h>\r\n\r\nJNIEXPORT jstring JNICALL\r\nJava_pet_home_main_Tes_getStr_1FromJNI(JNIEnv *env, jobject instance) {\r\n    \/\/ TODO\r\n    return (*env)->NewStringUTF(env, returnValue);\r\n}\r\n\r\nJNIEXPORT jint JNICALL\r\nJava_pet_home_main_Tes_add(JNIEnv *env, jobject instance, jint a, jint b) {\r\n    \/\/ TODO\r\n}\r\n```\r\n\r\n注意头文件中方法名，以“Java”开头说明是在 Java 平台中调用 JNI 方法的，后面的 pet_home_main_Tes_getStr_1FromJNI指的是包名＋类名＋方法名的格式，原本在 Java 中应该是以\".\"\r\n来进行分割，这里却用了\"_\"，这是因为在 Native 语言中\".\"有特殊的含义。\r\n\r\n还有getStr_1FromJNI中下划线后面多了个1，这是因为 Java 的getStr_FromJNI方法中包含了\"_\"，\r\n\r\n转换成JNI方法后就变成了   \"_1\"。\r\n\r\n##### 编写C代码\r\n\r\nC代码直接进行简单的内容返回即可：\r\n\r\n```C \r\n#include <jni.h>\r\n\r\nJNIEXPORT jint JNICALL\r\nJava_pet_home_main_Tes_add(JNIEnv *env, jobject instance, jint a, jint b) {\r\n    return a + b;\r\n}\r\n\r\nJNIEXPORT jstring JNICALL\r\nJava_pet_home_main_Tes_getStr_1FromJNI(JNIEnv *env, jobject instance) {\r\n    return (*env)->NewStringUTF(env, \"this is from jni\");\r\n}\r\n```\r\n\r\n##### 编译so库并运行\r\n\r\n编译so库在运行App时由Studio自动编译完成，不过可以在moudle的gradle文件中配置编译平台：\r\n\r\n```groovy\r\n    defaultConfig {\r\n       \r\n\t\t\/\/配置编译平台\r\n        ndk{\r\n            abiFilters \"armeabi\", \"armeabi-v7a\",\"x86\"\r\n        }\r\n    }\r\n```\r\n\r\nKotlin加载so库：\r\n\r\n```kotlin\r\n    companion object {\r\n        \/\/ Used to load the 'native-lib' library on application startup.\r\n        init {\r\n            System.loadLibrary(\"native-lib\")\r\n        }\r\n    }\r\n```\r\n\r\nJava加载so库：\r\n\r\n```java\r\nstatic{\r\n    System.loadLibrary(\"native-lib\")\r\n}\r\n```\r\n\r\n上面既然说明了有静态注册，那不难想象应该还有动态注册，动态注册又是如何实现的呢？\r\n\r\n#### 动态注册\r\n\r\n##### Log动态注册\r\n\r\n动态注册通过使用JNINativeMethod， 保存了声明函数和实现函数的一一对应关系。  它是一个结构体类型，\r\n\r\n该结构体的数组变量`gMethods[]`被注册到VM，这样VM就知道了当调用native方法时该调用哪个实现函数。\r\n\r\n以日志类Log为例：\r\n\r\nJava层Log类有三个native方法：\r\n\r\n```java\r\n    public static native boolean isLoggable(String tag, int level);\r\n \tpublic static native int println_native(int bufID,int priority, String tag, String msg);\r\n    private static native int logger_entry_max_payload_native();\r\n```\r\n\r\n对应的cpp实现`android_util_Log.cpp`：\r\n\r\n```c++\r\n\/* \/\/device\/libs\/android_runtime\/android_util_Log.cpp\r\n**\r\n** Copyright 2006, The Android Open Source Project\r\n**\r\n** Licensed under the Apache License, Version 2.0 (the \"License\");\r\n** you may not use this file except in compliance with the License.\r\n** You may obtain a copy of the License at\r\n**\r\n**     http:\/\/www.apache.org\/licenses\/LICENSE-2.0\r\n**\r\n** Unless required by applicable law or agreed to in writing, software\r\n** distributed under the License is distributed on an \"AS IS\" BASIS,\r\n** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n** See the License for the specific language governing permissions and\r\n** limitations under the License.\r\n*\/\r\n\r\n#define LOG_NAMESPACE \"log.tag.\"\r\n#define LOG_TAG \"Log_println\"\r\n\r\n#include <android-base\/macros.h>\r\n#include <assert.h>\r\n#include <cutils\/properties.h>\r\n#include <log\/log.h>               \/\/ For LOGGER_ENTRY_MAX_PAYLOAD.\r\n#include <utils\/Log.h>\r\n#include <utils\/String8.h>\r\n\r\n#include \"jni.h\"\r\n#include \"JNIHelp.h\"\r\n#include \"utils\/misc.h\"\r\n#include \"core_jni_helpers.h\"\r\n#include \"android_util_Log.h\"\r\n\r\nnamespace android {\r\n\r\nstruct levels_t {\r\n    jint verbose;\r\n    jint debug;\r\n    jint info;\r\n    jint warn;\r\n    jint error;\r\n    jint assert;\r\n};\r\nstatic levels_t levels;\r\n\r\nstatic jboolean isLoggable(const char* tag, jint level) {\r\n    return __android_log_is_loggable(level, tag, ANDROID_LOG_INFO);\r\n}\r\n\r\nstatic jboolean android_util_Log_isLoggable(JNIEnv* env, jobject clazz, jstring tag, jint level)\r\n{\r\n    if (tag == NULL) {\r\n        return false;\r\n    }\r\n\r\n    const char* chars = env->GetStringUTFChars(tag, NULL);\r\n    if (!chars) {\r\n        return false;\r\n    }\r\n\r\n    jboolean result = isLoggable(chars, level);\r\n\r\n    env->ReleaseStringUTFChars(tag, chars);\r\n    return result;\r\n}\r\n\r\nbool android_util_Log_isVerboseLogEnabled(const char* tag) {\r\n    return isLoggable(tag, levels.verbose);\r\n}\r\n\r\n\/*\r\n * In class android.util.Log:\r\n *  public static native int println_native(int buffer, int priority, String tag, String msg)\r\n *\/\r\nstatic jint android_util_Log_println_native(JNIEnv* env, jobject clazz,\r\n        jint bufID, jint priority, jstring tagObj, jstring msgObj)\r\n{\r\n    const char* tag = NULL;\r\n    const char* msg = NULL;\r\n\r\n    if (msgObj == NULL) {\r\n        jniThrowNullPointerException(env, \"println needs a message\");\r\n        return -1;\r\n    }\r\n\r\n    if (bufID < 0 || bufID >= LOG_ID_MAX) {\r\n        jniThrowNullPointerException(env, \"bad bufID\");\r\n        return -1;\r\n    }\r\n\r\n    if (tagObj != NULL)\r\n        tag = env->GetStringUTFChars(tagObj, NULL);\r\n    msg = env->GetStringUTFChars(msgObj, NULL);\r\n\r\n    int res = __android_log_buf_write(bufID, (android_LogPriority)priority, tag, msg);\r\n\r\n    if (tag != NULL)\r\n        env->ReleaseStringUTFChars(tagObj, tag);\r\n    env->ReleaseStringUTFChars(msgObj, msg);\r\n\r\n    return res;\r\n}\r\n\r\n\/*\r\n * In class android.util.Log:\r\n *  private static native int logger_entry_max_payload_native()\r\n *\/\r\nstatic jint android_util_Log_logger_entry_max_payload_native(JNIEnv* env ATTRIBUTE_UNUSED,\r\n                                                             jobject clazz ATTRIBUTE_UNUSED)\r\n{\r\n    return static_cast<jint>(LOGGER_ENTRY_MAX_PAYLOAD);\r\n}\r\n\r\n\/*\r\n * JNI registration.\r\n *\/\r\nstatic const JNINativeMethod gMethods[] = {\r\n    \/* name, signature, funcPtr *\/\r\n    { \"isLoggable\",      \"(Ljava\/lang\/String;I)Z\", (void*) android_util_Log_isLoggable },\r\n    { \"println_native\",  \"(IILjava\/lang\/String;Ljava\/lang\/String;)I\", (void*) android_util_Log_println_native },\r\n    { \"logger_entry_max_payload_native\",  \"()I\", (void*) android_util_Log_logger_entry_max_payload_native },\r\n};\r\n\r\nint register_android_util_Log(JNIEnv* env)\r\n{\r\n    jclass clazz = FindClassOrDie(env, \"android\/util\/Log\");\r\n\r\n    levels.verbose = env->GetStaticIntField(clazz, GetStaticFieldIDOrDie(env, clazz, \"VERBOSE\", \"I\"));\r\n    levels.debug = env->GetStaticIntField(clazz, GetStaticFieldIDOrDie(env, clazz, \"DEBUG\", \"I\"));\r\n    levels.info = env->GetStaticIntField(clazz, GetStaticFieldIDOrDie(env, clazz, \"INFO\", \"I\"));\r\n    levels.warn = env->GetStaticIntField(clazz, GetStaticFieldIDOrDie(env, clazz, \"WARN\", \"I\"));\r\n    levels.error = env->GetStaticIntField(clazz, GetStaticFieldIDOrDie(env, clazz, \"ERROR\", \"I\"));\r\n    levels.assert = env->GetStaticIntField(clazz, GetStaticFieldIDOrDie(env, clazz, \"ASSERT\", \"I\"));\r\n\r\n    return RegisterMethodsOrDie(env, \"android\/util\/Log\", gMethods, NELEM(gMethods));\r\n}\r\n\r\n}; \/\/ namespace android\r\n\r\n```\r\n\r\n可以看到Java层打印方法`println_native`对应的cpp方法`android_util_Log_println_native`并没有包含如上面静态注册所提到的`JNIEXPORT`等关键字样，这是因为native方法和实现方法通过`gMethods[]`进行了绑定。\r\n\r\n看下JNINativeMethod结构体内容：\r\n\r\n```c++\r\ntypedef struct {\r\n    const char* name;\r\n    const char* signature;\r\n    void*       fnPtr;\r\n} JNINativeMethod;\r\n```\r\n\r\n其中：\r\n\r\n`name`为java方法名；\r\n\r\n`signature`为java方法签名；\r\n\r\n`fnPtr`为本地实现函数指针；\r\n\r\n由于Java有函数重载的问题，所以使用方法签名避免方法名相同问题，这里方法签名涉及参数个数、参数类型、返回值。\r\n\r\n要知道方法签名，先看下java中类型在jni中对应的别名：\r\n\r\n| java      | native        | signature             |\r\n| --------- | ------------- | --------------------- |\r\n| byte      | jbyte         | B                     |\r\n| char      | jchar         | C                     |\r\n| double    | jdouble       | D                     |\r\n| float     | jfloat        | F                     |\r\n| int       | jint          | I                     |\r\n| short     | jshort        | S                     |\r\n| long      | jlong         | J                     |\r\n| boolean   | jboolean      | Z                     |\r\n| void      | void          | V                     |\r\n| 所有对象  | jobject       | L+classname+;         |\r\n| Class     | jclass        | Ljava\/lang\/Class;     |\r\n| String    | jstring       | Ljava\/lang\/String;    |\r\n| Throwable | jthrowable    | Ljava\/lang\/Throwable; |\r\n| Object[]  | jobjectArray  | [L+classname+;        |\r\n| byte[]    | jbyteArray    | [B                    |\r\n| char[]    | jcharArray    | [C                    |\r\n| doubel[]  | jdoubleArray  | [D                    |\r\n| float[]   | jfloatArray   | [F                    |\r\n| int[]     | jintArray     | [I                    |\r\n| short[]   | jshortArray   | [S                    |\r\n| long[]    | jlongArray    | [J                    |\r\n| boolean[] | jbooleanArray | [Z                    |\r\n\r\n已经知道`gMethods`保存了函数对应关系，然后在`register_android_util_Log`方法中进行了注册，\r\n\r\n追踪源码最终调用了`AndroidRuntime::registerNativeMethods`，将对应函数关系传递给了VM。\r\n\r\n那么`register_android_util_Log`是什么时候调用的呢？\r\n\r\n其实是在`AndroidRuntime.cpp`的`startReg`方法中调用的，源码如下：\r\n\r\n```c++\r\n\/*\r\n * Register android native functions with the VM.\r\n *\/\r\n\/*static*\/ int AndroidRuntime::startReg(JNIEnv* env)\r\n{\r\n    ATRACE_NAME(\"RegisterAndroidNatives\");\r\n    \/*\r\n     * This hook causes all future threads created in this process to be\r\n     * attached to the JavaVM.  (This needs to go away in favor of JNI\r\n     * Attach calls.)\r\n     *\/\r\n    androidSetCreateThreadFunc((android_create_thread_fn) javaCreateThreadEtc);\r\n\r\n    ALOGV(\"--- registering native functions ---\\n\");\r\n\r\n    \/*\r\n     * Every \"register\" function calls one or more things that return\r\n     * a local reference (e.g. FindClass).  Because we haven't really\r\n     * started the VM yet, they're all getting stored in the base frame\r\n     * and never released.  Use Push\/Pop to manage the storage.\r\n     *\/\r\n    env->PushLocalFrame(200);\r\n\r\n    if (register_jni_procs(gRegJNI, NELEM(gRegJNI), env) < 0) {\r\n        env->PopLocalFrame(NULL);\r\n        return -1;\r\n    }\r\n    env->PopLocalFrame(NULL);\r\n\r\n    \/\/createJavaThread(\"fubar\", quickTest, (void*) \"hello\");\r\n\r\n    return 0;\r\n}\r\n```\r\n\r\n上面方法中调用了`register_jni_procs`：\r\n\r\n```c++\r\nstatic int register_jni_procs(const RegJNIRec array[], size_t count, JNIEnv* env)\r\n{\r\n    for (size_t i = 0; i < count; i++) {\r\n        if (array[i].mProc(env) < 0) {\r\n#ifndef NDEBUG\r\n            ALOGD(\"----------!!! %s failed to load\\n\", array[i].mName);\r\n#endif\r\n            return -1;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n\r\n```\r\n\r\n在`register_jni_procs`方法的`if`语句执行了`register_android_util_Log`函数。\r\n\r\n这里简单的一个`if`语句其实还是有挺多逻辑的。\r\n\r\n首先看下`register_jni_procs`函数接收的第一个参数`gRegJNI`：\r\n\r\n```C++\r\nstatic const RegJNIRec gRegJNI[] = {\r\n    REG_JNI(register_com_android_internal_os_RuntimeInit),\r\n    REG_JNI(register_com_android_internal_os_ZygoteInit),\r\n    REG_JNI(register_android_os_SystemClock),\r\n    REG_JNI(register_android_util_EventLog),\r\n    REG_JNI(register_android_util_Log),\r\n    REG_JNI(register_android_util_MemoryIntArray),\r\n    REG_JNI(register_android_util_PathParser),\r\n    REG_JNI(register_android_app_admin_SecurityLog),\r\n    REG_JNI(register_android_content_AssetManager),\r\n \t\/\/后面省略很多\r\n};\r\n\r\n```\r\n\r\n上面可以看到这是一个`RegJNIRec`类型的静态数组，`RegJNIRec`又是什么呢？：\r\n\r\n```c++\r\n#ifdef NDEBUG\r\n    #define REG_JNI(name)      { name }\r\n    struct RegJNIRec {\r\n        int (*mProc)(JNIEnv*);\r\n    };\r\n#else\r\n    #define REG_JNI(name)      { name, #name }\r\n    struct RegJNIRec {\r\n        int (*mProc)(JNIEnv*);\r\n        const char* mName;\r\n    };\r\n#endif\r\n```\r\n\r\n可以看到`RegJNIRec`只是一个结构体，\r\n\r\n结合这两段源码可以看出`REG_JNI(xxx)`，其实就是{xxx}，\r\n\r\n所以 REG_JNI(register_android_util_Log),就是{register_android_util_Log},\r\n\r\n那么上面源码中的那些xxx是从哪里来的呢？其实在`AndroidRuntime.cpp`有很多类似这样的代码：\r\n\r\n```c++\r\nextern int register_android_app_admin_SecurityLog(JNIEnv* env);\r\nextern int register_android_content_AssetManager(JNIEnv* env);\r\nextern int register_android_util_EventLog(JNIEnv* env);\r\nextern int register_android_util_Log(JNIEnv* env);\r\n\r\n```\r\n\r\n`extern`告诉我们，它这里引用的这些函数诸如：register_android_util_Log等可能定义在另一个源文件中，\r\n\r\n这里的`register_android_util_Log`函数就定义在`android_util_Log.cpp`文件中。\r\n\r\n结构体RegJNIRec中有这样一个东西`int (*mProc)(JNIEnv*);`\r\n\r\n这是一个函数指针：函数变量名为mProc，返回int值，接收一个JNIEnv指针参数。\r\n\r\n`gRegJNI[]`其实就是把各个函数指针(诸如register_android_util_Log)赋值给结构体`RegJNIRec`中函数指针变量mProc。\r\n\r\n所以在`if`语句中执行`array[i].mProc(env)`其实就是调用了`extern`所引入的各个外部函数。从而达到注册jni函数目的。\r\n\r\n##### 自定义JNI动态注册\r\n\r\n动态注册相比静态注册灵活性提高了很多，没有那么多条条框框。\r\n\r\n但是上面只是讲了系统如何动态注册，那么我们实际开发JNi过程中又该在哪注册呢？毕竟系统启动过程就注册了系统所需JNI，这个过程对我们来说是不可控的。\r\n\r\n还记得我们在加载so库时是怎么做的吗？\r\n\r\n使用`System.loadLibrary`，这个方法调用完成后系统会回调我们的cpp\/c文件中的`JNI_OnLoad`函数：\r\n\r\n```c++\r\njint JNI_OnLoad(JavaVM *vm, void *reserved) {\r\n}\r\n\r\n```\r\n\r\n所以我们可以在这个方法中进行函数绑定。\r\n\r\n首先实现native函数：\r\n\r\n```c++\r\njstring getStr(JNIEnv *env, jobject instance) {\r\n    return (*env)->NewStringUTF(env, \"this is from jni\");\r\n}\r\n\/\/注意:实现的函数最少要包含JNIEnv *env, jobject instance 这2个参数\r\njint addResult(JNIEnv *env, jobject instance, jint a, jint b) {\r\n    return a + b;\r\n}\r\n\r\n```\r\n\r\n然后进行函数绑定：\r\n\r\n```c++\r\nstatic JNINativeMethod gMethods[] = {\r\n        {\"getStr_FromJNI\", \"()Ljava\/lang\/String;\", (void *) getStr},\r\n        {\"add\",            \"(II)I\",                (void *) addResult},\r\n};\r\n\r\n```\r\n\r\n最后在`JNI_OnLoad`中进行函数注册：\r\n\r\n```C++\r\njint JNI_OnLoad(JavaVM *vm, void *reserved) {\r\n    jint result = -1;\r\n    char className[20] = {\"pet\/home\/main\/Tes\"};\r\n    JNIEnv *env = NULL;\r\n    \/\/通过vm获取env\r\n    if ((*vm)->GetEnv(vm, (void **) &env, JNI_VERSION_1_4) != JNI_OK) {\r\n        return -1;\r\n    }\r\n    \/\/获取class\r\n    jclass clazz = (*env)->FindClass(env, (const char *) className);\r\n    \/\/函数注册\r\n    if ((*env)->RegisterNatives(env, clazz, gMethods, 2) < 0) {\r\n        return -1;\r\n    }\r\n    \/\/一定要返回版本号，否则会出错。\r\n    result = JNI_VERSION_1_4;\r\n    return result;\r\n}\r\n```\r\n\r\nActivity进行结果展示：\r\n\r\n```kotlin\r\n        val tes = Tes()\r\n        sample_text.text = \"${tes.getStr_FromJNI()}#####${tes.add(3, 5)}\"\r\n```\r\n\r\n##### JNI添加Log打印\r\n\r\n在so调试过程中免不了要进行日志打印，但如何在LogCat中显示JNI日志呢？\r\n\r\n首先引入`#include<android\/log.h>`头文件，\r\n\r\n然后进行宏定义：\r\n\r\n```c++\r\n#define TAG    \"tes.c\" \/\/ 自定义的LOG的Tag\r\n#define LOGD(...)  __android_log_print(ANDROID_LOG_DEBUG,TAG,__VA_ARGS__)\r\n#define LOGI(...)  __android_log_print(ANDROID_LOG_INFO,TAG,__VA_ARGS__)\r\n#define LOGW(...)  __android_log_print(ANDROID_LOG_WARN,TAG,__VA_ARGS__)\r\n#define LOGE(...)  __android_log_print(ANDROID_LOG_ERROR,TAG,__VA_ARGS__)\r\n```\r\n\r\n最后应用Log：\r\n\r\n```c++\r\njint addResult(JNIEnv *env, jobject instance, jint a, jint b) {\r\n    LOGD(\"a value is %d\", a);\r\n    LOGD(\"b value is %d\", b);\r\n    return a + b;\r\n}\r\n```\r\n\r\n\r\n\r\n### C\/C++调用Java\r\n\r\n代码沿用上面的，可以看到C\/C++层的native方法实现中，JNI方法接受的第二个参数是Java对象： jobject， 可以在\r\nJNI中操作这个jobject进而操作Java对象提供的变量和方法 。\r\n\r\n#### 获取class\r\n\r\n要操作jobject， 就是要访问这个对象并操作它的变量和方法。 JNI提供的类和对象操作函数有很多， 常用的有两个：\r\nFindClass和GetObjectClass， 在C和C++中分别有不同的函数原型。\r\n\r\n C++中的函数原型如下：\r\n\r\n```C++\r\njclass FindClass（const charname） ； \/\/查找类信息\r\njclass GetObjectClass（jobject obj） ； \/\/返回对象的类\r\n\r\n```\r\n\r\nC中的函数原型如下：\r\n\r\n```C\r\njclass（FindClass） （JNIEnv， const char） ；\r\njclass（GetObjectClass） （JNIEnv*， jobject） ； \r\n\r\n```\r\n\r\n给Tes类添加一个`calc`函数：\r\n\r\n```kotlin\r\nclass Tes {\r\n    val NAME = \"TES\"\r\n\r\n    external fun getStr_FromJNI(): String\r\n    external fun add(a: Int, b: Int): Int\r\n    fun calc(a: Int, b: Int): Int {\r\n        return a * b\r\n    }\r\n}\r\n\r\n```\r\n\r\n根据object实例获取jclass：\r\n\r\n```C++\r\n    jclass clzz = (*env)->GetObjectClass(env, instance);\r\n\r\n```\r\n\r\n\r\n\r\n#### 获取Java变量\r\n\r\n上面已经获取到了jclass，有了class可以通过`GetStaticFieldID`和`GetFieldID`获取静态变量ID和实例变量ID，\r\n\r\n获取到FieldID后，再通过`GetStaticxxxField`和`GetxxxField`获取静态变量或实例变量的值：\r\n\r\n```C++\r\n    jclass clzz = (*env)->GetObjectClass(env, instance);\r\n\t\/\/获取fieldid\r\n  \tjfieldID fieldID = (*env)->GetStaticFieldID(env, clzz, \"NAME\", \"Ljava\/lang\/String;\");\r\n\t\/\/根据id获取变量值\r\n    jstring nameStr = (jstring) (*env)->GetStaticObjectField(env, clzz, fieldID);\r\n    const char *name = (*env)->GetStringUTFChars(env, nameStr, JNI_FALSE);\r\n    LOGD(\"Tes name is %s\", name);\r\n\r\n```\r\n\r\n\r\n\r\n#### 调用Java方法\r\n\r\n上面了解到获取变量值前要先获取变量ID，同样调用方法前要先获取方法ID。\r\n\r\n通过`GetMethodID`和`GetStaticMethodID`获取实例方法和静态方法ID，\r\n\r\n通过`CallxxxMethod`和`CallStaticxxxMethod`调用实例方法和静态方法：\r\n\r\n```c++\r\n \tjclass clzz = (*env)->GetObjectClass(env, instance);\r\n\t\/\/获取方法id\r\n    jmethodID methID = (*env)->GetMethodID(env, clzz, \"calc\", \"(II)I\");\r\n\t\/\/调用方法\r\n    jint result = (*env)->CallIntMethod(env, instance, methID, 3, 2);\r\n    LOGD(\"result value is %d\", result);\r\n```\r\n\r\n\r\n\r\n### 关于JNIENV\r\n\r\nC++中： JNIEnv就是struct _JNIEnv。 JNIEnv *env等价于 struct  _JNIEnv *env， \r\n\r\n在调用JNI函数的时候， 只需要env-＞FindClass（ JNIEnv*， const char *） ， 就会间接调用JNINativeInterface结构体里定义的函数指针， 而无需首先对env解引用。\r\n\r\nC中： JNIEnv就是const struct JNINativeInterface*。JNIEnv *env实际等价于const struct JNINativeInterface **env，\r\n因此要得到JNINativeInterface结构体内的函数指针就必须先对env解引用得到（ *env） ，\r\n\r\n 即const struct JNINativeInterface *，这个指针才是真正指向JNINativeInterface结构体的指针，\r\n\r\n 然后再通过它调用具体的JNI函数。 因此需要这样调用：（ *env） -＞FindClass（ JNIEnv *， const char *） 。\r\n\r\n注意 JNIEnv只在当前线程中有效。 本地方法不能将JNIEnv从一个线程传递到另一个线程中。 \r\n\r\n相同的Java线程中对本地方法多次调用时， 传递给该本地方法的JNIEnv是相同的。 但是， 一个本地方法可被不同的Java线程所调用， 因此可以接受不同的JNIEnv。 \r\n\r\n\r\n\r\n### 关于CMakeLists.txt添加目录\r\n\r\nAndroid Studio添加jni支持后会创建CMakeLists.txt文件，\r\n\r\n其中会包含你创建的C文件：\r\n\r\n```txt\r\nadd_library( # Sets the name of the library.\r\n        native-lib\r\n        # Sets the library as a shared library.\r\n        SHARED\r\n        # Provides a relative path to your source file(s).\r\n       src\/main\/jni\/tes.c )\r\n```\r\n\r\n但是这里只包含一个文件，如果文件是多文件多目录该怎么办？\r\n\r\n可以添加：\r\n\r\n```\r\naux_source_directory( .\/src\/main\/cpp NATIVE_SRC) #参数1为源，参数2为目标\r\n\r\n```\r\n\r\n如果cpp目录下还要子目录，则继续添加：\r\n\r\n```\r\naux_source_directory( .\/src\/main\/cpp\/rtc_base RTC_BASE )\r\n\r\n```\r\n\r\n将 RTC_BASE 增加到 NATIVE_SRC 中，这样子目录的源文件也加入了编译行列中：\r\n\r\n```\r\nlist(APPEND NATIVE_SRC ${RTC_BASE})\r\n\r\n```\r\n\r\n最后修改add_library地方：\r\n\r\n```\r\nadd_library( # Sets the name of the library.\r\n        native-lib\r\n\r\n        # Sets the library as a shared library.\r\n        SHARED\r\n\r\n        # Provides a relative path to your source file(s).\r\n        ${NATIVE_SRC}\r\n        )\r\n\r\n```"
  },
  {
    "title" : "我是如何破解一个小视频app的",
    "created_time" : "2019-09-17 17:28:49",
    "body" : "### 前言\r\n\r\n最近想找一个看美剧的app，想看《黑袍纠察队》，一连下了几个app看看哪个效果好。\r\n\r\n结果无意中发现一个小(你)视(懂)频(得)app，随便点了几下发现都只能试看几十秒。\r\n\r\n看完整视频需要付费且价格不便宜(年费300)，爱优腾的年费赶上半价活动也才99\/年，\r\n\r\n所以付费观看我是拒绝的，就想着能不能破解下。\r\n\r\n### 工具\r\n\r\nandroid studio：安装java2smali插件，作为编辑器修改smali\r\n\r\napktool_2.4.0.jar：解压apk\r\n\r\nVirtualBox安装Ubuntu，openjdk：作为解压和重打包环境，在win下会有莫名的错误。\r\n\r\ndebug.keystore：android默认签名文件，用于apk重签名\r\n\r\njarsigner：jdk自带的签名工具\r\n\r\n以下app操作都在模拟器中运行，创建一个pad大屏模拟器，没有为啥就是看着爽\r\n\r\n### 目标\r\n\r\n工具和环境都准备好了，接下来要确认好目标，因为有了目标可以精准查找相应页面进行逻辑修改。\r\n\r\n现在视频是需要VIP才能完整播放的，我想不登录注册、没有vip直接播放完整视频：\r\n\r\n![不能完整播放](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/ll-play-no-vip-old.png)\r\n\r\n同一个视频播放后下次再次播放时会提示“你已经观看过，再次观看需要购买VIP”，我想随便点进来时直接播放就好，不要给我提示：\r\n\r\n![播放一次后再次播放提示](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/ll-after-play-no-vip-old.png)\r\n\r\n每次播放前都有个7s的视频，这个虽然可以忍受，但是我不想看：\r\n\r\n![7s广告](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/ll-play-ad-old%2Cpng.png)\r\n\r\nAPP现在要申请电话和存储权限，因为缓存关系，存储权限可以给它，但是我都不打算登录注册，电话权限我要去掉：\r\n\r\n![电话权限](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/ll-permission-old.png)\r\n\r\n所以现在4个目标基本明确了：\r\n\r\n- 无需登录和VIP进行全视频播放\r\n- 同一视频可以多次播放\r\n- 去广告\r\n- 去掉电话权限申请\r\n\r\n### 实操\r\n\r\n4个目标有3个都和播放页面相关，那就先搞前3个目标。\r\n\r\n#### 解压apk\r\n\r\n进入虚拟机的Ubuntu命令行，执行命令`java -jar apktool_2.4.0.jar d  llsp.apk`\r\n\r\n解压后文件如图：\r\n\r\n![解压目录](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/ll-unzip.png)\r\n\r\n#### 解压的项目导入到android studio\r\n\r\n#### 定位播放activity\r\n\r\n首先模拟器打开播放页面，adb查看当前播放页面Activity\r\n\r\n执行`dumpsys activity`\r\n\r\n定位到`ResumedActivity: ActivityRecord activity.PlayVideoActivity`即当前栈顶activity。\r\n\r\n#### 阅读smali\r\n\r\n在刚刚导入的项目中进入smali文件夹找到`PlayVideoActivity`。\r\n\r\n搜索发现除了`PlayVideoActivity`还有很多**PlayVideoActivity$1**类似的文件，其实这些都是`PlayVideoActivity`的内部类。\r\n\r\n##### 目标1：播放完整视频\r\n\r\n通过之前app播放，当发现你不是VIP时，几十秒后会弹出“此片试看已结束，您可以继续试看其他影片”的字样。\r\n\r\n所以第一想法就是这个几十秒的倒计时是app端实现的，我只要把倒计时去掉是不是就可以继续播放了。\r\n\r\n> 有时在学会走之前，先要跑起来.\r\n>\r\n> ​\t\t\t\t\t\t\t\t\t\t《钢铁侠》Tony Stark\r\n\r\n所以有了想法就赶紧去尝试，那么如何快速定位到倒计时及周围的逻辑呢？\r\n\r\n这里通过关键字快速定位法，既然有提示“此片试看已结束”了，那就去Activity中看看哪个方法调用了这个地方。\r\n\r\n但是smali中字符串是以Unicode方式存储的，所以在搜索前要把字符串转为Unicode码，\r\n\r\n“此片试看已结束”转码后的Unicode为\"\\u6b64\\u7247\\u8bd5\\u770b\\u5df2\\u7ed3\\u675f\"。\r\n\r\n用这个Unicode码去项目中搜索，发现只有`PlayVideoActivity$1`、`PlayVideoActivity$6`和`PlayVideoActivity$16`三个类中有该字符串的使用。\r\n\r\n\r\n\r\n`PlayVideoActivity$6`代码如下：\r\n\r\n```smali\r\n.class Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$6;\r\n.super Landroid\/os\/Handler;\r\n.source \"\"\r\n\r\n\r\n# annotations\r\n.annotation system Ldalvik\/annotation\/EnclosingClass;\r\n    value = Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n.end annotation\r\n\r\n.annotation system Ldalvik\/annotation\/InnerClass;\r\n    accessFlags = 0x0\r\n    name = null\r\n.end annotation\r\n\r\n\r\n# instance fields\r\n.field final synthetic ˏ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n\r\n# direct methods\r\n.method constructor <init>(Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;)V\r\n    .locals 0\r\n\r\n    .line 689\r\n    iput-object p1, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$6;->ˏ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    invoke-direct {p0}, Landroid\/os\/Handler;-><init>()V\r\n\r\n    return-void\r\n.end method\r\n\r\n\r\n# virtual methods\r\n.method public handleMessage(Landroid\/os\/Message;)V\r\n    .locals 2\r\n\r\n    .line 692\r\n    invoke-super {p0, p1}, Landroid\/os\/Handler;->handleMessage(Landroid\/os\/Message;)V\r\n\r\n    .line 693\r\n    iget v0, p1, Landroid\/os\/Message;->what:I\r\n\r\n    const\/4 v1, 0x1\r\n\r\n    if-ne v0, v1, :cond_0\r\n\r\n    .line 694\r\n    iget-object v0, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$6;->ˏ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    const-string v1, \"\\u6b64\\u7247\\u8bd5\\u770b\\u5df2\\u7ed3\\u675f\\uff0c\\u60a8\\u53ef\\u4ee5\\u7ee7\\u7eed\\u8bd5\\u770b\\u5176\\u4ed6\\u5f71\\u7247\\uff0c\\u6216\\u8005\\u6210\\u4e3a\\u4f1a\\u5458\\u65e0\\u9650\\u89c2\\u770b\\u6240\\u6709\\u5f71\\u7247\"\r\n\r\n    invoke-static {v0, v1}, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ˎ(Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;Ljava\/lang\/String;)V\r\n\r\n    .line 696\r\n    :cond_0\r\n    return-void\r\n.end method\r\n\r\n```\r\n\r\n\r\n\r\n`PlayVideoActivity$16`代码如下：\r\n\r\n```smali\r\n.class Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$16;\r\n.super Landroid\/os\/CountDownTimer;\r\n.source \"\"\r\n\r\n\r\n# annotations\r\n.annotation system Ldalvik\/annotation\/EnclosingClass;\r\n    value = Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n.end annotation\r\n\r\n.annotation system Ldalvik\/annotation\/InnerClass;\r\n    accessFlags = 0x0\r\n    name = null\r\n.end annotation\r\n\r\n\r\n# instance fields\r\n.field final synthetic ˋ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n\r\n# direct methods\r\n.method constructor <init>(Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;JJ)V\r\n    .locals 0\r\n\r\n    .line 337\r\n    iput-object p1, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$16;->ˋ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    invoke-direct {p0, p2, p3, p4, p5}, Landroid\/os\/CountDownTimer;-><init>(JJ)V\r\n\r\n    return-void\r\n.end method\r\n\r\n\r\n# virtual methods\r\n.method public onFinish()V\r\n    .locals 2\r\n\r\n    .line 346\r\n    iget-object v0, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$16;->ˋ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    invoke-virtual {v0}, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->getResources()Landroid\/content\/res\/Resources;\r\n\r\n    move-result-object v0\r\n\r\n    invoke-virtual {v0}, Landroid\/content\/res\/Resources;->getConfiguration()Landroid\/content\/res\/Configuration;\r\n\r\n    move-result-object v0\r\n\r\n    iget v0, v0, Landroid\/content\/res\/Configuration;->orientation:I\r\n\r\n    const\/4 v1, 0x2\r\n\r\n    if-ne v0, v1, :cond_0\r\n\r\n    .line 347\r\n    iget-object v0, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$16;->ˋ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    iget-object v0, v0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ॱˎ:Lchuangyuan\/ycj\/videolibrary\/video\/ExoUserPlayer;\r\n\r\n    invoke-virtual {v0}, Lchuangyuan\/ycj\/videolibrary\/video\/ExoUserPlayer;->onBackPressed()Z\r\n\r\n    .line 349\r\n    :cond_0\r\n    iget-object v0, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$16;->ˋ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    iget-object v0, v0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ˋॱ:Landroid\/widget\/TextView;\r\n\r\n    const\/16 v1, 0x8\r\n\r\n    invoke-virtual {v0, v1}, Landroid\/widget\/TextView;->setVisibility(I)V\r\n\r\n    .line 350\r\n    iget-object v0, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$16;->ˋ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    iget-object v0, v0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ॱˎ:Lchuangyuan\/ycj\/videolibrary\/video\/ExoUserPlayer;\r\n\r\n    invoke-virtual {v0}, Lchuangyuan\/ycj\/videolibrary\/video\/ExoUserPlayer;->onPause()V\r\n\r\n    .line 351\r\n    iget-object v0, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$16;->ˋ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    iget-object v0, v0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ॱˎ:Lchuangyuan\/ycj\/videolibrary\/video\/ExoUserPlayer;\r\n\r\n    invoke-virtual {v0}, Lchuangyuan\/ycj\/videolibrary\/video\/ExoUserPlayer;->onDestroy()V\r\n\r\n    .line 352\r\n    iget-object v0, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$16;->ˋ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    iget-object v0, v0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ˎ:Landroid\/view\/View;\r\n\r\n    const\/4 v1, 0x0\r\n\r\n    invoke-virtual {v0, v1}, Landroid\/view\/View;->setVisibility(I)V\r\n\r\n    .line 353\r\n    iget-object v0, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$16;->ˋ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    const-string v1, \"\\u6b64\\u7247\\u8bd5\\u770b\\u5df2\\u7ed3\\u675f\\uff0c\\u60a8\\u53ef\\u4ee5\\u7ee7\\u7eed\\u8bd5\\u770b\\u5176\\u4ed6\\u5f71\\u7247\\uff0c\\u6216\\u8005\\u6210\\u4e3a\\u4f1a\\u5458\\u65e0\\u9650\\u89c2\\u770b\\u6240\\u6709\\u5f71\\u7247\"\r\n\r\n    invoke-static {v0, v1}, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ˎ(Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;Ljava\/lang\/String;)V\r\n\r\n    .line 354\r\n    return-void\r\n.end method\r\n\r\n.method public onTick(J)V\r\n    .locals 3\r\n\r\n    .line 340\r\n    const-wide\/16 v0, 0x3e8\r\n\r\n    div-long v0, p1, v0\r\n\r\n    long-to-int v0, v0\r\n\r\n    invoke-static {v0}, Ljava\/lang\/String;->valueOf(I)Ljava\/lang\/String;\r\n\r\n    move-result-object v2\r\n\r\n    .line 341\r\n    iget-object v0, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$16;->ˋ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    iget-object v0, v0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ˋॱ:Landroid\/widget\/TextView;\r\n\r\n    invoke-virtual {v0, v2}, Landroid\/widget\/TextView;->setText(Ljava\/lang\/CharSequence;)V\r\n\r\n    .line 342\r\n    return-void\r\n.end method\r\n\r\n\r\n```\r\n\r\n\r\n\r\n`PlayVideoActivity$1`代码如下：\r\n\r\n```smali\r\n.class Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$1;\r\n.super Ljava\/lang\/Object;\r\n.source \"\"\r\n\r\n# interfaces\r\n.implements Lchuangyuan\/ycj\/videolibrary\/listener\/VideoInfoListener;\r\n\r\n\r\n# annotations\r\n.annotation system Ldalvik\/annotation\/EnclosingMethod;\r\n    value = Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ʼ()V\r\n.end annotation\r\n\r\n.annotation system Ldalvik\/annotation\/InnerClass;\r\n    accessFlags = 0x0\r\n    name = null\r\n.end annotation\r\n\r\n\r\n# instance fields\r\n.field final synthetic ॱ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n\r\n# direct methods\r\n.method constructor <init>(Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;)V\r\n    .locals 0\r\n\r\n    .line 576\r\n    iput-object p1, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$1;->ॱ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    invoke-direct {p0}, Ljava\/lang\/Object;-><init>()V\r\n\r\n    return-void\r\n.end method\r\n\r\n\r\n# virtual methods\r\n.method public isPlaying(Z)V\r\n    .locals 0\r\n\r\n    .line 638\r\n    return-void\r\n.end method\r\n\r\n.method public onLoadingChanged()V\r\n    .locals 0\r\n\r\n    .line 593\r\n    return-void\r\n.end method\r\n\r\n.method public onPlayEnd()V\r\n    .locals 3\r\n\r\n    .line 612\r\n    iget-object v0, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$1;->ॱ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    iget-object v0, v0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ॱˎ:Lchuangyuan\/ycj\/videolibrary\/video\/ExoUserPlayer;\r\n\r\n    if-eqz v0, :cond_0\r\n\r\n    .line 613\r\n    iget-object v0, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$1;->ॱ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    iget-object v0, v0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ॱˎ:Lchuangyuan\/ycj\/videolibrary\/video\/ExoUserPlayer;\r\n\r\n    invoke-virtual {v0}, Lchuangyuan\/ycj\/videolibrary\/video\/ExoUserPlayer;->onBackPressed()Z\r\n\r\n    .line 618\r\n    :cond_0\r\n    invoke-static {}, Lcom\/okappplay\/playproject\/AppContext;->ˊ()Lcom\/okappplay\/playproject\/AppContext;\r\n\r\n    move-result-object v0\r\n\r\n    invoke-virtual {v0}, Lcom\/okappplay\/playproject\/AppContext;->ˎ()Ljava\/lang\/String;\r\n\r\n    move-result-object v0\r\n\r\n    const-string v1, \"Y\"\r\n\r\n    invoke-virtual {v0, v1}, Ljava\/lang\/String;->equals(Ljava\/lang\/Object;)Z\r\n\r\n    move-result v0\r\n\r\n    if-eqz v0, :cond_2\r\n\r\n    .line 619\r\n    iget-object v0, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$1;->ॱ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    invoke-static {v0}, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ʼ(Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;)Landroid\/os\/CountDownTimer;\r\n\r\n    move-result-object v0\r\n\r\n    if-eqz v0, :cond_1\r\n\r\n    .line 620\r\n    iget-object v0, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$1;->ॱ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    invoke-static {v0}, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ʼ(Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;)Landroid\/os\/CountDownTimer;\r\n\r\n    move-result-object v0\r\n\r\n    invoke-virtual {v0}, Landroid\/os\/CountDownTimer;->cancel()V\r\n\r\n    .line 622\r\n    :cond_1\r\n    iget-object v0, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$1;->ॱ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    invoke-virtual {v0}, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->getApplicationContext()Landroid\/content\/Context;\r\n\r\n    move-result-object v0\r\n\r\n    invoke-static {v0}, Lo\/ก;->ˎ(Landroid\/content\/Context;)Lcom\/okappplay\/playproject\/bean\/UserBean;\r\n\r\n    move-result-object v0\r\n\r\n    invoke-virtual {v0}, Lcom\/okappplay\/playproject\/bean\/UserBean;->getUserType()Ljava\/lang\/String;\r\n\r\n    move-result-object v0\r\n\r\n    invoke-static {v0}, Ljava\/lang\/Integer;->parseInt(Ljava\/lang\/String;)I\r\n\r\n    move-result v2\r\n\r\n    .line 623\r\n    if-gtz v2, :cond_2\r\n\r\n    .line 624\r\n    iget-object v0, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$1;->ॱ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    iget-object v0, v0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ˎ:Landroid\/view\/View;\r\n\r\n    const\/4 v1, 0x0\r\n\r\n    invoke-virtual {v0, v1}, Landroid\/view\/View;->setVisibility(I)V\r\n\r\n    .line 626\r\n    iget-object v0, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$1;->ॱ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    const-string v1, \"\\u6b64\\u7247\\u8bd5\\u770b\\u5df2\\u7ed3\\u675f\\uff0c\\u60a8\\u53ef\\u4ee5\\u7ee7\\u7eed\\u8bd5\\u770b\\u5176\\u4ed6\\u5f71\\u7247\\uff0c\\u6216\\u8005\\u6210\\u4e3a\\u4f1a\\u5458\\u65e0\\u9650\\u89c2\\u770b\\u6240\\u6709\\u5f71\\u7247\"\r\n\r\n    invoke-static {v0, v1}, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ˎ(Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;Ljava\/lang\/String;)V\r\n\r\n    .line 631\r\n    :cond_2\r\n    return-void\r\n.end method\r\n\r\n.method public onPlayStart(J)V\r\n    .locals 2\r\n\r\n    .line 580\r\n    invoke-static {}, Lcom\/okappplay\/playproject\/AppContext;->ˊ()Lcom\/okappplay\/playproject\/AppContext;\r\n\r\n    move-result-object v0\r\n\r\n    invoke-virtual {v0}, Lcom\/okappplay\/playproject\/AppContext;->ˎ()Ljava\/lang\/String;\r\n\r\n    move-result-object v0\r\n\r\n    const-string v1, \"Y\"\r\n\r\n    invoke-virtual {v0, v1}, Ljava\/lang\/String;->equals(Ljava\/lang\/Object;)Z\r\n\r\n    move-result v0\r\n\r\n    if-eqz v0, :cond_0\r\n\r\n    .line 581\r\n    iget-object v0, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$1;->ॱ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    iget-boolean v0, v0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ॱˊ:Z\r\n\r\n    if-eqz v0, :cond_0\r\n\r\n    .line 582\r\n    iget-object v0, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$1;->ॱ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    const\/4 v1, 0x0\r\n\r\n    iput-boolean v1, v0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ॱˊ:Z\r\n\r\n    .line 583\r\n    iget-object v0, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$1;->ॱ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    invoke-static {v0}, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ʼ(Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;)Landroid\/os\/CountDownTimer;\r\n\r\n    move-result-object v0\r\n\r\n    invoke-virtual {v0}, Landroid\/os\/CountDownTimer;->start()Landroid\/os\/CountDownTimer;\r\n\r\n    .line 584\r\n    iget-object v0, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$1;->ॱ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    iget-object v0, v0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ˋॱ:Landroid\/widget\/TextView;\r\n\r\n    const\/4 v1, 0x0\r\n\r\n    invoke-virtual {v0, v1}, Landroid\/widget\/TextView;->setVisibility(I)V\r\n\r\n    .line 588\r\n    :cond_0\r\n    return-void\r\n.end method\r\n\r\n.method public onPlayerError(Lcom\/google\/android\/exoplayer2\/ExoPlaybackException;)V\r\n    .locals 2\r\n    .param p1    # Lcom\/google\/android\/exoplayer2\/ExoPlaybackException;\r\n        .annotation build Landroid\/support\/annotation\/Nullable;\r\n        .end annotation\r\n    .end param\r\n\r\n    .line 597\r\n    iget-object v0, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$1;->ॱ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    iget-boolean v0, v0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ᐝॱ:Z\r\n\r\n    if-nez v0, :cond_0\r\n\r\n    .line 598\r\n    iget-object v0, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$1;->ॱ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    iget-object v0, v0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ʽ:Landroid\/widget\/TextView;\r\n\r\n    const-string v1, \"\\u91cd\\u65b0\\u64ad\\u653e\"\r\n\r\n    invoke-virtual {v0, v1}, Landroid\/widget\/TextView;->setText(Ljava\/lang\/CharSequence;)V\r\n\r\n    .line 599\r\n    iget-object v0, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$1;->ॱ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    const\/4 v1, 0x1\r\n\r\n    iput-boolean v1, v0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ᐝॱ:Z\r\n\r\n    goto :goto_0\r\n\r\n    .line 601\r\n    :cond_0\r\n    iget-object v0, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$1;->ॱ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    invoke-virtual {v0}, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->getApplicationContext()Landroid\/content\/Context;\r\n\r\n    move-result-object v0\r\n\r\n    iget-object v1, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$1;->ॱ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    invoke-static {v1}, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ˏ(Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;)Lcom\/okappplay\/playproject\/bean\/VideoBean;\r\n\r\n    move-result-object v1\r\n\r\n    invoke-static {v0, v1}, Lo\/ก;->ʼ(Landroid\/content\/Context;Lcom\/okappplay\/playproject\/bean\/VideoBean;)Z\r\n\r\n    move-result v0\r\n\r\n    if-eqz v0, :cond_1\r\n\r\n    .line 602\r\n    iget-object v0, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$1;->ॱ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    iget-object v0, v0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ʽ:Landroid\/widget\/TextView;\r\n\r\n    const-string v1, \"\\u611f\\u8c22\\u60a8\\u7684\\u53cd\\u9988\"\r\n\r\n    invoke-virtual {v0, v1}, Landroid\/widget\/TextView;->setText(Ljava\/lang\/CharSequence;)V\r\n\r\n    goto :goto_0\r\n\r\n    .line 604\r\n    :cond_1\r\n    iget-object v0, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$1;->ॱ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    iget-object v0, v0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ʽ:Landroid\/widget\/TextView;\r\n\r\n    const-string v1, \"\\u70b9\\u51fb\\u53cd\\u9988\"\r\n\r\n    invoke-virtual {v0, v1}, Landroid\/widget\/TextView;->setText(Ljava\/lang\/CharSequence;)V\r\n\r\n    .line 608\r\n    :goto_0\r\n    return-void\r\n.end method\r\n\r\n```\r\n\r\n\r\n\r\n可以看出：\r\n\r\n`PlayVideoActivity$6`继承自`handler`,该类没有什么内容，只是重写了`handleMessage`方法。\r\n\r\n`PlayVideoActivity$16`继承自`CountDownTimer`，这是一个倒计时类，而我们的视频就是倒计时几十秒的，可以关注下\r\n\r\n`PlayVideoActivity$1`继承自`Object`，以为没什么用，但是它还实现了`VideoInfoListener`接口，其中有`onPlayStart`、`onPlayEnd`和`onPlayerError`等播放状态回调方法。\r\n\r\n视频倒计时是从点击试看按钮后开始计时的，所以会不会点击试看后调用播放功能当视频播放后回调`onPlayStart`时执行了计时功能？进去该方法看看就知道了\r\n\r\n在`onPlayStart`方法中有这样一段代码：\r\n\r\n```smali\r\n    .line 583\r\n    iget-object v0, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$1;->ॱ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    invoke-static {v0}, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ʼ(Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;)Landroid\/os\/CountDownTimer;\r\n\r\n    move-result-object v0\r\n\r\n    invoke-virtual {v0}, Landroid\/os\/CountDownTimer;->start()Landroid\/os\/CountDownTimer;\r\n```\r\n\r\n翻译过来的意思就是：\r\n\r\n把`PlayVideoActivity$1;->ॱ`这个变量放到`v0`寄存器，这个变量类型是`PlayVideoActivity`\r\n\r\n调用`PlayVideoActivity;->ʼ(Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;)`静态方法返回一个`CountDownTimer`\r\n\r\n把上面方法调用后的返回值放到`v0`寄存器  这个时候`v0`寄存器是一个`CountDownTimer`实例。\r\n\r\n最后调用`CountDownTimer`实例的`start`方法。这里应该就是倒计时开始的地方了。\r\n\r\n> 关于上面做一些说明：\r\n>\r\n> Android是基于寄存器的，Java是基于栈的，所以smali中的v0，p0都是寄存器。\r\n>\r\n> 一些不明所以的符号其实是混淆造成的。\r\n>\r\n> p0是非静态方法的隐形参数，表示调用当前方法的实例 this，所以可知显示传递的参数在smali中从p1开始。\r\n>\r\n> \r\n\r\n既然基本确定了这个倒计时是负责完整视频的，那么就注释掉最后这个虚方法的调用，重新打包签名(见下面)。\r\n\r\n最后运行时发现确实能直接观看完整视频了。\r\n\r\n视频都露点，所以不截图了。\r\n\r\n##### 目标2：同一视频可以多次播放\r\n\r\n现在播放过的视频再次播放提示“此片您已试看过”，不让我再看了。\r\n\r\n初步怀疑是在退出播放\/页面时对当前视频id进行了保存，而且只保存在了本地。。因为我清除数据或者从新安装后能从新观看。\r\n\r\n当再次点击视频进入播放页面时取出该视频id在本地存储里找，如果找到了就弹出提示不给播放。\r\n\r\n所以把“此片您已试看过”转为Unicode码去项目中搜索，发现在`VideoPlayActivity`的`ˏॱ()V`方法里有该字符串使用，相关代码如下：\r\n\r\n```smali\r\n    .line 391\r\n    :cond_2\r\n    const-string v0, \"\\u6b64\\u7247\\u60a8\\u5df2\\u7ecf\\u8bd5\\u770b\\u8fc7\\uff0c\\u60a8\\u53ef\\u4ee5\\u7ee7\\u7eed\\u8bd5\\u770b\\u5176\\u4ed6\\u5f71\\u7247\\uff0c\\u6216\\u8005\\u6210\\u4e3a\\u4f1a\\u5458\\u65e0\\u9650\\u89c2\\u770b\\u6240\\u6709\\u5f71\\u7247\"\r\n\r\n    invoke-direct {p0, v0}, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ˋ(Ljava\/lang\/String;)V\r\n```\r\n\r\n`const-string`表示取出常量字符串放到`v0`寄存器，\r\n\r\n`invoke-direct {p0, v0}`表示调用方法传入参数`p0`，`v0`  这里基本确定里面某个地方会调用弹窗了。\r\n\r\n为什么这里直接调用弹窗呢？直接就执行这个逻辑了吗？\r\n\r\n其实并没有，看上面还有个`:cond_2`，这表示一个跳转地址，\r\n\r\n也就是说在该方法上面地方执行了前面说的视频id比较，经过一些条件判断跳转到了`:cond_2`。\r\n\r\n顺腾摸瓜，果然又发现了`:cond_2 `代码如下：\r\n\r\n```\r\ninvoke-virtual {v1}, Lcom\/okappplay\/playproject\/bean\/VideoBean;->getVideoId()Ljava\/lang\/String;\r\n\r\n    move-result-object v1\r\n\r\n    invoke-static {v0, v1}, Lo\/ก;->ˋॱ(Landroid\/content\/Context;Ljava\/lang\/String;)Z\r\n\r\n    move-result v0\r\n\r\n    if-nez v0, :cond_2\r\n```\r\n\r\n这几句大概意思是：\r\n\r\n调用`getVideoId`返回视频id字符串\r\n\r\n通过`move-result-object`把id存到`v1`寄存器\r\n\r\n调用静态方法`Lo\/ก;->ˋॱ(Landroid\/content\/Context;Ljava\/lang\/String;)Z`返回布尔值\r\n\r\n通过`move-result`把布尔值存到`v0`寄存器\r\n\r\n`if-nez v0` 表示如果` v0`不为0就跳转到刚才的弹窗逻辑。\r\n\r\n感觉看到了希望的曙光，\r\n\r\n既然`v0`不为0就弹窗 ,不让看了，那我让`v0`为0不就好了吗。\r\n\r\n`v0`的值来自于静态方法的执行，进去看看，找到第一个return地方：\r\n\r\n```smali\r\n    invoke-interface {v2, v0, v1}, Landroid\/content\/SharedPreferences;->getString(Ljava\/lang\/String;Ljava\/lang\/String;)Ljava\/lang\/String;\r\n\r\n    move-result-object v3\r\n\r\n    .line 1207\r\n    invoke-static {v3}, Landroid\/text\/TextUtils;->isEmpty(Ljava\/lang\/CharSequence;)Z\r\n\r\n    move-result v0\r\n\r\n    if-eqz v0, :cond_0\r\n\r\n    .line 1208\r\n    const\/4 v0, 0x0\r\n\r\n    return v0\r\n    \r\n    .line 1211\r\n    :cond_0\r\n    new-instance v0, Lcom\/google\/gson\/Gson;\r\n```\r\n\r\n可以看得出来这里确实和我上面猜测的一样，把视频id存在本地了，而且就用sp存的。\r\n\r\n这里逻辑不用管，我们进这个方法目的就是让它返回0的\r\n\r\n第一个`return `返回`v0`寄存器值，而上面一行`const\/4 v0, 0x0 ` 直接把0存到了`v0`寄存器。\r\n\r\n这样就是可以直接观看的了，当然如果能执行到这里的话。\r\n\r\n不过既然弹窗了，那说明`if-eqz v0, :cond_0`这里，地址跳转到了`cond_0`。\r\n\r\n注释掉不给它机会判断就好了。\r\n\r\n按照上面打包签名验证下，果然多次播放也不会给提示了。\r\n\r\n到这里已经完成了非VIP观看完整视频且允许多次观看，如果处于看小视频目的，那已经完成了。\r\n\r\n不过我是为了提升技术的，所以继续目标3、4。\r\n\r\n##### 目标3：去广告\r\n\r\n广告这里不打算去掉页面的显示，只把倒计时7s改为1s，达到进入即播放效果。\r\n\r\n广告是在播放前，点击试看按钮后出现的倒计时。\r\n\r\n倒计时会出现\"广告xs\"的字样，所以去搜索“广告”的Unicode码，发现在内部类`PlayVideoActivity$19`中有使用，这个类是`CountDownTimer`子类，所以在``PlayVideoActivity`某个地方调用了该实例的start方法。\r\n\r\n查找发现只有下面方法中使用了`PlayVideoActivity$19`：\r\n\r\n```smali\r\n.method public ʽ()V\r\n    .locals 6\r\n\r\n    .line 289\r\n\r\n    new-instance v0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$19;\r\n\r\n    iget-object v1, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ˋ:Lcom\/okappplay\/playproject\/bean\/AdResult$AaData;\r\n\r\n    invoke-virtual {v1}, Lcom\/okappplay\/playproject\/bean\/AdResult$AaData;->getShowTime()Ljava\/lang\/String;\r\n\r\n    move-result-object v1\r\n\r\n    invoke-static {v1}, Ljava\/lang\/Integer;->parseInt(Ljava\/lang\/String;)I\r\n\r\n    move-result v1\r\n\r\n    mul-int\/lit16 v1, v1, 0x3e8\r\n\r\n    int-to-long v2, v1\r\n\r\n    move-object v1, p0\r\n\r\n    const-wide\/16 v4, 0x3e8\r\n\r\n    invoke-direct\/range {v0 .. v5}, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$19;-><init>(Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;JJ)V\r\n\r\n    iput-object v0, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ˉ:Landroid\/os\/CountDownTimer;\r\n\r\n    .line 307\r\n    return-void\r\n.end method\r\n```\r\n\r\n`new-instance v0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$19;`表示把`PlayVideoActivity$19`实例存入`v0`寄存器\r\n\r\n`invoke-direct\/range {v0 .. v5}, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$19;-><init>(Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;JJ)V `表示调用`PlayVideoActivity$19`的构造方法，这里把`v0`到`v5`几个寄存器的值都传递过去了。\r\n\r\n查看`PlayVideoActivity$19`构造方法：\r\n\r\n```\r\n# direct methods\r\n.method constructor <init>(Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;JJ)V\r\n    .locals 0\r\n\r\n    .line 289\r\n    iput-object p1, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$19;->ˎ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    invoke-direct {p0, p2, p3, p4, p5}, Landroid\/os\/CountDownTimer;-><init>(JJ)V\r\n\r\n    return-void\r\n.end method\r\n```\r\n\r\n可以看到实参和形参对应关系为：\r\n\r\n`v0`对应`p1`，`v1`对应`p2`，\r\n\r\n`invoke-direct {p0, p2, p3, p4, p5}, Landroid\/os\/CountDownTimer;-><init>(JJ)V`\r\n\r\n看到`p2`(也就是`v1`)表示倒计时总时长，\r\n\r\n所以我们修改`v1`值为1即可。\r\n\r\n只要找到把广告时间存到`v1`的地方，在其后面我们从新给`v1`存个`0x1`应该就可以了。\r\n\r\n可以看到下面这里获取到了广告时间，并且转为int类型存入`v1`：\r\n\r\n```\r\n    invoke-virtual {v1}, Lcom\/okappplay\/playproject\/bean\/AdResult$AaData;->getShowTime()Ljava\/lang\/String;\r\n\r\n    move-result-object v1\r\n   invoke-static {v1}, Ljava\/lang\/Integer;->parseInt(Ljava\/lang\/String;)I\r\n\r\n    move-result v1\r\n```\r\n\r\n所以我们在其后面添加：\r\n\r\n```smali\r\nconst v1,0x1\r\n```\r\n\r\n这时不管从AaData取到的广告值是多少，最后都是1s了。\r\n\r\n从新打包签名后验证即可。\r\n\r\n##### 目标4：去掉电话权限申请\r\n\r\n启动时的权限申请是在欢迎页申请的。\r\n\r\n通过命令行可以知道欢迎页是`WelComeActivity`，它也继承了`BaseActivity`\r\n\r\n去`WelComeActivity`中找实现的那几个抽象方法，看看哪个里面有关于权限申请的代码。\r\n\r\n最终找到如下代码：\r\n\r\n```smali\r\n    const-string v3, \"android.permission.READ_PHONE_STATE\"\r\n\r\n    const\/4 v4, 0x0\r\n\r\n    aput-object v3, v2, v4\r\n\r\n    const-string v3, \"android.permission.WRITE_EXTERNAL_STORAGE\"\r\n\r\n    const\/4 v4, 0x1\r\n\r\n    aput-object v3, v2, v4\r\n\r\n    invoke-static {v0, v1, v2}, Lcom\/okappplay\/playproject\/perssion\/PermissionsUtil;->ˎ(Landroid\/content\/Context;Lo\/م;[Ljava\/lang\/String;)V\r\n```\r\n\r\n第一行就用到了电话权限，\r\n\r\n我们知道权限的申请是按组来的，既然下面申请了\"写存储\"，那我干脆把电话权限改为\"读存储\"。\r\n\r\n让它多余但又不会抱错：\r\n\r\n```\r\n# const-string v3, \"android.permission.READ_PHONE_STATE\"\r\n  const-string v3, \"android.permission.READ_EXTERNAL_STORAGE\"\r\n```\r\n\r\n打包验证发现电话申请权限已经没有了。\r\n\r\n#### 重打包\r\n\r\n`java -jar apktool_2.4.0.jar b llsp -o aa.apk`\r\n\r\n#### 重签名\r\n\r\n`jarsigner -keystore debug.keystore aa.apk androiddebugkey`\r\n\r\n### 最后\r\n\r\n放一个破解后可以观看完整视频的截图：\r\n\r\n![完整视频截图](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/ll-play.png)\r\n\r\n能播放到29分钟，说明几十秒的倒计时已经无效了。\r\n\r\n参考：\r\n\r\napktool下载：https:\/\/ibotpeaches.github.io\/Apktool\/install\/\r\n\r\n关于CountDownTimer使用方法：https:\/\/www.jianshu.com\/p\/949cd818becc\r\n\r\n中文和Unicode互转：https:\/\/www.bejson.com\/convert\/unicode_chinese\/ \r\n\r\n《Android软件安全与逆向分析》\r\n\r\n《Android安全技术揭秘与防范》"
  },
  {
    "title" : "二叉树的遍历",
    "created_time" : "2019-09-25 09:43:09",
    "body" : "## 二叉树定义\r\n\r\n有一个根节点；\r\n\r\n除根节点外，其他每个节点都与其唯一的父节点相连；\r\n\r\n从根节点到其他每个节点都有且仅有一条路径；\r\n\r\n如果每个节点最多有两个子节点，我们就称这样的树为二叉树 \r\n\r\n\r\n\r\n## 二叉树遍历\r\n\r\n![图一](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/%E4%BA%8C%E5%8F%89%E6%A0%91.png)\r\n\r\n树的遍历分为先序遍历、中序遍历和后序遍历。\r\n\r\n初次学习树的遍历时比较难理解这几个定义到底是什么意思，是根据什么来定义先后和中的？\r\n\r\n其实是根据**根节点**调用位置定义的。\r\n\r\n所谓**先序遍历**就是先调用根节点，再遍历左子树，最后遍历右子树。简称“根左右”。\r\n\r\n所谓**中序遍历**就是先遍历左子树，再调用根节点，最后遍历右子树。简称“左根右”。\r\n\r\n所谓**后序遍历**就是先遍历左子树，再遍历右子树，最后调用根节点。简称“左右根”。\r\n\r\n**在调用右子树之前要确保左子树已经全部遍历完成**\r\n\r\n一个熟有左子树、右子树和当前节点值，所以创建二叉树类：\r\n\r\n```kotlin\r\nclass BinaryTree(var left: BinaryTree? = null, \r\n                 var right: BinaryTree? = null, \r\n                 var value: Char = 'A')\r\n\r\n\r\n\/**\r\n生成二叉树\r\n**\/\r\nprivate fun generatorTree(): BinaryTree {\r\n    val gTree = BinaryTree(value = 'G')\r\n    val dTree = BinaryTree(value = 'D', right = gTree)\r\n    val eTree = BinaryTree(value = 'E')\r\n    val bTree = BinaryTree(value = 'B', left = dTree, right = eTree)\r\n    val fTree = BinaryTree(value = 'F')\r\n    val cTree = BinaryTree(value = 'C', left = fTree)\r\n    val rootTree = BinaryTree(value = 'A', left = bTree, right = cTree)\r\n    return rootTree\r\n}\r\n```\r\n\r\n\r\n\r\n### 先序遍历\r\n\r\n先序遍历遍历顺序是“根左右”，\r\n\r\n1、A作为根节点时，A有左右节点，所以顺序为ABC，\r\n\r\n2、B作为根节点时，B有左右节点，所以顺序为BDE，\r\n\r\n3、D作为根节点时，只有右节点，把左节点用0补齐，所以顺序为D0G，\r\n\r\n4、E作为根节点时，没有节点，左右节点用0补齐，所以顺序为E00。\r\n\r\n5、C作为根节点时，只有左节点，右节点用0补齐，所以顺序为CF0。\r\n\r\n6、把2中的值代入到1的B，得到ABDEC，\r\n\r\n7、把3中的值代入到6的D，得到ABD0GEC\r\n\r\n8、把4中的值代入到7的E，得到ABD0GE00C\r\n\r\n9、把5中的值代入到8的C，得到ABD0GECF0\r\n\r\n10、最后消零得到ABDGECF。\r\n\r\n代码实现为：\r\n\r\n```kotlin\r\nprivate fun preorder(tree: BinaryTree?) {\r\n    tree?.let {\r\n        println(\"当前节点为${it.value}\")\r\n        preorder(it.left)\r\n        preorder(it.right)\r\n    }\r\n}\r\n```\r\n\r\n 打印结果为：\r\n\r\n```\r\n当前节点为A\r\n当前节点为B\r\n当前节点为D\r\n当前节点为G\r\n当前节点为E\r\n当前节点为C\r\n当前节点为F\r\n```\r\n\r\n\r\n\r\n### 中序遍历\r\n\r\n中序遍历遍历顺序是“左根右”，\r\n\r\n1、A作为根节点时，有BC节点，顺序为BAC\r\n\r\n2、B作为根节点时，有DE节点 ，顺序为DBE，\r\n\r\n3、D作为根节点时，有右节点G，左节点用0补齐，顺序为0DG，\r\n\r\n4、E作为根节点时，没有节点，用0补齐，顺序为0E0，\r\n\r\n5、C作为根节点时，有左节点F，右节点用0补齐，顺序为FC0。\r\n\r\n6、把2的值代入1中B，得到DBEAC，\r\n\r\n7、把3的值代入6中D，得到0DGBEAC，\r\n\r\n8、把4的值代入7中E，得到0DGB0E0AC，\r\n\r\n9、把5的值代入8中C，得到0DGB0E0AFC0，\r\n\r\n10、消零得到DGBEAFC\r\n\r\n代码实现为：\r\n\r\n```kotlin\r\nprivate fun midOrder(tree: BinaryTree?) {\r\n    tree?.let {\r\n        midOrder(it.left)\r\n        println(\"当前节点为${it.value}\")\r\n        midOrder(it.right)\r\n    }\r\n}\r\n```\r\n\r\n 打印结果为：\r\n\r\n```\r\n当前节点为D\r\n当前节点为G\r\n当前节点为B\r\n当前节点为E\r\n当前节点为A\r\n当前节点为F\r\n当前节点为C\r\n```\r\n\r\n\r\n\r\n### 后序遍历\r\n\r\n后序遍历遍历顺序是“左右根”，\r\n1、A作为根节点时，有BC节点，顺序为BCA\r\n\r\n2、B作为根节点时，有DE节点，顺序为DEB\r\n\r\n3、D作为根节点时，只有右节点G，左节点用0补齐，顺序为0GD\r\n\r\n4、E作为根节点时，没有节点，用0补齐，顺序为00E\r\n\r\n5、C作为根节点时，只有左节点F，右节点用0补齐，顺序为F0C\r\n\r\n6、把2的值代入1的B，得到DEBCA\r\n\r\n7、把3的值代入6的D，得到0GDEBCA\r\n\r\n8、把4的值代入7的E，得到0GD00EBCA\r\n\r\n9、把5的值代入8的C，得到0GD00EBF0CA\r\n\r\n10、消零得到GDEBFCA\r\n\r\n代码实现为：\r\n\r\n```kotlin\r\nprivate fun postOrder(tree: BinaryTree?) {\r\n    tree?.let {\r\n        postOrder(it.left)\r\n        postOrder(it.right)\r\n        println(\"当前节点为${it.value}\")\r\n    }\r\n}\r\n```\r\n\r\n打印结果为：\r\n\r\n```\r\n当前节点为G\r\n当前节点为D\r\n当前节点为E\r\n当前节点为B\r\n当前节点为F\r\n当前节点为C\r\n当前节点为A\r\n```"
  },
  {
    "title" : "Jar包修改并从新打包",
    "created_time" : "2019-10-06 10:32:34",
    "body" : "# 前言\r\n\r\n今天遇到一个奇葩的问题：某人的一个爬虫项目用到一个jar包，里面涉及登录功能。但是用户名和密码在jar里面固定了，现在账号权限没有了，需要使用新的帐号，所以就要从新打jar。\r\n\r\n但是当初做这个项目的人已经消失了，并没有源码，所以我的任务是修改这个jar的内容然后从新打包。\r\n\r\n# 步骤\r\n\r\n任务很直观，步骤也很明显：\r\n\r\n首先生成一个和需要替换的class文件一样的新文件，\r\n\r\n然后替换掉旧文件，\r\n\r\n最后打包。\r\n\r\n下面看看详细的操作步骤，\r\n\r\n## 生成新的替换文件\r\n\r\n### 使用jd-jui打开jar，找到要修改的类，ctrl+s保存为java文件\r\n\r\n![保存java文件](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/modifyjar-savetojava.png)\r\n\r\n### Intellij新建一个java项目，注意package要和修改类的包名保持一致\r\n\r\n如果要修改文件包名为`com.aa.bb`那么新建的package包名也要一样。\r\n\r\n### 如果该类文件依赖其他类，添加该jar包的依赖\r\n\r\n![添加依赖](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/modifyjar-dependency.png)\r\n\r\n### 如果没有报红则build project，生成新class文件\r\n\r\n![新文件](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/modifyjar-newclass.png)\r\n\r\n\r\n\r\n## 替换旧文件\r\n\r\n### 解压jar\r\n\r\n### 用新生成的class文件替换旧文件\r\n\r\n## 打包\r\n\r\n### 使用压缩软件压缩为zip，修改后缀名为jar。"
  },
  {
    "title" : "CompletableFuture基本使用",
    "created_time" : "2019-10-23 09:40:34",
    "body" : "# 前言\r\n\r\n工作中会有不少异步编程地方，看到相关知识点往往涉及`Runnable`和`Callable`。\r\n\r\n但是看下源码就会发现这两个都是函数式接口，功能单一，感觉不是那么好用。\r\n\r\n然后`Future`登场了，提供了取消和获取结果等几个方法：\r\n\r\n```java\r\npublic interface Future<V> {\r\n    boolean cancel(boolean mayInterruptIfRunning);\r\n    boolean isCancelled();\r\n    boolean isDone();\r\n    V get() throws InterruptedException, ExecutionException;\r\n    V get(long timeout, TimeUnit unit)\r\n        throws InterruptedException, ExecutionException, TimeoutException;\r\n}\r\n```\r\n\r\n但是这时候`Future`的使用仍然还是比较简单的，\r\n\r\n在线程池提交任务的时候返回`Future`：\r\n\r\n```\r\n ExecutorService executor = Executors.newSingleThreadExecutor();\r\n Future<String> future = executor.submit(new Callable<String>() {\r\n            @Override\r\n            public String call() throws Exception {\r\n            \t\/\/耗时处理\r\n                return \"\";\r\n            }\r\n        });\r\n```\r\n\r\n在我们依赖异步结果的时候通过`future.get()`获取结果，如果任务还没有完成，这会阻塞当前线程。\r\n\r\n感觉`Future`并没有给我们异步编程带来多大便利，对下面任务它仍然很无力：\r\n\r\n- 将两个异步计算合并为一个——这两个异步计算之间相互独立，同时第二个又依赖于第一个的结果。\r\n- 等待`Future`集合中的所有任务都完成。\r\n- 仅等待`Future`集合中最快结束的任务完成（有可能因为它们试图通过不同的方式计算同一个值），并返回它的结果。\r\n- 应对`Future`的完成事件（即当`Future`的完成事件发生时会收到通知，并能使用`Future`计算的结果进行下一步的操作，不只是简单地阻塞等待操作的结果）。\r\n\r\n好在，JDK8之后Java推出了 `CompletableFuture `，支持非阻塞的多功能`Future`，它的功能包括但不限于上面的任务，可见它的功能强大了。\r\n\r\n下面对`CompletableFuture `方法加以分析：\r\n\r\n\r\n\r\n# 方法解析\r\n\r\n\r\n\r\n## 获取 CompletableFuture 实例\r\n\r\n`CompletableFuture` 提供了静态工厂方法获取实例对象，所以我们不用自己new生成。\r\n\r\n如果`CompletableFuture` 运行后有返回值可以通过`supplyAsync`方法，\r\n\r\n如果没有返回值可以通过`runAsync`方法。\r\n\r\n### runAsync\r\n\r\n不需要返回值时，可以使用`runAsync`获取实例,可以看到有2个名称为`runAsync`的方法：\r\n\r\n```java\r\n public static CompletableFuture<Void> runAsync(Runnable runnable) {\r\n        return asyncRunStage(asyncPool, runnable);\r\n    }\r\n    \r\npublic static CompletableFuture<Void> runAsync(Runnable runnable,\r\n                                                   Executor executor) {\r\n        return asyncRunStage(screenExecutor(executor), runnable);\r\n    }\r\n```\r\n\r\n这里方法重载，第二个参数`executor`为自定义的线程池。\r\n\r\n如果没有设置则使用系统默认的` ForkJoinPool.commonPool()`。\r\n\r\n使用方法：\r\n\r\n```java\r\nCompletableFuture.runAsync(() -> {\r\n            System.out.println(\"runAsync\");\r\n        });\r\n```\r\n\r\n\r\n\r\n### supplyAsync\r\n\r\n如果需要返回值，可以使用`supplyAsync`获取实例，可以看到也有2个名称为`supplyAsync`的方法：\r\n\r\n```java\r\n    public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier) {\r\n        return asyncSupplyStage(asyncPool, supplier);\r\n    }\r\n    public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier,\r\n                                                       Executor executor) {\r\n        return asyncSupplyStage(screenExecutor(executor), supplier);\r\n    }\r\n```\r\n\r\n使用方法：\r\n\r\n```java\r\n CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {\r\n            return \"supplyAsync\";\r\n        });\r\n        System.out.println(future.join());\r\n```\r\n\r\n\r\n\r\n## 等待任务完成\r\n\r\n如果我们想阻塞当前线程直到任务完成，可以使用`get`和`join`两种方法。\r\n\r\n`get` 方法抛出的 ExecutionException 是一个受检异常（checked exception）。\r\n`join` 方法与 `get `方法相同，不同之处在于，如果异常出现， `join`方法将抛出\r\n由底层异常所引发的 CompletionException，它是一个非受检异常（unchecked\r\nexception）  \r\n\r\n### get\r\n\r\n`get`有2个方法：\r\n\r\n```java\r\npublic T get() throws InterruptedException, ExecutionException {\r\n        Object r;\r\n        return reportGet((r = result) == null ? waitingGet(true) : r);\r\n}\r\n\r\npublic T get(long timeout, TimeUnit unit)\r\n        throws InterruptedException, ExecutionException, TimeoutException {\r\n        Object r;\r\n        long nanos = unit.toNanos(timeout);\r\n        return reportGet((r = result) == null ? timedGet(nanos) : r);\r\n}\r\n```\r\n\r\n其中`public T get(long timeout, TimeUnit unit)`表示为延迟`timeout`时间后没有返回值则抛出异常。\r\n\r\n使用方法：\r\n\r\n```java\r\n CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {\r\n            return \"supplyAsync\";\r\n        });\r\n        try {\r\n            String result = future.get();\r\n            System.out.println(result);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        } catch (ExecutionException e) {\r\n            e.printStackTrace();\r\n        }\r\n```\r\n\r\n\r\n\r\n### join\r\n\r\n使用方法：\r\n\r\n```java\r\nCompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> {\r\n            return \"supplyAsync-1\";\r\n        });\r\nSystem.out.println(future1.join());\r\n```\r\n\r\n在`join`和`get`之间，我更倾向于使用`join`，不用每次都`try catch`。而且`CompletableFuture`后面有专门的异常处理方法。\r\n\r\n### getNow\r\n\r\n这里还有一个不常用方法，\r\n\r\n看下方法：\r\n\r\n```java\r\npublic T getNow(T valueIfAbsent) {\r\n        Object r;\r\n        return ((r = result) == null) ? valueIfAbsent : reportJoin(r);\r\n}\r\n```\r\n\r\n调用`getNow`时，如果任务没有完成，不进行阻塞等待，而是直接返回值`valueIfAbsent`。\r\n\r\n使用方法：\r\n\r\n```java\r\nCompletableFuture future2 = CompletableFuture.supplyAsync(() -> {\r\n            sleep(2000);\r\n            return \"hello\";\r\n        });\r\nSystem.out.println(future2.getNow(\"world\"));\/\/打印world\r\n```\r\n\r\n\r\n\r\n## 完成任务\r\n\r\n###   complete  \r\n\r\nfuture调用`complete(T t)` 会立即执行。 但是`complete(T t)` 只能调用一次， 后续的重复调用会失效。\r\n\r\n如果future已经执行完毕能够返回结果， 此时再调用`complete(T t)` 则会无效。\r\n\r\n使用方法：\r\n\r\n```java\r\nCompletableFuture future3 = CompletableFuture.supplyAsync(() -> \"hello\");\r\nfuture3.complete(\"world\");\r\nSystem.out.println(future3.join());\/\/打印world\r\n```\r\n\r\n###   completeExceptionally  \r\n\r\n使用`completeExceptionally（Throwable ex)`则抛出一个异常， 而不是一个成功的结果。  \r\n\r\n使用方法：\r\n\r\n```java\r\nCompletableFuture future4 = CompletableFuture.supplyAsync(() -> \"hello\");\r\n        future4.completeExceptionally(new Exception(\"exception..\"));\r\n        try {\r\n            future4.get();\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        } catch (ExecutionException e) {\r\n            e.printStackTrace();\r\n        }\r\n```\r\n\r\n\r\n\r\n## thenApply\r\n\r\n`thenApply`的功能相当于将CompletableFuture＜t＞转换成Completablefuture＜U＞。  \r\n\r\nfuture执行完成后紧接着把结果通过函数参数传递到`thenApply`，然后继续处理future结果并返回一个新的future。\r\n\r\n| 方法名                                                       | 描述                       |\r\n| :----------------------------------------------------------- | :------------------------- |\r\n| public <U> CompletableFuture<U> thenApply(Function<? super T,? extends U> fn) | 使用上一个任务所在线程执行 |\r\n| public <U> CompletableFuture<U> thenApplyAsync(Function<? super T,? extends U> fn) | 使用Fork.joinPool线程池    |\r\n| public <U> CompletableFuture<U> thenApplyAsync(Function<? super T,? extends U> fn, Executor executor) | 指定线程池                 |\r\n\r\n使用方法：\r\n\r\n```java\r\nCompletableFuture<String> future = CompletableFuture.supplyAsync(() -> \"hello\").thenApplyAsync((str) -> str + \" world\");\r\nSystem.out.println(future.join());\r\n```\r\n\r\n\r\n\r\n## thenCompose\r\n\r\n`thenCompose` 可用于组合多个 `CompletableFuture`， 将前一个结果作为下一个计算\r\n的参数， 它们之间存在着先后顺序。  它是连接多个`CompletableFuture `\r\n\r\n\r\n\r\n| 方法名                                                       | 描述                       |\r\n| :----------------------------------------------------------- | :------------------------- |\r\n| public <U> CompletableFuture<U> thenCompose(    Function<? super T, ? extends CompletionStage<U>> fn) | 使用上一个任务所在线程执行 |\r\n| public <U> CompletableFuture<U> thenComposeAsync(    Function<? super T, ? extends CompletionStage<U>> fn) | 使用Fork.joinPool线程池    |\r\n| public <U> CompletableFuture<U> thenComposeAsync(    Function<? super T, ? extends CompletionStage<U>> fn,    Executor executor) | 指定线程池                 |\r\n\r\n使用方法：\r\n\r\n```java\r\n CompletableFuture future1 = CompletableFuture.supplyAsync(() -> {\r\n            System.out.println(Thread.currentThread().getName());\r\n            return \"hello\";\r\n        }).thenCompose(str -> CompletableFuture.supplyAsync(() -> {\r\n            System.out.println(Thread.currentThread().getName());\r\n            return (str + \" world\");\r\n        })).thenApplyAsync(str -> CompletableFuture.supplyAsync(() -> {\r\n            System.out.println(Thread.currentThread().getName());\r\n            return str + \" last\";\r\n        }));\r\n        System.out.println(future1.join());\r\n```\r\n\r\n\r\n\r\n##   thenCombine  \r\n\r\n使用`thenCombine` 之后， future1、 future2之间是并行执行的， 最后再将结果汇总并返回。 \r\n\r\n| 方法名                                                       | 描述                    |\r\n| ------------------------------------------------------------ | ----------------------- |\r\n| public <U,V> CompletableFuture<V> thenCombine(    CompletionStage<? extends U> other,    BiFunction<? super T,? super U,? extends V> fn) |                         |\r\n| public <U,V> CompletableFuture<V> thenCombineAsync(    CompletionStage<? extends U> other,    BiFunction<? super T,? super U,? extends V> fn) | 使用Fork.joinPool线程池 |\r\n| public <U,V> CompletableFuture<V> thenCombineAsync(    CompletionStage<? extends U> other,    BiFunction<? super T,? super U,? extends V> fn, Executor executor) | 指定线程池              |\r\n\r\n使用方法：\r\n\r\n```java\r\n        CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> {\r\n            return \"hello\";\r\n        });\r\n\r\n        CompletableFuture<String> future3 = CompletableFuture.supplyAsync(() -> {\r\n            return \"world\";\r\n        });\r\n        CompletableFuture<String> future5 = future2.thenCombine(future3, (s1, s2) -> {\r\n            return s1 + \"##\" + s2;\r\n        });\r\n        System.out.println(future5.join());\r\n```\r\n\r\n\r\n\r\n## thenAcceptBoth\r\n\r\n上面说了`thenCombine` 是将结果汇总并返回，那如果不需要返回就可以使用`thenAcceptBoth`。\r\n\r\n返回`Void`类型泛型。\r\n\r\n| 方法名                                                       | 描述                    |\r\n| ------------------------------------------------------------ | ----------------------- |\r\n| public <U> CompletableFuture<Void> thenAcceptBoth(    CompletionStage<? extends U> other,    BiConsumer<? super T, ? super U> action) |                         |\r\n| public <U> CompletableFuture<Void> thenAcceptBothAsync(    CompletionStage<? extends U> other,    BiConsumer<? super T, ? super U> action) | 使用Fork.joinPool线程池 |\r\n| public <U> CompletableFuture<Void> thenAcceptBothAsync(    CompletionStage<? extends U> other,    BiConsumer<? super T, ? super U> action, Executor executor) | 指定线程池              |\r\n\r\n使用方法：\r\n\r\n```java\r\nCompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> {\r\n            return \"hello\";\r\n        });\r\n\r\nCompletableFuture<String> future3 = CompletableFuture.supplyAsync(() -> {\r\n            return \"world\";\r\n        });\r\nCompletableFuture<Void> future5 = future2.thenAcceptBothAsync(future3, (s1, s2) -> {\r\n            System.out.println(s1 + \"##\" + s2);\r\n        });\r\nSystem.out.println(future5.join());\r\n```\r\n\r\n\r\n\r\n## whenComplete\r\n\r\n 当`CompletableFuture`的计算结果完成，或者抛出异常的时候，都可以进入`whenComplete`方法对结果进行处理。\r\n\r\n| 方法名                                                       | 描述                    |\r\n| ------------------------------------------------------------ | ----------------------- |\r\n| public CompletableFuture<T> whenComplete(    BiConsumer<? super T, ? super Throwable> action) |                         |\r\n| public CompletableFuture<T> whenCompleteAsync(    BiConsumer<? super T, ? super Throwable> action) | 使用Fork.joinPool线程池 |\r\n| public CompletableFuture<T> whenCompleteAsync(    BiConsumer<? super T, ? super Throwable> action, Executor executor) | 指定线程池              |\r\n\r\n使用方法：\r\n\r\n```java\r\n        CompletableFuture.supplyAsync(() -> \"hello\")\r\n                .thenApply((s1) -> s1 + \"@@\")\r\n                .whenCompleteAsync((result, throwable) -> {\r\n                    System.out.println(result);\r\n                });\r\n```\r\n\r\n\r\n\r\n## handle\r\n\r\n 当`CompletableFuture`的计算结果完成，或者抛出异常的时候，可以通过`handle`方法对结果进行处理 。\r\n\r\n`handle`和`whenComplete`相比，`whenComplete`是没有返回值的，而`handle`是有返回值的。\r\n\r\n| 方法名                                                       | 描述 |\r\n| ------------------------------------------------------------ | ---- |\r\n| public <U> CompletionStage<U> handle    (BiFunction<? super T, Throwable, ? extends U> fn); |      |\r\n| public <U> CompletionStage<U> handleAsync    (BiFunction<? super T, Throwable, ? extends U> fn); |      |\r\n| public <U> CompletionStage<U> handleAsync    (BiFunction<? super T, Throwable, ? extends U> fn,     Executor executor); |      |\r\n\r\n使用方法：\r\n\r\n```java\r\n        CompletableFuture future = CompletableFuture.supplyAsync(() -> \"hello\")\r\n                .thenApply((s1) -> s1 + \"@@\")\r\n                .handleAsync((result, throwable) -> {\r\n                    System.out.println(result);\r\n                    return result;\r\n                });\r\n        System.out.println(future.join());\r\n```\r\n\r\n\r\n\r\n## thenAccept\r\n\r\n  `thenAccept` 是只会对计算结果进行消费而不会返回任何结果的方法。  \r\n\r\n| 方法名                                                       | 描述 |\r\n| ------------------------------------------------------------ | ---- |\r\n| public CompletionStage<Void> thenAccept(Consumer<? super T> action); |      |\r\n| public CompletionStage<Void> thenAcceptAsync(Consumer<? super T> action); |      |\r\n| public CompletionStage<Void> thenAcceptAsync(Consumer<? super T> action,                                             Executor executor); |      |\r\n\r\n使用方法：\r\n\r\n```java\r\n        CompletableFuture future = CompletableFuture.supplyAsync(() -> \"hello\")\r\n                .thenApply((s1) -> s1 + \"@@\")\r\n                .thenAcceptAsync(s -> System.out.println(s));\r\n\r\n        future.join();\r\n```\r\n\r\n\r\n\r\n## acceptEither\r\n\r\n`acceptEither`表示的是两个Future， 当其中任意一个Future计算完成的时候就会执行 。\r\n\r\n| 方法名                                                       | 描述 |\r\n| ------------------------------------------------------------ | ---- |\r\n| public CompletionStage<Void> acceptEither    (CompletionStage<? extends T> other,     Consumer<? super T> action); |      |\r\n| public CompletionStage<Void> acceptEitherAsync    (CompletionStage<? extends T> other,     Consumer<? super T> action); |      |\r\n| public CompletionStage<Void> acceptEitherAsync    (CompletionStage<? extends T> other,     Consumer<? super T> action,     Executor executor); |      |\r\n\r\n使用方法：\r\n\r\n```java\r\n  CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> \"jenson\");\r\n  CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> \"hello\");\r\n  CompletableFuture<Void> future = future1.acceptEither(future2, o -> \t     \tSystem.out.println(o));\r\n  future.join();\r\n\r\n```\r\n\r\n\r\n\r\n##   applyToEither\r\n\r\n`applyToEither` 与 `acceptEither` 类似，\r\n\r\n`applyToEither` 有返回值，`acceptEither` 没有返回值。\r\n\r\n| 方法名                                                       | 描述 |\r\n| ------------------------------------------------------------ | ---- |\r\n| public <U> CompletionStage<U> applyToEither    (CompletionStage<? extends T> other,     Function<? super T, U> fn); |      |\r\n| public <U> CompletionStage<U> applyToEitherAsync    (CompletionStage<? extends T> other,     Function<? super T, U> fn); |      |\r\n| public <U> CompletionStage<U> applyToEitherAsync    (CompletionStage<? extends T> other,     Function<? super T, U> fn,     Executor executor); |      |\r\n\r\n使用方法：\r\n\r\n```java\r\nCompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> \"jenson\");\r\nCompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> \"hello\");\r\nCompletableFuture<String> future = future1.applyToEitherAsync(future2, s -> s);\r\nSystem.out.println(\"result=\" + future.join());\r\n```\r\n\r\n\r\n\r\n## allOf\r\n\r\n| 方法名                                                       | 描述                                                |\r\n| ------------------------------------------------------------ | --------------------------------------------------- |\r\n| public static CompletableFuture<Void> allOf(CompletableFuture<?>... cfs) | 在所有future完成后，返回一个CompletableFuture<Void> |\r\n\r\n\r\n\r\n使用方法：\r\n\r\n```java\r\n val future2 = CompletableFuture.supplyAsync { \"hello\" }\r\n val future3 = CompletableFuture.supplyAsync { \"jenson\" }\r\n val future4 = CompletableFuture.supplyAsync { \"qq\" }\r\n CompletableFuture.allOf(future2, future3, future4).join()\r\n```\r\n\r\n\r\n\r\n## anyOf\r\n\r\n`anyOf`和`acceptEither`、 `applyToEither`的区别在于，\r\n\r\n 后两者只能使用在两个future中， 而`anyOf`可以使用在多个future中。  \r\n\r\n\r\n\r\n## 异常处理\r\n\r\n`CompletableFuture`在运行时如果遇到异常， 则可以使用`get` 并抛出异常进行处理，\r\n\r\n 但这并不是一个最好的方法。 `CompletableFuture`本身也提供了几种方式来处理异常。\r\n\r\n###   Exceptionally  \r\n\r\n| 方法名                                                       | 描述                                                 |\r\n| ------------------------------------------------------------ | ---------------------------------------------------- |\r\n| public CompletionStage<T> exceptionally    (Function<Throwable, ? extends T> fn); | 只有future抛出异常时候才触发这个方法调用fn函数计算。 |\r\n\r\n使用方法：\r\n\r\n```java\r\nCompletableFuture.supplyAsync(() -> \"jenson\").thenApply(s -> {\r\n            s = null;\r\n            return s.length();\r\n        }).exceptionally(t -> {\r\n            System.out.println(t.getMessage());\r\n            return null;\r\n        }).join();\r\n```\r\n\r\n###   whenComplete  \r\n\r\n`whenComplete` 在前面已经介绍过了， 在这里跟`exceptionally`的作用差不多， \r\n\r\n可以捕获任意阶段的异常。 如果没有异常， 就执行action。  \r\n\r\n### handle\r\n\r\n  与`whenComplete`相似的方法是`handle`。"
  },
  {
    "title" : "Android性能优化整理",
    "created_time" : "2019-10-30 07:22:43",
    "body" : "# 图\r\n\r\n\r\n\r\n![Android性能优化图](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%9B%BE.png)\r\n\r\n\r\n\r\n# 文章\r\n\r\n[浅谈Android性能优化系列(0)之为什么需要性能优化](http:\/\/www.jenson.top\/post\/26\/)\r\n\r\n[浅谈Android性能优化系列(1)之安装包大小优化]( http:\/\/www.jenson.top\/post\/27\/ )\r\n\r\n[浅谈Android性能优化系列(2)之稳定性优化]( http:\/\/www.jenson.top\/post\/28\/ )\r\n\r\n[浅谈Android性能优化系列(3)之网络优化]( http:\/\/www.jenson.top\/post\/30\/ )\r\n\r\n[浅谈Android性能优化系列(4)之耗电优化]( http:\/\/www.jenson.top\/post\/29\/ )\r\n\r\n[浅谈Android性能优化系列(5)之UI优化]( http:\/\/www.jenson.top\/post\/31\/ )\r\n\r\n[浅谈Android性能优化系列(6)之内存优化]( http:\/\/www.jenson.top\/post\/32\/ )\r\n\r\n[浅谈Android性能优化系列工具篇之Battery Historian电量检测工具使用]( http:\/\/www.jenson.top\/post\/122\/ )\r\n\r\n[浅谈Android性能优化系列工具篇之MAT使用]( http:\/\/www.jenson.top\/post\/62\/ )\r\n\r\n[关于FileMonitor的想法和实现](http:\/\/www.jenson.top\/post\/139\/)"
  },
  {
    "title" : "关于FileMonitor的想法和实现",
    "created_time" : "2019-11-02 12:17:29",
    "body" : "# 0x00 前言\r\n\r\nAndroid为我们提供了很多好用的工具，以便我们能从各个角度来分析查找出App中的缺陷。\r\n\r\n比如UI优化的Hierarchy Viewer、方法检测的TraceView、内存泄漏的Mat。\r\n\r\n但是发现Android常用的工具里面对IO操作分析监控工具比较少，或者说没有？\r\n\r\n已知的检测IO的StrictMode也只能检测主线程的磁盘操作，对于IO的分析及优化是不能达到的。\r\n\r\n所以就萌生了自己实现一个IO监控工具的想法。\r\n<!-- more -->\r\n\r\n# 0x01 目标\r\n\r\n有了想法，但也不要着急去做，首先要去细化要实现什么样的功能？\r\n\r\n这里IO监控暂时只想监控文件IO，不包括sqlite。\r\n\r\n想实现：\r\n\r\n- 监控文件的打开、读写、关闭状态、次数及耗时。\r\n- 当前操作文件的线程、进程及堆栈信息\r\n- 当前文件路径\r\n\r\n# 0x02 尝试\r\n\r\n## 文件IO流程简单分析\r\n\r\n很多多黑科技的实现不过是**动态代理**的具体应用。\r\n\r\n要做文件IO监控，首先查看文件从Java到Native的流程。\r\n\r\n看看能不能从中找到hook点。\r\n\r\n我们知道文件的操作都是通过流来完成，\r\n\r\n所以我随便点开了个`FileOutputStream`源码，看看里面`write`方法如何实现的：\r\n\r\n![image-20191102175146704](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/%E6%96%87%E4%BB%B6%E7%9B%91%E6%8E%A7-write%E6%96%B9%E6%B3%95.png)\r\n\r\n让人蛋疼的情况出现了，这刚走一步，就出现了框架类`IoBridge`，通过应用层不能继续深入源码了。\r\n\r\n所以只能通过Android源码里去分析，源码位置为：\r\n\r\n`E:\\AndroidSource\\Android-8.0.0_r9\\libcore\\luni\\src\\main\\java\\libcore\\io\\IoBridge.java`\r\n\r\n其`write`方法为：\r\n\r\n```java\r\n    public static void write(FileDescriptor fd, byte[] bytes, int byteOffset, int byteCount) throws IOException {\r\n        Arrays.checkOffsetAndCount(bytes.length, byteOffset, byteCount);\r\n        if (byteCount == 0) {\r\n            return;\r\n        }\r\n        try {\r\n            while (byteCount > 0) {\r\n                int bytesWritten = Libcore.os.write(fd, bytes, byteOffset, byteCount);\r\n                byteCount -= bytesWritten;\r\n                byteOffset += bytesWritten;\r\n            }\r\n        } catch (ErrnoException errnoException) {\r\n            throw errnoException.rethrowAsIOException();\r\n        }\r\n    }\r\n```\r\n\r\n这里的核心部分就是`Libcore.os.write(fd, bytes, byteOffset, byteCount);`\r\n\r\n进去看看这个`Libcore`的实现：\r\n\r\n```java\r\npublic final class Libcore {\r\n    private Libcore() { }\r\n\r\n    \/**\r\n     * Direct access to syscalls. Code should strongly prefer using {@link #os}\r\n     * unless it has a strong reason to bypass the helpful checks\/guards that it\r\n     * provides.\r\n     *\/\r\n    public static Os rawOs = new Linux();\r\n\r\n    \/**\r\n     * Access to syscalls with helpful checks\/guards.\r\n     *\/\r\n    public static Os os = new BlockGuardOs(rawOs);\r\n}\r\n```\r\n\r\n可以看到`LibCore`的实现非常简单，所以可以确定干货都在`OS`里面。\r\n\r\n这个`OS`其实是个接口，里面定义了所有对于文件操作，方法比较多，这里随便找几个方法看看：\r\n\r\n```java\r\npublic interface Os {\r\n    public FileDescriptor accept(FileDescriptor fd, SocketAddress peerAddress) throws ErrnoException, SocketException;\r\n    public void chmod(String path, int mode) throws ErrnoException;\r\n    public int pread(FileDescriptor fd, ByteBuffer buffer, long offset) throws ErrnoException, InterruptedIOException;\r\n    public int pread(FileDescriptor fd, byte[] bytes, int byteOffset, int byteCount, long offset) throws ErrnoException, InterruptedIOException;\r\n    public int pwrite(FileDescriptor fd, ByteBuffer buffer, long offset) throws ErrnoException, InterruptedIOException;\r\n    public int pwrite(FileDescriptor fd, byte[] bytes, int byteOffset, int byteCount, long offset) throws ErrnoException, InterruptedIOException;\r\n    public int read(FileDescriptor fd, ByteBuffer buffer) throws ErrnoException, InterruptedIOException;\r\n    public int read(FileDescriptor fd, byte[] bytes, int byteOffset, int byteCount) throws ErrnoException, InterruptedIOException;\r\n    public void rename(String oldPath, String newPath) throws ErrnoException;\r\n    public int write(FileDescriptor fd, ByteBuffer buffer) throws ErrnoException, InterruptedIOException;\r\n    public int write(FileDescriptor fd, byte[] bytes, int byteOffset, int byteCount) throws ErrnoException, InterruptedIOException;\r\n    public int writev(FileDescriptor fd, Object[] buffers, int[] offsets, int[] byteCounts) throws ErrnoException, InterruptedIOException;\r\n}\r\n\r\n```\r\n\r\n既然`OS`是接口，那自然就有实现类，看下它的继承关系图：\r\n\r\n![image-20191102181510086](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/%E6%96%87%E4%BB%B6%E7%9B%91%E6%8E%A7-OS%E7%BB%A7%E6%89%BF%E5%9B%BE.png)\r\n\r\n其中`Linux`里面是`native`方法，调用JNI层。\r\n\r\n刚才看到`Libcore`的`os`是这样的：\r\n\r\n`public static Os os = new BlockGuardOs(rawOs);`\r\n\r\n所以`Libcore.os.write`方法其实调用的是`BlockGuardOs`中的方法，进去看看内容：\r\n\r\n```java\r\n    @Override public int write(FileDescriptor fd, ByteBuffer buffer) throws ErrnoException, InterruptedIOException {\r\n        BlockGuard.getThreadPolicy().onWriteToDisk();\r\n        return os.write(fd, buffer);\r\n    }\r\n```\r\n\r\n这里又调用了`os.write`方法。\r\n\r\n这个`os`变量就是`public static Os os = new BlockGuardOs(rawOs);`中的`rawOs`。\r\n\r\n也就是说从这开始进入`native`方法了，看下实现：\r\n\r\n```java\r\npublic int write(FileDescriptor fd, ByteBuffer buffer) throws ErrnoException, InterruptedIOException {\r\n        final int bytesWritten;\r\n        final int position = buffer.position();\r\n        if (buffer.isDirect()) {\r\n            bytesWritten = writeBytes(fd, buffer, position, buffer.remaining());\r\n        } else {\r\n            bytesWritten = writeBytes(fd, NioUtils.unsafeArray(buffer), NioUtils.unsafeArrayOffset(buffer) + position, buffer.remaining());\r\n        }\r\n\r\n        maybeUpdateBufferPosition(buffer, position, bytesWritten);\r\n        return bytesWritten;\r\n    }\r\n    public int write(FileDescriptor fd, byte[] bytes, int byteOffset, int byteCount) throws ErrnoException, InterruptedIOException {\r\n        \/\/ This indirection isn't strictly necessary, but ensures that our public interface is type safe.\r\n        return writeBytes(fd, bytes, byteOffset, byteCount);\r\n    }\r\n    private native int writeBytes(FileDescriptor fd, Object buffer, int offset, int byteCount) throws ErrnoException, InterruptedIOException;\r\n    public native int writev(FileDescriptor fd, Object[] buffers, int[] offsets, int[] byteCounts) throws ErrnoException, InterruptedIOException;\r\n\r\n```\r\n\r\n通过`write`调用了`native`方法的`writeBytes`。\r\n\r\n至此，流程就简单分析完了。\r\n\r\n## 寻找hook点\r\n\r\nJava层流程分析完了，接下来就是在Java层寻找hook点。\r\n\r\n如果没有合适点，再去寻找Native层。\r\n\r\n因为我们要统计open、close、read、write四个地方。\r\n\r\n所以一个不错的方案是自定义一个类`BlockGuardOSProxy`继承`ForwardingOs`,实现我们需要的方法，\r\n\r\n然后找个合适的点，用我们的类替换掉系统的类，当对文件IO操作时，会回调到我们类重写的方法。\r\n\r\n在我们的方法中添加相关分析，然后继续调用系统层，让流程继续，这是代理思想。\r\n\r\n可以看下时序图：\r\n\r\n![image-20191102185450269](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/%E6%96%87%E4%BB%B6%E7%9B%91%E6%8E%A7-%E5%8E%9F%E6%97%B6%E5%BA%8F%E5%9B%BE.png)\r\n\r\n\r\n\r\n刚才我们看到`Libcore`中`os`变量是`public`的。\r\n\r\n所以我们可以把这个`os`变量变成我们的`BlockGuardOSProxy`。然后在我们方法里面调用`BlockGuardOs`。\r\n\r\n这样既拦截了我们想要的方法，又不会影响流程。这样最新流程就是这样的：\r\n\r\n![image-20191102185845650](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/%E6%96%87%E4%BB%B6%E7%9B%91%E6%8E%A7-%E6%96%B0%E6%97%B6%E5%BA%8F%E5%9B%BE.png)\r\n\r\n\r\n\r\n## 如何修改\r\n\r\n经过上面的分析，已经基本找到了hook点。接下来如何修改呢？\r\n\r\n```java\r\nLibcore.os = BlockGuardOSProxy(Libcore.os)\r\n```\r\n\r\n在`Application`方法里加上这样一句应该就可以完成替换了。\r\n\r\n其余的工作只要在`BlockGuardOSProxy`处理就好了。\r\n\r\n但是现在又要面临一个问题，就是`Libcore`和`ForwardingOs`这些类在应用层不存在不能编译通过。\r\n\r\n看看源码结构图：\r\n\r\n![image-20191102190806076](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/%E6%96%87%E4%BB%B6%E7%9B%91%E6%8E%A7-libcore%E4%BB%A3%E7%A0%81%E6%88%AA%E5%9B%BE.png)\r\n\r\n通过源码结构图发现里面有`src`目录，这分明也是一个小项目类型。\r\n\r\n所以这里面的代码应该是独立能编译的。\r\n\r\n既然都是java代码那我们也就可以打成一个jar包。\r\n\r\njar包有了，放到我们的项目libs下就可以了。\r\n\r\n不过其实不用我们自己动手打包，网上有现成的，也可以从自己ROM中提取，位置是：\r\n\r\n`\/system\/framework\/core-libart.jar`\r\n\r\n至此，文件IO监控已经完成，我们只使用了简单的静态代理。\r\n\r\n# 0x03 测试\r\n\r\n很多时候很多数据是需要缓存的，\r\n\r\n一般的缓存不是存sqlite就是File缓存。\r\n\r\n而对于不涉及隐私安全的，使用File缓存可以得到更好的性能。\r\n\r\n比如微博每条动态，谁都可以看，所以缓存时使用File缓存也可以。\r\n\r\n我们自定义一个数据类：\r\n\r\n```kotlin\r\ndata class WBItem(var textContent: String? = null,\r\n                  var imgUrl: String? = null,\r\n                  var good: Int = 0) : Serializable\r\n```\r\n\r\n对象序列化使用`ObjectOutputStream`，现在我们把200条信息缓存到本地File：\r\n\r\n```kotlin\r\n    private fun writeWBItemWithoutBuffer() {\r\n        thread {\r\n            val dir = Environment.getExternalStorageDirectory()\r\n            val mdir = File(\"${dir.path}${File.separator}monitor\")\r\n            val file1 = File(\"${mdir.path}${File.separator}wb.cache\")\r\n            if (checkFile()) {\r\n                LogUtils.e(file1.path)\r\n                val fos: OutputStream = FileOutputStream(file1)\r\n                val data = arrayListOf<WBItem>()\r\n                val oos = ObjectOutputStream(fos)\r\n                for (i in 0..200) {\r\n                    val wbItem = WBItem().apply {\r\n                        textContent = \"这是文本内容--$i\"\r\n                        imgUrl = \"这是图片url--$i\"\r\n                        good = i\/\/点赞数\r\n                    }\r\n                    data.add(wbItem)\r\n                }\r\n                oos.writeObject(data)\r\n                oos.flush()\r\n                oos.close()\r\n                fos.close()\r\n            }\r\n        }\r\n    }\r\n```\r\n\r\n打印Log如下：\r\n\r\n```\r\nFileWrap(fdInt=59, fd=java.io.FileDescriptor@b5e92d3, \r\npid=12323, tid=12371, mode=1, \r\npath=\/storage\/emulated\/0\/monitor\/wb.cache, \r\nopenTime=1572695396436, closeTime=1572695396532, \r\nprocess=null, thread=Thread-2, \r\nreadCount=0, readBytes=0, readTime=0, \r\nwriteCount=611, writeBytes=11793, writeTime=96, stacktrace=java.io.FileOutputStream.write(FileOutputStream.java:381)\r\n    java.io.ObjectOutputStream$BlockDataOutputStream.drain(ObjectOutputStream.java:1973)\r\n    java.io.ObjectOutputStream$BlockDataOutputStream.setBlockDataMode(ObjectOutputStream.java:1855)\r\n    java.io.ObjectOutputStream.<init>(ObjectOutputStream.java:253)\r\n    top.jenson.filemonitor.MainActivity$writeWBItemWithoutBuffer$1.invoke(MainActivity.kt:116)\r\n    top.jenson.filemonitor.MainActivity$writeWBItemWithoutBuffer$1.invoke(MainActivity.kt:12)\r\n    kotlin.concurrent.ThreadsKt$thread$thread$1.run(Thread.kt:30)\r\n    )\r\n```\r\n\r\n其中：\r\n\r\n`path`表示操作的文件路径\r\n\r\n通过`closeTime`-`openTime`可以计算出文件耗时。\r\n\r\n`stacktrace`表示调用堆栈，可以快速定位到问题位置。\r\n\r\n`readCount`表示读取次数，我们这里是写对象，自然为0了。\r\n\r\n`writeCount`表示写入次数，这里显示611次，200个对象写入这么多次？？？，\r\n\r\n后来查证，好像每个对象的每个属性都要被写入一次，再加上系统一些附加的。那就差不多了。\r\n\r\n不过这也就说明了200个对象，10多kb文件，写入如此高的次数是需要优化的。\r\n\r\n下面看看使用了buffer后的代码实现：\r\n\r\n```kotlin\r\nprivate fun writeWBItemWithBuffer() {\r\n        thread {\r\n            val dir = Environment.getExternalStorageDirectory()\r\n            val mdir = File(\"${dir.path}${File.separator}monitor\")\r\n            val file1 = File(\"${mdir.path}${File.separator}wb.cache\")\r\n            if (checkFile()) {\r\n                LogUtils.e(file1.path)\r\n                val fos: OutputStream = FileOutputStream(file1)\r\n                val data = arrayListOf<WBItem>()\r\n                val bos = ByteArrayOutputStream()\r\n                val oos = ObjectOutputStream(bos)\r\n                for (i in 0..200) {\r\n                    val wbItem = WBItem().apply {\r\n                        textContent = \"这是文本内容--$i\"\r\n                        imgUrl = \"这是图片url--$i\"\r\n                        good = i\r\n                    }\r\n                    data.add(wbItem)\r\n                }\r\n                oos.writeObject(data)\r\n                oos.flush()\r\n                bos.writeTo(fos)\r\n                bos.flush()\r\n                bos.close()\r\n                oos.close()\r\n                fos.close()\r\n            }\r\n        }\r\n    }\r\n```\r\n\r\n优化后的Log打印如下：\r\n\r\n```\r\nFileWrap(fdInt=59, fd=java.io.FileDescriptor@17f3d09, \r\npid=12653, tid=12696, mode=1, \r\npath=\/storage\/emulated\/0\/monitor\/wb.cache, \r\nopenTime=1572695907143, closeTime=1572695907144, \r\nprocess=null, thread=Thread-2, \r\nreadCount=0, readBytes=0, readTime=0, \r\nwriteCount=1, writeBytes=11793, writeTime=1, stacktrace=java.io.FileOutputStream.write(FileOutputStream.java:381)\r\n    java.io.ByteArrayOutputStream.writeTo(ByteArrayOutputStream.java:167)\r\n    top.jenson.filemonitor.MainActivity$writeWBItemWithBuffer$1.invoke(MainActivity.kt:154)\r\n    top.jenson.filemonitor.MainActivity$writeWBItemWithBuffer$1.invoke(MainActivity.kt:12)\r\n    kotlin.concurrent.ThreadsKt$thread$thread$1.run(Thread.kt:30)\r\n```\r\n\r\n可以看到优化后的`writeCount=1`。\r\n\r\n未优化的耗时计算为：1572695396532-1572695396436=‭96‬\r\n\r\n优化后的耗时计算为：1572695907144-1572695907143=1\r\n\r\n\r\n\r\n其实不仅对象序列化，其他的文件缓存也都可以监控并发现问题点。\r\n\r\n感谢：\r\n\r\n[【个人笔记一】ART系统类的编译解析加载探究]( https:\/\/www.twblogs.net\/a\/5b8aaa392b71775d1ce866c1\/zh-cn )\r\n\r\n[android 从java到C层文件读取流程]( https:\/\/blog.csdn.net\/zhu929033262\/article\/details\/51496809 )\r\n\r\n[剖析 Android ART Runtime (2) – dex2oat]( https:\/\/mssun.me\/blog\/android-art-runtime-2-dex2oat.html )"
  },
  {
    "title" : "浅谈Java注解(一)",
    "created_time" : "2019-11-15 10:47:15",
    "body" : "# 0x00 前言\r\n\r\n⼀直以来对于Java注解的理解都停留在`@Override`的使⽤上⾯。\r\n\r\n对于其他则知之较少，但是慢慢发现很多框架都使⽤了注解功能，\r\n\r\n越来越觉得有必要了解下注解的实现了。\r\n\r\n对于注解的学习可以按照图下的四个步骤：  \r\n\r\n![image-20191115143353914](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/qtzj-01-01.png)\r\n\r\n下⾯分别来介绍下每步\r\n\r\n<!-- more -->  \r\n\r\n# 0x01 知道\r\n\r\n## 什么是注解\r\n\r\nJava注解从5.0版本推出，\r\n\r\n注解就是对类、⽅法、参数、变量、构造器及\r\n\r\n包声明中的特殊修饰符，实现对元数据的描述。  \r\n\r\n## 元数据是什么\r\n\r\n简单点说元数据就是⽤来存储数据的数据，\r\n\r\n⽐如⽤来描述学⽣信息需要定义⼀个Student类，\r\n\r\n那么Student类⽤来描述学⽣信息，\r\n\r\n但是谁⼜来描述Student类本身呢？\r\n\r\n就是元类了(meta class)，即Java中Class类。\r\n\r\n其实在注解出现之前，它的功能也有其他⼀些⽅法来实现，\r\n\r\n但是那个时候的实现是⽐较随意的，由开发⼈员⾃⾏实现。\r\n\r\n所以注解的出现相当于统⼀了标准。  \r\n\r\n# 0x02 使用\r\n\r\n## 内置标准注解\r\n\r\nJava注解在推出时便内置了三种标准注解：\r\n\r\n`@Override`，说明当前⽅法覆盖⽗类的⽅法实现。\r\n\r\n`@Deprecated`，说明该代码已经废弃了，不建议使⽤，如果使⽤了编译器会发出警告。\r\n\r\n`@SuppressWarnings`，说明关闭当前修饰代码段内的编译器警告信息。\r\n\r\n使⽤⽅法如下：  \r\n\r\n![image-20191115143733722](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/qtzj-01-02.png)\r\n\r\n可以清楚看到标记了\r\n\r\n`@Deprecated`的⽅法会被划线来表示已经过期废弃。\r\n\r\ntest()和test1()两个⽅法同样的实现， test1()标记了`@SuppressWarnings`⽽没有出现⻩⾊警告信息。\r\n\r\n`@Override`重写⽗⽅法，如果父类没有该⽅法就出现错误提示的。 \r\n\r\n# 0x03 自定义 \r\n\r\n## 元注解\r\n\r\n上⾯简单介绍了Java内置的三种标准注解，但是这三种根本不够看的，我们需要更深⼊的了解。\r\n\r\n在这之前需要了解⼀个知识点：**元注解**。\r\n\r\n上⾯有说到描述类的类叫元类 ，\r\n\r\n所以这⾥描述注解的注解⾃然就是元注解:\r\n\r\n下⾯是描述Override注解的注解 ：\r\n\r\n```java\r\n@Target(ElementType.METHOD)\r\n@Retention(RetentionPolicy.SOURCE)\r\npublic @interface Override {\r\n}\r\n```\r\n\r\n  Java提供了四种元注解⽤来帮助自定义新注解：  \r\n\r\n| 分类       | 描述                   |\r\n| ---------- | ---------------------- |\r\n| @Document  | 是否被包含在Doc文档    |\r\n| @Inherited | 是否允许子类继承该注解 |\r\n| @Retention | 声明周期               |\r\n| @Target    | 作用目标               |\r\n\r\n四种元注解主要了解`@Retention`和`@Target`即可。\r\n\r\n### @Retention\r\n\r\n`@Retention`有三个可选值：  \r\n\r\n| 分类                    | 描述                               |\r\n| ----------------------- | ---------------------------------- |\r\n| RetentionPolicy.SOURCE  | 仅编译期可见                       |\r\n| RetentionPolicy.CLASS   | 仅加载class前可见，存在于class文件 |\r\n| RetentionPolicy.RUNTIME | 一直可见，包括运行时               |\r\n\r\n网上关于`RetentionPolicy.SOURCE`的说法有说“在编译阶段丢弃”,\r\n\r\n⼀时让我很费解，既然在编译阶段就丢弃了，\r\n\r\n那`@override`重写标记也是编译阶段丢弃，\r\n\r\n但是它⼜如何实现⽗类没有该⽅法时出现编译错误提示呢？\r\n\r\n所以我觉得对于`RetentionPolicy.SOURCE`的描述还是⽤\r\n\r\n**仅存在于编译阶段更准确⼀些。**\r\n\r\n### @Target\r\n\r\n关于@Target也有多个属性值可选：  \r\n\r\n| 分类                        | 描述                               |\r\n| --------------------------- | ---------------------------------- |\r\n| ElementType.TYPE            | 类、接口（包括注释类型）或枚举声明 |\r\n| ElementType.FIELD           | 字段声明（包括枚举常量）           |\r\n| ElementType.METHOD          | 方法声明                           |\r\n| ElementType.PARAMETER       | 参数声明                           |\r\n| ElementType.CONSTRUCTOR     | 构造方法声明                       |\r\n| ElementType.LOCAL_VARIABLE  | 局部变量声明                       |\r\n| ElementType.PACKAGE         | 包声明                             |\r\n| ElementType.ANNOTATION_TYPE | 用在注解上                         |\r\n| ElementType.TYPE_PARAMETER  | 1.8添加                            |\r\n| ElementType.TYPE_USE        | 1.8添加                            |\r\n\r\n关于元注解的介绍已经说完了，下⾯开始元注解实战  \r\n\r\n## 实战元注解\r\n\r\n先看下需求：\r\n\r\n现在从服务器返回⼀个json串`{age:29,name:Jenson}`,\r\n\r\n我们要设计⼀个注解，通过注解绑定json和我在本地已有实体类，\r\n\r\n代码如下:\r\n\r\n```java\r\n@Target(ElementType.FIELD)\r\n@Retention(RetentionPolicy.RUNTIME)\r\npublic @interface PAnn {\r\n    String name() default \"\";\r\n}\r\n```\r\n\r\n因为是给People属性设置注解\r\n\r\n所以使⽤`@Target(value =ElementType.FIELD)`，\r\n\r\n因为要⽤到反射，所以设置周期为\r\n\r\n`@Retention(RetentionPolicy.RUNTIME)`。\r\n\r\n实体类：  \r\n\r\n```java\r\npublic class People {\r\n    @PAnn(name = \"name\")\r\n    String name;\r\n    @PAnn(name = \"age\")\r\n    int age;\r\n\r\n    public People() {\r\n    }\r\n\r\n    public People(String name, int age) {\r\n        this.name = name;\r\n        this.age = age;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public int getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(int age) {\r\n        this.age = age;\r\n    }\r\n}\r\n\r\n```\r\n\r\n现在我们要设计⼀个JsonParser类，\r\n\r\n通过⽅法(JsonParser()).parse(text, People.class)；\r\n\r\n可以直接解析成功并返回⼀个People对象。\r\n\r\n下⾯看JsonParser.parse的实现：  \r\n\r\n```java\r\npublic class JsonParser {\r\n    public <T> T parse(String text, Class<T> clz) throws InstantiationException, IllegalAccessException, JSONException {\r\n        T t = clz.newInstance();\r\n        Field[] fields = clz.getDeclaredFields();\r\n        JSONObject object = new JSONObject(text);\r\n        for (int i = 0; i < fields.length; i++) {\r\n            Field f = fields[i];\r\n            PAnn pAnn = f.getAnnotation(PAnn.class);\r\n            if (pAnn != null) {\r\n                f.setAccessible(true);\r\n                f.set(t, object.get(pAnn.name()));\r\n            }\r\n        }\r\n        return t;\r\n    }\r\n}\r\n\r\n```\r\n\r\n因为通过注解绑定了People的属性和json的key值。\r\n\r\n所以通过反射拿到注解信息的value，\r\n\r\n通过这个value作为key拿到json的value。\r\n\r\n最后通过set⽅法把json的value赋值给对应的属性。\r\n\r\n这样完成了解析过程。\r\n\r\n最后看看main⽅法实现：  \r\n\r\n```kotlin\r\n        val text = \"\"\"{name:\"jenson\",age=30}\"\"\"\r\n        try {\r\n            val p = (JsonParser()).parse(text, People::class.java)\r\n            Log.e(this.javaClass.simpleName, \"${p.name},${p.age}\")\r\n        } catch (e: Exception) {\r\n            e.printStackTrace()\r\n        }\r\n\r\n```\r\n\r\n打印结果：\r\n\r\n`MainActivity: jenson,30`\r\n\r\n这样看起来好像⽐直接使⽤JSONObject解析麻烦，\r\n\r\n但是其实这样做更灵活，\r\n\r\n而且⼀般服务器交互过程都是若⼲个实体类，\r\n\r\n⽽我们只要实现这⼀次就可以达到通⽤的⽬的。\r\n\r\n⽐如下次解析消息类时只要给消息实体加上注解 ，\r\n\r\n然后如下使⽤就可以完成解析：\r\n\r\n```java\r\nMessage msg = (Message) JsonParser.parse(json, Message.class);\r\n```\r\n\r\n其实看下jackson和gson等使⽤注解的解析应该都是类似的⽅法。\r\n\r\n另外注解在hibernate和各种测试框架都有⼴泛应⽤。\r\n\r\n所以了解注解原理对理解相关注解框架很有帮助  。\r\n\r\n\r\n\r\n# 0x04 原理\r\n\r\n这⾥的原理只介绍注解在classFile中的实现机制。\r\n\r\n上⾯说了四种元注解主要了解@Retention和@Target。\r\n\r\n下⾯分别说说这两种实现  ：\r\n\r\n##   @Retention\r\n\r\n@Retention有三种可选值： SOURCE、 CLASS和RUNTIME。  \r\n\r\n上⾯说了三种值代表的意义，但是这三种值是如何实现的呢？\r\n\r\n### @RetentionPolicy.SOURCE\r\n\r\n只在源码中存在或者说只在编译成字节码⽂件前存在。\r\n\r\n这时疑问就来了，我们运⾏的都是字节码⽂件，也就是在编译后，\r\n\r\n那`@override`⼜怎么达到重写检查的效果的呢？\r\n\r\n因为`@override`注解修饰的是@Retention.SOURCE。\r\n\r\n这个问题也困惑了我很久。\r\n\r\n因为关于重写检查在IDE中都是即时提示的，⼀度怀疑是IDE搞的⻤。\r\n\r\n有这个想法还是很愚蠢的，同时也说明了⾃⼰基本功的Low。\r\n\r\n我们⼀直在讲编译，其实这是⼀个⽐较⼤范围的概念。\r\n\r\n就是说编译这个步骤不是原⼦性的，还能分成很多⼩步骤：\r\n\r\n词法分析、语法分析、语义分析，\r\n\r\n经过⼀些列分析后才执⾏编译(参⻅编译器原理)\r\n\r\n附⼀张编译器步骤图：  \r\n\r\n![image-20191115145727351](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/qtzj-01-03.png)\r\n\r\n现在清楚了之所以IDE在编译前很智能即时的对\r\n\r\n@Retention.SOURCE注解给出提示，\r\n\r\n是因为IDE对我们输⼊进⾏实时词法、语法、语义的分析。  \r\n\r\n\r\n\r\n\r\n\r\n### @RetentionPolicy.CLASS\r\n\r\n\r\n\r\n只能活到字节码⽂件中，\r\n\r\n再往后⾯的操作是@RetentionPolicy.CLASS所不能及的。\r\n\r\n⽣命周期⽐SOURCE⻓⼀点，却⼜不及RUNTIME。\r\n\r\n如果没有设置，那么注解默认是使⽤RetentionPolicy.CLASS的，\r\n\r\n因为编译后它只存在于字节码⽂件中，\r\n\r\n所以⼀般应⽤开发⼈员⽐较少⽤到，\r\n\r\n更多的可能是给底层研发⼈员来使⽤的吧，我是这样认为的。\r\n\r\n现在⼜产⽣⼀个疑问：\r\n\r\n怎么证明`RetentionPolicy.SOURCE`没有存在字节码⽂件中，\r\n\r\n⽽`RetentionPolicy.CLASS`存在于字节码⽂件中呢？\r\n\r\n这个问题答案只能从`classFile`中找到了。\r\n\r\n编译后的字节码⽂件⼀般称为`classFile`。\r\n\r\n在`classFile`中有⼀个名为字段表的结构，\r\n\r\n字段表⼜包含⼀个属性表，属性表其中⼀项是`RuntimeInvisibleAnnotations`\r\n\r\n(参⻅Java虚拟机规范）。\r\n\r\n如果为`RetentionPolicy.CLASS`，那么字节码⽂件中会出现这属性，\r\n\r\n如果为`RetentionPolicy.SOURCE`，则没有这个属性。\r\n\r\n下⾯对⽐下SOURCE和CLASS字节码⽂件结构：  \r\n\r\n`RetentionPolicy.CLASS`如图：\r\n\r\n![image-20191115175742841](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/qtzj-01-04.png)\r\n\r\n`RetentionPolicy.SOURCE`如图：\r\n\r\n![image-20191115175908599](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/qtzj-01-05.png)\r\n\r\n\r\n\r\n\r\n\r\n### @RetentionPolicy.RUNTIME\r\n\r\n这个是⽣命周期最⻓的，既然存在于虚拟机运⾏时环境中，\r\n\r\n那是不是为应⽤开发⼈员提供了功能？不然的话那和CLASS⼀样了。\r\n\r\n最主要的功能就是通过反射能拿到注解相关信息了。\r\n\r\n注意⼀点：既然`RetentionPolicy.RUNTIME`和`RetentionPolicy.CLASS`都存在于字节码⽂件中，\r\n\r\n那么如何区分它们呢？\r\n\r\n上⾯看到设置`RetentionPolicy.CLASS`后属性表中多了个`RuntimeInvisibleAnnotations`属性。\r\n\r\n⽽设置`RetentionPolicy.RUNTIME`后属性表中其实多了个`RuntimeVisibleAnnotations`属性:\r\n\r\n如图:\r\n\r\n![image-20191115180044571](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/qtzj-01-06.png)\r\n\r\n\r\n\r\n很明显意思是`运行时不可见注解`和`运行时可见注解`。\r\n\r\n这样JVM加载classFile时根据这个属性来判断\r\n\r\n是否将注解信息加载到JVM中，\r\n\r\n如果是`RuntimeVisibleAnnotations`则表明我们可以通过反射拿到相关的注解信息。 \r\n\r\n\r\n\r\n## @Target\r\n\r\n`Target`表示注解设置的目标是谁。\r\n\r\n⼀般是设置给类、字段和⽅法。\r\n\r\n但JVM如何保证我们给类设置的注解不会被⽤在字段或⽅法的身上呢？\r\n\r\n在Java虚拟机规范中讲到： \r\n\r\nclassFile包含字段表、方法表和属性表，\r\n\r\n而字段表和⽅法表中⼜都分别有⾃⼰的属性表。\r\n\r\n字段表和⽅法表中各⾃的属性表同样也都拥有`RuntimeVisibleAnnotations`和\r\n`RuntimeInvisibleAnnotations`属性，\r\n\r\n前提是你设置了相关注解信息。这样根据你设置注解位置不同，\r\n\r\n在classFile中不同区域的属性表也会有不同的注解信息显示。\r\n\r\n现在新创建了⼀个test注解，⽤来修饰⽅法：\r\n\r\n  ```java\r\n@Target(ElementType.METHOD)\r\n@Retention(RetentionPolicy.CLASS)\r\npublic @interface MTest {\r\n}\r\n  ```\r\n\r\n  编译后字节码如下图：\r\n\r\n![image-20191115180439961](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/qtzj-01-07.png)\r\n\r\n可以看到修饰字段和修饰⽅法的注解都还在，\r\n\r\n由此可见， JVM根据不同的区域属性表来显示注解信息是成⽴的。  \r\n\r\n\r\n\r\n# 0x05 关于classFile\r\n\r\n上⾯多次提到了classFile，到底classFile长什么样？\r\n\r\n上⾯图中可视化还是⽐较强的，其实真正的classFile是这个样子：\r\n\r\n![image-20191115153303026](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/qtzj-01-08.png)\r\n\r\n打开之后显示的都是⼗六进制内容，初次看难免让⼈头大。\r\n\r\n但是其实这都是按照JVM规范来定义的。  \r\n\r\n简单看两个了解下JVM对classFile⽂件定义的规则：\r\n\r\nJVM规定⾸个4个字节为魔数，\r\n\r\n紧挨着的2各字节为小版本号，\r\n\r\n小版本后⾯紧挨着的2各字节为主版本号。\r\n\r\n## 魔数\r\n\r\n前4个字节为CAFEBABE，⼀般直接理解为咖啡宝⻉。\r\n\r\n这个魔数是固定不变的，\r\n\r\n它的作⽤就是⽤来判断该⽂本是否为可被JVM接受的class⽂件。\r\n\r\n所以如果你直接从后缀把⼀个⽂件改为*.class是不会被JVM加载的。\r\n\r\n## 版本号\r\n\r\n版本号分为minor_version（副版本号） 、 major_version（主版本号）2个部分。\r\n\r\n如果⼀个class⽂件副版本号为v，主版本号为V，那么该class⽂件版本就为V.v\r\n\r\n⼀个JVM实例只能⽀持特定范围内的主版本号（a～i） 和0⾄特定范围内（0～m） 的副版本号。\r\n\r\n假设⼀个class⽂件的格式版本号为v，\r\n\r\n 仅当a.0≤v≤i.m成⽴时， 这个class⽂件才可以被此Java虚拟机⽀持。\r\n\r\n不同版本的Java虚拟机实现⽀持的版本号也不同， \r\n\r\n⾼版本号的Java虚拟机实现可以⽀持低版本号的class⽂件，反之则不成⽴。\r\n\r\nOracle的JDK在1.0.2版本时， ⽀持的class格式版本号范围为45.0～45.3；\r\n\r\nJDK版本在1.1.x时， ⽀持的class格式版本号范围扩展⾄45.0～45.65535；\r\n\r\nJDK版本为1.k时（k≥2） 时， 对应的class⽂件格式版本号的范围为45.0～44+k.0。\r\n\r\n现在看看截图中classFile，副版本号为0000，主版本号为0034。\r\n\r\n当然这是⼗六进制的，转换成⼗进制是0和52。\r\n\r\n所以该classFile版本号是52.0？  \r\n\r\n这怎么和我们的版本号对应上的呢？\r\n\r\n看这句JDK版本为 版本为1.k时（ 时（k≥2）） 时， \r\n\r\n对应的 对应的class⽂件格式版本号的范围为45.0～～44+k.0。\r\n\r\n求k值： 44+k=52—>k=8，所以JDK版本为： 1.8.0\r\n\r\n下⾯是我通过命令⾏获取的JDK版本信息：\r\n\r\njava version \"1.8.0_101\"\r\n\r\nJava(TM) SE Runtime Environment (build 1.8.0_101-b13)\r\n\r\nJava HotSpot(TM) 64-Bit Server VM (build 25.101-b13, mixed mode)  \r\n\r\n# 0x06 总结\r\n\r\nclassFile后⾯还有很多结构，也还有很多有意思的地⽅，\r\n\r\n感兴趣可以参考《JVM规范》。\r\n\r\n很多时候⽤不到的东西并不是没有用，而是我们使⽤的东西还太浅。"
  },
  {
    "title" : "关于屏幕适配",
    "created_time" : "2019-11-20 15:59:53",
    "body" : "# 0x00 了解几个公式：\r\n\r\n本文都是参考[头条的适配]( https:\/\/mp.weixin.qq.com\/s\/d9QCoBP6kV9VSWvVldVVwA )\r\n\r\n\r\n\r\ndpi=开方（长²+宽²）\/尺寸\r\n\r\ndensity= dpi\/160\r\n\r\ndensity=设备宽px\/设计图宽dp\r\n\r\npx = dp*density  dp为我们给控件设置的宽高值\r\n\r\ndp=px\/density\r\n\r\n\r\n\r\n# 0x01 按比例适配\r\n\r\n设计图屏幕宽度360dp，宽度1080px，一个View宽度为100dp。\r\n\r\n那么View在屏幕宽度中占比为 100\/360≈0.28。\r\n\r\n设计图中的尺寸比例是适配好的。\r\n\r\n\r\n\r\n接下来开始在其他尺寸运行，\r\n\r\n在设备A中，dpi为560，宽度1440px，\r\n\r\n根据：density= dpi\/160，求得density=560\/160。\r\n\r\n根据dp=px\/density，求得dp=1440\/(560\/160)=411.4dp\r\n\r\n所以设备A的屏幕宽度为411.4dp，\r\n\r\nView宽度100dp不变，\r\n\r\n在设备A中，View宽度占比为100\/411.4≈0.24\r\n\r\n可见只按dp设置值是无法达到理想适配效果的。\r\n\r\n**View宽度100dp不变**这个是必要条件，\r\n\r\n所以要保证比例的话，任何设备dp宽度也只能为360dp。\r\n\r\n而dp=px\/density，\r\n\r\n**设备像素宽度px各个设备也不同**\r\n\r\n所以为了保证dp为360，根据px不同，设置不同的density。\r\n\r\n根据density=px\/dp求出设备该设置的density。\r\n\r\n\r\n\r\n把density设置给DisplayMetrics的density属性\r\n\r\n顺便求出densityDpi设置给DisplayMetrics的densityDpi属性：\r\n\r\ndensityDpi=该设置的density*160\r\n\r\n顺便求出scaleDensity设置给DisplayMetrics的scaleDensity属性：\r\n\r\nscaleDensity=targetDensity * (scaleDensity \/ density)\r\n\r\n\r\n\r\n根据上面内容封装代码为：\r\n\r\n```kotlin\r\n@file:JvmName(\"ScreenAdapter\")\r\n\r\npackage top.jenson.pet.tool\r\n\r\nimport android.app.Activity\r\nimport android.app.Application\r\nimport android.content.ComponentCallbacks\r\nimport android.content.res.Configuration\r\nimport android.os.Bundle\r\nimport err\r\n\r\n\/**\r\n * mdpi 160\r\n * density表示dp转px的系数，\r\n * px表示设备像素数，\r\n * dp，也就是dpi，表示像素密度，表示1pd占多少像素\r\n * px = density * dp;\r\n * density = dpi \/ 160;\r\n * px = dp * (dpi \/ 160);\r\n *\/\r\nclass ScreenAdapter {\r\n    companion object {\r\n        var density: Float = 0f\r\n        var scaleDensity: Float = 0f\r\n\r\n\r\n        \/**\r\n         * @param application\r\n         * @param designDp 设计提供的基密度数\r\n         *\/\r\n        @JvmStatic\r\n        fun init(application: Application, designDp: Int) {\r\n            application.registerActivityLifecycleCallbacks(object :\r\n                Application.ActivityLifecycleCallbacks {\r\n                override fun onActivityPaused(activity: Activity?) {\r\n                }\r\n\r\n                override fun onActivityResumed(activity: Activity?) {\r\n                }\r\n\r\n                override fun onActivityStarted(activity: Activity?) {\r\n                }\r\n\r\n                override fun onActivityDestroyed(activity: Activity?) {\r\n                }\r\n\r\n                override fun onActivitySaveInstanceState(activity: Activity?, outState: Bundle?) {\r\n                }\r\n\r\n                override fun onActivityStopped(activity: Activity?) {\r\n                }\r\n\r\n                override fun onActivityCreated(activity: Activity?, savedInstanceState: Bundle?) {\r\n                    setCustomDensity(activity!!, application, designDp)\r\n                }\r\n            })\r\n        }\r\n\r\n        private fun setCustomDensity(activity: Activity, application: Application, designDp: Int) {\r\n            val appDisplayMetrics = application.resources.displayMetrics\r\n            if (density == 0f) {\r\n                density = appDisplayMetrics.density\r\n                scaleDensity = appDisplayMetrics.scaledDensity\r\n                application.registerComponentCallbacks(object : ComponentCallbacks {\r\n                    override fun onLowMemory() {\r\n                    }\r\n\r\n                    override fun onConfigurationChanged(newConfig: Configuration?) {\r\n                        if (newConfig != null && newConfig.fontScale > 0) {\r\n                            scaleDensity = application.resources.displayMetrics.scaledDensity\r\n                        }\r\n                    }\r\n                })\r\n            }\r\n\r\n            val targetDensity = appDisplayMetrics.widthPixels \/ designDp\r\n            val targetScaleDensity = targetDensity * (scaleDensity \/ density)\r\n            val targetDensityDpi = targetDensity * 160\r\n\r\n            appDisplayMetrics.density = targetDensity.toFloat()\r\n            appDisplayMetrics.scaledDensity = targetScaleDensity\r\n            appDisplayMetrics.densityDpi = targetDensityDpi\r\n\r\n            val activityDisplayMetrics = activity.resources.displayMetrics\r\n            activityDisplayMetrics.density = targetDensity.toFloat()\r\n            activityDisplayMetrics.densityDpi = targetDensityDpi\r\n            activityDisplayMetrics.scaledDensity = targetScaleDensity\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n在Application中初始化：\r\n\r\n```kotlin\r\n        ScreenAdapter.init(this, 360)\r\n```\r\n\r\n避免在每个Activity中都调用，也不用在BaseActivity中调用。"
  },
  {
    "title" : "关于Android旧项目模块化组件化实现",
    "created_time" : "2019-11-25 09:56:05",
    "body" : "# 0x00 前言\r\n\r\n很多公司都喊起了模块化、组件化、插件化、热更新的口号。\r\n\r\n没用过，有点心慌；想用一下，但是上来就是四个名词更TM心慌，都是咋个意思？\r\n\r\n个人想法，为了理解方便，把它们分门别类一下：\r\n\r\n**模块化、组件化主要是提升开发体验**\r\n\r\n**插件化、热更新主要是提升用户体验**\r\n\r\n这两类可以分开学习，\r\n\r\n这里我们就先学习下模块化、组件化。\r\n\r\n# 0x01 为什么学\r\n\r\n学习新东西是有成本的，这是个功利的时代，\r\n\r\n我们很在意它能不能保本，如果能捞点就更好了。\r\n\r\n很多时候项目你以为是这样的：\r\n\r\n![image-20191126112252677](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/moudle-1.png)\r\n\r\n\r\n\r\n但实际是这样的：\r\n\r\n![image-20191126112410109](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/moudle-2.png)\r\n\r\n\r\n\r\n随着项目功能越来越丰富，代码越来越臃肿，\r\n\r\n带来的一个显著问题是编译时间变长。\r\n\r\n因为一点的改动都会造成一次全局的编译。\r\n\r\n如果实现模块化，每次只编译自己负责的模块岂不是很好？\r\n\r\n虽然说是各自负责模块，但是模块界限并不清晰，难免越界。\r\n\r\n所以我们渴望项目架构做出调整。\r\n\r\n经常我们实现初步模块化架构可能如图：\r\n\r\n\r\n\r\n![image-20191126114419704](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/moudle-3.png)\r\n\r\n这只是最基本的模块化结构图。\r\n\r\n对了，我们开头说了模块化\/组件化，但是现在一直提的只是模块化。\r\n\r\n**怎么才算组件化？**\r\n\r\n**我觉得组件化是更细粒度的模块化。**\r\n\r\n**模块是一组功能相关业务模块，比如动态模块有动态列表，动态详情，发表动态等一组功能**\r\n\r\n**组件是功能单一模块，比如动态和聊天都可以发送视频类型，取出视频播放这一功能作为组件**\r\n\r\n**组件可以单独抽取出来作为SDK，将来为公司其他项目直接引入可用**\r\n\r\n所以现在我们心中的模块化组件化结构图可能是这样的：\r\n\r\n![image-20191127101901377](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/moudle-4.png)\r\n\r\n\r\n\r\n# 0x02 结构调整\r\n\r\n在我看来模块化\/组件化第一步就是先结构调整。\r\n\r\n而结构调整的第一步是创建相关moudle。\r\n\r\n## 创建moudle\r\n\r\n我这里创建的moudle都是选择`android library`。\r\n\r\n创建好所需的moudle，按结构图添加好依赖关系。\r\n\r\n每个moudle都有一个`build.gradle`文件。\r\n\r\n我们要保证每个`build.gradle`中的\r\n\r\n`compileSdkVersion`、`minSdkVersion`、`targetSdkVersion`、`buildToolsVersion`值都相同，\r\n\r\n不然可能会有冲突。\r\n\r\n可以在项目根目录新建文件`common_config.gradle`，添加内容：\r\n\r\n```groovy\r\nproject.ext {\r\n    compileSdkVersion = 28\r\n    minSdkVersion = 21\r\n    targetSdkVersion = 21\r\n    buildToolsVersion = \"29.0.2\"\r\n}\r\n```\r\n\r\n然后在每个`build.gradle`文件中添加引用：\r\n\r\n```groovy\r\napply from: \"${rootProject.rootDir}\/common_config.gradle\"\r\n```\r\n\r\n接下来为各个属性使用统一的值：\r\n\r\n```groovy\r\nbuildToolsVersion project.ext.buildToolsVersion\r\ncompileSdkVersion project.ext.compileSdkVersion\r\nminSdkVersion project.ext.minSdkVersion\r\ntargetSdkVersion project.ext.targetSdkVersion\r\n```\r\n\r\n这样以后修改相关属性值只需要修改一次即可。\r\n\r\n到这一步，从新编译尝试运行项目。\r\n\r\n修复遇到的问题，确保现在在空壳moudle情况下可以正常运行。\r\n\r\n开始为后面操作做准备。\r\n\r\n## 代码拆分\r\n\r\n上面创建了moudle，但是里面还是空的。这一步来填内容。\r\n\r\n按照结构图开始像择菜一样择代码，把择出来的代码放到相应moudle中。\r\n\r\n但凡项目稍微大点，这都是一个痛苦且漫长的过程。\r\n\r\n择完代码后，业务moudle之间没有依赖关系，导致无法相互调用。\r\n\r\n**如果遇到组件之间的跳转代码飘红的地方暂时先注释掉。**\r\n\r\n**如果遇到组件之间的数据通信飘红地方也先注释掉。**\r\n\r\n**如果出现moudle无法使用它所依赖moudle已经添加依赖库中类的情况下，**\r\n\r\n**可能是你的依赖库使用的是`implementation`，改为`api`即可。**\r\n\r\n这俩的区别是：\r\n\r\n你在A moudle中用`implementation`添加的依赖，依赖的类库只能在A 本moudle中使用。\r\n\r\n如果其他moudle引用了A moudle，其他moudle要使用A中依赖的类库，需要使用`API`声明。\r\n\r\n譬如：\r\n\r\n```groovy\r\n    api 'com.squareup.retrofit2:retrofit:2.5.0'\r\n    api 'com.squareup.retrofit2:converter-gson:2.0.2'\r\n    \/\/rxjava\r\n    api 'io.reactivex.rxjava2:rxandroid:2.0.1'\r\n    \/\/二维码\r\n    api 'com.google.zxing:core:3.3.0'\r\n```\r\n\r\n## 适时下沉\r\n\r\n不要为了图方便一口气把所有文件都下沉到common。\r\n\r\n不要抱着反正下沉到common，我的moudle也能正常使用的心态。\r\n\r\n做人要有节操。\r\n\r\n## anko问题\r\n\r\n对于多个moudle公用的布局，我把它们下沉到common模块中。\r\n\r\n但是业务moudle通过anko直接使用id进行操作时是没有问题的。\r\n\r\n但是一旦编译运行就出现unresolve。\r\n\r\n所以只能通过手动方式获取：\r\n\r\n```kotlin\r\nprivate val titleView by lazy { find<TextView>(R.id.titleView) }\r\n```\r\n\r\n\r\n\r\n经过这一阶段的处理，你的App应该可以运行起来。\r\n\r\n同一个moudle之间可以跳转、数据传递。\r\n\r\n剩下的慢慢处理。\r\n\r\n# 0x03 模块间跳转\r\n\r\n上面说了模块之间的跳转飘红注释掉。\r\n\r\n这里我们来处理模块间跳转。\r\n\r\n上面模块间跳转所以会出错是因为使用了`显示跳转`，\r\n\r\n强依赖关系，而模块之前是没有关系的，导致飘红。\r\n\r\n那么如何实现模块之间正确跳转呢？\r\n\r\n## 隐式跳转\r\n\r\n隐式跳转，\r\n\r\n一种方式通过`action`跳转，\r\n\r\n首先要在`AndroidManifest`中对应actvity设置`IntentFilter`：\r\n\r\n```xml\r\n<intent-filter>\r\n     <action android:name=\"top.jenson.setting.activity.about\"\/>\r\n     <category android:name=\"android.intent.category.DEFAULT\"\/>\r\n<\/intent-filter>\r\n```\r\n\r\n然后在其他moudle使用如下跳转：\r\n\r\n```kotlin\r\nstartActivity(Intent(\"top.jenson.setting.activity.setting\"))\r\n```\r\n\r\n\r\n\r\n还可以通过另一种方式隐式跳转：包名+Activity全路径形式：\r\n\r\n```kotlin\r\nval intent = Intent()\r\nintent.setClassName(\"模块包名\", \"activity类全名称\")\r\nintent.component = ComponentName(\"模块包名\", \"activity类全名称\")\r\nstartActivity(intent)\r\n```\r\n\r\n\r\n\r\n隐式跳转并不理想，因为如果其他模块负责人把相关信息修改了。\r\n\r\n有可能会导致你的跳转异常崩溃。\r\n\r\n尽管你可以通过`intent.resolveActivity(activity!!.packageManager)`来判断。\r\n\r\n但是显然这是比较麻烦且不友好的。况且获取Fragment你要怎么办？\r\n\r\n## 路由跳转\r\n\r\n隐式跳转用着不舒服？还可以使用路由跳转。\r\n\r\nAndroid路由框架还是蛮多的，`activityRouter`、`deepLink`、`ARouter`等等。\r\n\r\n根据情况选择自己熟悉的框架即可。这里我使用`ARouter`。\r\n\r\n### 添加依赖\r\n\r\n在`build.gradle`中添加：\r\n\r\n下面是Kotlin方式\r\n\r\n```groovy\r\napply plugin: 'kotlin-kapt'\r\n\r\nkapt {\r\n    arguments {\r\n        arg(\"AROUTER_MODULE_NAME\", project.getName())\r\n    }\r\n}\r\n\r\ndependencies {\r\n    api 'com.alibaba:arouter-api:1.4.1'\r\n    kapt 'com.alibaba:arouter-compiler:1.2.2'\r\n   \r\n}\r\n```\r\n\r\n如果使用Java方式，及进阶使用参考[Github]( https:\/\/github.com\/alibaba\/ARouter\/blob\/master\/README_CN.md )\r\n\r\n### 统一声明path\r\n\r\n在Common moudle新建常量类，其中封装各个moudle中使用的path：\r\n\r\n```kotlin\r\nclass Constant {\r\n    companion object {\r\n        \/\/chat模块\r\n        \/\/common模块\r\n        const val COMMON_BDMapActivity = \"\/COMMON\/BDMapActivity\"\r\n        const val COMMON_AddLocationActivity = \"\/COMMON\/AddLocationActivity\"\r\n        \/\/dynamic模块\r\n        const val DYNAMIC_AddDynamicActivity = \"\/DYNAMIC\/AddDynamicActivity\"\r\n        \/\/feed模块\r\n        const val FEED_NearFeedActivity = \"\/FEED\/NearFeedActivity\"\r\n        \/\/lost模块\r\n        const val LOST_FindPetActivity = \"\/LOST\/FindPetActivity\"\r\n        \/\/setting模块\r\n        const val SETTING_FeedBackActivity = \"\/SETTING\/FeedBackActivity\"\r\n        const val SETTING_AboutActivity = \"\/SETTING\/AboutActivity\"\r\n        const val SETTING_SettingActivity = \"\/SETTING\/SettingActivity\"\r\n        \/\/user模块\r\n        const val USER_RegistActivity = \"\/USER\/RegistActivity\"\r\n        const val USER_LoginActivity = \"\/USER\/LoginActivity\"\r\n        const val USER_FindPwdActivity = \"\/USER\/FindPwdActivity\"\r\n    }\r\n}\r\n```\r\n\r\n### 调用\r\n\r\n无参调用使用：\r\n\r\n```kotlin\r\nARouter.getInstance().build(Constant.SETTING_AboutActivity).navigation()\r\n```\r\n\r\n如果要携带数据，在`navigation`前通过`with`函数传递：\r\n\r\n```java\r\nARouter.getInstance().build(\"\/test\/1\")\r\n            .withLong(\"key1\", 666L)\r\n            .withString(\"key3\", \"888\")\r\n            .withObject(\"key4\", new Test(\"Jack\", \"Rose\"))\r\n            .navigation();\r\n```\r\n\r\n期间遇到两个问题已解决，参考：\r\n\r\n[ ARouter::Compiler >>> No module name ]( https:\/\/blog.csdn.net\/a34927341\/article\/details\/87690451 )\r\n\r\n[ arouter there's  no route matched ]( https:\/\/blog.csdn.net\/weixin_37292229\/article\/details\/93375669 )\r\n\r\n## 项目调整\r\n\r\n模块间跳转大部分操作就是`actvity启动`和`获取fragment` ，以`activity启动`为例。\r\n\r\n跳转可以分为`调用点`和`被调用方`。\r\n\r\n`调用点`是指调用跳转的地方，譬如：\r\n\r\n```kotlin\r\nval intent = Intent(activity, AboutActivity::class.java)\r\nstartActivity(Intent(intent))\r\n```\r\n\r\n把调用点直接替换为上面介绍的跳转方法。\r\n\r\n`被调用方`是负责响应调用的类，如果涉及数据传递，就需要修改，\r\n\r\n为接收数据的变量添加@Autowired注解，譬如：\r\n\r\n```kotlin\r\n  @Autowired\r\n  var name;\r\n  @Autowired\r\n  var age;\r\n```\r\n\r\n **ARouter会自动对字段进行赋值，无需主动获取。**\r\n\r\n按照上面方式完成所有模块跳转修改，\r\n\r\n目前你的项目应该确保模块间页面互相打开是没问题的。\r\n\r\n# 0x04 模块间通信\r\n\r\n通过上面操作，目前已经完成了模块间跳转功能。\r\n\r\n本节开始处理模块间通信问题。\r\n\r\n通过结构图可以看到模块之间是没有依赖的。\r\n\r\n所以直接通信不现实，那么只能走间接通信。\r\n\r\n业务模块都依赖了common moudle。\r\n\r\n**我们可以把通信内容(数据类)下沉到common模块，通过事件总线实现通信**\r\n\r\n事件总线有一个不好的地方就是每个不同的消息事件都对应成一个数据类。\r\n\r\n如果事件很多，我们需要维护的事件类是庞大的。\r\n\r\n每次的事件修改，都是对common moudle的修改。\r\n\r\n所以**可以单独创建EventMoudle，用来存放事件类，common moudle 依赖它。**\r\n\r\n\r\n\r\n经过上面的一通修改，目前你的App功能应该和调整前一样，各功能正常运行。\r\n\r\n但是我们结构调整的最初目标：单独编译还没实现。\r\n\r\n# 0x05 独立编译\r\n\r\n上面已经通过`common_config.gradle`抽取了四个通用属性。\r\n\r\n下面我们要继续抽取。\r\n\r\n## 继续抽取build.gradle\r\n\r\n我们看到每个moudle都有一个`build.gradle`。\r\n\r\n每个文件里面开头都引用了几个插件，除了lib和Application，大体都是一样的：\r\n\r\n```groovy\r\n\/\/主moudle\r\napply plugin: 'com.android.application'\r\n\/\/lib moudle\r\nextension.apply plugin: 'com.android.library'\r\n\r\napply plugin: 'kotlin-android'\r\napply plugin: 'kotlin-android-extensions'\r\napply plugin: 'kotlin-kapt'\r\n```\r\n\r\n所以在`common_config.gradle`的`ext`域中添加：\r\n\r\n```\r\n    \/\/主moudle使用\r\n    setAppDefaultConfig = {\r\n        extension ->\r\n            extension.apply plugin: 'com.android.application'\r\n            extension.apply plugin: 'kotlin-android'\r\n            extension.apply plugin: 'kotlin-android-extensions'\r\n            extension.apply plugin: 'kotlin-kapt'\r\n    }\r\n\t\/\/lib moudle使用\r\n    setLibDefaultConfig = {\r\n        extension ->\r\n            extension.apply plugin: 'com.android.library'\r\n            extension.apply plugin: 'kotlin-android'\r\n            extension.apply plugin: 'kotlin-android-extensions'\r\n            extension.apply plugin: 'kotlin-kapt'\r\n    }\r\n    \r\n```\r\n\r\n由于在`android{}`和`dependencies{}`中也有很多相同内容，所以把这两个地方也提取出来。\r\n\r\n在`common_config.gradle`的`ext`域添加为：\r\n\r\n```\r\n    setAndroidConfig = {\r\n        extension ->\r\n            extension.compileSdkVersion = 28\r\n            extension.buildToolsVersion = \"29.0.2\"\r\n            extension.defaultConfig {\r\n                kapt {\r\n                    arguments {\r\n                        arg(\"AROUTER_MODULE_NAME\", extension.project.getName())\r\n                    }\r\n                }\r\n                minSdkVersion = 21\r\n                targetSdkVersion = 21\r\n                testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\r\n            }\r\n\/\/            extension.dataBinding {\r\n\/\/                enable = true\r\n\/\/            }\r\n    }\r\n\r\n    setDependencies = {\r\n\r\n    }\r\n```\r\n\r\n不管是主moudle还是lib moudle，它们都包含`setAndroidConfig`和`setDependencies`。\r\n\r\n所以要把这两个放入前面moudle内容中。\r\n\r\n修改后内容为：\r\n\r\n```groovy\r\nproject.ext {\r\n    setAppDefaultConfig = {\r\n        extension ->\r\n            extension.apply plugin: 'com.android.application'\r\n            extension.apply plugin: 'kotlin-android'\r\n            extension.apply plugin: 'kotlin-android-extensions'\r\n            extension.apply plugin: 'kotlin-kapt'\r\n            setAndroidConfig extension.android\r\n            setDependencies extension.dependencies\r\n    }\r\n    setLibDefaultConfig = {\r\n        extension ->\r\n            extension.apply plugin: 'com.android.library'\r\n            extension.apply plugin: 'kotlin-android'\r\n            extension.apply plugin: 'kotlin-android-extensions'\r\n            extension.apply plugin: 'kotlin-kapt'\r\n            setAndroidConfig extension.android\r\n            setDependencies extension.dependencies\r\n    }\r\n\r\n    setAndroidConfig = {\r\n        extension ->\r\n            extension.compileSdkVersion = 28\r\n            extension.buildToolsVersion = \"29.0.2\"\r\n            extension.defaultConfig {\r\n                kapt {\r\n                    arguments {\r\n                        arg(\"AROUTER_MODULE_NAME\", extension.project.getName())\r\n                    }\r\n                }\r\n                minSdkVersion = 21\r\n                targetSdkVersion = 21\r\n                testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\r\n            }\r\n\/\/            extension.dataBinding {\r\n\/\/                enable = true\r\n\/\/            }\r\n    }\r\n\r\n    setDependencies = {\r\n        extension ->\r\n            extension.implementation fileTree(dir: 'libs', include: ['*.jar'])\r\n            extension.implementation \"org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version\"\r\n            extension.implementation 'androidx.appcompat:appcompat:1.0.2'\r\n            extension.implementation 'androidx.core:core-ktx:1.0.2'\r\n            extension.kapt 'com.alibaba:arouter-compiler:1.2.2'\r\n    }\r\n}\r\n```\r\n\r\n内容抽取差不之后，需要把每个`build.gradle`中重复的内容移除掉。\r\n\r\n同时添加`common_config.gradle`使用：\r\n\r\n```groovy\r\napply from: \"${rootProject.rootDir}\/common_config.gradle\"\r\nproject.ext.setAppDefaultConfig project\r\n```\r\n\r\n同步项目并运行，为后面做准备。\r\n\r\n## 独立编译\r\n\r\n现在我的项目动态模块`dynamic`只有Fragment提供给app moudle的MainActivity。\r\n\r\n![image-20191127162514819](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/moudle-5.png)\r\n\r\n我现在打算独立运行`dynamic`。\r\n\r\n首先要添加个标志`isDebug`。如果为true表示我要独立运行，否则作为lib运行。\r\n\r\n标志加在`common_config.gradle`中`isDebug = true`。\r\n\r\n### 判断是否作为lib\r\n\r\n在`dynamic`的`build.gradle`中，根据`isDebug`来判断该moudle是否作为lib:\r\n\r\n```groovy\r\nif (project.ext.isDebug) {\r\n    project.ext.setAppDefaultConfig project\r\n} else {\r\n    project.ext.setLibDefaultConfig project\r\n}\r\n```\r\n\r\n### 设置applicationId\r\n\r\n作为app moudle，需要设置`applicationId`。\r\n\r\n在`dynamic`的`build.gradle`中，根据`isDebug`来判断该moudle是否添加`applicationId`:\r\n\r\n```groovy\r\nif (project.ext.isDebug) {\r\n            applicationId \"top.jenson.pet\"\r\n}\r\n```\r\n\r\n### 取消被依赖\r\n\r\n一个app中，你要当主moudle，就不能作为lib被其他moudle依赖。\r\n\r\n所以要根据`isDebug`来判断是否可以被添加依赖。\r\n\r\n在app moudle的`build.gradle`中修改：\r\n\r\n```\r\n    if (!project.ext.isDebug) {\r\n        implementation project(path: ':dynamic')\r\n    }\r\n```\r\n\r\n同步项目，发现已经多出了可以运行的`dynamic`：\r\n\r\n![image-20191127164425098](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/moudle-6.png)\r\n\r\n运行时提示错误`More than one file was found with OS independent path 'META-INF\/rxjava.properties'`。\r\n\r\n这是rxjava引起的问题。\r\n\r\n在`dynamic`的`build.gradle`中`defaultConfig`添加：\r\n\r\n```groovy\r\n        packagingOptions {\r\n            exclude 'META-INF\/rxjava.properties'\r\n        }\r\n```\r\n\r\n再次运行，发现还是运行不起来。因为没有可运行的activity。\r\n\r\n### 添加debug内容\r\n\r\n在`dynamic`的`src`下创建`debug`目录。\r\n\r\n和`main`目录一样，新建`AndroidManifest.xml`，`java`，`res`。\r\n\r\n新建`DynamicListActivity`，包裹Fragment。\r\n\r\n在`debug`目录的`AndroidManifest`注册Activity  :\r\n\r\n```xml\r\n        <activity android:name=\"activity.DynamicListActivity\">\r\n            <intent-filter>\r\n                <action android:name=\"android.intent.action.MAIN\"\/>\r\n                <category android:name=\"android.intent.category.LAUNCHER\" \/>\r\n            <\/intent-filter>\r\n        <\/activity>\r\n```\r\n\r\n结构图为：\r\n\r\n![image-20191127172530979](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/moudle-7.png)\r\n\r\n\r\n\r\n一般项目都有自定义Application，里面有很多初始化的逻辑。\r\n\r\n在`debug`下的`AndroidManifest`，为了避免各种问题，这里也使用以前定义的Application：\r\n\r\n```xml\r\n<application\r\n            android:name=\"top.jenson.common.acitivty.PetApplication\"\r\n            android:allowBackup=\"true\"\r\n            android:icon=\"@mipmap\/ic_launcher\"\r\n            android:label=\"@string\/app_name\"\r\n            android:roundIcon=\"@mipmap\/ic_launcher_round\"\r\n            android:supportsRtl=\"true\"\r\n            android:theme=\"@style\/AppTheme\"\r\n            android:usesCleartextTraffic=\"true\">\r\n        <activity android:name=\".activity.AddDynamicActivity\" \/>\r\n        <activity android:name=\"activity.DynamicListActivity\">\r\n            <intent-filter>\r\n                <action android:name=\"android.intent.action.MAIN\" \/>\r\n                <category android:name=\"android.intent.category.LAUNCHER\" \/>\r\n            <\/intent-filter>\r\n        <\/activity>\r\n    <\/application>\r\n```\r\n\r\n\r\n\r\n我们在`debug`目录下新建了很多内容，用于为本moudle提供一个入库Activity。\r\n\r\n这些内容只在独立编译时才会用到，作为lib时无需使用。\r\n\r\n所以在`build.gradle`中配置：\r\n\r\n```groovy\r\n    sourceSets {\r\n        main() {\r\n            jniLibs.srcDirs = ['libs']\r\n            if (project.ext.isDebug) {\r\n                manifest.srcFile 'src\/debug\/AndroidManifest.xml'\r\n                res.srcDirs = ['src\/debug\/res', 'src\/main\/res']\r\n            } else {\r\n                manifest.srcFile 'src\/main\/AndroidManifest.xml'\r\n                resources {\r\n                    exclude 'src\/debug\/*'\r\n                }\r\n            }\r\n        }\r\n    }\r\n```\r\n\r\n\r\n\r\n运行后如图：\r\n\r\n![image-20191127172857836](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/moudle-8.png)\r\n\r\n可以看到现在已经没有了app moudle作为主moudle时的底部导航。\r\n\r\n因为我这里的Activity只是单纯的包含了Fragment，没有其他逻辑。\r\n\r\n\r\n\r\n目前为止，项目模块化已经基本完成。\r\n\r\n以后其他的改动都是在此基础上进行。"
  },
  {
    "title" : "关于Android旧项目模块化组件化实现--续篇",
    "created_time" : "2019-11-29 10:14:51",
    "body" : "# 0x00 前言\r\n\r\n经过[关于Android旧项目模块化组件化实现]( http:\/\/www.jenson.top\/post\/143\/ )\r\n\r\n实现模块化后。\r\n\r\n在执行sync时，发现`dynamic moudle`其他兄弟模块也都执行了从新编译，\r\n\r\n可以看到其他moudle也都执行了相应task：\r\n\r\n```txt\r\nExecuting tasks: [clean, :user:generateDebugSources, :feed:generateDebugSources, :setting:generateDebugSources, :lost:generateDebugSources, :app:generateDebugSources, :chat:generateDebugSources, :dynamic:generateDebugSources, :common:generateDebugSources] in project D:\\AndroidStudioProjects\\PetsHome\r\n\r\n> Task :clean UP-TO-DATE\r\n> Task :app:clean\r\n> Task :chat:clean\r\n> Task :common:clean\r\n> Task :dynamic:clean\r\n> Task :feed:clean\r\n> Task :lost:clean\r\n> Task :setting:clean\r\n> Task :user:clean\r\n> Task :common:preBuild UP-TO-DATE\r\n> Task :common:preDebugBuild UP-TO-DATE\r\n> Task :user:preBuild UP-TO-DATE\r\n> Task :user:preDebugBuild UP-TO-DATE\r\n> Task :common:packageDebugRenderscript NO-SOURCE\r\n> Task :user:checkDebugManifest\r\n> Task :user:generateDebugBuildConfig\r\n> Task :user:prepareLintJar UP-TO-DATE\r\n> Task :user:prepareLintJarForPublish UP-TO-DATE\r\n> Task :common:compileDebugAidl NO-SOURCE\r\n> Task :user:compileDebugAidl NO-SOURCE\r\n> Task :user:compileDebugRenderscript NO-SOURCE\r\n> Task :user:generateDebugSources\r\n> Task :feed:preBuild UP-TO-DATE\r\n> Task :feed:preDebugBuild UP-TO-DATE\r\n> Task :feed:compileDebugAidl NO-SOURCE\r\n> Task :feed:checkDebugManifest\r\n> Task :feed:compileDebugRenderscript NO-SOURCE\r\n> Task :feed:generateDebugBuildConfig\r\n> Task :feed:prepareLintJar UP-TO-DATE\r\n> Task :feed:prepareLintJarForPublish UP-TO-DATE\r\n> Task :feed:generateDebugSources\r\n> Task :setting:preBuild UP-TO-DATE\r\n> Task :setting:preDebugBuild UP-TO-DATE\r\n> Task :setting:compileDebugAidl NO-SOURCE\r\n> Task :setting:checkDebugManifest\r\n> Task :setting:compileDebugRenderscript NO-SOURCE\r\n> Task :setting:generateDebugBuildConfig\r\n> Task :setting:prepareLintJar UP-TO-DATE\r\n> Task :setting:prepareLintJarForPublish UP-TO-DATE\r\n> Task :setting:generateDebugSources\r\n> Task :lost:preBuild UP-TO-DATE\r\n> Task :lost:preDebugBuild UP-TO-DATE\r\n> Task :lost:compileDebugAidl NO-SOURCE\r\n> Task :lost:checkDebugManifest\r\n> Task :lost:compileDebugRenderscript NO-SOURCE\r\n> Task :lost:generateDebugBuildConfig\r\n> Task :lost:prepareLintJar UP-TO-DATE\r\n> Task :lost:prepareLintJarForPublish UP-TO-DATE\r\n> Task :lost:generateDebugSources\r\n> Task :app:preBuild UP-TO-DATE\r\n> Task :app:preDebugBuild UP-TO-DATE\r\n> Task :app:compileDebugAidl NO-SOURCE\r\n> Task :app:checkDebugManifest\r\n> Task :app:compileDebugRenderscript NO-SOURCE\r\n> Task :app:generateDebugBuildConfig\r\n> Task :app:prepareLintJar UP-TO-DATE\r\n> Task :app:prepareLintJarForPublish UP-TO-DATE\r\n> Task :app:generateDebugSources\r\n> Task :chat:preBuild UP-TO-DATE\r\n> Task :chat:preDebugBuild UP-TO-DATE\r\n> Task :chat:compileDebugAidl NO-SOURCE\r\n> Task :chat:checkDebugManifest\r\n> Task :chat:compileDebugRenderscript NO-SOURCE\r\n> Task :chat:generateDebugBuildConfig\r\n> Task :chat:prepareLintJar UP-TO-DATE\r\n> Task :chat:prepareLintJarForPublish UP-TO-DATE\r\n> Task :chat:generateDebugSources\r\n> Task :dynamic:preBuild UP-TO-DATE\r\n> Task :dynamic:preDebugBuild UP-TO-DATE\r\n> Task :dynamic:compileDebugAidl NO-SOURCE\r\n> Task :dynamic:checkDebugManifest\r\n> Task :dynamic:compileDebugRenderscript NO-SOURCE\r\n> Task :dynamic:generateDebugBuildConfig\r\n> Task :dynamic:prepareLintJar UP-TO-DATE\r\n> Task :dynamic:prepareLintJarForPublish UP-TO-DATE\r\n> Task :dynamic:generateDebugSources\r\n> Task :common:checkDebugManifest\r\n> Task :common:compileDebugRenderscript NO-SOURCE\r\n> Task :common:generateDebugBuildConfig\r\n> Task :common:prepareLintJar UP-TO-DATE\r\n> Task :common:prepareLintJarForPublish UP-TO-DATE\r\n> Task :common:generateDebugSources\r\n\r\nBUILD SUCCESSFUL in 0s\r\n41 actionable tasks: 24 executed, 17 up-to-date\r\n\r\n```\r\n\r\n\r\n\r\n也就是说目前只成功独立运行了`dynamic moudle`。并没有实现独立编译功能。\r\n\r\n所以对于指望独立编译以达到节省时间来说，还要继续研究。\r\n\r\n\r\n\r\n# 0x01 分析\r\n\r\n在独立运行`dynamic moudle`时，并没有使用到其他兄弟模块，它们依旧参与了编译过程。\r\n\r\n问题出在了哪里？\r\n\r\n每个Android  studio创建的项目，\r\n\r\n根目录下有个`setting.gradle`，每个moudle又有各自的`build.gradle`。\r\n\r\n在`setting.gradle`囊括了所有的moudle。\r\n\r\n如果独立运行时，不导入无关兄弟moudle，又会怎样？\r\n\r\n修改内容如下：\r\n\r\n```groovy\r\n\/\/ include ':app', ':dynamic', ':chat', ':user', ':setting', ':feed', ':lost', ':common'\r\n\/\/修改为\r\ninclude  ':dynamic', ':common'\r\n```\r\n\r\n执行sync，打印内容为：\r\n\r\n```txt\r\nExecuting tasks: [:dynamic:generateDebugSources, :common:generateDebugSources] in project D:\\AndroidStudioProjects\\PetsHome\r\n\r\n:dynamic\r\n> Task :common:preBuild UP-TO-DATE\r\n> Task :common:preDebugBuild UP-TO-DATE\r\n> Task :dynamic:preBuild UP-TO-DATE\r\n> Task :dynamic:preDebugBuild UP-TO-DATE\r\n> Task :common:packageDebugRenderscript NO-SOURCE\r\n> Task :dynamic:checkDebugManifest UP-TO-DATE\r\n> Task :dynamic:generateDebugBuildConfig UP-TO-DATE\r\n> Task :dynamic:prepareLintJar UP-TO-DATE\r\n> Task :dynamic:prepareLintJarForPublish UP-TO-DATE\r\n> Task :common:checkDebugManifest UP-TO-DATE\r\n> Task :common:compileDebugAidl NO-SOURCE\r\n> Task :dynamic:compileDebugAidl NO-SOURCE\r\n> Task :dynamic:compileDebugRenderscript NO-SOURCE\r\n> Task :dynamic:generateDebugSources UP-TO-DATE\r\n> Task :common:compileDebugRenderscript NO-SOURCE\r\n> Task :common:generateDebugBuildConfig UP-TO-DATE\r\n> Task :common:prepareLintJar UP-TO-DATE\r\n> Task :common:prepareLintJarForPublish UP-TO-DATE\r\n> Task :common:generateDebugSources UP-TO-DATE\r\n\r\nBUILD SUCCESSFUL in 0s\r\n8 actionable tasks: 8 up-to-date\r\n```\r\n\r\n可以看到要减少编译，我们需要**动态包含\/取消无关moudle**。\r\n\r\n# 0x02 修改\r\n\r\n声明一个`aloneMoudle`表示要独立编译的模块\r\n\r\n声明一个`commonMoudle`表示公共模块，\r\n\r\n声明一个`logicMoudles`表示业务模块数组列表\r\n\r\n如果`aloneMoudle`不为空，那么从`logicMoudles`取出模块和`commonMoudle`一起include。\r\n\r\n内容修改为：\r\n\r\n```groovy\r\ndef aloneMoudle = ':dynamic'\r\ndef commonMoudle = ':common'\r\ndef logicMoudles = [':app', ':dynamic', ':chat', ':user', ':setting', ':feed', ':lost']\r\n\r\nif (aloneMoudle != null) {\r\n    def index = logicMoudles.indexOf(aloneMoudle)\r\n    include logicMoudles[index], commonMoudle\r\n} else {\r\n    include ':app', ':dynamic', ':chat', ':user', ':setting', ':feed', ':lost', ':common'\r\n}\r\n```\r\n\r\n修改完成后，执行sync。没有报错，且只执行了dynamic和common相关task。\r\n\r\n但是现在要独立编译运行某个模块，\r\n\r\n除了要修改`setting.gradle`中`aloneMoudle`为相应模块名称。\r\n\r\n还要修改`common_config.gradle`中`isDebug=true`。\r\n\r\n最后修改对应模块的`build.gradle`，添加ApplicationId:\r\n\r\n```groovy\r\n        if (project.ext.isDebug) {\r\n            applicationId \"top.jenson.pet\"\r\n        }\r\n```\r\n\r\n这显然比较麻烦的。步骤多了就容易出错。\r\n\r\n# 0x03 改进\r\n\r\n三步嫌麻烦，一步到位最好。\r\n\r\n每个`build.gradle`对应一个project。\r\n\r\n`setting.gradle`对应setting\r\n\r\n目前的情况是，\r\n\r\n`common_config.gradle`可以获取到project作用域，却获取不到setting作用域。\r\n\r\n而project和setting互相无法作用。\r\n\r\n如果要一步到位，需要`common_config.gradle`、`build.gradle`和`setting.gradle`都能获取的一个作用域。\r\n\r\n而`gradle.properties`就是这三个地方都能访问的域。\r\n\r\n## 修改gradle.properties\r\n\r\n在该文件中添加内容：\r\n\r\n```\r\naloneMoudle=:app\r\n```\r\n\r\n## 修改settings.gradle\r\n\r\n该文件内容修改为：\r\n\r\n```groovy\r\ndef commonMoudle = ':common'\r\ndef mainMoudle = ':app'\r\ndef logicMoudles = [':dynamic', ':chat', ':user', ':setting', ':feed', ':lost']\r\n\r\nif (aloneMoudle == mainMoudle) {\r\n    println \"编译主模\"\r\n    include ':app', ':dynamic', ':chat', ':user', ':setting', ':feed', ':lost', ':common'\r\n} else {\r\n    println \"单独编译模块：$aloneMoudle\"\r\n    def index = logicMoudles.indexOf(aloneMoudle)\r\n    include logicMoudles[index], commonMoudle\r\n}\r\n```\r\n\r\n这里目前分为业务逻辑模块、基础模块和主模块。\r\n\r\n获取`aloneMoudle`，\r\n\r\n如果和主模块名称一致，那么说明这里不是独立编译，常规编译所有模块。\r\n\r\n如果和主模块名称不一致，说明要独立编译，那么只编译该模块和其依赖模块，兄弟模块不引入。\r\n\r\n\r\n\r\n## 修改common_config\r\n\r\n添加属性`isAloneMoudle`：\r\n\r\n```\r\nisAloneMoudle = (aloneMoudle == ':app' ? false : true)\r\n```\r\n\r\n如果`gradle.properties`中设置的`aloneMoudle`名称和主模块一致，\r\n\r\n表示不能作为独立编译`isAloneMoudle=false`，\r\n\r\n否则表示将要独立编译`isAloneMoudle=true`。\r\n\r\n\r\n\r\n修改原`setAndroidConfig extension.android`\r\n\r\n为`setAndroidConfig extension, extension.android`。\r\n\r\n改为接收2个参数。\r\n\r\n\r\n\r\n在`setAndroidConfig`闭包中，\r\n\r\n添加是否把当前模块作为主模块的判断：\r\n\r\n```groovy\r\ndef isAsMainMoudle = isAloneMoudle && aloneMoudle.contains(pro.name)\r\n```\r\n\r\n意思是上面确定了将要作为独立编译，\r\n\r\n并且独立编译模块名称和当前project名称一致，本模块才作为主模块。\r\n\r\n添加`sourceSets`设置：\r\n\r\n```groovy\r\n            if (isAsMainMoudle) {\r\n                extension.sourceSets {\r\n                    main() {\r\n                        jniLibs.srcDirs = ['libs']\r\n                        if (project.ext.isAloneMoudle) {\r\n                            manifest.srcFile 'src\/debug\/AndroidManifest.xml'\r\n                            res.srcDirs = ['src\/debug\/res', 'src\/main\/res']\r\n                        } else {\r\n                            manifest.srcFile 'src\/main\/AndroidManifest.xml'\r\n                            resources {\r\n                                exclude 'src\/debug\/*'\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n```\r\n\r\n在闭包`defaultConfig`中添加：\r\n\r\n```groovy\r\nif (isAsMainMoudle) {\r\n      applicationId \"top.jenson.pet\"\r\n}\r\n```\r\n\r\n\r\n\r\n之前的`isDebug`变量去掉，修改后的全部内容为：\r\n\r\n```groovy\r\nproject.ext {\r\n\r\n    isAloneMoudle = (aloneMoudle == ':app' ? false : true)\r\n    println \"isAloneMoudle:$isAloneMoudle\"\r\n\r\n    setAppDefaultConfig = {\r\n        extension ->\r\n            println \"@@${extension}\"\r\n            extension.apply plugin: 'com.android.application'\r\n            extension.apply plugin: 'kotlin-android'\r\n            extension.apply plugin: 'kotlin-android-extensions'\r\n            extension.apply plugin: 'kotlin-kapt'\r\n\/\/            extension.description \"app\"\r\n            setAndroidConfig extension, extension.android\r\n            setDependencies extension.dependencies\r\n    }\r\n\r\n    setLibDefaultConfig = {\r\n        extension ->\r\n            extension.apply plugin: 'com.android.library'\r\n            extension.apply plugin: 'kotlin-android'\r\n            extension.apply plugin: 'kotlin-android-extensions'\r\n            extension.apply plugin: 'kotlin-kapt'\r\n\/\/            extension.description \"library\"\r\n            setAndroidConfig extension, extension.android\r\n            setDependencies extension.dependencies\r\n    }\r\n\r\n\r\n    setAndroidConfig = {\r\n        pro, extension ->\r\n            extension.compileSdkVersion = 28\r\n            extension.buildToolsVersion = \"29.0.2\"\r\n            println \"aloneMoudle=$aloneMoudle\"\r\n            println \"pro.name=$pro.name\"\r\n            def isAsMainMoudle = isAloneMoudle && aloneMoudle.contains(pro.name)\r\n            println \"isAsMainMoudle:$isAsMainMoudle\"\r\n            extension.defaultConfig {\r\n                if (isAsMainMoudle) {\r\n                    applicationId \"top.jenson.pet\"\r\n                }\r\n                kapt {\r\n                    arguments {\r\n                        arg(\"AROUTER_MODULE_NAME\", extension.project.getName())\r\n                    }\r\n                }\r\n                minSdkVersion = 21\r\n                targetSdkVersion = 21\r\n                testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\r\n            }\r\n            if (isAsMainMoudle) {\r\n                extension.sourceSets {\r\n                    main() {\r\n                        jniLibs.srcDirs = ['libs']\r\n                        if (project.ext.isAloneMoudle) {\r\n                            manifest.srcFile 'src\/debug\/AndroidManifest.xml'\r\n                            res.srcDirs = ['src\/debug\/res', 'src\/main\/res']\r\n                        } else {\r\n                            manifest.srcFile 'src\/main\/AndroidManifest.xml'\r\n                            resources {\r\n                                exclude 'src\/debug\/*'\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n\/\/            extension.dataBinding {\r\n\/\/                enable = true\r\n\/\/            }\r\n    }\r\n\r\n    setDependencies = {\r\n        extension ->\r\n            extension.implementation fileTree(dir: 'libs', include: ['*.jar'])\r\n            extension.implementation \"org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version\"\r\n            extension.implementation 'androidx.appcompat:appcompat:1.0.2'\r\n            extension.implementation 'androidx.core:core-ktx:1.0.2'\r\n            extension.kapt 'com.alibaba:arouter-compiler:1.2.2'\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## 修改build.gradle\r\n\r\n修改所有业务模块下的`build.gradle`：\r\n\r\n```groovy\r\n\/\/project.ext.setLibDefaultConfig project\r\n\/\/改为动态设置\r\nif (project.ext.isAloneMoudle) {\r\n    project.ext.setAppDefaultConfig project\r\n} else {\r\n    project.ext.setLibDefaultConfig project\r\n}\r\n```\r\n\r\n\r\n\r\n基础模块的`build.gradle`固定位`project.ext.setLibDefaultConfig project`就好。\r\n\r\n\r\n\r\n\r\n\r\n# 0x04 结尾\r\n\r\n经过上面的修改。\r\n\r\n在给业务模块添加好独立入口代码后。\r\n\r\n\r\n\r\n**只要在`gradle.properties`改为想要独立运行的模块。**\r\n\r\n**后面流程自动执行：**\r\n\r\n然后`settings.gradle`会根据你设置的名称，找到该模块和基础模块引入，其他不引入。\r\n\r\n这样只会编译指定模块和其依赖模块(这里只有common)。\r\n\r\n每个模块编译时都会用到`common_config`。\r\n\r\n编译dynamic模块时，\r\n\r\n执行到\r\n\r\n`isAloneMoudle = (aloneMoudle == ':app' ? false : true)`\r\n\r\n返回true。\r\n\r\n执行到闭包\r\n\r\n`setAndroidConfig`时\r\n\r\n`def isAsMainMoudle = isAloneMoudle && aloneMoudle.contains(pro.name)`\r\n\r\n返回true。\r\n\r\n然后就会给该模块添加`applicationId`。\r\n\r\n同时设置编译源码位置`sourceSets`。"
  },
  {
    "title" : "Groovy闭包委托",
    "created_time" : "2019-12-22 09:00:27",
    "body" : "# 0x00 前言\r\n\r\nGroovy中闭包是一个重要的知识点。\r\n\r\nGradle中也大量使用闭包功能，\r\n\r\n所以了解闭包是一个绕不过去的坎。\r\n\r\n# 0x01 闭包介绍\r\n\r\n什么是闭包？\r\n\r\n**直观的说，闭包就是一个代码块。**\r\n\r\n大括号括起来的代码块，但不是Java中的代码块。\r\n\r\n这是一个闭包：\r\n\r\n```groovy\r\ndef f1 = { println \"this is closure\" }\r\n```\r\n\r\n这也是一个闭包：\r\n\r\n```groovy\r\ndef f2 = { x -> println \"x=$x\" }\r\n```\r\n\r\n这还是一个闭包：\r\n\r\n```groovy\r\nclass ClosureTest {\r\n    def play(closure) {\r\n        closure()\r\n    }\r\n}\r\n\r\nnew ClosureTest().play() {\/\/闭包\r\n    println \"play invoked\"\r\n}\r\n```\r\n\r\n有没有发现这货和Lambda表达式还真像。\r\n\r\n像就对了，因为闭包源于Lambda，但又高于Lambda。\r\n\r\n通过上面例子可以发现，\r\n\r\n**闭包就像一个寄生虫，它须要依附于变量或方法，不能作为代码块单独存在。**\r\n\r\n上面方法依附可以提取出为变量依附：\r\n\r\n```groovy\r\ndef playClosure = { println \"play invoked\" }\r\nnew ClosureTest().play(playClosure)\r\n```\r\n\r\n调用闭包时就像调用方法一样，加上括号和参数就行了。\r\n\r\n刚才说闭包高于Lambda，高在哪里了？\r\n\r\n高在了闭包支持方法分发。\r\n\r\n# 0x02 闭包委托\r\n\r\n上面说的方法分发，也就是本节的委托。\r\n\r\n闭包内有三个属性：`thisObject`，`owner`，`delegate`。\r\n\r\n闭包内我们难免会调用其他方法，\r\n\r\n那么闭包外部不同地方有了相同方法时，闭包怎么知道该调用哪些方法呢？\r\n\r\n这三个属性就用于确定由哪个对象来处理闭包内的方法。\r\n\r\n**`thisObject`：该属性指向的是定义该闭包所在的类或对象**\r\n\r\n**`owner`：该属性和`thisObject`相似，但是如果闭包嵌套闭包时，内部闭包`owner`指向外部闭包**\r\n\r\n**`delegate`该属性默认初始化为`owner`的值。就是说它俩是一样的。**\r\n\r\n**但是我们可以给`delegate`从新赋值来更改委托。**\r\n\r\n下面看下实操：\r\n\r\n```groovy\r\ndef testClouser = {\r\n    println \"testClouser thisObject:\" + thisObject\r\n    println \"testClouser owner:\" + owner\r\n    println \"testClouser delegate:\" + delegate\r\n}\r\ntestClouser.call()\r\n\/\/testClouser thisObject:t12@57cf54e1\r\n\/\/testClouser owner:t12@57cf54e1\r\n\/\/testClouser delegate:t12@57cf54e1\r\n```\r\n\r\n通过打印可以看到这三个属性值都是一个t12的实例对象。\r\n\r\n这里的t12是我创建的t12.groovy文件。\r\n\r\n编译后该文件会对应一个t12.class。\r\n\r\n这个闭包直接定义在文件里，所以三个属性值默认都是定义该闭包类t12的对象。\r\n\r\n再看一个例子：\r\n\r\n```groovy\r\nclass Test1 {\r\n    def static closureTest = {\r\n        println \"closureTest this:\" + thisObject\r\n        println \"closureTest owner:\" + owner\r\n        println \"closureTest delegate:\" + delegate\r\n    }\r\n}\r\n\r\nTest1.closureTest()\r\n\/\/closureTest this:class Test1\r\n\/\/closureTest owner:class Test1\r\n\/\/closureTest delegate:class Test1\r\n```\r\n\r\n这次闭包定义在了类Test1内部，而且声明了static。\r\n\r\n打印出来的时候三个属性值都是指向定义该类Test1的，\r\n\r\n再看一个例子：         \r\n\r\n```groovy\r\nclass Test1 {\r\n    def outerClosure = {\r\n        println \"outerClosure thisObject:\" + thisObject\r\n        println \"outerClosure owner:\" + owner\r\n        println \"outerClosure delegate:\" + delegate\r\n        def innerClosure = {\r\n            println \"innerClosure thisObject:\" + thisObject\r\n            println \"innerClosure owner:\" + owner\r\n            println \"innerClosure delegate:\" + delegate\r\n        }\r\n        innerClosure()\r\n    }\r\n}\r\n\r\nnew Test1().outerClosure()\r\n\/\/outerClosure thisObject:Test1@32502377\r\n\/\/outerClosure owner:Test1@32502377\r\n\/\/outerClosure delegate:Test1@32502377\r\n\/\/innerClosure thisObject:Test1@32502377\r\n\/\/innerClosure owner:Test1$_closure1@36916eb0\r\n\/\/innerClosure delegate:Test1$_closure1@36916eb0\r\n```\r\n\r\n通过打印可以看到外部闭包三个属性值都执行了Test1实例。\r\n\r\n而内部闭包的`thisObject`指向了定义该闭包所在类Test1实例。\r\n\r\n`owner`和`delegate`指向了外部闭包。\r\n\r\n通过三个例子证明了上面三个属性含义的准确性。\r\n\r\n\r\n\r\n# 0x03 闭包委托模式\r\n\r\n上面介绍了闭包委托三个属性含义，\r\n\r\n但是我们仍然不知道闭包内方法调用具体如何分发的。\r\n\r\n**默认情况下闭包委托顺序为`thisObject`->`owner`->`delegate`。**\r\n\r\n就是说闭包内方法调用时，默认先从`thisObject`指向类\/对象中寻找，如果找到了则调用。\r\n\r\n如果没有找到，路由到`owner`，由`owner`指向类\/对象中寻找，如果找到了则调用。\r\n\r\n如果没有找到，路由到`delegate`，由其指向类\/对象寻址，如果找到了则调用，否则抛出异常。\r\n\r\n实操一下：\r\n\r\n```groovy\r\nclass Example {\r\n\r\n    def str1 = \"hello\"\r\n    def outerClosure = {\r\n        def str2 = \"groovy\"\r\n        def innerClosure = {\r\n            println str1\r\n            println str2\r\n        }\r\n        innerClosure()\r\n    }\r\n\r\n    def foo(closure) {\r\n        Closure closur = closure\r\n        closur.delegate = new Handler()\r\n        closur.resolveStrategy = Closure.OWNER_FIRST\r\n        closur()\r\n    }\r\n}\r\n\r\nnew Example().outerClosure()\r\n\/\/hello\r\n\/\/groovy\r\n```\r\n\r\n打印结果不用想就知道是什么了。\r\n\r\n可以看到str1变量定义在了类内部，\r\n\r\nstr2变量定义在了外部闭包中，\r\n\r\n当在内部闭包打印两个变量时，\r\n\r\n先由`thisObject`指向当前类Example的对象处理，找打了str1。\r\n\r\n但是`thisObject`没有找到str2，所以交由`owner`处理。\r\n\r\n`owner`指向外部闭包，而str2刚好定义在外部闭包，找到并打印处理。\r\n\r\n到这里一切都还说得通，但是如何证明`delegate`呢？\r\n\r\n代码改进一下：\r\n\r\n```groovy\r\nclass Handler {\r\n    def str2 = \"Handler\"\r\n}\r\n\r\nclass Example {\r\n    def str1 = \"hello\"\r\n    def outerClosure = {\r\n        def innerClosure = {\r\n            delegate = new Handler()\r\n            println str1\r\n            println str2\r\n        }\r\n        innerClosure()\r\n    }\r\n}\r\nnew Example().outerClosure()\r\n\/\/hello\r\n\/\/Handler\r\n```\r\n\r\n这里我把str2从外部闭包中去掉，\r\n\r\n新建Handler类，里面定义了str2。\r\n\r\n常理来说在一个类闭包中直接使用另一个类的变量是怎么都说不过去的。\r\n\r\n所以我在内部闭包中加了一句`delegate = new Handler()`。\r\n\r\n回想下上面对`delegate`属性解释。\r\n\r\n默认`delegate`和`owner`是一样的值，但是我现在给从新赋值了。\r\n\r\n`delegate`指向了Handler。\r\n\r\n`thisObject`和`owner`处理不了的，由`delegate`指向的Handler来处理。\r\n\r\n所以打印了 hello Handler。\r\n\r\n上面的顺序一直按默认顺序委托的。\r\n\r\n有没有办法改变委托顺序呢？\r\n\r\n**Groovy已经为我们提供了改变委托策略：**\r\n\r\n**`Closure.OWNER_FIRST` 默认策略。**\r\n\r\n**如果属性或方法存在`owner`指向类\/对象中，那么由`owner`处理，如果不在，交由`delegate`处理**\r\n\r\n**`Closure.DELEGATE_FIRST` 颠倒了默认策略：优先交由`delegate` ，然后才是`owner`**\r\n\r\n**`Closure.OWNER_ONLY` 只交给`owner`处理，`delegate` 会被忽略**\r\n\r\n**`Closure.DELEGATE_ONLY` 只交给`delegate`处理，`owner`会被忽略**\r\n\r\n**`Closure.TO_SELF` 只交给当前闭包自己处理，不是`owner`和`delegate`，**\r\n\r\n**可以被用于当开发人员需要使用先进的元数据编程技术和希望实现一个自定义的选择策略时。**\r\n\r\n**当我们实现了自己的 Closure 子类时，他才是有意义的。**\r\n\r\n\r\n\r\n源码中只提供了这几种策略模式。\r\n\r\n而网上很多资源也都是根据这几种模式做了简单介绍。\r\n\r\n但是看完这些介绍我反而更疑惑了。\r\n\r\n1、为什么只有`Closure.OWNER_FIRST`和`Closure.DELEGATE_FIRST`，\r\n\r\n却没有`Closure.THISOBJECT_FIRST`？\r\n\r\n2、`Closure.OWNER_ONLY` 只交给`owner`处理，`delegate` 会被忽略，那么`thisObject`呢？\r\n\r\n\r\n\r\n实践出真知，我们先试试这两个only模式。\r\n\r\n首先看看`Closure.DELEGATE_ONLY`：\r\n\r\n```groovy\r\nclass Handler {\r\n    def str2 = \"Handler\"\r\n}\r\n\r\nclass Example {\r\n    def str1 = \"hello\"\r\n    def outerClosure = {\r\n        def innerClosure = {\r\n            delegate = new Handler()\r\n            resolveStrategy = DELEGATE_ONLY\r\n            println str1\r\n            println str2\r\n        }\r\n        innerClosure()\r\n    }\r\n}\r\n\r\nnew Example().outerClosure()\r\n\/\/Caught: groovy.lang.MissingPropertyException: No such property: str1 for class: Handler\r\n```\r\n\r\n上面代码并不能执行成功，\r\n\r\n异常显示str1在Handler类中找不到。\r\n\r\ninnerClosure中`thisObject`指向的是Example类对象。\r\n\r\n如果`thisObject`执行的话，那么是可以找到str1的。\r\n\r\n所以可以确定\r\n\r\n**`Closure.DELEGATE_ONLY` 将只执行`delegate`，`thisObject`和`owner`将不被执行。**\r\n\r\n再来看看`Closure.OWNER_ONLY`：\r\n\r\n```groovy\r\nclass Handler {\r\n    def str2 = \"Handler\"\r\n}\r\n\r\nclass Example {\r\n    def str1 = \"hello\"\r\n    def outerClosure = {\r\n        def innerClosure = {\r\n            delegate = new Handler()\r\n            resolveStrategy = OWNER_ONLY\r\n            println str1\r\n            println str2\r\n        }\r\n        innerClosure()\r\n    }\r\n}\r\nnew Example().outerClosure()\r\n\/\/hello\r\n\/\/Caught: groovy.lang.MissingPropertyException: No such property: str2 for class: Example\r\n```\r\n\r\n上面代码也不能执行成功。\r\n\r\n异常显示从Example类中找不到str2，但是找到了str1。\r\n\r\n上面我们了解了内部闭包的`owner`指向外部闭包。\r\n\r\n但是外部闭包并没有str1，怎么会成功打印呢？\r\n\r\n最初我也是被这块困扰的，这有点类似`类的双亲委派机制`。\r\n\r\n所以我们别忘了，`owner`指向了外部闭包，所以str1交由外部闭包来处理。\r\n\r\n外部闭包路由属性和方法时，\r\n\r\n默认又按`thisObject`->`owner`->`delegate`顺序来查找的。\r\n\r\n而外部闭包的`thisObject`指向Example类，所以它最终是能找到str1的。\r\n\r\n轮到str2时，内部闭包和外部闭包都找不到，所以抛出异常。\r\n\r\n目前可以确定\r\n\r\n**当嵌套闭包时，内部闭包有机会让`owner`执行时(包含`Closure.OWNER_ONLY`)，**\r\n\r\n**那么它就会路由到它的外部闭包。**\r\n\r\n**如此层层外翻，直到路由到最外层闭包，**\r\n\r\n**如果还是不能找到则抛出异常，任意一处路由到了指定方法\/属性，则终止。**\r\n\r\n我们再修改下代码，来验证下我的猜想：\r\n\r\n```groovy\r\nclass Handler {\r\n    def str2 = \"Handler\"\r\n}\r\n\r\nclass Example {\r\n    def str1 = \"hello\"\r\n    def outerClosure = {\r\n        delegate = new Handler()\r\n        def innerClosure = {\r\n            resolveStrategy = OWNER_ONLY\r\n            println str1\r\n            println str2\r\n        }\r\n        innerClosure()\r\n    }\r\n}\r\nnew Example().outerClosure()\r\n\/\/hello\r\n\/\/Handler\r\n```\r\n\r\n很简单的修改，\r\n\r\n只把内部闭包的`delegate`修改移动到了外部闭包。\r\n\r\n因为内部闭包设置了`OWNER_ONLY`策略，导致设置了`delegate`也无用。\r\n\r\n现在移动到外部闭包。\r\n\r\n按照上面的想法，\r\n\r\n外部闭包会默认执行`thisObject`->`owner`->`delegate`顺序来查找str2。\r\n\r\n当执行到`delegate`时交给了Handler来处理找到了str2。\r\n\r\n所以打印了Handler，而没有抛出异常，这也证实了上面的猜想。\r\n\r\n\r\n\r\n这几次实践解答了上面问题2的疑惑。\r\n\r\n**但是问题1的为什么没有`Closure.THISOBJECT_FIRST`模式呢？**\r\n\r\n**关于这个问题，**\r\n\r\n**我的想法是`Closure.OWNER_FIRST`间接实现了`Closure.THISOBJECT_FIRST`的功能。**\r\n\r\n**当只有一层闭包时，`thisObject`和`owner`指向是一样的。**\r\n\r\n**当有嵌套闭包时，`owner`指向包裹它的外层闭包，**\r\n\r\n**层层外翻，最终也会指向到`thisObject`所指向的类\/对象。**\r\n\r\n**同理`Closure.OWNER_ONLY`也间接实现了`Closure_THISOBJECT_ONLY`的功能。**\r\n\r\n**可能出于这个原因，没有设置`Closure_THISOBJECT_ONLY`和`Closure.THISOBJECT_FIRST`。**"
  },
  {
    "title" : "Flutter常见问题之软键盘顶起布局问题",
    "created_time" : "2019-12-30 03:09:28",
    "body" : "Flutter中默认情况下，页面弹出软键盘时会对当前布局产生影响：\r\n\r\n即会把底部布局挤压上去，如果不想软键盘顶起布局，可以在\r\n\r\n`scaffold`上设置：`resizeToAvoidBottomInset: false,`。\r\n\r\n默认为true会顶起布局。\r\n\r\n```dart\r\nreturn Scaffold(\r\n      resizeToAvoidBottomInset: false,\r\n      appBar: AppBar(\r\n        title: Text(\"意见反馈\"),\r\n      ),);\r\n```\r\n\r\n\r\n\r\n在`scaffold`属性中还有一个类似的属性：`resizeToAvoidBottomPadding`。\r\n\r\n该属性被标记为`@Deprecated`，推荐使用`resizeToAvoidBottomInset`。"
  },
  {
    "title" : "Flutter常见问题之软键盘显示隐藏",
    "created_time" : "2019-12-30 02:10:13",
    "body" : "如果想在`页面启动`时就设置软键盘的显示隐藏，\r\n\r\n可以通过给`TextField`设置`autofocus:`属性。\r\n\r\n `autofocus:true`表示默认弹出软键盘，\r\n\r\n`autofocus:false`表示不弹出软键盘：\r\n\r\n```dart\r\nTextField(\r\n                controller: controller,\r\n                maxLines: 8,\r\n                autofocus: true,\r\n                decoration: InputDecoration(hintText: _hintext),\r\n              )\r\n```\r\n\r\n\r\n\r\n如果想在操作过程中设置软键盘的显示隐藏，\r\n\r\n可以通过给`TextField`设置`focusNode:`属性。\r\n\r\n首先创建一个`FocusNode`实例：`FocusNode _focusNode = FocusNode();`\r\n\r\n为`TextField`设置`focusNode属性：\r\n\r\n```dart\r\nTextField(\r\n                focusNode: _focusNode,\r\n                controller: controller,\r\n                maxLines: 8,\r\n                autofocus: true,\r\n                decoration: InputDecoration(hintText: _hintext),\r\n              ),\r\n```\r\n\r\n当想让它隐藏软键盘时，设置`_focusNode.unfocus();`。\r\n\r\n当想让它显示软键盘时，设置`FocusScope.of(context).requestFocus(_focusNode);`."
  },
  {
    "title" : "Flutter常见问题之setstate内存泄漏问题",
    "created_time" : "2020-01-01 01:45:47",
    "body" : "在做延时任务返回刷新UI时，任务完成前退出页面出现了这个问题。\r\n\r\n大概意思就是在`dispose()`之后调用了`setstate()`造成的内存泄漏。\r\n\r\n既然是`setstate`使用不当造成的，就看看源码注释怎么解释的：\r\n\r\n```dart\r\n  \/\/\/ Notify the framework that the internal state of this object has changed.\r\n  \/\/\/\r\n  \/\/\/ Whenever you change the internal state of a [State] object, make the\r\n  \/\/\/ change in a function that you pass to [setState]:\r\n  \/\/\/\r\n  \/\/\/ ```dart\r\n  \/\/\/ setState(() { _myState = newValue });\r\n  \/\/\/ ```\r\n  \/\/\/\r\n  \/\/\/ The provided callback is immediately called synchronously. It must not\r\n  \/\/\/ return a future (the callback cannot be `async`), since then it would be\r\n  \/\/\/ unclear when the state was actually being set.\r\n  \/\/\/\r\n  \/\/\/ Calling [setState] notifies the framework that the internal state of this\r\n  \/\/\/ object has changed in a way that might impact the user interface in this\r\n  \/\/\/ subtree, which causes the framework to schedule a [build] for this [State]\r\n  \/\/\/ object.\r\n  \/\/\/\r\n  \/\/\/ If you just change the state directly without calling [setState], the\r\n  \/\/\/ framework might not schedule a [build] and the user interface for this\r\n  \/\/\/ subtree might not be updated to reflect the new state.\r\n  \/\/\/\r\n  \/\/\/ Generally it is recommended that the `setState` method only be used to\r\n  \/\/\/ wrap the actual changes to the state, not any computation that might be\r\n  \/\/\/ associated with the change. For example, here a value used by the [build]\r\n  \/\/\/ function is incremented, and then the change is written to disk, but only\r\n  \/\/\/ the increment is wrapped in the `setState`:\r\n  \/\/\/\r\n  \/\/\/ ```dart\r\n  \/\/\/ Future<void> _incrementCounter() async {\r\n  \/\/\/   setState(() {\r\n  \/\/\/     _counter++;\r\n  \/\/\/   });\r\n  \/\/\/   Directory directory = await getApplicationDocumentsDirectory();\r\n  \/\/\/   final String dirName = directory.path;\r\n  \/\/\/   await File('$dir\/counter.txt').writeAsString('$_counter');\r\n  \/\/\/ }\r\n  \/\/\/ ```\r\n  \/\/\/\r\n  \/\/\/ It is an error to call this method after the framework calls [dispose].\r\n  \/\/\/ You can determine whether it is legal to call this method by checking\r\n  \/\/\/ whether the [mounted] property is true.\r\n  @protected\r\n  void setState(VoidCallback fn) {\r\n  \r\n  }\r\n```\r\n\r\n注释前面主要介绍如何正确使用`setstate`：\r\n\r\n**只在`setstate`中包裹和状态直接相关的变更值。**\r\n\r\n**其他诸如计算、IO操作不要放在里面。**\r\n\r\n最后介绍了当框架层调用了`dispose`后，你再调用`setstate`会出现异常。\r\n\r\n你可以通过使用`mounted`检查它是否为`true`。然后再调用`setstate`。\r\n\r\n所以我们目前可以这样使用：\r\n\r\n```dart\r\nif (mounted) {\r\n      setState(() {\r\n        visiable = !visiable;\r\n      });\r\n    }\r\n```\r\n\r\n\r\n\r\n顺便看一下`mounted`是什么东西：\r\n\r\n```dart\r\n\/\/\/ Whether this [State] object is currently in a tree.\r\n  \/\/\/\r\n  \/\/\/ After creating a [State] object and before calling [initState], the\r\n  \/\/\/ framework \"mounts\" the [State] object by associating it with a\r\n  \/\/\/ [BuildContext]. The [State] object remains mounted until the framework\r\n  \/\/\/ calls [dispose], after which time the framework will never ask the [State]\r\n  \/\/\/ object to [build] again.\r\n  \/\/\/\r\n  \/\/\/ It is an error to call [setState] unless [mounted] is true.\r\n  bool get mounted => _element != null;\r\n```\r\n\r\n注释中说明了`mounted`用来判断你的`state`对象是否还在控件树。\r\n\r\n创建`state`对象后到调用`initState`之前，框架层通过关联`state`和`BuildContext`来完成挂载。\r\n\r\n在框架层调用`dispose`之前都是存在的。\r\n\r\n**可以知道通过`mounted`来判断`state`是否还存活。**\r\n\r\n**如果返回`true`，才可以安全的调用`setstate`更新状态。**\r\n\r\n\r\n\r\n**如果业务中需要使用延时操作，可以使用`Timer`代替`Future`。**\r\n\r\n**因为`Timer.cancel`可以在`dispose`回调方法中取消延时，而`Future`没有取消操作。**"
  },
  {
    "title" : "Flutter入门之Dialog使用",
    "created_time" : "2020-01-04 08:59:55",
    "body" : "Flutter为我们提供了两种Dialog：\r\n\r\n`SimpleDialog`和`AlertDialog`。\r\n\r\n通过`showDialog`方法，可以避免我们在`build`方法的一大串布局控件中去添加dialog。\r\n\r\n而是把dialog提取到一个方法中：\r\n\r\n```dart\r\n  \/\/\/显示提示对话框\r\n  Future showAlertDialog() async {\r\n    return showDialog(\r\n        context: context,\r\n        builder: (context) {\r\n          return AlertDialog(\r\n            title: Text(\"此操作会删除数据\"),\r\n            content: Text(\"确定删除吗？\"),\r\n            actions: <Widget>[\r\n              FlatButton(\r\n                child: Text(\"取消\"),\r\n                onPressed: () {\r\n                  Navigator.of(context).pop();\r\n                },\r\n              ),\r\n              FlatButton(\r\n                child: Text(\"确定\"),\r\n                onPressed: () {\r\n                  Navigator.of(context).pop();\r\n                },\r\n              ),\r\n            ],\r\n          );\r\n        });\r\n  }\r\n\r\n  \/\/\/显示简单对话框\r\n  Future showSimpleDialog() async {\r\n    return showDialog(\r\n        context: context,\r\n        builder: (context) {\r\n          return SimpleDialog(\r\n            title: Text(\"这是simpledialog\"),\r\n            children: <Widget>[\r\n              SimpleDialogOption(\r\n                onPressed: () {},\r\n                child: Text(\"第一行信息\"),\r\n              ),\r\n              SimpleDialogOption(\r\n                onPressed: () {},\r\n                child: Text(\"第二行信息\"),\r\n              ),\r\n            ],\r\n          );\r\n        });\r\n  }\r\n```\r\n\r\n\r\n\r\n`AlertDialog`通过`actions`属性添加操作。\r\n\r\n`SimpleDialog`通过`children`添加内容，其中可以通过`SimpleDialogOption`添加简单操作。"
  },
  {
    "title" : "Flutter入门之Loading使用",
    "created_time" : "2020-01-04 09:01:11",
    "body" : "loading使用一般有2种场景：\r\n\r\n场景一：点击某个按钮进行耗时操作前弹出loading直到耗时操作完成，才可继续操作页面。\r\n\r\n场景二：刚进入某个页面时就执行耗时操作，直到耗时操作完成才显示页面。\r\n\r\n\r\n\r\n场景一可以使用`Stack`，它类似Android中的`FrameLayout`。\r\n\r\n最后声明的控件在最上层，这样把loading声明最后，在需要的时候显示出来，\r\n\r\n可以阻止对页面进行其他操作，实现如下：\r\n\r\n```dart\r\n@override\r\n  Widget build(BuildContext context) {\r\n    final TextEditingController controller = TextEditingController();\r\n    controller.addListener(() {\r\n      _feedText = controller.text;\r\n    });\r\n    return Scaffold(\r\n      appBar: AppBar(\r\n        title: Text(\"意见反馈\"),\r\n      ),\r\n      body: Container(\r\n        width: double.infinity,\r\n        height: double.infinity,\r\n        margin: const EdgeInsets.all(20),\r\n        child: Stack(\r\n          children: <Widget>[\r\n            Align(\r\n              alignment: FractionalOffset.topCenter,\r\n              child: TextField(\r\n                focusNode: _focusNode,\r\n                controller: controller,\r\n                maxLines: 8,\r\n                autofocus: true,\r\n                decoration: InputDecoration(hintText: _hintext),\r\n              ),\r\n            ),\r\n            Align(\r\n              alignment: FractionalOffset.bottomCenter,\r\n              child: RaisedButton(\r\n                color: Colors.blue,\r\n                shape: RoundedRectangleBorder(\r\n                    borderRadius: BorderRadius.all(Radius.circular(6))),\r\n                onPressed: () {\r\n                  submitFeedBack();\r\n                },\r\n                child: Text(\r\n                  \"提交\",\r\n                  style: TextStyle(fontSize: 16, color: Colors.white),\r\n                ),\r\n              ),\r\n            ),\r\n            Offstage(\r\n              offstage: visiable,\r\n              child: LoadingWidget(),\/\/封装的loading控件\r\n            ),\r\n          ],\r\n        ),\r\n      ),\r\n    );\r\n  }\r\n```\r\n\r\n\r\n\r\n场景二可以使用`visiable ? Loading(): Center()`方式：\r\n\r\n```dart\r\nclass _FirstPageState extends State<FirstPage> {\r\n  bool visiable = true;\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    print(\"FirstPage - build\");\r\n    Future.delayed(Duration(seconds: 6), () {\r\n      if (mounted) {\r\n        setState(() {\r\n          visiable = false;\r\n        });\r\n      }\r\n    });\r\n\r\n    return Scaffold(\r\n      appBar: AppBar(\r\n        title: Text(\"firstPage\"),\r\n      ),\r\n      body: visiable\/\/初始为true显示loading。\r\n          ? Text(\"loading....\")\r\n          : Center(),\r\n    );\r\n  }\r\n}\r\n\r\n```"
  },
  {
    "title" : "关于Android旧项目模块化组件化实现(三)",
    "created_time" : "2020-01-13 06:53:47",
    "body" : "# 0x00 前言\r\n\r\n在前面两篇组件化文章中，\r\n\r\n通过[关于Android旧项目模块化组件化实现](http:\/\/www.jenson.top\/post\/143\/)实现了模块独立运行，\r\n\r\n通过[关于Android旧项目模块化组件化实现--续篇](http:\/\/www.jenson.top\/post\/144\/)实现了模块独立编译。\r\n\r\n但是细细考量下会发现还有很多可以改进的地方。\r\n\r\n比如公司项目有多个apk。\r\n\r\n各个apk又都涉及了相同组件的使用该怎么办？\r\n\r\n这里我提出个概念“组件司有化”。\r\n\r\n**所谓“组件司有化”，是指提取组件，使其不局限于app内使用，**\r\n\r\n**而是上升到公司高度，使公司内部其他项目都能使用它。**\r\n\r\n那么如何实现\"组件司有化\"？\r\n\r\n首先组件\/模块打包aar，\r\n\r\n其次公司搭建内部maven库，\r\n\r\n然后aar上传maven库，\r\n\r\n最后依赖maven库添加。\r\n\r\n下面看每一步具体如何实现。\r\n\r\n# 0x01 组件打包aar\r\n\r\n在侧边栏打开`Gradle任务栏`，找到`xx模块\/Tasks\/build\/build`：\r\n\r\n![image-20200113114029599](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200113114029599.png)\r\n\r\n双击执行后在模块的`build\/outputs\/aar\/`目录生成了打包好的aar。\r\n\r\n这里生成的了`debug`和`release`两种包：\r\n\r\n![image-20200113114052907](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200113114052907.png)\r\n\r\n如果要生成某一种包，可以在`xx模块\/Tasks\/other\/`下，\r\n\r\n找到`assembleDebug`和`assembleRelease`：\r\n\r\n![image-20200113114118337](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200113114118337.png)\r\n\r\n点击即可生成对应类型的aar。\r\n\r\n\r\n\r\n# 0x02 搭建私有maven\r\n\r\n## 下载仓库\r\n\r\n下载[nexus-repository-oss](https:\/\/www.sonatype.com\/nexus-repository-oss)。\r\n\r\n如果不想直接使用最新类型，\r\n\r\n从这里下载[版本列表](https:\/\/help.sonatype.com\/repomanager3\/download\/download-archives---repository-manager-3)\r\n\r\n## 运行\r\n\r\n下载后解压，\r\n\r\n通过`cmd`进入目录`C:\\Users\\Jenson\\Downloads\\nexus-3.20.0-04-win64\\nexus-3.20.0-04\\bin`。\r\n\r\n执行`nexus.exe \/run`启动服务。\r\n\r\n出现如下字样表示启动成功：\r\n\r\n![image-20200113114404384](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200113114404384.png)\r\n\r\n执行`http:\/\/localhost:8081\/`打开服务页面。\r\n\r\n## 登录\r\n\r\n旧版登录账号密码为admin;admin123。\r\n\r\n新版密码改了，账号仍然是`admin`\r\n\r\n在解压目录搜索`admin`，出现`admin.password`字样的文件。\r\n\r\n或者在目录`C:\\Users\\Jenson\\Downloads\\nexus-3.20.0-04-win64\\sonatype-work\\nexus3`查找。\r\n\r\n打开密码文件，复制该文件中字符串登录即可。\r\n\r\n参考：[Nexus3 初始密码不再是admin123](https:\/\/www.jianshu.com\/p\/fcb128e34c87)\r\n\r\n\r\n\r\n# 0x03 创建repository\r\n\r\n## 介绍\r\n\r\n登录后的nexus页面很简单，顶部只有2个tab。\r\n\r\n第一个tab页面只有创建好的列表和手动上传两块功能。\r\n\r\n![image-20200113115257718](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200113115257718.png)\r\n\r\n第二个tab页面虽然功能稍多，但是平常也只用到repository：\r\n\r\n可以创建新的repository并配置存储目录。\r\n\r\n![image-20200113115555754](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200113115555754.png)\r\n\r\n## 创建\r\n\r\n点击创建一个新的存储位置，默认在C盘不太好。\r\n\r\n![image-20200113115758053](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200113115758053.png)\r\n\r\n位置路径分配到D盘：\r\n\r\n![image-20200113115915543](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200113115915543.png)\r\n\r\n点击创建。\r\n\r\n创建新的repository：\r\n\r\n![image-20200113115950018](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200113115950018.png)\r\n\r\n这里因为用的maven，所以选择maven2类型：\r\n\r\n![image-20200113120027853](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200113120027853.png)\r\n\r\n![image-20200113120302940](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200113120302940.png)\r\n\r\n创建好之后列表多了个新的repository：\r\n\r\n![image-20200113120345972](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200113120345972.png)\r\n\r\n\r\n\r\n# 0x04 aar上传\r\n\r\n前面创建好了repository，\r\n\r\n创建仓库就是要存储东西的，\r\n\r\n上传有手动和自动两种。\r\n\r\n## 手动上传\r\n\r\n进入upload页面，选择新建的user repository：\r\n\r\n![image-20200113120538582](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200113120538582.png)\r\n\r\n\r\n\r\n创建之前我们先分析下添加依赖时各个部件名称：\r\n\r\n```groovy\r\nimplementation 'top.jenson.user:libuser:1.1.4'\r\n\/\/使用冒号分隔，各个部分名称为：\r\n\/\/'groupId:artifactId:version'\r\n```\r\n\r\n了解了这三部分可以继续上传了：\r\n\r\n![image-20200113121053127](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200113121053127.png)\r\n\r\n填完后内容：\r\n\r\n![image-20200113121132568](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200113121132568.png)\r\n\r\n上传后有提示信息：\r\n\r\n![image-20200113121212906](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200113121212906.png)\r\n\r\n点击查看页面如下：\r\n\r\n![image-20200113121238903](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200113121238903.png)\r\n\r\n\r\n\r\n通过browse查看如图：\r\n\r\n![image-20200113121359053](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200113121359053.png)\r\n\r\n至此已经完成了user库的1.0.0版本的手动上传。\r\n\r\n\r\n\r\n## 自动上传\r\n\r\n上面手工上传，在库较少情况下还可以，但是随着项目发展，\r\n\r\n库越来越多时，每个手动上传就比较蛋疼了。\r\n\r\n所以实现自动上传是有必要的。\r\n\r\n在项目根目录(以便其他moudle引用)创建`upload_to_maven.gradle`。\r\n\r\n首先添加`maven`插件\r\n\r\n```groovy\r\napply plugin: 'maven'\r\n```\r\n\r\n然后设置仓库url和账号、密码信息：\r\n\r\n```groovy\r\n\/\/定义变量\r\n\/\/设置仓库位置\r\ndef RELEASE_REPOSITORY_URL = 'http:\/\/127.0.0.1:8081\/repository\/user\/'\r\n\/\/登录账号\r\ndef NEXUS_USERNAME = 'admin'\r\n\/\/登录密码\r\ndef NEXUS_PASSWORD = 'qqqq'\r\n```\r\n\r\n然后就是上传逻辑了，\r\n\r\n我们既然依赖了maven插件，它就给我们提供了相应的上传闭包：\r\n\r\n```groovy\r\nafterEvaluate { project ->\r\n    println \"project=$project.name\"\r\n    uploadArchives {\r\n        repositories {\r\n            mavenDeployer {\r\n\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n我们要做的就是在`mavenDeployer`完成功能。\r\n\r\n由于我这里只打算用user模块测试，所以内容填写的是user模块相关：\r\n\r\n```groovy\r\nafterEvaluate { project ->\r\n    println \"project=$project.name\"\r\n    uploadArchives {\r\n        repositories {\r\n            mavenDeployer {\r\n                pom.groupId = 'top.jenson.user'\r\n                pom.artifactId = 'libuser'\r\n                pom.version = '1.1.1'\r\n                pom.packaging = 'aar'\r\n                pom.name = project.name\r\n                repository(url: RELEASE_REPOSITORY_URL) {\r\n                    authentication(userName: NEXUS_USERNAME, password: NEXUS_PASSWORD)\r\n                }\r\n\/\/                snapshotRepository(url: SNAPSHOT_REPOSITORY_URL) {\r\n\/\/                    authentication(userName: NEXUS_USERNAME, password: NEXUS_PASSWORD)\r\n\/\/                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n全部内容为：\r\n\r\n```groovy\r\napply plugin: 'maven'\r\n\r\ndef RELEASE_REPOSITORY_URL = 'http:\/\/127.0.0.1:8081\/repository\/user\/'\r\ndef NEXUS_USERNAME = 'admin'\r\ndef NEXUS_PASSWORD = 'qqqq'\r\n\r\nafterEvaluate { project ->\r\n    println \"project=$project.name\"\r\n    uploadArchives {\r\n        repositories {\r\n            mavenDeployer {\r\n                pom.groupId = 'top.jenson.user'\r\n                pom.artifactId = 'libuser'\r\n                pom.version = '1.1.1'\r\n                pom.packaging = 'aar'\r\n                pom.name = project.name\r\n\r\n                repository(url: RELEASE_REPOSITORY_URL) {\r\n                    authentication(userName: NEXUS_USERNAME, password: NEXUS_PASSWORD)\r\n                }\r\n\/\/                snapshotRepository(url: SNAPSHOT_REPOSITORY_URL) {\r\n\/\/                    authentication(userName: NEXUS_USERNAME, password: NEXUS_PASSWORD)\r\n\/\/                }\r\n\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\nuser模块的build.gradle添加该文件依赖：\r\n\r\n```groovy\r\napply from:\"${rootProject.rootDir}\/upload_to_maven.gradle\"\r\n```\r\n\r\n然后在`gradle任务栏`，user模块下找到uploadArchives任务双击执行\r\n\r\n![image-20200113124231648](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200113124231648.png)\r\n\r\n\r\n\r\n出现如下字样表示上传成功：\r\n\r\n![image-20200113124421013](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200113124421013.png)\r\n\r\n\r\n\r\n接下里还要去maven库中看看是不是真得存在了：\r\n\r\n![image-20200113124554173](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200113124554173.png)\r\n\r\n可以看到aar文件已经存在已经上传成功了。\r\n\r\n\r\n\r\n## 自动上传优化\r\n\r\n上面只是针对user模块使用，所以groupId、artifactId和version都直接写代码里面了。\r\n\r\n这里我们进行抽取，以保证各个模块通用：\r\n\r\n在需要的模块下创建`gradle.properties`文件，比如user添加内容：\r\n\r\n```properties\r\nGROUPID=top.jenson.user\r\nARTIFACT_ID=libuser\r\nVERSION=1.1.1\r\n```\r\n\r\n原本的pom信息直接调用这些变量即可：\r\n\r\n```properties\r\n pom.groupId = GROUPID\r\n pom.artifactId = ARTIFACT_ID\r\n pom.version = VERSION\r\n pom.packaging = 'aar'\r\n pom.name = project.name\r\n```\r\n\r\ngradle文件最终修改为：\r\n\r\n```groovy\r\napply plugin: 'maven'\r\n\r\ndef RELEASE_REPOSITORY_URL = 'http:\/\/127.0.0.1:8081\/repository\/user\/'\r\ndef NEXUS_USERNAME = 'admin'\r\ndef NEXUS_PASSWORD = 'qqqq'\r\n\r\nafterEvaluate { project ->\r\n    println \"project=$project.name\"\r\n    uploadArchives {\r\n        repositories {\r\n            mavenDeployer {\r\n                println \"groupId=$GROUPID, artifactId=$ARTIFACT_ID, version=$VERSION\"\r\n                pom.groupId = GROUPID\r\n                pom.artifactId = ARTIFACT_ID\r\n                pom.version = VERSION\r\n                pom.packaging = 'aar'\r\n                pom.name = project.name\r\n\r\n                repository(url: RELEASE_REPOSITORY_URL) {\r\n                    authentication(userName: NEXUS_USERNAME, password: NEXUS_PASSWORD)\r\n                }\r\n\/\/                snapshotRepository(url: SNAPSHOT_REPOSITORY_URL) {\r\n\/\/                    authentication(userName: NEXUS_USERNAME, password: NEXUS_PASSWORD)\r\n\/\/                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n上面添加了打印信息，看下打印日志：\r\n\r\n![image-20200113143725884](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200113143725884.png)\r\n\r\n\r\n\r\n\r\n\r\n# 0x05 maven依赖添加\r\n\r\n上面已经完成了aar的打包和上传。\r\n\r\n我们做了这么多都是为了这一步：使用\r\n\r\n接下来我们就希望像使用第三方库一样依赖使用。\r\n\r\n创建一个新项目`mavenTest`。\r\n\r\n由于我们使用了私有maven库，所以在项目的`build.gradle`添加私有repository：\r\n\r\n```groovy\r\nallprojects {\r\n    repositories {\r\n        maven {\r\n            url 'http:\/\/127.0.0.1:8081\/repository\/user\/'\r\n        }\r\n        google()\r\n        jcenter()\r\n    }\r\n}\r\n```\r\n\r\n在模块下添加依赖：\r\n\r\n```groovy\r\n    implementation 'top.jenson.user:libuser:1.1.1@aar'\r\n```\r\n\r\n同步之后查看external library：\r\n\r\n![image-20200113141159102](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200113141159102.png)\r\n\r\n可以看到通过新依赖已经成功下载到新项目中，\r\n\r\n后面就可以随意使用了。\r\n\r\n\r\n\r\n\r\n\r\n# 0x06 结尾\r\n\r\n你可能好奇`implementation 'top.jenson.user:libuser:1.1.1@aar'`这个是怎么来的？为什么加个aar？\r\n\r\n![image-20200113141450534](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200113141450534.png)\r\n\r\n在repository中，可以选择要添加的方式。\r\n\r\n这里选择了gradle后，下面直接给出了依赖代码。\r\n\r\n如果不加aar，好像会查找相应的jar。\r\n\r\n\r\n\r\n> windows下有个巨坑问题就是其他操作都正常情况下，\r\n>\r\n> 每次添加依赖同步时都会出现`Unable to resolve dependency`错误。\r\n>\r\n> 总的来说就是找不到依赖包。\r\n>\r\n> 网上找了一天信息都没有遇到这个问题的。。\r\n>\r\n> 最终通过如下方式应该可以解决：\r\n>\r\n> 第一种入手点是\r\n>\r\n> 启动nexus服务时，系统会弹出通信提示窗口，\r\n>\r\n> 意思是nexus.exe要请求通信，\r\n>\r\n> 给出2个勾选框，1是家里、办公室环境2是机场、咖啡厅\r\n>\r\n> 这里把这两个都勾选上。尤其是1。如果你已经错过这个了，建议从新解压运行。\r\n>\r\n> 第二种入手点是\r\n>\r\n> 找到`C:\\Users\\Jenson\\Downloads\\nexus-3.20.0-04-win64\\sonatype-work\\nexus3\\etc\\nexus.properties`配置文件。\r\n>\r\n> 把`application-host=0.0.0.0`改为`127.0.0.1`。\r\n>\r\n> 第三种入手点是降级下载旧版,\r\n>\r\n> 比如[这个文章](https:\/\/blog.csdn.net\/xiaxiayige\/article\/details\/80636091)使用了3.12版本而且可以正常使用。\r\n>\r\n> 你也可以安装这个版本,然后参照文章按步操作。\r\n\r\n\r\n\r\n\r\n\r\n我当时问题是3.20新版没有勾选家里、办公室环境那个。\r\n\r\n最终删除新版安装旧版时又弹窗，然后勾选了。\r\n\r\n然后旧版竟然可以用了，接着从新解压新版并运行，此时新版也可以使用了。"
  },
  {
    "title" : "Dart入门之扩展函数",
    "created_time" : "2020-01-15 04:20:27",
    "body" : "# 0x00 前言\r\n\r\nDart2.7提供了一个令人期待的功能，就是扩展函数。\r\n\r\n用过Kotlin或Groovy的应该很熟悉。\r\n\r\n它是向既有库添加新功能的方式。\r\n\r\n虽然是扩展函数，但是和使用普通函数没有什么区别，\r\n\r\n所以你并不会感知到它。\r\n\r\n一般来说，如果你使用别人的API或者被广泛使用的库时，你想修改它是不现实的。\r\n\r\n但是仍然想扩展它的一些功能。\r\n\r\n这时扩展函数就派上用场了。\r\n\r\n\r\n\r\n# 0x01 介绍\r\n\r\n通常我们会像选这样把字符串转为int：\r\n\r\n```dart\r\nint.parse('42')\r\n```\r\n\r\n但是如果在String类上有类似的替代函数，想必它会更简短易用：\r\n\r\n```dart\r\n'42'.parseInt()\r\n```\r\n\r\n要使用这个功能，你可以导入包含String的扩展类库：\r\n\r\n```dart\r\nimport 'string_apis.dart';\r\nprint('42'.parseInt()); \/\/ Use an extension method.\r\n```\r\n\r\n扩展功能不仅可以定义方法，还能定义成员，如getter、setter、operators。\r\n\r\n另外扩展也可以有名称，这在API冲突时很有用。\r\n\r\n# 0x02 定义\r\n\r\n下面看看如何实现对字符串进行操作的扩展函数`parseInt()`：\r\n\r\n```dart\r\nextension NumberParsing on String {\r\n  int parseInt() {\r\n    return int.parse(this);\r\n  }\r\n  \/\/ ···\r\n}\r\n```\r\n\r\n**定义扩展函数时，**\r\n\r\n**先使用`extension`关键字，后面跟`扩展名`，**\r\n\r\n**`扩展名`后面接 关键字 `on`，**\r\n\r\n**`on`关键字后面接要作用的类。**\r\n\r\n**然后是代码块定义函数。**\r\n\r\n语法格式：\r\n\r\n```dart\r\nextension <extension name> on <type> {\r\n  (<member definition>)*\r\n}\r\n```\r\n\r\n**如果你想要创建一个只在声明它的库中使用的扩展函数，**\r\n\r\n**可以省略它的扩展名或者扩展名以下划线(_)开头：**\r\n\r\n```dart\r\nextension on String {\r\n  double parseDouble() {\r\n    return double.parse(this);\r\n  }\r\n}\r\n\r\nextension _NumParseon on String {\r\n  double parseDouble() {\r\n    return double.parse(this);\r\n  }\r\n}\r\n```\r\n\r\n\r\n\r\n# 0x03 使用\r\n\r\n## 静态和动态类型\r\n\r\n**不能在动态变量上使用扩展函数**\r\n\r\n例如，下面这样做会出现异常：\r\n\r\n```dart\r\ndynamic d = '2';\r\nprint(d.parseInt()); \/\/ Runtime exception: NoSuchMethodError\r\n```\r\n\r\n**扩展函数可以和类型推断一起使用**\r\n\r\n例如，下面代码会正常运行：\r\n\r\n```dart\r\nvar v = '2';\r\nprint(v.parseInt()); \/\/ Output: 2\r\n```\r\n\r\n**`dynamic`不能使用是因为扩展函数是静态解析的。**\r\n\r\n**`dynamic`只有在运行期才能确定其类型，**\r\n\r\n**也由于扩展函数的静态解析原因，所以不用担心它的性能问题。**\r\n\r\n\r\n\r\n## API冲突问题\r\n\r\n现在定义了2个string扩展文件：\r\n\r\nstring_ex.dart：\r\n\r\n```dart\r\nextension NumberParsing on String {\r\n  int parseInt() {\r\n    return int.parse(this);\r\n  }\r\n}\r\n```\r\n\r\nstring_ex2.dart：\r\n\r\n```dart\r\nextension NumberParsing2 on String {\r\n  int parseInt() {\r\n    return int.parse(this);\r\n  }\r\n}\r\n\r\nextension PhoneParsing on String {\r\n  bool isPhone() {\r\n    return false;\r\n  }\r\n}\r\n```\r\n\r\n都引入的时候会出现冲突问题：\r\n\r\n![image-20200115104953260](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200115104953260.png)\r\n\r\n如果你的扩展成员和其他接口或者其他扩展成员冲突，那么你不得不采取一些措施。\r\n\r\n**使用`show`或`hide`限制公开的API**：\r\n\r\n```dart\r\nimport 'string_ex.dart';\r\nimport 'string_ex2.dart' hide NumberParsing2;\r\n\r\nvoid main() {\r\n  print(\"22\".parseInt());\r\n  print(\"33\".isPhone());\r\n}\r\n```\r\n\r\n\r\n\r\n**使用`显示扩展`，即通过扩展名调用扩展函数。不过这会让你的代码看起来像包装类**：\r\n\r\n```dart\r\nimport 'string_ex.dart';\r\nimport 'string_ex2.dart';\r\n\r\nvoid main() {\r\n  \/\/ print('42'.parseInt()); \/\/ Doesn't work.\r\n  print(NumberParsing('22').parseInt());\r\n  print(NumberParsing2('33').parseInt());\r\n  print(\"33\".isPhone());\r\n}\r\n```\r\n\r\n\r\n\r\n**如果扩展名都相同了，可以通过`as`给`导入文件`定义别名**：\r\n\r\nstring_ex3.dar:\r\n\r\n```dart\r\nextension NumberParsing on String {\r\n  int parseInt() {\r\n    return int.parse(this);\r\n  }\r\n}\r\n```\r\n\r\n这和sting_ex.dart扩展名冲突。\r\n\r\n通过`as`给导入文件定义别名：\r\n\r\n```dart\r\nimport 'string_ex.dart';\r\nimport 'string_ex2.dart';\r\nimport 'string_ex3.dart' as ex3;\r\n\r\nvoid main() {\r\n  \/\/ print('42'.parseInt()); \/\/ Doesn't work.\r\n  print(NumberParsing('22').parseInt());\r\n  print(NumberParsing2('33').parseInt());\r\n  print(ex3.NumberParsing('55').parseInt());\r\n  print(\"33\".isPhone());\r\n}\r\n\r\n```"
  },
  {
    "title" : "Flutter框架之CachedNetworkImage源码分析",
    "created_time" : "2020-01-16 06:32:41",
    "body" : "# 0x00 前言\r\n\r\n图片框架是各个平台必备产品，Flutter也不例外。\r\n\r\n目前Flutter生态还在发展阶段，可选择性并不多。\r\n\r\n在做信息流时，我选择了`CachedNetworkImage`作为图片显示框架。\r\n\r\n因为别说对框架不熟悉，就连Flutter都才刚上手。\r\n\r\n所以瞅瞅框架源码如何实现以便更好使用是有必要的。\r\n\r\n# 0x01 介绍\r\n\r\n在使用之前要先添加库的依赖，\r\n\r\n关于`cached_network_image`信息可以在这查找：[cached_network_image](https:\/\/pub.dev\/packages\/cached_network_image)。\r\n\r\n添加依赖后看下如何使用：\r\n\r\n```dart\r\n        child: CachedNetworkImage(\r\n          imageUrl: imgs[i].imgUrl,\r\n        )\r\n```\r\n\r\n没错最基本的使用，就是这么简单。\r\n\r\n看下构造函数：\r\n\r\n```dart\r\n  CachedNetworkImage({\r\n    Key key,\r\n    @required this.imageUrl,\r\n    this.imageBuilder,\r\n    this.placeholder,\r\n    this.errorWidget,\r\n    this.fadeOutDuration: const Duration(milliseconds: 1000),\r\n    this.fadeOutCurve: Curves.easeOut,\r\n    this.fadeInDuration: const Duration(milliseconds: 500),\r\n    this.fadeInCurve: Curves.easeIn,\r\n    this.width,\r\n    this.height,\r\n    this.fit,\r\n    this.alignment: Alignment.center,\r\n    this.repeat: ImageRepeat.noRepeat,\r\n    this.matchTextDirection: false,\r\n    this.httpHeaders,\r\n    this.cacheManager,\r\n    this.useOldImageOnUrlChange: false,\r\n    this.color,\r\n    this.filterQuality: FilterQuality.low,\r\n    this.colorBlendMode,\r\n    this.placeholderFadeInDuration,\r\n  }) \r\n```\r\n\r\n可以看到虽然参数很多，但必须的就只有`imageUrl`这一项。\r\n\r\n所以只要设置了`imageUrl`就能显示图片了。\r\n\r\n如果为了更好地体验，\r\n\r\n可以使用`placeholder`作为加载中的占位符，\r\n\r\n可以使用`errorWidget`作为加载失败的占位符。\r\n\r\n但是作为图片框架，其核心功能应该是缓存功能，下面看看如何实现缓存的。\r\n\r\n# 0x02 缓存分析\r\n\r\n\r\n\r\n`CachedNetworkImage`是一个`StatefulWidget`，\r\n\r\n所以必然有一个与之对应的`State`类，\r\n\r\n通过`createState`看到了是`CachedNetworkImageState`:\r\n\r\n```dart\r\n  @override\r\n  CachedNetworkImageState createState() {\r\n    return CachedNetworkImageState();\r\n  }\r\n```\r\n\r\n进去`CachedNetworkImageState`类看看`build`：\r\n\r\n```dart\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return _animatedWidget();\r\n  }\r\n```\r\n\r\n一行代码，只是简单调用了内部方法，\r\n\r\n看看该方法实现：\r\n\r\n```dart\r\n  _animatedWidget() {\r\n    var fromMemory = _cacheManager().getFileFromMemory(widget.imageUrl);\r\n\r\n    return StreamBuilder<FileInfo>(\r\n      key: _streamBuilderKey,\r\n      initialData: fromMemory,\r\n      stream: _cacheManager()\r\n          .getFile(widget.imageUrl, headers: widget.httpHeaders)\r\n          \/\/ ignore errors if not mounted\r\n          .handleError(() {}, test: (_) => !mounted)\r\n          .where((f) =>\r\n              f?.originalUrl != fromMemory?.originalUrl ||\r\n              f?.validTill != fromMemory?.validTill),\r\n      builder: (BuildContext context, AsyncSnapshot<FileInfo> snapshot) {\r\n        if (snapshot.hasError) {\r\n          \/\/ error\r\n          if (_imageHolders.length == 0 || _imageHolders.last.error == null) {\r\n            _addImage(image: null, error: snapshot.error);\r\n          }\r\n        } else {\r\n          var fileInfo = snapshot.data;\r\n          if (fileInfo == null) {\r\n            \/\/ placeholder\r\n            if (_imageHolders.length == 0 || _imageHolders.last.image != null) {\r\n              _addImage(\r\n                  image: null,\r\n                  duration: widget.placeholderFadeInDuration ?? Duration.zero);\r\n            }\r\n          } else if (_imageHolders.length == 0 ||\r\n              _imageHolders.last.image?.originalUrl != fileInfo.originalUrl ||\r\n              _imageHolders.last.image?.validTill != fileInfo.validTill) {\r\n            _addImage(\r\n                image: fileInfo,\r\n                duration: _imageHolders.length > 0 ? null : Duration.zero);\r\n          }\r\n        }\r\n\r\n        var children = <Widget>[];\r\n        for (var holder in _imageHolders) {\r\n          if (holder.error != null) {\r\n            children.add(_transitionWidget(\r\n                holder: holder, child: _errorWidget(context, holder.error)));\r\n          } else if (holder.image == null) {\r\n            children.add(_transitionWidget(\r\n                holder: holder, child: _placeholder(context)));\r\n          } else {\r\n            children.add(_transitionWidget(\r\n                holder: holder,\r\n                child: _image(\r\n                  context,\r\n                  FileImage(holder.image.file),\r\n                )));\r\n          }\r\n        }\r\n\r\n        return Stack(\r\n          fit: StackFit.passthrough,\r\n          alignment: widget.alignment,\r\n          children: children.toList(),\r\n        );\r\n      },\r\n    );\r\n  }\r\n```\r\n\r\n里面代码较多，莫慌，简单抽取下看看主要实现：\r\n\r\n```dart\r\n  _animatedWidget() {\r\n      \/\/标注1\r\n    var fromMemory = _cacheManager().getFileFromMemory(widget.imageUrl);\r\n\r\n    return StreamBuilder<FileInfo>(\r\n      key: _streamBuilderKey,\r\n      initialData: fromMemory,\r\n      stream: _cacheManager() \/\/标注2\r\n          .getFile(widget.imageUrl, headers: widget.httpHeaders)\r\n         ,\r\n      builder: (BuildContext context, AsyncSnapshot<FileInfo> snapshot) { \/\/标注3\r\n      },\r\n    );\r\n  }\r\n```\r\n\r\n精简后的代码标注了123点。\r\n\r\n分别看下这三个地方。\r\n\r\n开始之前先看下`_cacheManager()`实现：\r\n\r\n```dart\r\n  BaseCacheManager _cacheManager() {\r\n    return widget.cacheManager ?? DefaultCacheManager();\r\n  \r\n```\r\n\r\n**可以看到如果我们自己没有设置`cacheManager`，**\r\n\r\n**那么框架会给我们自动设置一个`DefaultCacheManager`。**\r\n\r\n**所以不用担心不设置缓存器就会每次从网络拉取图片的问题。**\r\n\r\n## 内存缓存\r\n\r\n标注1其实就是从内存获取缓存，看名字就知道了。\r\n\r\n然后把获取到的值赋作为`StreamBuilder`构造函数参数`initialData`传进去。\r\n\r\n基础缓存框架`BaseCacheManager`是一个抽象类，\r\n\r\n`DefaultCacheManager`是它的默认实现。\r\n\r\n看下方法内容：\r\n\r\n```dart\r\n  \/\/\/Returns the file from memory if it has already been fetched\r\n  FileInfo getFileFromMemory(String url) {\r\n    return store.getFileFromMemory(url);\r\n  }\r\n```\r\n\r\n可以看到它啥也没干，派了手下人`store`去干了。\r\n\r\n这里的`store`是`CacheStore`类型。\r\n\r\n看下它里面方法实现：\r\n\r\n```dart\r\n  FileInfo getFileFromMemory(String url) {\r\n    if (_memCache[url] == null || _filePath == null) {\r\n      return null;\r\n    }\r\n    var cacheObject = _memCache[url];\r\n\r\n    var path = p.join(_filePath, cacheObject.relativePath);\r\n    return new FileInfo(\r\n        File(path), FileSource.Cache, cacheObject.validTill, url);\r\n  }\r\n```\r\n\r\n这里主要逻辑就是从`_memCache`里面使用`url`作为key，看看能不能拿到什么东西。\r\n\r\n如果没拿到返回null，\r\n\r\n如果侥幸拿到了，那我根据拿到的对象里的`relativePath`并拼接缓存目录`_filePath`，\r\n\r\n组成缓存文件的完整路径。\r\n\r\n根据完整路径创建一个`FileInfo`。\r\n\r\n这就完成了内存缓存获取。\r\n\r\n\r\n\r\n下面看看标准2的实现\r\n\r\n\r\n\r\n## 本地缓存\r\n\r\n标注2获取本地缓存的逻辑主要是`getFile`部分。\r\n\r\n下面看看具体实现：\r\n\r\n```dart\r\n\/\/\/ Get the file from the cache and\/or online, depending on availability and age.\r\n\/\/\/ Downloaded form [url], [headers] can be used for example for authentication.\r\n\/\/\/ The files are returned as stream. First the cached file if available, when the\r\n\/\/\/ cached file is too old the newly downloaded file is returned afterwards.\r\nStream<FileInfo> getFile(String url, {Map<String, String> headers}) {\r\n  var streamController = new StreamController<FileInfo>();\r\n  _pushFileToStream(streamController, url, headers);\r\n  return streamController.stream;\r\n}\r\n```\r\n\r\n可以看到这个方法里只创建了一个`StreamController`实例。\r\n\r\n然后就把事情交给`_pushFileToStream`处理了，\r\n\r\n继续看：\r\n\r\n```dart\r\n  _pushFileToStream(StreamController streamController, String url,\r\n      Map<String, String> headers) async {\r\n    FileInfo cacheFile;\r\n    try {\r\n      cacheFile = await getFileFromCache(url);\r\n      if (cacheFile != null) {\r\n        streamController.add(cacheFile);\r\n      }\r\n    } catch (e) {\r\n      print(\r\n          \"CacheManager: Failed to load cached file for $url with error:\\n$e\");\r\n    }\r\n    if (cacheFile == null || cacheFile.validTill.isBefore(DateTime.now())) {\r\n      try {\r\n        var webFile = await webHelper.downloadFile(url, authHeaders: headers);\r\n        if (webFile != null) {\r\n          streamController.add(webFile);\r\n        }\r\n      } catch (e) {\r\n        assert(() {\r\n          print(\r\n              \"CacheManager: Failed to download file from $url with error:\\n$e\");\r\n          return true;\r\n        }());\r\n        if (cacheFile == null && streamController.hasListener) {\r\n          streamController.addError(e);\r\n        }\r\n      }\r\n    }\r\n    streamController.close();\r\n  }\r\n```\r\n\r\n从代码不难看出，从中间if分开。\r\n\r\n上部分逻辑是从本地获取缓存并添加到`streamController`\r\n\r\n下部分逻辑是从网络获取数据并添加到`streamController`。\r\n\r\n下面分别看看实现逻辑。\r\n\r\n看下`getFileFromCache`的实现：\r\n\r\n```dart\r\n  \/\/\/Get the file from the cache\r\n  Future<FileInfo> getFileFromCache(String url) async {\r\n    return await store.getFile(url);\r\n  }\r\n```\r\n\r\n日常甩锅给`store`，\r\n\r\n现在我们知道不管从内存还是从本地都是由`CacheStore`经手。\r\n\r\n看下里面实现：\r\n\r\n```dart\r\n  Future<FileInfo> getFile(String url) async {\r\n    var cacheObject = await retrieveCacheData(url);\r\n    if (cacheObject == null || cacheObject.relativePath == null) {\r\n      return null;\r\n    }\r\n    var path = p.join(await filePath, cacheObject.relativePath);\r\n    return new FileInfo(\r\n        File(path), FileSource.Cache, cacheObject.validTill, url);\r\n  }\r\n```\r\n\r\n这里面通过`retrieveCacheData`获取缓存，后面的都是判断和封装。\r\n\r\n其实现内容为：\r\n\r\n```dart\r\n  Future<CacheObject> retrieveCacheData(String url) {\r\n    if (_memCache.containsKey(url)) {\r\n      return Future.value(_memCache[url]);\r\n    }\r\n    if (!_futureCache.containsKey(url)) {\r\n      var completer = new Completer<CacheObject>();\r\n      _getCacheDataFromDatabase(url).then((cacheObject) async {\r\n        if (cacheObject != null && !await _fileExists(cacheObject)) {\r\n          final provider = await _cacheObjectProvider;\r\n          provider.delete(cacheObject.id);\r\n          cacheObject = null;\r\n        }\r\n        completer.complete(cacheObject);\r\n\r\n        _memCache[url] = cacheObject;\r\n        _futureCache[url] = null;\r\n      });\r\n\r\n      _futureCache[url] = completer.future;\r\n    }\r\n    return _futureCache[url];\r\n  }\r\n```\r\n\r\n第一个if语句：\r\n\r\n```dart\r\nif (_memCache.containsKey(url)) {\r\n      return Future.value(_memCache[url]);\r\n    }\r\n```\r\n\r\n这里又从内存获取一遍，\r\n\r\n如果没有获取到，且第二个if也没有取到，\r\n\r\n则执行`_getCacheDataFromDatabase(url)`：\r\n\r\n```dart\r\n  Future<CacheObject> _getCacheDataFromDatabase(String url) async {\r\n    var provider = await _cacheObjectProvider;\r\n    var data = await provider.get(url);\r\n    if (await _fileExists(data)) {\r\n      _updateCacheDataInDatabase(data);\r\n    }\r\n    _scheduleCleanup();\r\n    return data;\r\n  }\r\n```\r\n\r\n到这里真相慢慢浮出水面了，因为名字里带了`database`。\r\n\r\n看来快要从数据库取数据了。\r\n\r\n`_cacheObjectProvider`其泛型类型为`CacheObjectProvider`。\r\n\r\n所以`provider.get(url);`调用的就是`CacheObjectProvider`中`get`方法：\r\n\r\n```dart\r\n  Future<CacheObject> get(String url) async {\r\n    List<Map> maps = await db.query(tableCacheObject,\r\n        columns: null, where: \"$columnUrl = ?\", whereArgs: [url]);\r\n    if (maps.length > 0) {\r\n      return new CacheObject.fromMap(maps.first);\r\n    }\r\n    return null;\r\n  }\r\n```\r\n\r\n到这里可以看到终于调用了database，进行了sqlite查询以获取缓存。\r\n\r\n**上面说了不管从内存还是从本地都是由`CacheStore`经手。**\r\n\r\n**只是从内存获取时直接从其Map类型属性`_memCache`中获取就完事了，**\r\n\r\n**而如果是获取本地缓存时，交给了其`Future<CacheObjectProvider >`类型**\r\n\r\n**`_cacheObjectProvider`来处理。**\r\n\r\n**关于`CacheObjectProvider`本类只是sqlite基本操作的封装类。**\r\n\r\n至此本地缓存获取流程结束。\r\n\r\n\r\n\r\n**总结一下：**\r\n\r\n**本地缓存也还是调用了一下内存缓存，**\r\n\r\n**内存缓存没有数据，则从本地sqlite查询。**\r\n\r\n**sqlite缓存的是源图片url和本地图片path的对应关系。**\r\n\r\n**通过url找到了path，进而找到了本地图片。**\r\n\r\n\r\n\r\n如果首次加载，前面都是获取不到数据的，接下来看看网络获取。\r\n\r\n## 网络获取\r\n\r\n继续回到`_pushFileToStream`方法，看看下部分：\r\n\r\n```dart\r\n  try {\r\n        var webFile = await webHelper.downloadFile(url, authHeaders: headers);\r\n        if (webFile != null) {\r\n          streamController.add(webFile);\r\n        }\r\n      } catch (e) {\r\n        assert(() {\r\n          print(\r\n              \"CacheManager: Failed to download file from $url with error:\\n$e\");\r\n          return true;\r\n        }());\r\n        if (cacheFile == null && streamController.hasListener) {\r\n          streamController.addError(e);\r\n        }\r\n      }\r\n```\r\n\r\n可以看到这里使用了`WebHelper`来下载文件。\r\n\r\n```dart\r\n  \/\/\/Download the file from the url\r\n  Future<FileInfo> downloadFile(String url,\r\n      {Map<String, String> authHeaders, bool ignoreMemCache = false}) async {\r\n    if (!_memCache.containsKey(url) || ignoreMemCache) {\r\n      var completer = new Completer<FileInfo>();\r\n      () async {\r\n        try {\r\n          final cacheObject =\r\n              await _downloadRemoteFile(url, authHeaders: authHeaders);\r\n          completer.complete(cacheObject);\r\n        } catch (e) {\r\n          completer.completeError(e);\r\n        } finally {\r\n          _memCache.remove(url);\r\n        }\r\n      }();\r\n\r\n      _memCache[url] = completer.future;\r\n    }\r\n    return _memCache[url];\r\n  }\r\n```\r\n\r\n**`WebHelper`不仅是对`http`网络库进行了包装调用，**\r\n\r\n**还持有了`CacheStore`的引用，以便在下载完数据后进行数据缓存。**\r\n\r\n**有意思的是这里又进行了一次`_memCache`判断，这次的`_memCache`并非`CacheStore`里面的。**\r\n\r\n**而是`WebHelper`在构造函数中自己创建的。**\r\n\r\n**就是说`WebHelper`也有做了自己的内存缓存。**\r\n\r\n继续看代码，\r\n\r\n`downloadFile`里面调用了内部方法`_downloadRemoteFile`。\r\n\r\n```dart\r\n  \/\/\/Download the file from the url\r\n  Future<FileInfo> _downloadRemoteFile(String url,\r\n      {Map<String, String> authHeaders}) async {\r\n    var cacheObject = await _store.retrieveCacheData(url);\r\n    if (cacheObject == null) {\r\n      cacheObject = new CacheObject(url);\r\n    }\r\n\r\n    var headers = new Map<String, String>();\r\n    if (authHeaders != null) {\r\n      headers.addAll(authHeaders);\r\n    }\r\n\r\n    if (cacheObject.eTag != null) {\r\n      headers[\"If-None-Match\"] = cacheObject.eTag;\r\n    }\r\n\r\n    var success = false;\r\n\r\n    var response = await _fileFetcher(url, headers: headers);\r\n    success = await _handleHttpResponse(response, cacheObject);\r\n\r\n    if (!success) {\r\n      throw HttpException(\r\n          \"No valid statuscode. Statuscode was ${response?.statusCode}\");\r\n    }\r\n\r\n    _store.putFile(cacheObject);\r\n    var filePath = p.join(await _store.filePath, cacheObject.relativePath);\r\n\r\n    return FileInfo(\r\n        new File(filePath), FileSource.Online, cacheObject.validTill, url);\r\n  }\r\n```\r\n\r\n这里使用`_fileFetcher`执行网络请求返回`reposnse`。\r\n\r\n通过`_handleHttpResponse`从`response`取出值赋给`cacheObject`。\r\n\r\n这里`_fileFetcher`是在`WebHelper`构造函数进行赋值的：\r\n\r\n```dart\r\n  WebHelper(this._store, this._fileFetcher) {\r\n    _memCache = new Map();\r\n    if (_fileFetcher == null) {\r\n        \/\/这里赋值\r\n      _fileFetcher = _defaultHttpGetter;\r\n    }\r\n  }\r\n  \r\n    Future<FileFetcherResponse> _defaultHttpGetter(String url,\r\n      {Map<String, String> headers}) async {\r\n    var httpResponse = await http.get(url, headers: headers);\r\n    return new HttpFileFetcherResponse(httpResponse);\r\n  }\r\n```\r\n\r\n给它赋值的`_defaultHttpGetter`本质是`HttpFileFetcherResponse`的实例。\r\n\r\n而该类只是包装了`http.get`请求返回的结果。\r\n\r\n至此网络获取流程也已经结束。\r\n\r\n整个缓存调用流程可以简单理解为：\r\n\r\n![image-20200116105412493](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200116105412493.png)\r\n\r\n\r\n\r\n\r\n\r\n# 0x03 流程分析\r\n\r\n## 瞎比比\r\n\r\n前面看了三种缓存的实现，所以你懂了该框架实现流程了吗？\r\n\r\n不，你顶多只是了解了三种缓存流程大概实现方式。\r\n\r\n至于框架的调用流程才刚开始。。。\r\n\r\n先来个类图看下主要类的关系：\r\n\r\n<img src=\"https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200115232508547.png\" alt=\"image-20200115232508547\" style=\"zoom:200%;\" \/>\r\n\r\n在上面缓存流程中，我们标注了123点。\r\n\r\n这三点是围绕`StreamBuilder`展开的。\r\n\r\n这三点分别对应了`StreamBuilder`构造函数中的\r\n\r\n`initialData`、`stream`、`builder`。\r\n\r\n你几乎可以认为掌握了这三块流程，也就掌握了该框架实现流程原理。\r\n\r\n\r\n\r\n## 入正题\r\n\r\n通过类图我们知道逻辑开始渐入复杂，\r\n\r\n是从`CachedNetworkImageState`的`build`方法开始的。\r\n\r\n因为这里调用了它所依赖的`StreamBuilder`。\r\n\r\n我们的标注也是从这里开始的。\r\n\r\n进入`StreamBuilder`类：\r\n\r\n```dart\r\nclass StreamBuilder<T> extends StreamBuilderBase<T, AsyncSnapshot<T>> {\r\n  \/\/\/ The [builder] must not be null.\r\n  const StreamBuilder({\r\n    Key key,\r\n    this.initialData,\r\n    Stream<T> stream,\r\n    @required this.builder,\r\n  }) : assert(builder != null),\r\n       super(key: key, stream: stream);\r\n\r\n  final AsyncWidgetBuilder<T> builder;\r\n\r\n  final T initialData;\r\n\r\n  @override\r\n  AsyncSnapshot<T> initial() => AsyncSnapshot<T>.withData(ConnectionState.none, initialData);\r\n\r\n  @override\r\n  AsyncSnapshot<T> afterConnected(AsyncSnapshot<T> current) => current.inState(ConnectionState.waiting);\r\n\r\n  @override\r\n  AsyncSnapshot<T> afterData(AsyncSnapshot<T> current, T data) {\r\n    return AsyncSnapshot<T>.withData(ConnectionState.active, data);\r\n  }\r\n\r\n  @override\r\n  AsyncSnapshot<T> afterError(AsyncSnapshot<T> current, Object error) {\r\n    return AsyncSnapshot<T>.withError(ConnectionState.active, error);\r\n  }\r\n\r\n  @override\r\n  AsyncSnapshot<T> afterDone(AsyncSnapshot<T> current) => current.inState(ConnectionState.done);\r\n\r\n  @override\r\n  AsyncSnapshot<T> afterDisconnected(AsyncSnapshot<T> current) => current.inState(ConnectionState.none);\r\n\r\n  @override\r\n  Widget build(BuildContext context, AsyncSnapshot<T> currentSummary) => builder(context, currentSummary);\r\n}\r\n```\r\n\r\n类的代码并不多，\r\n\r\n`StreamBuilder`是个泛型类，注意它和其父类的泛型类型即可。\r\n\r\n构造函数中`initialData`直接赋值给了属性`final T initialData`。\r\n\r\n`stream`传递给了父类，该类本身没有调用。\r\n\r\n`builder`直接赋值给了属性`final AsyncWidgetBuilder<T> builder`。\r\n\r\n\r\n\r\n**最后的方法`build`方法调用了函数类型属性`builder`。**\r\n\r\n**记住`StreamBuilder`的这个`builder`实现是我们构造`StreamBuilder`时传入完成的。**\r\n\r\n剩下好些个重写方法，暂时不管，小憩一下，\r\n\r\n\r\n\r\n继续看看它的父类：\r\n\r\n```dart\r\nabstract class StreamBuilderBase<T, S> extends StatefulWidget {\r\n  \/\/\/ Creates a [StreamBuilderBase] connected to the specified [stream].\r\n  const StreamBuilderBase({ Key key, this.stream }) : super(key: key);\r\n\r\n  final Stream<T> stream;\r\n\r\n  S initial();\r\n\r\n  S afterConnected(S current) => current;\r\n\r\n  S afterData(S current, T data);\r\n\r\n  S afterError(S current, Object error) => current;\r\n\r\n  S afterDone(S current) => current;\r\n\r\n  S afterDisconnected(S current) => current;\r\n\r\n  \/\/\/ Returns a Widget based on the [currentSummary].\r\n  Widget build(BuildContext context, S currentSummary);\r\n\r\n  @override\r\n  State<StreamBuilderBase<T, S>> createState() => _StreamBuilderBaseState<T, S>();\r\n}\r\n```\r\n\r\n`StreamBuilderBase`是一个抽象泛型类。\r\n\r\n通过这两处泛型类，可以知道这里的泛型 `<S>` 其实就是 `AsyncSnapshot<T>`。\r\n\r\n下面提供了很多关于 `S`的抽象方法，暂且放一放，知道这些抽象方法在`StreamBuilder`实现了即可。\r\n\r\n`StreamBuilderBase`继承了`StatefulWidget`。\r\n\r\n由此它必定重写`createState`，创建了`_StreamBuilderBaseState`实例。\r\n\r\n创建了`_StreamBuilderBaseState`后，我们知道`State`生命周期有`initState`和`build`。\r\n\r\n看看它们的实现：\r\n\r\n```dart\r\nclass _StreamBuilderBaseState<T, S> extends State<StreamBuilderBase<T, S>> {\r\n  StreamSubscription<T> _subscription;\r\n  S _summary;\r\n\r\n  @override\r\n  void initState() {\r\n    super.initState();\r\n    _summary = widget.initial();\r\n    _subscribe();\r\n  }\r\n\r\n  @override\r\n  void didUpdateWidget(StreamBuilderBase<T, S> oldWidget) {\r\n    super.didUpdateWidget(oldWidget);\r\n    if (oldWidget.stream != widget.stream) {\r\n      if (_subscription != null) {\r\n        _unsubscribe();\r\n        _summary = widget.afterDisconnected(_summary);\r\n      }\r\n      _subscribe();\r\n    }\r\n  }\r\n\r\n  @override\r\n  Widget build(BuildContext context) => widget.build(context, _summary);\r\n\r\n  @override\r\n  void dispose() {\r\n    _unsubscribe();\r\n    super.dispose();\r\n  }\r\n\r\n  void _subscribe() {\r\n    if (widget.stream != null) {\r\n      _subscription = widget.stream.listen((T data) {\r\n        setState(() {\r\n          _summary = widget.afterData(_summary, data);\r\n        });\r\n      }, onError: (Object error) {\r\n        setState(() {\r\n          _summary = widget.afterError(_summary, error);\r\n        });\r\n      }, onDone: () {\r\n        setState(() {\r\n          _summary = widget.afterDone(_summary);\r\n        });\r\n      });\r\n      _summary = widget.afterConnected(_summary);\r\n    }\r\n  }\r\n\r\n  void _unsubscribe() {\r\n    if (_subscription != null) {\r\n      _subscription.cancel();\r\n      _subscription = null;\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n\r\n\r\n看下`initState`代码`_summary = widget.initial();`，\r\n\r\n调用了`widget`的`initial`方法。\r\n\r\n这个`widget`指向`StreamBuilderBase`，它的`initial`方法是抽象的。\r\n\r\n没关系，刚才说了它有实现类`StreamBuilder`,看看它的实现：\r\n\r\n```dart\r\n @override\r\n  AsyncSnapshot<T> initial() => AsyncSnapshot<T>.withData(ConnectionState.none, initialData);\r\n```\r\n\r\n看下`AsyncSnapshot`实现：\r\n\r\n```dart\r\n@immutable\r\nclass AsyncSnapshot<T> {\r\n  const AsyncSnapshot._(this.connectionState, this.data, this.error)\r\n    : assert(connectionState != null),\r\n      assert(!(data != null && error != null));\r\n\r\n  const AsyncSnapshot.nothing() : this._(ConnectionState.none, null, null);\r\n  const AsyncSnapshot.withData(ConnectionState state, T data) : this._(state, data, null);\r\n  const AsyncSnapshot.withError(ConnectionState state, Object error) : this._(state, null, error);\r\n\r\n  \/\/\/ Current state of connection to the asynchronous computation.\r\n  final ConnectionState connectionState;\r\n\r\n  final T data;\r\n}\r\n```\r\n\r\n可以看到这个异步快照(暂时这么叫)类并没有做什么，\r\n\r\n只是对从`StreamBuilder`传进来的`initialData`和`ConnectionState`以及一个`error`的一个包装。\r\n\r\n目前只要知道能从异步快照中拿到`initialData`和`error`及`ConnectionState`状态即可。\r\n\r\n包装好的异步快照赋值给了`_summary`。\r\n\r\n权且不管`initState`其他代码，现在我们已经拿到了异步快照，\r\n\r\n假如已经`initState`执行完毕，那么就该回调`build`方法构建widget了。\r\n\r\n\r\n\r\n看看`build`函数实现：`widget.build(context, _summary)`，就这一行调用。\r\n\r\n这个`State`没有自己创建widget，而是交给了其对应的`widget`的`build`处理。\r\n\r\n该`build`又是个抽象方法，如上所述具体实现在`StreamBuilder`：\r\n\r\n```dart\r\n@override\r\n  Widget build(BuildContext context, AsyncSnapshot<T> currentSummary) => builder(context, currentSummary);\r\n```\r\n\r\n**上面说了`StreamBuilder`里的这个`builder`就是当初我们创建`StreamBuilder`传参的`builder`。**\r\n\r\n**`builder`参数类型为`BuildContext context, AsyncSnapshot<T> snapshot`。**\r\n\r\n**所以搞了半天，你从`StreamBuilder`的`initialData`传进去的数据，**\r\n\r\n**经过异步快照包装一下，又从`StreamBuilder`的`builder`返回来供你使用了。**\r\n\r\n**`builder`最终返回`widget`类型。在`builder`代码块中你可以根据异步快照信息来显示你的控件。**\r\n\r\n**目前来看，如果不是首次获取的图片，并且内存缓存还没有被回收，那么可以通过`initialData`直接进行读取图片显示。**\r\n\r\n**至此你应该知道内存缓存数据的来去流程了。**\r\n\r\n\r\n\r\n上面我们说假如`initState`已经执行完毕，\r\n\r\n其实并没有啊，返回去继续看`initState`，里面还调用了`_subscribe`：\r\n\r\n```dart\r\n  void _subscribe() {\r\n    if (widget.stream != null) {\r\n      _subscription = widget.stream.listen((T data) {\r\n        setState(() {\r\n          _summary = widget.afterData(_summary, data);\r\n        });\r\n      }, onError: (Object error) {\r\n        setState(() {\r\n          _summary = widget.afterError(_summary, error);\r\n        });\r\n      }, onDone: () {\r\n        setState(() {\r\n          _summary = widget.afterDone(_summary);\r\n        });\r\n      });\r\n      _summary = widget.afterConnected(_summary);\r\n    }\r\n  }\r\n```\r\n\r\n如果`stream`不为空，则设置`stream`监听。\r\n\r\n看下监听函数参数：\r\n\r\n```dart\r\n  StreamSubscription<T> listen(void onData(T event),\r\n      {Function onError, void onDone(), bool cancelOnError});\r\n```\r\n\r\n这里有`onData`、`onError`、`onDone`三个函数参数。\r\n\r\n这三个参数分别会在`stream`对应的`StreamController`执行`add`、`addError`和`close`时进行触发。\r\n\r\n也就是说：\r\n\r\n**`StreamController.add`执行时，触发`_summary = widget.afterData(_summary, data);`**\r\n\r\n**`StreamController.addError`执行时，触发`_summary = widget.afterError(_summary, data);`**\r\n\r\n**`StreamController.close`执行时，触发`_summary = widget.afterConnected(_summary, data);`**\r\n\r\n至于`stream`和`StreamController`怎么扯上关系的，还要从`StreamBuilder`构造函数参数`stream`看起。\r\n\r\n\r\n\r\n我们看到`_cacheManager().getFile`是返回了`Stream`。\r\n\r\n在`getFile`里面创建了`StreamController`实例，\r\n\r\n而每个`StreamController`实例控制着一个`stream`：\r\n\r\n```dart\r\nabstract class StreamController<T> implements StreamSink<T> {\r\n  \/** The stream that this controller is controlling. *\/\r\n  Stream<T> get stream;\r\n}\r\n```\r\n\r\n通过`streamController.stream`直接返回了构造函数所需的`stream`实例。\r\n\r\n现在我们清楚了原来\r\n\r\n`streamController.stream`和上面`_subscribe`中`widget.stream`是同一个对象。\r\n\r\n由于上面设置了`widget.stream`监听，\r\n\r\n所以我们后面对`streamController`的操作都会通过监听回调相应的函数。\r\n\r\n关系绑定好了，我们继续看代码：\r\n\r\n```dart\r\n  _pushFileToStream(StreamController streamController, String url,\r\n      Map<String, String> headers) async {\r\n    FileInfo cacheFile;\r\n    try {\r\n      cacheFile = await getFileFromCache(url);\r\n      if (cacheFile != null) {\r\n        streamController.add(cacheFile);\r\n      }\r\n    } catch (e) {\r\n      print(\r\n          \"CacheManager: Failed to load cached file for $url with error:\\n$e\");\r\n    }\r\n    if (cacheFile == null || cacheFile.validTill.isBefore(DateTime.now())) {\r\n      try {\r\n        var webFile = await webHelper.downloadFile(url, authHeaders: headers);\r\n        if (webFile != null) {\r\n          streamController.add(webFile);\r\n        }\r\n      } catch (e) {\r\n        assert(() {\r\n          print(\r\n              \"CacheManager: Failed to download file from $url with error:\\n$e\");\r\n          return true;\r\n        }());\r\n        if (cacheFile == null && streamController.hasListener) {\r\n          streamController.addError(e);\r\n        }\r\n      }\r\n    }\r\n    streamController.close();\r\n  }\r\n```\r\n\r\n上面讲本地缓存已经看过一遍了，这次应该不慌了吧。\r\n\r\n代码大概流程就是\r\n\r\n如果我从`getFileFromCache`获取到了数据，将调用`streamController.add(cacheFile)`。\r\n\r\n如果没有获取到我将从网络获取，\r\n\r\n如果我从`webHelper.downloadFile`获取到了数据，也调用`streamController.add(webFile)`。\r\n\r\n如果期间出现异常，将调用`streamController.addError(e)`。\r\n\r\n到最后调用`streamController.close()`。\r\n\r\n上面说了这三个函数调用时，分别回调监听函数中的`onData`、`onError`、`onDone`。\r\n\r\n\r\n\r\n假如获取数据成功调用了`onData`，则调用`_summary = widget.afterData(_summary, data)`。\r\n\r\n这里的`widget`是抽象类，实现方法从`StreamBuilder`里面找：\r\n\r\n```dart\r\n@override\r\n  AsyncSnapshot<T> afterData(AsyncSnapshot<T> current, T data) {\r\n    return AsyncSnapshot<T>.withData(ConnectionState.active, data);\r\n  }\r\n\r\n  @override\r\n  AsyncSnapshot<T> afterError(AsyncSnapshot<T> current, Object error) {\r\n    return AsyncSnapshot<T>.withError(ConnectionState.active, error);\r\n  }\r\n\r\n  @override\r\n  AsyncSnapshot<T> afterDone(AsyncSnapshot<T> current) => current.inState(ConnectionState.done);\r\n```\r\n\r\n这里把三个实现函数都拿出来了，\r\n\r\n可以看到`afterData`调用后也只是对拿到的`<T>`和`ConnectionState`进行包装。\r\n\r\n而`afterError`是对一个`error`和`ConnectionState`进行包装。\r\n\r\n`afterDone`则只是把最后的`_summary`中`ConnectionState`状态改为`done`。\r\n\r\n你应该注意到这三个函数都是包裹在`setState`中的。\r\n\r\n因此导致这三个函数的调用都将导致该`State`的`build`函数调用。\r\n\r\n上面说了该`State`的`build`没有自己生成widget，\r\n\r\n而是调用`widget.build(context, _summary)`。\r\n\r\n而该实现方法调用了`builder(context, currentSummary)`\r\n\r\n最终把`_summary`外送到`StreamBuilder`的构造函数参数`builder`中。\r\n\r\n这块是我们自己实现的。\r\n\r\n\r\n\r\n总的来说，`initialData`和`stream`两个地方都是为`builder`提供数据的。\r\n\r\n最终的落脚点是`builder`的实现，我们来看看源码：\r\n\r\n```dart\r\n      builder: (BuildContext context, AsyncSnapshot<FileInfo> snapshot) {\r\n        if (snapshot.hasError) {\r\n          \/\/ error\r\n          if (_imageHolders.length == 0 || _imageHolders.last.error == null) {\r\n            _addImage(image: null, error: snapshot.error);\r\n          }\r\n        } else {\r\n          var fileInfo = snapshot.data;\r\n          if (fileInfo == null) {\r\n            \/\/ placeholder\r\n            if (_imageHolders.length == 0 || _imageHolders.last.image != null) {\r\n              _addImage(\r\n                  image: null,\r\n                  duration: widget.placeholderFadeInDuration ?? Duration.zero);\r\n            }\r\n          } else if (_imageHolders.length == 0 ||\r\n              _imageHolders.last.image?.originalUrl != fileInfo.originalUrl ||\r\n              _imageHolders.last.image?.validTill != fileInfo.validTill) {\r\n            _addImage(\r\n                image: fileInfo,\r\n                duration: _imageHolders.length > 0 ? null : Duration.zero);\r\n          }\r\n        }\r\n\r\n        var children = <Widget>[];\r\n        for (var holder in _imageHolders) {\r\n          if (holder.error != null) {\r\n            children.add(_transitionWidget(\r\n                holder: holder, child: _errorWidget(context, holder.error)));\r\n          } else if (holder.image == null) {\r\n            children.add(_transitionWidget(\r\n                holder: holder, child: _placeholder(context)));\r\n          } else {\r\n            children.add(_transitionWidget(\r\n                holder: holder,\r\n                child: _image(\r\n                  context,\r\n                  FileImage(holder.image.file),\r\n                )));\r\n          }\r\n        }\r\n\r\n        return Stack(\r\n          fit: StackFit.passthrough,\r\n          alignment: widget.alignment,\r\n          children: children.toList(),\r\n        );\r\n      }\r\n```\r\n\r\n这段代码从中间`var children = <Widget>[]`可以分为上下两部分。\r\n\r\n其中上部分就是根据`snapshot`的状态来填充`_imageHolders`：\r\n\r\n如果`snapshot.hasError`返回`true`，\r\n\r\n说明之前有调用过`streamControler.addError`，否则应该是false的。\r\n\r\n\r\n\r\n`_imageHolders`是`_ImageTransitionHolder`类型列表：\r\n\r\n```dart\r\nclass _ImageTransitionHolder {\r\n  final FileInfo image;\r\n  AnimationController animationController;\r\n  final Object error;\r\n  Curve curve;\r\n  final TickerFuture forwardTickerFuture;\r\n\r\n  _ImageTransitionHolder({\r\n    this.image,\r\n    @required this.animationController,\r\n    this.error,\r\n    this.curve: Curves.easeIn,\r\n  }) : forwardTickerFuture = animationController.forward();\r\n\r\n  dispose() {\r\n    if (animationController != null) {\r\n      animationController.dispose();\r\n      animationController = null;\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n通过源码可以看到`_ImageTransitionHolder`也是一个包装类。\r\n\r\n包装了`image`、`error`和动画控制器。\r\n\r\n\r\n\r\n当`snapshot.hasError`返回`true`时，\r\n\r\n添加一个包装了错误信息的`_ImageTransitionHolder`到`_imageHolders`。\r\n\r\n如果获取到了数据添加一个包装了`FileInfo`信息的`_ImageTransitionHolder`到`_imageHolders`。\r\n\r\n如果没有获取到数据就添加一个空`FileInfo`。\r\n\r\n\r\n\r\n下部分通过遍历`_imageHolders`，根据不同信息创建不同的widget：\r\n\r\n```dart\r\n        var children = <Widget>[];\r\n        for (var holder in _imageHolders) {\r\n          if (holder.error != null) {\r\n            children.add(_transitionWidget(\r\n                holder: holder, child: _errorWidget(context, holder.error)));\r\n          } else if (holder.image == null) {\r\n            children.add(_transitionWidget(\r\n                holder: holder, child: _placeholder(context)));\r\n          } else {\r\n            children.add(_transitionWidget(\r\n                holder: holder,\r\n                child: _image(\r\n                  context,\r\n                  FileImage(holder.image.file),\r\n                )));\r\n          }\r\n        }\r\n```\r\n\r\n拿到`error`的`_ImageTransitionHolder`时，\r\n\r\n会给`child`设置`_errorWidget`：\r\n\r\n```dart\r\n  _errorWidget(BuildContext context, Object error) {\r\n    return widget.errorWidget != null\r\n        ? widget.errorWidget(context, widget.imageUrl, error)\r\n        : _placeholder(context);\r\n  }\r\n```\r\n\r\n可以看到`_errorWidget`函数里面就是调用创建`CachedNetworkImage`时传递的`errorWidget`。\r\n\r\n如果没有设置`errorWidget`,则调用`_placeholder`函数。\r\n\r\n可知我们设置的错误信息占位控件是在此时被填充显示的。\r\n\r\n\r\n\r\n同样在遍历中，当`holder.image == null`为true时，\r\n\r\n也会调用`_placeholder`：\r\n\r\n```dart\r\n  _placeholder(BuildContext context) {\r\n    return widget.placeholder != null\r\n        ? widget.placeholder(context, widget.imageUrl)\r\n        : SizedBox(\r\n            width: widget.width,\r\n            height: widget.height,\r\n          );\r\n  }\r\n```\r\n\r\n同样你会发现，这里调用了我们创建`CachedNetworkImage`时传递的`placeholder`。\r\n\r\n这是加载到数据前的默认显示占位控件。\r\n\r\n\r\n\r\n如果前两个判断都没有成立，说明现在正常获取到了数据，\r\n\r\n调用了`_image`：\r\n\r\n```dart\r\n  _image(BuildContext context, ImageProvider imageProvider) {\r\n    return widget.imageBuilder != null\r\n        ? widget.imageBuilder(context, imageProvider)\r\n        : Image(\r\n            image: imageProvider,\r\n            fit: widget.fit,\r\n            width: widget.width,\r\n            height: widget.height,\r\n            alignment: widget.alignment,\r\n            repeat: widget.repeat,\r\n            color: widget.color,\r\n            colorBlendMode: widget.colorBlendMode,\r\n            matchTextDirection: widget.matchTextDirection,\r\n            filterQuality: widget.filterQuality,\r\n          );\r\n  }\r\n```\r\n\r\n这里调用了`widget.imageBuilder`，\r\n\r\n如果它没有值，则使用默认的`Image`控件显示图片，\r\n\r\n如果它有值，则把`imageProvider`交给它处理，\r\n\r\n这里的`imageProvider`是`FileImage`类型，它包装了从`FileInfo`获取到的`file`。\r\n\r\n而这里的`imageBuilder`又是我们自定义的部分。\r\n\r\n所以如果默认的`Image`显示不能满足你的要求，\r\n\r\n你可以通道自定义`imageBuilder`实现来达到理想效果。\r\n\r\n\r\n\r\n至此`CachedNetworkImage`框架大体流程分析完了，你看懂了多少？\r\n\r\n\r\n\r\n\r\n\r\n这里有个疑问，为什么`_imageHolders`要使用List，起了什么作用？\r\n\r\n另外还有个问题是之前说了stream监听，每次回调都最终从新调用`builder`。\r\n\r\n一个图片显示过程可能面临好几次的`build`。这块需要考虑是否有可能会有性能问题？"
  },
  {
    "title" : "Flutter状态管理之Provider源码分析",
    "created_time" : "2020-01-18 14:29:15",
    "body" : "# 0x00 前言\r\n\r\nFlutter在做全局状态管理时，没有提供像Android中Application类来保存全局状态。\r\n\r\n好在还有框架可以使用，目前谷歌官方推荐使用Provider管理全局状态。\r\n\r\n所以花了点时间看了下源码大概实现流程。\r\n\r\n\r\n\r\n要了解Provider大概原理，个人觉得从以下三点入手即可：\r\n\r\n1、什么时候，如何存储data？存到哪里去了？\r\n\r\n2、如何取出data使用？\r\n\r\n3、如何刷新data以及为何刷新data也就刷新了widget？\r\n\r\n后面的源码分析会从这三点入手贯穿整个使用流程。\r\n\r\n当然在分析源码前看下简单的使用方法。\r\n\r\n# 0x01 使用\r\n\r\n## 添加依赖\r\n\r\n```yaml\r\nprovider: ^4.0.0\r\n```\r\n\r\n最新版从[pub获取](https:\/\/pub.dev\/packages\/provider)\r\n\r\n## 继承ChangeNotifier\r\n\r\n把自己创建的数据类继承`ChangeNotifier`，\r\n\r\n想监听哪些属性改变时进行刷新，则创建set方法，\r\n\r\n并在方法中调用`notifyListeners`：\r\n\r\n```dart\r\nclass UserBean with ChangeNotifier {\r\n  String avatarUrl;\r\n  String name;\r\n  String token;\r\n  String mobile;\r\n  String pwd;\r\n  String id;\r\n\r\n  UserBean([\r\n    this.id,\r\n    this.name,\r\n    this.mobile,\r\n    this.pwd,\r\n    this.token,\r\n    this.avatarUrl,\r\n  ]);\r\n\r\n  void setData(\r\n      {String name,\r\n      String mobile,\r\n      String pwd,\r\n      String token,\r\n      String avatarUrl,\r\n      String id,\r\n      bool isSaveDB = true}) async {\r\n    this.name = name;\r\n    this.mobile = mobile;\r\n    this.pwd = pwd;\r\n    this.token = token;\r\n    this.avatarUrl = avatarUrl;\r\n    this.id = id;\r\n    print(\"mobile=$mobile\");\r\n    notifyListeners();\r\n    if (isSaveDB) {\r\n      int id = await UserProvider.dao.update(this);\r\n      print(\"id=$id\");\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n## 配置MultiProvider\r\n\r\n由于我的所有页面都可能会检测登录状态，\r\n\r\n所以我把`MultiProvider`配置到了`main`入口处。\r\n\r\n我暂时只想管理`UserBean`，所以只配置了这一个类：\r\n\r\n```dart\r\nvoid main() => runApp(MyApp());\r\n\r\n\/\/\/ app入口\r\nclass MyApp extends StatelessWidget {\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    \/\/ 创建路由对象\r\n    final router = Router();\r\n    \/\/ 配置路由集Routes的路由对象\r\n    Routes.configureRoutes(router);\r\n    \/\/ 指定Application的路由对象\r\n    FindCatApp.router = router;\r\n\t\/\/配置MultiProvider\r\n    return MultiProvider(\r\n      providers: [\r\n        ChangeNotifierProvider(create: (_) => UserBean()),\/\/\r\n      ],\r\n      child: MaterialApp(\r\n        onGenerateRoute: FindCatApp.router.generator,\r\n        localizationsDelegates: [\r\n          GlobalMaterialLocalizations.delegate,\r\n          GlobalWidgetsLocalizations.delegate,\r\n          CatLocalizationsDelegate()\r\n        ],\r\n        supportedLocales: [const Locale('en', 'US'), const Locale('zh', 'CN')],\r\n        theme: ThemeData(\r\n          primarySwatch: Colors.blue,\r\n        ),\r\n        home: HomePage(),\r\n      ),\r\n    );\r\n  }\r\n}\r\n```\r\n\r\n\r\n\r\n## 获取(更新)数据\r\n\r\n配置完成后可以通过`Provider.of<UserBean>(context)`获取数据来判断用户状态。\r\n\r\n如果要更新状态，通过调用`Provider.of<UserBean>(context).setData`即可。\r\n\r\n\r\n\r\n最简单的使用大概就是这样，\r\n\r\n下面开始进入源码分析。\r\n\r\n# 0x02 分析\r\n\r\n\r\n\r\n<img src=\"https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/Provider%E6%B5%81%E7%A8%8B.jpeg\" alt=\"Provider流程\" style=\"zoom:300%;\" \/>\r\n\r\n后面的分析都是本着一个新手对一切都是未知的角度来分析，\r\n\r\n不会提前把一些知识点讲出来，以便提供一个最客观的视角。\r\n\r\n这里把前言中的三点概括为`data存储流程`，`data取出流程`，`data刷新流程`。\r\n\r\n下面分别看看各流程是如何执行的。\r\n\r\n## data存储流程\r\n\r\n通过上面的简单使用，你应该已经知道配置数据发生在\r\n\r\n使用`MultiProvider`时，我们提供的`providers`构造函数参数。\r\n\r\n我这里的`providers`使用的是`ChangeNotifierProvider`，\r\n\r\n它使用构造函数参数`create`带走了我的`UserBean`。\r\n\r\n看下它的构造函数：\r\n\r\n```dart\r\n  ChangeNotifierProvider({\r\n    Key key,\r\n    @required Create<T> create,\r\n    bool lazy,\r\n    Widget child,\r\n  }) : super(\r\n          key: key,\r\n          create: create,\r\n          dispose: _dispose,\r\n          lazy: lazy,\r\n          child: child,\r\n        );\r\n```\r\n\r\n这里的`create`是`Create<T>`。\r\n\r\n它是个函数类型参数：`typedef Create<T> = T Function(BuildContext context);`\r\n\r\n可以看到它提供一个`context`，然后返回一个`T`。\r\n\r\n这里的`context`返回给你是为了让你创建`widget`用的。\r\n\r\n目前我们知道我的`UserBean`被`create`携带。\r\n\r\n我们要做的就是盯住它走向哪里。\r\n\r\n这里并没有属性接收它，直接传给了`super`。\r\n\r\n\r\n\r\n别手软，点进去。\r\n\r\n然后来到了`ListenableProvider<T extends Listenable>`类中：\r\n\r\n```dart\r\n  ListenableProvider({\r\n    Key key,\r\n    @required Create<T> create,\r\n    Dispose<T> dispose,\r\n    bool lazy,\r\n    Widget child,\r\n  })  : assert(create != null),\r\n        super(\r\n          key: key,\r\n          startListening: _startListening,\r\n          create: create,\r\n          dispose: dispose,\r\n          debugCheckInvalidValueType: kReleaseMode\r\n              ? null\r\n              : (value) {\r\n                  if (value is ChangeNotifier) {\r\n                    \/\/ ignore: invalid_use_of_protected_member\r\n                    assert(!value.hasListeners, '''\r\nThe default constructor of ListenableProvider\/ChangeNotifierProvider\r\nmust create a new, unused Listenable.\r\n\r\nIf you want to reuse an existing Listenable, use the second constructor:\r\n\r\n- DO use ChangeNotifierProvider.value to provider an existing ChangeNotifier:\r\n\r\nMyChangeNotifier variable;\r\nChangeNotifierProvider.value(\r\n  value: variable,\r\n  child: ...\r\n)\r\n\r\n- DON'T reuse an existing ChangeNotifier using the default constructor.\r\n\r\nMyChangeNotifier variable;\r\nChangeNotifierProvider(\r\n  create: (_) => variable,\r\n  child: ...\r\n)\r\n''');\r\n                  }\r\n                },\r\n          lazy: lazy,\r\n          child: child,\r\n        );\r\n```\r\n\r\n仍然没有赋值给属性，而是又调用了`super`。\r\n\r\n难道它的存在感这么低？\r\n\r\n不管它，点进去，继续看。\r\n\r\n\r\n\r\n进入了`InheritedProvider<T>`类:\r\n\r\n```dart\r\n  InheritedProvider({\r\n    Key key,\r\n    Create<T> create,\r\n    T update(BuildContext context, T value),\r\n    UpdateShouldNotify<T> updateShouldNotify,\r\n    void Function(T value) debugCheckInvalidValueType,\r\n    StartListening<T> startListening,\r\n    Dispose<T> dispose,\r\n    bool lazy,\r\n    Widget child,\r\n  })  : _lazy = lazy,\r\n        _delegate = _CreateInheritedProvider(\r\n          create: create,\r\n          update: update,\r\n          updateShouldNotify: updateShouldNotify,\r\n          debugCheckInvalidValueType: debugCheckInvalidValueType,\r\n          startListening: startListening,\r\n          dispose: dispose,\r\n        ),\r\n        super(key: key, child: child);\r\n```\r\n\r\n可以看到这里虽然没有直接赋值给属性，\r\n\r\n但是把它包裹在了`_delegate`属性里面了。\r\n\r\n而且在`super`里面没有在传递`create`。\r\n\r\n既然数据通过`_delegate`能拿到，\r\n\r\n那就放眼望去，看看谁要使用它，\r\n\r\n类里面没有找到谁要调用该属性了。\r\n\r\n别慌，看下源码：\r\n\r\n```dart\r\nclass InheritedProvider<T> extends SingleChildStatelessWidget {\r\n  \/\/\/ Creates a value, then expose it to its descendants.\r\n  \/\/\/\r\n  \/\/\/ The value will be disposed of when [InheritedProvider] is removed from\r\n  \/\/\/ the widget tree.\r\n  InheritedProvider({\r\n    Key key,\r\n    Create<T> create,\r\n    T update(BuildContext context, T value),\r\n    UpdateShouldNotify<T> updateShouldNotify,\r\n    void Function(T value) debugCheckInvalidValueType,\r\n    StartListening<T> startListening,\r\n    Dispose<T> dispose,\r\n    bool lazy,\r\n    Widget child,\r\n  })  : _lazy = lazy,\r\n        _delegate = _CreateInheritedProvider(\r\n          create: create,\r\n          update: update,\r\n          updateShouldNotify: updateShouldNotify,\r\n          debugCheckInvalidValueType: debugCheckInvalidValueType,\r\n          startListening: startListening,\r\n          dispose: dispose,\r\n        ),\r\n        super(key: key, child: child);\r\n\r\n  \/\/\/ Expose to its descendants an existing value,\r\n  InheritedProvider.value({\r\n    Key key,\r\n    @required T value,\r\n    UpdateShouldNotify<T> updateShouldNotify,\r\n    StartListening<T> startListening,\r\n    bool lazy,\r\n    Widget child,\r\n  })  : _lazy = lazy,\r\n        _delegate = _ValueInheritedProvider(\r\n          value: value,\r\n          updateShouldNotify: updateShouldNotify,\r\n          startListening: startListening,\r\n        ),\r\n        super(key: key, child: child);\r\n\r\n  InheritedProvider._constructor({\r\n    Key key,\r\n    _Delegate<T> delegate,\r\n    bool lazy,\r\n    Widget child,\r\n  })  : _lazy = lazy,\r\n        _delegate = delegate,\r\n        super(key: key, child: child);\r\n\r\n  final _Delegate<T> _delegate;\r\n  final bool _lazy;\r\n\r\n  @override\r\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\r\n    super.debugFillProperties(properties);\r\n    _delegate.debugFillProperties(properties);\r\n  }\r\n\r\n  @override\r\n  _InheritedProvderElement<T> createElement() {\r\n    return _InheritedProvderElement<T>(this);\r\n  }\r\n\r\n  @override\r\n  Widget buildWithChild(BuildContext context, Widget child) {\r\n    return _DefaultInheritedProviderScope<T>(\r\n      owner: this,\r\n      child: child,\r\n    );\r\n  }\r\n}\r\n```\r\n\r\n我们看到`InheritedProvider<T>`继承了`SingleChildStatelessWidget`。\r\n\r\n既然继承了`Widget`，总归要调用`build`吧：\r\n\r\n我们发现只有`buildWithChild`，没有我们想要的方法，\r\n\r\n没关系，去`SingleChildStatelessWidget`里面看看，\r\n\r\n我有理由怀疑它继承了`StatelessWidget`：\r\n\r\n```dart\r\n\/\/\/ Its [build] method must **not** be overriden. Instead use [buildWithChild].\r\nabstract class SingleChildStatelessWidget extends StatelessWidget\r\n    implements SingleChildWidget {\r\n  \/\/\/ Creates a widget that has exactly one child widget.\r\n  const SingleChildStatelessWidget({Key key, Widget child})\r\n      : _child = child,\r\n        super(key: key);\r\n\r\n  final Widget _child;\r\n\r\n  \/\/\/ A [build] method that receives an extra `child` parameter.\r\n  \/\/\/\r\n  \/\/\/ This method may be called with a `child` different from the parameter\r\n  \/\/\/ passed to the constructor of [SingleChildStatelessWidget].\r\n  \/\/\/ It may also be called again with a different `child`, without this widget\r\n  \/\/\/ being recreated.\r\n  Widget buildWithChild(BuildContext context, Widget child);\r\n\r\n  @override\r\n  Widget build(BuildContext context) => buildWithChild(context, _child);\r\n\r\n  @override\r\n  SingleChildStatelessElement createElement() {\r\n    return SingleChildStatelessElement(this);\r\n  }\r\n}\r\n```\r\n\r\n果不其然，它自己添加了`buildWithChild`，让继承自`StatelessWidget`的\r\n\r\n`build`方法直接调用了`buildWithChild`方法，\r\n\r\n这样它的子类通过实现`buildWithChild`方法达到间接实现`build`。\r\n\r\n所以我能在子类中不用`buildWithChild`这个方法，再次重写`build`吗?\r\n\r\n我劝你善良，类开头注释已经说了：\r\n\r\n`\/\/\/ Its [build] method must **not** be overriden. Instead use [buildWithChild].`\r\n\r\n\r\n\r\n既然系统调用`build`方法时调用了`buildWithChild`，\r\n\r\n那我们返回`InheritedProvider<T>`看看该方法实现：\r\n\r\n```dart\r\n  @override\r\n  Widget buildWithChild(BuildContext context, Widget child) {\r\n    return _DefaultInheritedProviderScope<T>(\r\n      owner: this,\r\n      child: child,\r\n    );\r\n  }\r\n```\r\n\r\n这里的widget返回的是`_DefaultInheritedProviderScope<T>`类型。\r\n\r\n重要的一点`owner`参数中，传了`this`，`InheritedProvider<T>`把自己搭进去了。\r\n\r\n所以通过`InheritedProvider<T>`实例，间接拿到`_delegate`属性，进而取得我的数据。。\r\n\r\n想想就开心，因为很可能找对了路子。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n进去`_DefaultInheritedProviderScope<T>`类看看：\r\n\r\n```dart\r\nclass _DefaultInheritedProviderScope<T> extends InheritedWidget {\r\n  _DefaultInheritedProviderScope({\r\n    this.owner,\r\n    @required Widget child,\r\n  }) : super(child: child);\r\n\r\n  final InheritedProvider<T> owner;\r\n\r\n  @override\r\n  bool updateShouldNotify(InheritedWidget oldWidget) {\r\n    return false;\r\n  }\r\n\r\n  @override\r\n  _DefaultInheritedProviderScopeElement<T> createElement() {\r\n    return _DefaultInheritedProviderScopeElement<T>(this);\r\n  }\r\n}\r\n```\r\n\r\n这个类没有什么逻辑，甚至作为`Widget`，都没有`build`方法。\r\n\r\n然后查看了下`Widget`源码，原来还真没有，\r\n\r\n**`build`方法是在子类`StatelessWidget`、`StatefullWidget`中添加的。**\r\n\r\n那重点就放在了`createElement`。\r\n\r\n因为这个返回值`_DefaultInheritedProviderScopeElement<T>(this)`里面传递了\r\n\r\n`_DefaultInheritedProviderScope<T>`实例，\r\n\r\n通过该实例能得到属性`owner`，而`owner`是`InheritedProvider<T>`实例，\r\n\r\n通过`InheritedProvider<T>`进一步拿到`_delegate`。\r\n\r\n路径我们找到了\r\n\r\n**但是`createElement`什么时候调用呢？**\r\n\r\n### runapp启动粗略分析\r\n\r\n这个问题先弄清楚才好往下看，不骗你，真的。\r\n\r\n不知道该怎么进行的时候就从`runApp`开始试试：\r\n\r\n```dart\r\nvoid runApp(Widget app) {\r\n  WidgetsFlutterBinding.ensureInitialized()\r\n    ..scheduleAttachRootWidget(app)\r\n    ..scheduleWarmUpFrame();\r\n}\r\n```\r\n\r\n我们只看处理`Widget app`地方，进去`scheduleAttachRootWidget`看看：\r\n\r\n```dart\r\n  @protected\r\n  void scheduleAttachRootWidget(Widget rootWidget) {\r\n    Timer.run(() {\r\n      attachRootWidget(rootWidget);\r\n    });\r\n  \r\n```\r\n\r\n`attachRootWidget`看名字是把rootWidget添加到控件树，继续进去：\r\n\r\n```dart\r\n  void attachRootWidget(Widget rootWidget) {\r\n    _renderViewElement = RenderObjectToWidgetAdapter<RenderBox>(\r\n      container: renderView,\r\n      debugShortDescription: '[root]',\r\n      child: rootWidget,\r\n    ).attachToRenderTree(buildOwner, renderViewElement);\r\n  }\r\n```\r\n\r\n上面`RenderObjectToWidgetAdapter<RenderBox>`包裹了`rootWidget`后，调用渲染树：\r\n\r\n```dart\r\n  \/\/\/ Used by [runApp] to bootstrap applications.\r\n  RenderObjectToWidgetElement<T> attachToRenderTree(BuildOwner owner, [ RenderObjectToWidgetElement<T> element ]) {\r\n    if (element == null) {\r\n      owner.lockState(() {\r\n        element = createElement();\r\n        assert(element != null);\r\n        element.assignOwner(owner);\r\n      });\r\n      owner.buildScope(element, () {\r\n        element.mount(null, null);\r\n      });\r\n      \/\/ This is most likely the first time the framework is ready to produce\r\n      \/\/ a frame. Ensure that we are asked for one.\r\n      SchedulerBinding.instance.ensureVisualUpdate();\r\n    } else {\r\n      element._newWidget = this;\r\n      element.markNeedsBuild();\r\n    }\r\n    return element;\r\n  }\r\n```\r\n\r\n首次初始化时，`element`为空，所以会调用`createElement()`。\r\n\r\n然后后面紧跟着执行` owner.buildScope`,\r\n\r\n调用`element.mount(null, null);`：\r\n\r\n```dart\r\n @override\r\n  void mount(Element parent, dynamic newSlot) {\r\n    assert(parent == null);\r\n    super.mount(parent, newSlot);\r\n    _rebuild();\r\n  }\r\n```\r\n\r\n这里的`super.mount`函数会一直调用到`Element`的`mount`。\r\n\r\n这里的`rebuild`开始执行控件树构建：\r\n\r\n```dart\r\n  void _rebuild() {\r\n    try {\r\n        \/\/这里的widget是RenderObjectToWidgetAdapter<RenderBox>\r\n      _child = updateChild(_child, widget.child, _rootChildSlot);\r\n      assert(_child != null);\r\n    } catch (exception, stack) {\r\n      final FlutterErrorDetails details = FlutterErrorDetails(\r\n        exception: exception,\r\n        stack: stack,\r\n        library: 'widgets library',\r\n        context: ErrorDescription('attaching to the render tree'),\r\n      );\r\n      FlutterError.reportError(details);\r\n      final Widget error = ErrorWidget.builder(details);\r\n      _child = updateChild(null, error, _rootChildSlot);\r\n    }\r\n  }\r\n```\r\n\r\n继续看`updateChild(_child, widget.child, _rootChildSlot)`：\r\n\r\n```dart\r\n  @protected\r\n  Element updateChild(Element child, Widget newWidget, dynamic newSlot) {\r\n    assert(() {\r\n      if (newWidget != null && newWidget.key is GlobalKey) {\r\n        final GlobalKey key = newWidget.key;\r\n        key._debugReserveFor(this);\r\n      }\r\n      return true;\r\n    }());\r\n    if (newWidget == null) {\r\n      if (child != null)\r\n        deactivateChild(child);\r\n      return null;\r\n    }\r\n    if (child != null) {\r\n      if (child.widget == newWidget) {\r\n        if (child.slot != newSlot)\r\n          updateSlotForChild(child, newSlot);\r\n        return child;\r\n      }\r\n      if (Widget.canUpdate(child.widget, newWidget)) {\r\n        if (child.slot != newSlot)\r\n          updateSlotForChild(child, newSlot);\r\n        child.update(newWidget);\r\n        assert(child.widget == newWidget);\r\n        assert(() {\r\n          child.owner._debugElementWasRebuilt(child);\r\n          return true;\r\n        }());\r\n        return child;\r\n      }\r\n      deactivateChild(child);\r\n      assert(child._parent == null);\r\n    }\r\n      \/\/类似于Android中的View.inflate\r\n    return inflateWidget(newWidget, newSlot);\r\n  }\r\n```\r\n\r\n这方法中只看最后`inflateWidget(newWidget, newSlot);`，\r\n\r\n这里类似于`View.inflate`，\r\n\r\n不过`View.inflate`是把xml控件转成`View Tree`，\r\n\r\n而这里是把`widget`转成`Element`。\r\n\r\n看看`inflateWidget`实现：\r\n\r\n```dart\r\n  @protected\r\n  Element inflateWidget(Widget newWidget, dynamic newSlot) {\r\n    assert(newWidget != null);\r\n    final Key key = newWidget.key;\r\n    if (key is GlobalKey) {\r\n      final Element newChild = _retakeInactiveElement(key, newWidget);\r\n      if (newChild != null) {\r\n        assert(newChild._parent == null);\r\n        assert(() {\r\n          _debugCheckForCycles(newChild);\r\n          return true;\r\n        }());\r\n        newChild._activateWithParent(this, newSlot);\r\n        final Element updatedChild = updateChild(newChild, newWidget, newSlot);\r\n        assert(newChild == updatedChild);\r\n        return updatedChild;\r\n      }\r\n    }\r\n      \/\/调用了widget的createElement方法。\r\n      \/\/newWidget是myApp\r\n    final Element newChild = newWidget.createElement();\r\n    assert(() {\r\n      _debugCheckForCycles(newChild);\r\n      return true;\r\n    }());\r\n    newChild.mount(this, newSlot);\r\n    assert(newChild._debugLifecycleState == _ElementLifecycle.active);\r\n    return newChild;\r\n  }\r\n```\r\n\r\n看这一行`Element newChild = newWidget.createElement();`,\r\n\r\n由于`newWidget`是`myapp`实例，\r\n\r\n也就是`StatelessWidget`，而它创建了`StatelessElement`。\r\n\r\n所以下面的`newChild.mount(this, newSlot);`\r\n\r\n其实调用的是`StatelessElement`的`mount`函数，\r\n\r\n但是`StatelessElement`没有重写该函数，\r\n\r\n所以调用了其父类`ComponentElement`的`mount`函数：\r\n\r\n```dart\r\n  @override\r\n  void mount(Element parent, dynamic newSlot) {\r\n    super.mount(parent, newSlot);\r\n    assert(_child == null);\r\n    assert(_active);\r\n    _firstBuild();\r\n    assert(_child != null);\r\n  }\r\n```\r\n\r\n该函数中调用了`_firstBuild`:\r\n\r\n```dart\r\n  void _firstBuild() {\r\n    rebuild();\r\n  }\r\n  \r\n    void rebuild() {\r\n   \/\/***省略断言      \r\n    performRebuild();\r\n    assert(() {\r\n      assert(owner._debugCurrentBuildTarget == this);\r\n      owner._debugCurrentBuildTarget = debugPreviousBuildTarget;\r\n      return true;\r\n    }());\r\n    assert(!_dirty);\r\n  }\r\n```\r\n\r\n在`rebuild`中调用了`performRebuild`：\r\n\r\n```dart\r\n  @override\r\n  void performRebuild() {\r\n    if (!kReleaseMode && debugProfileBuildsEnabled)\r\n      Timeline.startSync('${widget.runtimeType}',  arguments: timelineWhitelistArguments);\r\n\r\n    assert(_debugSetAllowIgnoredCallsToMarkNeedsBuild(true));\r\n    Widget built;\r\n    try {\r\n       \/\/调用当前widget.build\r\n        \/\/比如statelesswidget.build,\r\n      built = build();\r\n      debugWidgetBuilderValue(widget, built);\r\n    } catch (e, stack) {\r\n      built = ErrorWidget.builder(\r\n        _debugReportException(\r\n          ErrorDescription('building $this'),\r\n          e,\r\n          stack,\r\n          informationCollector: () sync* {\r\n            yield DiagnosticsDebugCreator(DebugCreator(this));\r\n          },\r\n        ),\r\n      );\r\n    } finally {\r\n      \/\/ We delay marking the element as clean until after calling build() so\r\n      \/\/ that attempts to markNeedsBuild() during build() will be ignored.\r\n      _dirty = false;\r\n      assert(_debugSetAllowIgnoredCallsToMarkNeedsBuild(false));\r\n    }\r\n    try {\r\n        \/\/向下遍历\r\n      _child = updateChild(_child, built, slot);\r\n      assert(_child != null);\r\n    } catch (e, stack) {\r\n      built = ErrorWidget.builder(\r\n        _debugReportException(\r\n          ErrorDescription('building $this'),\r\n          e,\r\n          stack,\r\n          informationCollector: () sync* {\r\n            yield DiagnosticsDebugCreator(DebugCreator(this));\r\n          },\r\n        ),\r\n      );\r\n      _child = updateChild(null, built, slot);\r\n    }\r\n\r\n    if (!kReleaseMode && debugProfileBuildsEnabled)\r\n      Timeline.finishSync();\r\n  }\r\n```\r\n\r\n可以看到这里调用了`build`方法。\r\n\r\n目前这是在`myapp`的`StatelessWidget`实例中调用`build`方法，\r\n\r\n这样目前完成了一个很粗糙的`widget.build`调用。\r\n\r\n那`myapp`中的很多其他`widget`怎么办呢?\r\n\r\n当然通过`_child = updateChild(_child, built, slot)`继续遍历执行啊。\r\n\r\n不过这里的`built`是我们配置的`MultiProvider`了。\r\n\r\n总结一下执行步骤：\r\n\r\n1、`scheduleAttachRootWidget`\r\n\r\n2、`RenderObjectToWidgetAdapter<RenderBox>.attachToRenderTree()`\r\n\r\n3、`RenderObjectToWidgetElement<T>.mount(null, null)`\r\n\r\n4、`RenderObjectToWidgetElement<T>._rebuild()`\r\n\r\n5、`Element.updateChild(Element child, Widget newWidget, dynamic newSlot)`\r\n\r\n6、`Element.inflateWidget(Widget newWidget, dynamic newSlot)`\r\n\r\n7、`newWidget.createElement()`\r\n\r\n8、`newChild.mount(this, newSlot)`\r\n\r\n9、`ComponentElement.mount(Element parent, dynamic newSlot)`\r\n\r\n10、`ComponentElement._firstBuild()`\r\n\r\n11、`Element.rebuild()`\r\n\r\n12、`ComponentElement.performRebuild()`\r\n\r\n13、`Widget build()`\r\n\r\n**这里的`build`是`ComponentElement`调用`performRebuild`方法时，该方法里面调用的`build`，**\r\n\r\n**所以这里的`build`方法其实是`ComponentElement`定义的一个抽象方法，**\r\n\r\n**该抽象方法，在`StatefulElement`被实现为`state.build(this)`，**\r\n\r\n**在`StatelessElement`被实现为`widget.build(this)`。**\r\n\r\n**而我们只是实现这块的`build`内容返回`widget`。**\r\n\r\n**可见`widget`只是`Element`配置文件，`widget`很多方法调用受`Element`控制。**\r\n\r\n14、从新执行步骤5的`updateChild`，进行子控件遍历。\r\n\r\n了解了这些，我们继续往下看。\r\n\r\n上面我们讲到这里：\r\n\r\n```dart\r\n  @override\r\n  _DefaultInheritedProviderScopeElement<T> createElement() {\r\n    return _DefaultInheritedProviderScopeElement<T>(this);\r\n  }\r\n```\r\n\r\n然后就不知道`createElement`如何调用了。\r\n\r\n从上面步骤7可以知道：\r\n\r\n当我们在`inflate`  widget `_DefaultInheritedProviderScope<T>`时，\r\n\r\n用该实例调用`createElement`，\r\n\r\n然后创建并返回了`_DefaultInheritedProviderScopeElement<T>`实例`newChild`,\r\n\r\n然后步骤8，通过步骤7创建的`newChild`调用`mount`函数，\r\n\r\n`_DefaultInheritedProviderScopeElement<T>`本身没有实现`mount`，\r\n\r\n但是通过混入方式继承了`_InheritedProviderScopeMixin<T>`。\r\n\r\n这里有实现`mount`：\r\n\r\n```dart\r\n  @override\r\n  void mount(Element parent, dynamic newSlot) {\r\n    _providerCount++;\r\n    if (_providerCount == 1) {\r\n      _startWatchingScheduler();\r\n    }\r\n    super.mount(parent, newSlot);\r\n  }\r\n```\r\n\r\n通过`super.mount`，进入了`ComponentElement`的`mount`实现：\r\n\r\n```dart\r\n  @override\r\n  void mount(Element parent, dynamic newSlot) {\r\n    super.mount(parent, newSlot);\r\n    assert(_child == null);\r\n    assert(_active);\r\n    _firstBuild();\r\n    assert(_child != null);\r\n  }\r\n```\r\n\r\n再次通过`super.mount`，进入`Element`的`mount`基类实现：\r\n\r\n```dart\r\n  @mustCallSuper\r\n  void mount(Element parent, dynamic newSlot) {\r\n    _parent = parent;\r\n    _slot = newSlot;\r\n    _depth = _parent != null ? _parent.depth + 1 : 1;\r\n    _active = true;\r\n    if (parent != null) \/\/ Only assign ownership if the parent is non-null\r\n      _owner = parent.owner;\r\n    if (widget.key is GlobalKey) {\r\n      final GlobalKey key = widget.key;\r\n      key._register(this);\r\n    }\r\n    _updateInheritance();\r\n    assert(() {\r\n      _debugLifecycleState = _ElementLifecycle.active;\r\n      return true;\r\n    }());\r\n  }\r\n```\r\n\r\n看下`_updateInheritance()`实现：\r\n\r\n```dart\r\n  void _updateInheritance() {\r\n    assert(_active);\r\n    _inheritedWidgets = _parent?._inheritedWidgets;\r\n  }\r\n```\r\n\r\n**`_updateInheritance`这个方法其实是保存并下发你的全局数据的方法。**\r\n\r\n该方法具体实现在`ComponentElement`中：\r\n\r\n```dart\r\n  @override\r\n  void _updateInheritance() {\r\n    assert(_active);\r\n    final Map<Type, InheritedElement> incomingWidgets = _parent?._inheritedWidgets;\r\n    if (incomingWidgets != null)\r\n      _inheritedWidgets = HashMap<Type, InheritedElement>.from(incomingWidgets);\r\n    else\r\n      _inheritedWidgets = HashMap<Type, InheritedElement>();\r\n    _inheritedWidgets[widget.runtimeType] = this;\r\n  }\r\n```\r\n\r\n这里首先判断父`Element`的`_inheritedWidgets`是否有值，\r\n\r\n如果有值则根据既有值转化一个新的的`_inheritedWidgets`，\r\n\r\n如果没有值则创建一个新的空的`_inheritedWidgets`。\r\n\r\n最后保存当前值：` _inheritedWidgets[widget.runtimeType] = this;`\r\n\r\n这个操作发生在`Element`子类``_DefaultInheritedProviderScopeElement<T>`中。\r\n\r\n这里的保存当前值是指：\r\n\r\n`_DefaultInheritedProviderScope<T>`的`rumtimeType`作为`key`，\r\n\r\n`_DefaultInheritedProviderScopeElement<T>`实例作为`value`。\r\n\r\n看下截图：\r\n\r\n![image-20200118164531001](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200118164531001.png)\r\n\r\n\r\n\r\n你可能有疑问，因为这并不是我开始的`UserBean`。\r\n\r\n别慌，其实通过`_DefaultInheritedProviderScopeElement<T>`就能拿到你的数据。\r\n\r\n在取出流程中将会看到具体操作。\r\n\r\n\r\n\r\n## data取出流程\r\n\r\n看完了存储流程，下面来看看如何取出数据的。\r\n\r\n由于平时使用`Provider.of<UserBean>(context)`这种操作比较多，\r\n\r\n所以从这里的源码作为入口：\r\n\r\n```dart\r\n  static T of<T>(BuildContext context, {bool listen}) {\r\n    assert(\r\n      T != dynamic,\r\n      '''\r\nTried to call Provider.of<dynamic>. This is likely a mistake and is therefore\r\nunsupported.\r\n\r\nIf you want to expose a variable that can be anything, consider changing\r\n`dynamic` to `Object` instead.\r\n''',\r\n    );\r\n    assert(!(listen == true && !isWidgetTreeBuilding), '''\r\nTried to listen to a value exposed with provider, from outside of the widget tree.\r\n''');\r\n\r\n    InheritedContext<T> inheritedElement;\r\n\r\n    if (context.widget is _DefaultInheritedProviderScope<T>) {\r\n      \/\/ An InheritedProvider<T>'s update tries to obtain a parent provider of\r\n      \/\/ the same type.\r\n      context.visitAncestorElements((parent) {\r\n        inheritedElement = parent.getElementForInheritedWidgetOfExactType<_DefaultInheritedProviderScope<T>>()\r\n            as _DefaultInheritedProviderScopeElement<T>;\r\n        return false;\r\n      });\r\n    } else {\r\n      inheritedElement = context.getElementForInheritedWidgetOfExactType<_DefaultInheritedProviderScope<T>>()\r\n          as _DefaultInheritedProviderScopeElement<T>;\r\n    }\r\n\r\n    if (inheritedElement == null) {\r\n      throw ProviderNotFoundException(T, context.widget.runtimeType);\r\n    }\r\n\r\n    if (listen ?? isWidgetTreeBuilding) {\r\n      context.dependOnInheritedElement(inheritedElement as InheritedElement);\r\n    }\r\n\r\n    return inheritedElement.value;\r\n  }\r\n\r\n```\r\n\r\n参数的`context`一般就是我们使用`Provider.of<UserBean>`时，所在的widget对应的`Element`。\r\n\r\n```dart\r\nBuildContext get context => _element\r\n```\r\n\r\n这个一般不会是`_DefaultInheritedProviderScope<T>`。\r\n\r\n所以会通过 `else`方法来取值。\r\n\r\n看看`Element`中该方法实现：\r\n\r\n```dart\r\n  @override\r\n  InheritedElement getElementForInheritedWidgetOfExactType<T extends InheritedWidget>() {\r\n    assert(_debugCheckStateIsActiveForAncestorLookup());\r\n    final InheritedElement ancestor = _inheritedWidgets == null ? null : _inheritedWidgets[T];\r\n    return ancestor;\r\n  }\r\n```\r\n\r\n这里直接使用泛型`T`作为key了，\r\n\r\n而调用该方法地方的`T`指的是`_DefaultInheritedProviderScope<T>`，\r\n\r\n在使用时，我们又指定了`<UserBean>`。\r\n\r\n所以实际通过`_inheritedWidgets[_DefaultInheritedProviderScope<UserBean>]`来取值。\r\n\r\n想当然的能取到值了。\r\n\r\n取出`InheritedElement`值 使用`as`转成`_DefaultInheritedProviderScopeElement<T>`。\r\n\r\n最后直接通过`inheritedElement.value`来取值了。\r\n\r\n所以这算完事了吗？\r\n\r\n其实这才刚开始。\r\n\r\n刚才使用的`inheritedElement`是`InheritedContext<T>`类型。\r\n\r\n看下它的`value`：\r\n\r\n```dart\r\nT get value;\r\n```\r\n\r\n这是一个抽象的。\r\n\r\n它的实现在`_InheritedProviderScopeMixin<T>`类中：\r\n\r\n```dart\r\n  @override\r\n  T get value => _delegateState.value;\r\n```\r\n\r\n这个类又是`mixin`类型的，意思是只能其他类通过`with`方式实现？\r\n\r\n没关系先不管了，只要知道`_DefaultInheritedProviderScopeElement<T>` with 它就行了。\r\n\r\n这个类在上面有接触过。\r\n\r\n上面的`_delegateState.value` 中`_delegateState`其实就是\r\n\r\n`_DefaultInheritedProviderScopeElement<T>` 的属性：\r\n\r\n```dart\r\n@override\r\n_DelegateState<T, _Delegate<T>> _delegateState;\r\n```\r\n\r\n这个属性在`_mountDelegate`调用时才进行赋值的：\r\n\r\n```dart\r\n  @override\r\n  void _mountDelegate() {\r\n    _delegateState = widget.owner._delegate.createState()..element = this;\r\n  }\r\n```\r\n\r\n什么时候又会调用该方法呢？\r\n\r\n这是一个重写方法，抽象方法在那个`_InheritedProviderScopeMixin<T>`方法中：\r\n\r\n```dart\r\nmixin _InheritedProviderScopeMixin<T> on InheritedElement implements InheritedContext<T> {\r\n  void _mountDelegate();\r\n  \r\n  @override\r\n  void performRebuild() {\r\n    if (_firstBuild) {\r\n      _firstBuild = false;\r\n      _mountDelegate();\r\n    }\r\n    super.performRebuild();\r\n  }\r\n}\r\n```\r\n\r\n顺便看到了该方法是在`performRebuild()`中调用。\r\n\r\n只有首次构建时候调用一次。\r\n\r\n这里的`performRebuild`相当于上面步骤12、`ComponentElement.performRebuild()`。\r\n\r\n经过上面步骤完成了`_delegateState`的赋值。\r\n\r\n下面看下`_delegateState.value`的获取：\r\n\r\n```dart\r\nclass _CreateInheritedProviderState<T> extends _DelegateState<T, _CreateInheritedProvider<T>> {\r\n  T _value;\r\n\r\n  @override\r\n  T get value {\r\n      \/\/首次执行时_didInitValue=false,所以进入执行\r\n    if (!_didInitValue) {\r\n      _didInitValue = true;\r\n      if (delegate.create != null) {\r\n        assert(debugSetInheritedLock(true));\r\n        _value = delegate.create(element);\r\n        assert(debugSetInheritedLock(false));\r\n\r\n        assert(() {\r\n          delegate.debugCheckInvalidValueType?.call(_value);\r\n          return true;\r\n        }());\r\n      }\r\n      if (delegate.update != null) {\r\n        _value = delegate.update(element, _value);\r\n\r\n        assert(() {\r\n          delegate.debugCheckInvalidValueType?.call(_value);\r\n          return true;\r\n        }());\r\n      }\r\n    }\r\n\r\n    element._isNotifyDependentsEnabled = false;\r\n    _removeListener ??= delegate.startListening?.call(element, _value);\r\n    element._isNotifyDependentsEnabled = true;\r\n    assert(delegate.startListening == null || _removeListener != null);\r\n    return _value;\r\n  }\r\n\r\n}\r\n```\r\n\r\n可以看到`_CreateInheritedProviderState<T>`提供了存储值的最终地方`T _value`。\r\n\r\n同时提供了获取值方法`T get value`。\r\n\r\n首次进入时`_didInitValue=false`，\r\n\r\n所以必定执行`if`语句块，\r\n\r\n至于`delegate.create`我们早就设置过了，不会为空。\r\n\r\n所以会执行`delegate.create(element)`返回值赋给`_value`并返回。\r\n\r\n如果不是第一次获取值了，则不再执行`if`语句块，\r\n\r\n而是直接返回内容。\r\n\r\n通过这里我们知道了 `_value`只有首次调用时才会执行`create`函数予以返回。\r\n\r\n现在明白了为什么这块很多名字都叫`delegate`了。\r\n\r\n这块是延迟加载机制实现的。\r\n\r\n\r\n\r\n至此，数据取出流程分析完了。\r\n\r\n\r\n\r\n## data刷新流程\r\n\r\n分析完了数据存储和取出流程，\r\n\r\n下面该分析数据更新时为什么会自动刷新Widget了。\r\n\r\n这里从`UserBean`的`notifyListeners`看起：\r\n\r\n```dart\r\n  @protected\r\n  @visibleForTesting\r\n  void notifyListeners() {\r\n    assert(_debugAssertNotDisposed());\r\n    if (_listeners != null) {\r\n      final List<VoidCallback> localListeners = List<VoidCallback>.from(_listeners);\r\n      for (VoidCallback listener in localListeners) {\r\n        try {\r\n          if (_listeners.contains(listener))\r\n            listener();\r\n        } catch (exception, stack) {\r\n          FlutterError.reportError(FlutterErrorDetails(\r\n            exception: exception,\r\n            stack: stack,\r\n            library: 'foundation library',\r\n            context: ErrorDescription('while dispatching notifications for $runtimeType'),\r\n            informationCollector: () sync* {\r\n              yield DiagnosticsProperty<ChangeNotifier>(\r\n                'The $runtimeType sending notification was',\r\n                this,\r\n                style: DiagnosticsTreeStyle.errorProperty,\r\n              );\r\n            },\r\n          ));\r\n        }\r\n      }\r\n    }\r\n  }\r\n```\r\n\r\n这里知识遍历了`localListeners`并进行了函数调用。\r\n\r\n`localListeners`里面保存的就是函数类型`VoidCallback`。\r\n\r\n现在陷入死胡同了，因为这里只有调用，不知道什么时候添加的监听。。\r\n\r\n**回头想想，之所以调用监听，**\r\n\r\n**是因为数据刷新了，我需要使用该数据的控件即时知道。**\r\n\r\n**所以监听应该在使用该数据的地方。**\r\n\r\n不过这里还是从配置数据开始看一下。\r\n\r\n说到配置数据又要回去看`ChangeNotifierProvider<T extends ChangeNotifier>`了，\r\n\r\n不过里面没有找到相关调用，\r\n\r\n进去父类`ListenableProvider<T extends Listenable>`:\r\n\r\n```dart\r\nclass ListenableProvider<T extends Listenable> extends InheritedProvider<T> {\r\n  \/\/\/ Creates a [Listenable] using [create] and subscribes to it.\r\n  \/\/\/\r\n  \/\/\/ [dispose] can optionally passed to free resources\r\n  \/\/\/ when [ListenableProvider] is removed from the tree.\r\n  \/\/\/\r\n  \/\/\/ [create] must not be `null`.\r\n  ListenableProvider({\r\n    Key key,\r\n    @required Create<T> create,\r\n    Dispose<T> dispose,\r\n    bool lazy,\r\n    Widget child,\r\n  })  : assert(create != null),\r\n        super(\r\n          key: key,\r\n          startListening: _startListening,\r\n          create: create,\r\n          dispose: dispose,\r\n          debugCheckInvalidValueType: kReleaseMode\r\n              ? null\r\n              : (value) {\r\n                  if (value is ChangeNotifier) {\r\n                    \/\/ ignore: invalid_use_of_protected_member\r\n                    assert(!value.hasListeners, '''\r\nThe default constructor of ListenableProvider\/ChangeNotifierProvider\r\nmust create a new, unused Listenable.\r\n\r\nIf you want to reuse an existing Listenable, use the second constructor:\r\n\r\n- DO use ChangeNotifierProvider.value to provider an existing ChangeNotifier:\r\n\r\nMyChangeNotifier variable;\r\nChangeNotifierProvider.value(\r\n  value: variable,\r\n  child: ...\r\n)\r\n\r\n- DON'T reuse an existing ChangeNotifier using the default constructor.\r\n\r\nMyChangeNotifier variable;\r\nChangeNotifierProvider(\r\n  create: (_) => variable,\r\n  child: ...\r\n)\r\n''');\r\n                  }\r\n                },\r\n          lazy: lazy,\r\n          child: child,\r\n        );\r\n\r\n  \/\/\/ Provides an existing [Listenable].\r\n  ListenableProvider.value({\r\n    Key key,\r\n    @required T value,\r\n    UpdateShouldNotify<T> updateShouldNotify,\r\n    Widget child,\r\n  }) : super.value(\r\n          key: key,\r\n          value: value,\r\n          updateShouldNotify: updateShouldNotify,\r\n          startListening: _startListening,\r\n          child: child,\r\n        );\r\n\r\n}\r\n```\r\n\r\n上面有个`_startListening`静态函数，\r\n\r\n函数中调用了` value?.addListener(e.markNeedsNotifyDependents);`\r\n\r\n这里有可能就是添加数据监听器地方。\r\n\r\n但是`_startListening`没有在该类直接调用，\r\n\r\n而是传递给了父类，点进去看看：\r\n\r\n```dart\r\n  InheritedProvider({\r\n    Key key,\r\n    Create<T> create,\r\n    T update(BuildContext context, T value),\r\n    UpdateShouldNotify<T> updateShouldNotify,\r\n    void Function(T value) debugCheckInvalidValueType,\r\n    StartListening<T> startListening,\r\n    Dispose<T> dispose,\r\n    bool lazy,\r\n    Widget child,\r\n  })  : _lazy = lazy,\r\n        _delegate = _CreateInheritedProvider(\r\n          create: create,\r\n          update: update,\r\n          updateShouldNotify: updateShouldNotify,\r\n          debugCheckInvalidValueType: debugCheckInvalidValueType,\r\n          startListening: startListening,\r\n          dispose: dispose,\r\n        ),\r\n        super(key: key, child: child)\r\n```\r\n\r\n传递过来的`startListening`被包裹到了`_CreateInheritedProvider`：\r\n\r\n```dart\r\nclass _CreateInheritedProvider<T> extends _Delegate<T> {\r\n  _CreateInheritedProvider({\r\n    this.create,\r\n    this.update,\r\n    UpdateShouldNotify<T> updateShouldNotify,\r\n    this.debugCheckInvalidValueType,\r\n    this.startListening,\r\n    this.dispose,\r\n  })  : assert(create != null || update != null),\r\n        _updateShouldNotify = updateShouldNotify;\r\n\r\n  final Create<T> create;\r\n  final T Function(BuildContext context, T value) update;\r\n  final UpdateShouldNotify<T> _updateShouldNotify;\r\n  final void Function(T value) debugCheckInvalidValueType;\r\n  final StartListening<T> startListening;\r\n  final Dispose<T> dispose;\r\n\r\n  @override\r\n  _CreateInheritedProviderState<T> createState() => _CreateInheritedProviderState();\r\n}\r\n```\r\n\r\n这里虽然赋值给属性`startListening`，但是没有调用地方。\r\n\r\n进去`_CreateInheritedProviderState`看看：\r\n\r\n```dart\r\n  T _value;\r\n  _CreateInheritedProvider<T> _previousWidget;\r\n\r\n  @override\r\n  T get value {\r\n    if (!_didInitValue) {\r\n      _didInitValue = true;\r\n      if (delegate.create != null) {\r\n        assert(debugSetInheritedLock(true));\r\n        _value = delegate.create(element);\r\n        assert(debugSetInheritedLock(false));\r\n\r\n        assert(() {\r\n          delegate.debugCheckInvalidValueType?.call(_value);\r\n          return true;\r\n        }());\r\n      }\r\n      if (delegate.update != null) {\r\n        _value = delegate.update(element, _value);\r\n\r\n        assert(() {\r\n          delegate.debugCheckInvalidValueType?.call(_value);\r\n          return true;\r\n        }());\r\n      }\r\n    }\r\n\r\n    element._isNotifyDependentsEnabled = false;\r\n    _removeListener ??= delegate.startListening?.call(element, _value);\r\n    element._isNotifyDependentsEnabled = true;\r\n    assert(delegate.startListening == null || _removeListener != null);\r\n    return _value;\r\n  }\r\n```\r\n\r\n在`_CreateInheritedProviderState`类中发现\r\n\r\n在获取数据`value`的`get`方法中调用了`delegate.startListening?.call(element, _value);`。\r\n\r\n`call`函数第二个参数就是我们全局管理的数据。\r\n\r\n而在静态的`startListening`函数中，第二个参数`Listenable value`：\r\n\r\n```dart\r\n  static VoidCallback _startListening(\r\n    InheritedContext<Listenable> e,\r\n    Listenable value,\r\n  ) {\r\n    value?.addListener(e.markNeedsNotifyDependents);\r\n    return () => value?.removeListener(e.markNeedsNotifyDependents);\r\n  }\r\n```\r\n\r\n**看下这行代码`value?.addListener(e.markNeedsNotifyDependents);`。**\r\n\r\n**相当于调用了`userBean?.addListener`。**\r\n\r\n**所以每个使用全局数据的地方都会为其添加一个监听**\r\n\r\n那么`e.markNeedsNotifyDependents`是什么呢？\r\n\r\n这个`e`是`_InheritedProviderScopeMixin<T>`。\r\n\r\n`markNeedsNotifyDependents`方法为：\r\n\r\n```dart\r\n  @override\r\n  void markNeedsNotifyDependents() {\r\n    if (!_isNotifyDependentsEnabled) return;\r\n\r\n    markNeedsBuild();\r\n    _shouldNotifyDependents = true;\r\n  }\r\n```\r\n\r\n**这里把`_shouldNotifyDependents`设置为true。**\r\n\r\n**表示我这个全局数据更新了，应该通知所有依赖它的widget**\r\n\r\n\r\n\r\n这里调用了`markNeedsBuild`，表示自己要重建，\r\n\r\n```dart\r\n  void markNeedsBuild() {\r\n    assert(_debugLifecycleState != _ElementLifecycle.defunct);\r\n    if (!_active)\r\n      return;\r\n      \/\/去掉大部分断言\r\n    if (dirty)\r\n      return;\r\n    _dirty = true;\r\n    owner.scheduleBuildFor(this);\r\n  }\r\n```\r\n\r\n该方法中标记`dirty=true`表示需要重建。这样绘制下一帧时重建该widget。\r\n\r\n然后调用`scheduleBuildFor`，\r\n\r\n```dart\r\n  void scheduleBuildFor(Element element) {\r\n    if (element._inDirtyList) {\r\n      _dirtyElementsNeedsResorting = true;\r\n      return;\r\n    }\r\n    if (!_scheduledFlushDirtyElements && onBuildScheduled != null) {\r\n      _scheduledFlushDirtyElements = true;\r\n      onBuildScheduled();\r\n    }\r\n    _dirtyElements.add(element);\r\n    element._inDirtyList = true;\r\n    assert(() {\r\n      if (debugPrintScheduleBuildForStacks)\r\n        debugPrint('...dirty list is now: $_dirtyElements');\r\n      return true;\r\n    }());\r\n  }\r\n```\r\n\r\n这是计划重建，重建前把标记为`dirty`的`element`加入到`_dirtyElements`。\r\n\r\n还调用了`onBuildScheduled()`。\r\n\r\n这是一个函数类型属性`VoidCallback onBuildScheduled;`。\r\n\r\n它在`WidgetsBinding`调用`initInstances`时赋值：\r\n\r\n```dart\r\n  void initInstances() {\r\n    super.initInstances();\r\n    _instance = this;\r\n    \/\/ Initialization of [_buildOwner] has to be done after\r\n    \/\/ [super.initInstances] is called, as it requires [ServicesBinding] to\r\n    \/\/ properly setup the [defaultBinaryMessenger] instance.\r\n    _buildOwner = BuildOwner();\r\n      \/\/赋值\r\n    buildOwner.onBuildScheduled = _handleBuildScheduled;\r\n    window.onLocaleChanged = handleLocaleChanged;\r\n    window.onAccessibilityFeaturesChanged = handleAccessibilityFeaturesChanged;\r\n    SystemChannels.navigation.setMethodCallHandler(_handleNavigationInvocation);\r\n    FlutterErrorDetails.propertiesTransformers.add(transformDebugCreator);\r\n  }\r\n```\r\n\r\n所以`onBuildScheduled`指向的是`_handleBuildScheduled`：\r\n\r\n```dart\r\n  void _handleBuildScheduled() {\r\n    \/\/ If we're in the process of building dirty elements, then changes\r\n    \/\/ should not trigger a new frame.\r\n\r\n    ensureVisualUpdate();\r\n  }\r\n```\r\n\r\n在`ensureVisualUpdate`方法中调用了`scheduleFrame`。\r\n\r\n而`scheduleFrame`中调用了`window.scheduleFrame()`执行新一帧的刷新。\r\n\r\n\r\n\r\n上面`markNeedsBuild`是在`_DefaultInheritedProviderScopeElement<T>`中，\r\n\r\n如果重建，会调用旗下方法`build`：\r\n\r\n```dart\r\n  @override\r\n  Widget build() {\r\n    if (_isLazy(widget) == false) {\r\n      value; \/\/ this will force the value to be computed.\r\n    }\r\n    _delegateState.build();\r\n    if (_shouldNotifyDependents) {\r\n      _shouldNotifyDependents = false;\r\n      notifyClients(widget);\r\n    }\r\n    return super.build();\r\n  }\r\n```\r\n\r\n**可以看到如果`_shouldNotifyDependents`为true，**\r\n\r\n**会调用` notifyClients(widget)`。**\r\n\r\n**这里会通知使用该全局数据的控件：**\r\n\r\n```dart\r\n  @override\r\n  void notifyClients(InheritedWidget oldWidget) {\r\n    assert(_debugCheckOwnerBuildTargetExists('notifyClients'));\r\n    for (Element dependent in _dependents.keys) {\r\n      assert(() {\r\n        \/\/ check that it really is our descendant\r\n        Element ancestor = dependent._parent;\r\n        while (ancestor != this && ancestor != null)\r\n          ancestor = ancestor._parent;\r\n        return ancestor == this;\r\n      }());\r\n      \/\/ check that it really depends on us\r\n      assert(dependent._dependencies.contains(this));\r\n      notifyDependent(oldWidget, dependent);\r\n    }\r\n  }\r\n```\r\n\r\n看下`notifyDependent(oldWidget, dependent)`：\r\n\r\n```dart\r\n  @protected\r\n  void notifyDependent(covariant InheritedWidget oldWidget, Element dependent) {\r\n    dependent.didChangeDependencies();\r\n  }\r\n```\r\n\r\n看下这里调用了`dependent.didChangeDependencies();`。\r\n\r\n这个`dependent`就是你使用全局数据widget所对应的`Element`。\r\n\r\n看下该实现：\r\n\r\n```dart\r\n  @mustCallSuper\r\n  void didChangeDependencies() {\r\n    assert(_active); \/\/ otherwise markNeedsBuild is a no-op\r\n    assert(_debugCheckOwnerBuildTargetExists('didChangeDependencies'));\r\n    markNeedsBuild();\r\n  }\r\n```\r\n\r\n这里又调用了`markNeedsBuild`，上面介绍了这块设置`dirty`并准备下一帧刷新。\r\n\r\n这说明使用该数据的`widget`面临刷新，从而获取最新全局数据。\r\n\r\n\r\n\r\n至此完成了数据更新时即时刷新控件的流程分析。\r\n\r\n\r\n\r\n# 0x03 超精简全局状态管理实现\r\n\r\n## 创建保存\r\n\r\n在上面存储流程中我们了解到，\r\n\r\n实际存储数据的是`Map`类型，\r\n\r\n`key`为`Type`类型，但是一般使用`InheritedWidget`实现类的`runtimeType`作为key。\r\n\r\n`value`为`InheritedElement`类型，也就是你自定义的`InheritedWidget`所对应的`element`。\r\n\r\n绕不开的是需要自定义一个继承自`InheritedWidget`的类，为了便于扩展，使用了泛型：\r\n\r\n```dart\r\nclass JInherritedWidget<T> extends InheritedWidget {\r\n  final T data;\r\n\r\n  JInherritedWidget({this.data, Widget child}) : super(child: child);\r\n\r\n  @override\r\n  bool updateShouldNotify(JInherritedWidget oldWidget) {\r\n    return oldWidget.data != data;\r\n  }\r\n}\r\n\/\/顺便定义一个数据类People\r\nclass People {\r\n  String name;\r\n\r\n  People(this.name);\r\n}\r\n```\r\n\r\n这里我直接把`data`放到了widget中，\r\n\r\n通过阅读存储流程，应该了解到在构建`InheritedWidget`时候，\r\n\r\n系统自动调用了`_updateInheritance`执行了`JInherritedWidget`和`Element`存储。\r\n\r\n我们需要做的就是把它用到widget tree中。\r\n\r\n目前，我们完成了创建和保存工作。\r\n\r\n下面我们看看如何实现数据获取\r\n\r\n## 数据获取\r\n\r\n`BuildContext`为我们提供了获取`InheritedElement`以及`InheritedWidget`方法。\r\n\r\n通过`getElementForInheritedWidgetOfExactType`方法拿到保存在`Map`中的value值即`Element`。\r\n\r\n通过`dependOnInheritedElement`，使用`element`得到相应的`Widget`。\r\n\r\n拿到`InheritedWidget`转为我们自定义widget，随后即可拿到data：\r\n\r\n```dart\r\n  static T of<T>(BuildContext context) {\r\n    InheritedElement element =\r\n        context.getElementForInheritedWidgetOfExactType<JInherritedWidget<T>>();\r\n    return (element.dependOnInheritedElement(element) as JInherritedWidget<T>)\r\n        .data;\r\n  }\r\n```\r\n\r\n这就完成了数据的获取。\r\n\r\n目前还差数据更新，\r\n\r\n## 数据更新\r\n\r\n其实如果没有看源码的话，可能数据更新难度最大的部分\r\n\r\n（前提是没有给`JInherritedWidget`在包一层、使用Listenable情况下）。\r\n\r\n单纯的更新data值是很容易的：\r\n\r\n```dart\r\nJInherritedWidget.of<People>(context).name = \"jenson ,${i++}\";\r\n```\r\n\r\n但是我们把值更新了，管理该控件的`JInherritedWidget`不知道你更新了，\r\n\r\n使用该数据的控件也不知道你更新了。\r\n\r\n**Provider和网上很多例子都是用了`Listenable`，实现了`监听模式`。**\r\n\r\n**但是看过源码通过上面data刷新流程会了解到，**\r\n\r\n**系统为我们提供了`notifyClients`来通知使用该数据的控件，**\r\n\r\n**然后你也可以通过`markNeedsBuild`标记`JInherritedWidget`自身刷新。**\r\n\r\n**这里注意一点，通知其他控件要先于标记自身刷新，否则触发异常。**\r\n\r\n所以这里添加一个静态更新方法：\r\n\r\n```dart\r\n  static void update<T>(BuildContext context) {\r\n    InheritedElement element =\r\n        context.getElementForInheritedWidgetOfExactType<JInherritedWidget<T>>();\r\n    element.notifyClients(\r\n        (element.dependOnInheritedElement(element) as JInherritedWidget<T>));\r\n    element.markNeedsBuild();\r\n  }\r\n```\r\n\r\n所有代码只有一个类：\r\n\r\n```dart\r\nclass JInherritedWidget<T> extends InheritedWidget {\r\n  final T data;\r\n\r\n  JInherritedWidget({this.data, Widget child}) : super(child: child);\r\n\r\n  static T of<T>(BuildContext context) {\r\n    InheritedElement element =\r\n        context.getElementForInheritedWidgetOfExactType<JInherritedWidget<T>>();\r\n    return (element.dependOnInheritedElement(element) as JInherritedWidget<T>)\r\n        .data;\r\n  }\r\n\r\n  static void update<T>(BuildContext context) {\r\n    InheritedElement element =\r\n        context.getElementForInheritedWidgetOfExactType<JInherritedWidget<T>>();\r\n    element.notifyClients(\r\n        (element.dependOnInheritedElement(element) as JInherritedWidget<T>));\r\n    element.markNeedsBuild();\r\n  }\r\n\r\n  @override\r\n  bool updateShouldNotify(JInherritedWidget oldWidget) {\r\n    return oldWidget.data != data;\r\n  }\r\n}\r\n```\r\n\r\n\r\n\r\n点击刷新数据是代码：\r\n\r\n```dart\r\n          JInherritedWidget.of<People>(context).name = \"jenson ,${i++}\";\r\n          JInherritedWidget.update<People>(context);\r\n```\r\n\r\n使用代码：\r\n\r\n```dart\r\nchild: UserNameWidget(name: JInherritedWidget.of<People>(context).name)\r\n```\r\n\r\n效果如图：\r\n\r\n![image-20200119140606347](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200119140606347.png)"
  },
  {
    "title" : "Android Studio创建Flutter项目卡住的解决办法",
    "created_time" : "2020-02-16 08:31:10",
    "body" : "# 0x00 前言\r\n\r\n最近这些天梯子不好用，导致使用Android Studio创建Flutter工程时一直停留在create project的加载页面，\r\n\r\n停留几分钟不带动的。\r\n\r\n梯子不知道什么时候才能好，等不及所以只能从Flutter入手。\r\n\r\n# 0x01 配置\r\n\r\n## Flutter设置到path变量\r\n\r\n把Flutter的安装目录的bin添加到path变量中：\r\n\r\n```\r\nD:\\flutter\\flutter\\bin\r\n```\r\n\r\n## 设置系统变量\r\n\r\n为系统变量添加：\r\n\r\nkey `PUB_HOSTED_URL `，value `https:\/\/pub.flutter-io.cn`\r\n\r\nkey `FLUTTER_STORAGE_BASE_URL`，value `https:\/\/storage.flutter-io.cn`\r\n\r\n## 设置Flutter doctor\r\n\r\n打开cmd，输入`flutter doctor`，\r\n\r\n如果有提示`Some Android License not accepted`，\r\n\r\n继续输入命令：`flutter doctor --android-licenses`，\r\n\r\n在后面的所有提示中全部选择`y`。\r\n\r\n# 0x02 结尾\r\n\r\n通过上面设置完成后，再次创建Flutter project时大概几秒钟就能创建完成。"
  },
  {
    "title" : "Flutter project运行时一直卡在assembleDebug",
    "created_time" : "2020-02-16 09:18:33",
    "body" : "# 0x00 前言\r\n\r\n刚创建的Flutter project运行时一直卡在assembleDebug，\r\n\r\n估计也是梯子不能正常使用原因，因为之前都没有遇到这个问题。\r\n\r\n# 0x01 修改\r\n\r\n因为打包使用的是Gradle，所以把相关仓库依赖都改为国内阿里云。\r\n\r\n修改android moudle中`build.gradle`文件中`repositories`闭包：\r\n\r\n```groovy\r\nbuildscript {\r\n    ext.kotlin_version = '1.3.50'\r\n    repositories {\r\n        maven{ url 'https:\/\/maven.aliyun.com\/repository\/google' }\r\n        maven{ url 'https:\/\/maven.aliyun.com\/repository\/jcenter' }\r\n        maven{url 'http:\/\/maven.aliyun.com\/nexus\/content\/groups\/public'}\r\n\/\/        google()\r\n\/\/        jcenter()\r\n    }\r\n\r\n    dependencies {\r\n        classpath 'com.android.tools.build:gradle:3.5.0'\r\n        classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\"\r\n    }\r\n}\r\n\r\nallprojects {\r\n    repositories {\r\n        maven{ url 'https:\/\/maven.aliyun.com\/repository\/google' }\r\n        maven{ url 'https:\/\/maven.aliyun.com\/repository\/jcenter' }\r\n        maven{url 'http:\/\/maven.aliyun.com\/nexus\/content\/groups\/public'}\r\n\/\/        google()\r\n\/\/        jcenter()\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n修改Flutter SDK下的`flutter.gradle`：\r\n\r\n安装目录下`D:\\flutter\\flutter\\packages\\flutter_tools\\gradle`：\r\n\r\n```groovy\r\nbuildscript {\r\n    repositories {\r\n        \/\/google()\r\n        \/\/jcenter()\r\n\t\tmaven{ url 'https:\/\/maven.aliyun.com\/repository\/google' }\r\n        maven{ url 'https:\/\/maven.aliyun.com\/repository\/jcenter' }\r\n        maven{url 'http:\/\/maven.aliyun.com\/nexus\/content\/groups\/public'}\r\n    }\r\n    dependencies {\r\n        classpath 'com.android.tools.build:gradle:3.5.0'\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n同时如果`gradle-wrapper.properties`使用的版本在你本地没有，修改为本地已有版本：\r\n\r\n`distributionUrl=https\\:\/\/services.gradle.org\/distributions\/gradle-6.0.1-all.zip`"
  },
  {
    "title" : "Provider优化Widget刷新",
    "created_time" : "2020-02-22 16:55:16",
    "body" : "# 0x00 前言\r\n\r\n在我们使用Provider监听数据更新时，\r\n\r\n通常会使用`Provider.of<T>(context).xxx`来获取数据填充给相应的Widget，\r\n\r\n比如：`Text(\"${Provider.of<User>(context).name}\")`\r\n\r\n但是这会带来严重的Widget刷新性能问题。\r\n\r\n因为这里的`context`实际是Widget所对应的Element对象。\r\n\r\n而这个`context`一般来自函数`Widget build(BuildContext context)`的参数，\r\n\r\n所以一旦传入了`context`，\r\n\r\n**在数据变更时，该Widget作为根节点的Widget树中，所有StatefulWidget都会被重新构建。**\r\n\r\n**也就是说我本来只想刷新使用该监听数据的Widget，结果却导致了相关Widget树的rebuild。**\r\n\r\n如果我们只想刷新使用该数据的Widget该怎么办？\r\n\r\nProvider已经为我们提供了相关方法。\r\n\r\n# 0x01 Consumer\r\n\r\n## 一般操作\r\n\r\n其实上面操作之所以会导致Widget树的rebuild，是因为使用的`context`范围较大的缘故。\r\n\r\n如果我们只使用监听数据的Widget所对应的`context`不就好了吗？\r\n\r\n确实是这样的！\r\n\r\n如何获取Widget对应的`context`？\r\n\r\n放在平时，我们一般的操作是为监听数据单独创建一个自定义Widget，\r\n\r\n从而得到该Widget的`context`：\r\n\r\n```dart\r\nimport 'package:flutter\/widgets.dart';\r\nimport 'package:flutter_t4\/bean\/user.dart';\r\nimport 'package:provider\/provider.dart';\r\n\r\nclass UserWidget extends StatefulWidget {\r\n  @override\r\n  State<StatefulWidget> createState() => _State();\r\n}\r\n\r\nclass _State extends State<UserWidget> {\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return Text(\"${Provider.of<User>(context).name}\");\r\n  }\r\n}\r\n\r\n```\r\n\r\n## 源码分析\r\n\r\n每监听一个数据就要自定义一个Widget是比较麻烦的事情。\r\n\r\nProvider想到了这一点，为我们提供了`Consumer`。\r\n\r\n看一下该类源码：\r\n\r\n```dart\r\nclass Consumer<T> extends SingleChildStatelessWidget {\r\n  \/\/\/ {@template provider.consumer.constructor}\r\n  \/\/\/ Consumes a [Provider<T>]\r\n  \/\/\/ {@endtemplate}\r\n  Consumer({\r\n    Key key,\r\n    @required this.builder,\r\n    Widget child,\r\n  })  : assert(builder != null),\r\n        super(key: key, child: child);\r\n\r\n  \/\/\/ {@template provider.consumer.builder}\r\n  \/\/\/ Build a widget tree based on the value from a [Provider<T>].\r\n  \/\/\/\r\n  \/\/\/ Must not be `null`.\r\n  \/\/\/ {@endtemplate}\r\n  final Widget Function(BuildContext context, T value, Widget child) builder;\r\n\r\n  @override\r\n  Widget buildWithChild(BuildContext context, Widget child) {\r\n    return builder(\r\n      context,\r\n      Provider.of<T>(context),\r\n      child,\r\n    );\r\n  }\r\n}\r\n```\r\n\r\n这是一个泛型类，\r\n\r\n构造函数有一个必须参数`builder`，这是一个函数类型参数，返回Widget类型\r\n\r\n`builder`函数有三个参数：\r\n\r\n`BuildContext context` 指的是该Widget对应的Element，\r\n\r\n`T value` 指的是要监听的值，\r\n\r\n`Widget child` 指的是子widget，\r\n\r\n`builder`函数由`buildWithChild`函数调用，\r\n\r\n那`buildWithChild`又是什么东西？我们只认识`build`函数的。\r\n\r\n没办法，进父类`SingleChildStatelessWidget`去看看：\r\n\r\n```dart\r\nabstract class SingleChildStatelessWidget extends StatelessWidget\r\n    implements SingleChildWidget {\r\n  \/\/\/ Creates a widget that has exactly one child widget.\r\n  const SingleChildStatelessWidget({Key key, Widget child})\r\n      : _child = child,\r\n        super(key: key);\r\n\r\n  final Widget _child;\r\n\r\n  \/\/\/ A [build] method that receives an extra `child` parameter.\r\n  \/\/\/\r\n  \/\/\/ This method may be called with a `child` different from the parameter\r\n  \/\/\/ passed to the constructor of [SingleChildStatelessWidget].\r\n  \/\/\/ It may also be called again with a different `child`, without this widget\r\n  \/\/\/ being recreated.\r\n  Widget buildWithChild(BuildContext context, Widget child);\r\n\r\n  @override\r\n  Widget build(BuildContext context) => buildWithChild(context, _child);\r\n\r\n  @override\r\n  SingleChildStatelessElement createElement() {\r\n    return SingleChildStatelessElement(this);\r\n  }\r\n}\r\n```\r\n\r\n可以看到原来这是一个`StatelessWidget`，\r\n\r\n而且从这里我们也看到了熟悉的`build`函数，\r\n\r\n它没有自己实现，直接调用了`buildWithChild`。\r\n\r\n而`buildWithChild`调用`builder`，交给我们来实现。\r\n\r\n这里我们注意一点，从`Consumer`构造函数传入的`child Widget`，\r\n\r\n在这里赋值给了`_child`，而后通过`buildWithChild`给返回了。\r\n\r\n这说明在调用`build`函数时，没有造成子Widget树的rebuild，\r\n\r\nrebuild的只有该Widget自身，大大提高了UI刷新效率。\r\n\r\n也可以说**Consumer对child Widget进行了缓存**。\r\n\r\n示例中我们只监听了`User`，可以这样实现：\r\n\r\n```dart\r\nConsumer<User>(builder: (context, data, child) {\r\n              return Text(\"${data.name}\");\r\n            }),\r\n```\r\n\r\n\r\n\r\n现在可以说相比之前有了很大进步，\r\n\r\n是不是可以就此止步，开心的使用`Consumer`了？\r\n\r\n事实上我就是这么做的，直到看了`Selector`源码。\r\n\r\n上面我们实现了当`User`发生变化时刷新其对应的Widget。\r\n\r\n但是有没有想过如果是一个复杂的类，有几十个属性，\r\n\r\n而这个Widget只显示某一条属性（name），那么其他几十条属性变化造成的刷新都是非必须的。\r\n\r\n这在无形中也造成了性能问题。\r\n\r\n那有没有办法只监听类的某一条属性变化，然后刷新Widget呢？\r\n\r\n答案是有的，就是我们接下来要讲的`Selector`。\r\n\r\n# 0x02 Selector\r\n\r\n## 源码分析\r\n\r\n看下`Selector`源码：\r\n\r\n```dart\r\nclass Selector<A, S> extends Selector0<S> {\r\n  \/\/\/ {@macro provider.selector}\r\n  Selector({\r\n    Key key,\r\n    @required ValueWidgetBuilder<S> builder,\r\n    @required S Function(BuildContext, A) selector,\r\n    ShouldRebuild<S> shouldRebuild,\r\n    Widget child,\r\n  })  : assert(selector != null),\r\n        super(\r\n          key: key,\r\n          shouldRebuild: shouldRebuild,\r\n          builder: builder,\r\n          selector: (context) => selector(context, Provider.of(context)),\r\n          child: child,\r\n        );\r\n}\r\n```\r\n\r\n它和`Consumer`一样也是泛型类，不过它有两个泛型参数，\r\n\r\n看下构造函数，\r\n\r\n`ValueWidgetBuilder<S> builder` 它和`Consumer`中的`builder`一样，通过泛型值返回Widget\r\n\r\n`Function(BuildContext, A) selector` 转换器，把A转换成S，也可以理解为属性选择器，选择A类的某一条属性返回。\r\n\r\n`ShouldRebuild<S> shouldRebuild` 函数类型参数，根据对比前后两次S值返回bool值表示是否需要rebuild Widget。\r\n\r\n`Widget child` 同`Consumer`一样，可以缓存的子Widget。非必须\r\n\r\n\r\n\r\n该类只有一个构造函数，要知道具体逻辑需要深入父类`Selector0`：\r\n\r\n```dart\r\nclass Selector0<T> extends SingleChildStatefulWidget {\r\n  \/\/\/ Both `builder` and `selector` must not be `null`.\r\n  Selector0({\r\n    Key key,\r\n    @required this.builder,\r\n    @required this.selector,\r\n    ShouldRebuild<T> shouldRebuild,\r\n    Widget child,\r\n  })  : assert(builder != null),\r\n        assert(selector != null),\r\n        _shouldRebuild = shouldRebuild,\r\n        super(key: key, child: child);\r\n\r\n  \/\/\/ A function that builds a widget tree from `child` and the last result of\r\n  \/\/\/ [selector].\r\n  \/\/\/\r\n  \/\/\/ [builder] will be called again whenever the its parent widget asks for an\r\n  \/\/\/ update, or if [selector] return a value that is different from the\r\n  \/\/\/ previous one using [operator==].\r\n  \/\/\/\r\n  \/\/\/ Must not be `null`.\r\n  final ValueWidgetBuilder<T> builder;\r\n\r\n  \/\/\/ A function that obtains some [InheritedWidget] and map their content into\r\n  \/\/\/ a new object with only a limited number of properties.\r\n  \/\/\/\r\n  \/\/\/ The returned object must implement [operator==].\r\n  \/\/\/\r\n  \/\/\/ Must not be `null`\r\n  final T Function(BuildContext) selector;\r\n\r\n  final ShouldRebuild<T> _shouldRebuild;\r\n\r\n  @override\r\n  _Selector0State<T> createState() => _Selector0State<T>();\r\n}\r\n```\r\n\r\n可以看到`Selector0`是一个`StatefulWidget`，\r\n\r\n不用想，它的主要逻辑肯定在其State里面了，打开看看：\r\n\r\n```dart\r\nclass _Selector0State<T> extends SingleChildState<Selector0<T>> {\r\n  T value;\r\n  Widget cache;\r\n  Widget oldWidget;\r\n\r\n  @override\r\n  Widget buildWithChild(BuildContext context, Widget child) {\r\n    final selected = widget.selector(context);\r\n\r\n    var shouldInvalidateCache = oldWidget != widget ||\r\n        (widget._shouldRebuild != null && widget._shouldRebuild.call(value, selected)) ||\r\n        (widget._shouldRebuild == null && !const DeepCollectionEquality().equals(value, selected));\r\n    if (shouldInvalidateCache) {\r\n      value = selected;\r\n      oldWidget = widget;\r\n      cache = widget.builder(\r\n        context,\r\n        selected,\r\n        child,\r\n      );\r\n    }\r\n    return cache;\r\n  }\r\n}\r\n```\r\n\r\n可以看到这类只有`buildWithChild`一个方法。\r\n\r\n有了`Consumer`经验，可以推断`SingleChildState`一定在其`build`方法中调用了`buildWithChild`。\r\n\r\n事实也是如此。\r\n\r\n所以我们只要看`buildWithChild`实现即可。\r\n\r\n首先调用了`widget.selector(context)`，\r\n\r\n`selector`实现方法为`(context) => selector(context, Provider.of(context))`。\r\n\r\n这里获取了监听的数据泛型A对应的值，然后根据A拿到S。\r\n\r\n\r\n\r\n然后是一个大表达式，返回`shouldInvalidateCache`值表示是否需要刷新。\r\n\r\n当我们首次执行`buildWithChild`时，\r\n\r\n`oldWidget`为null，所以`oldWidget != widget`一定为true，\r\n\r\n所以一定执行`if`语句块，也就是首次运行必调用`builder`。\r\n\r\n与此同时也进行了相关赋值，比如`value`、`oldWidget`、`cache`。\r\n\r\n\r\n\r\n当泛型A对应的监听对象发生变化时，\r\n\r\n再次执行`buildWithChild`，此时` oldWidget != widget`返回false。\r\n\r\n继续执行后面表达式，\r\n\r\n如果我们通过构造函数设置了`_shouldRebuild`，则调用它的实现来比较S的前后变化。\r\n\r\n如果没有设置，则使用`DeepCollectionEquality`进行S前后变化比较。\r\n\r\n也就是说\r\n\r\n**如果是A的其他属性变化引起的`build`，**\r\n\r\n**执行到此处时，由于比较返回false，不会执行`builder`函数调用。**\r\n\r\n**直接返回`cache`，也就不会造成显示的Widget rebuild。**\r\n\r\n\r\n\r\n示例User使用如下：\r\n\r\n```dart\r\nSelector<User, String>(\r\n                builder: (context, data, child) {\r\n                  return Text(\"$data\");\r\n                },\r\n                selector: (context, user) => user.name),\r\n```"
  },
  {
    "title" : "关于couldn't find \"libflutter.so异常解决",
    "created_time" : "2020-02-24 07:34:32",
    "body" : "# 0x00 前言\r\n\r\nFlutter项目真机运行时出现`couldn't find \"libflutter.so\"异常信息。\r\n\r\n造成启动就崩溃。\r\n\r\n# 0x00 分析\r\n\r\n之前是可以正常运行的，在添加极光IM后修改了NDK架构类型支持就有了这个问题。\r\n\r\n所以可以基本确定是CPU架构类型支持修改的问题。\r\n\r\n先看下各CPU架构类型及支持范围：\r\n\r\n![cpu arm图](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/cpu%20arm.webp)\r\n\r\n我在修改NDK类型时，把`arm64-v8a`写成了`armeabi-v8a`，导致cpu架构类型的不支持。\r\n\r\n当我们修改了NDK配置后，记住即时点击`sync`同步，\r\n\r\n如果出现CPU架构不支持，在Running Device地方会给出提示信息。\r\n\r\n比如这里的模拟器只支持x86和x86_64，但是我的app只配置了arm64-v8a。\r\n\r\n这种情况下运行的app是闪退的，要及时修改配置。\r\n\r\n![image-20200320151730809](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200320151730809.png)"
  },
  {
    "title" : "Flutter异常处理与崩溃收集",
    "created_time" : "2020-02-25 15:35:41",
    "body" : "# 0x00 前言\r\n\r\n通常我们在写程序时都是假设执行期间不会发生不正确的事情，然后一撸到底。\r\n\r\n但事实是我们需要把各种设备环境因素考虑进去，以便提供更好的用户体验。\r\n\r\n所以我们需要良好的异常处理。\r\n\r\n# 0x01 异常划分\r\n\r\n说到异常划分，作为Java过来人，\r\n\r\n下意识想到的就是受检异常(编译期异常)和非受检异常(运行时异常)。\r\n\r\n但是Dart和Kotlin一样，都是运行时异常。\r\n\r\n所以这里的异常是根据我使用Flutter过程中自己做的分类，\r\n\r\n姑且分为**UI异常(Widget异常)**和**逻辑异常**。\r\n\r\n## UI异常\r\n\r\n在Flutter中，我把 `build`方法中出现的异常称为UI异常也叫**Widget异常**。\r\n\r\n因为Flutter中的UI构建是基于通过`Widget build(BuildContext context)`方法的响应式构建。\r\n\r\nFramework中构建Widget树时会执行`performRebuild`方法。\r\n\r\n该方法中调用了我们熟知的`build`方法。\r\n\r\nFramework中对`build`方法专门做了`try catch`处理：\r\n\r\n```dart\r\n    Widget built;\r\n    try {\r\n      built = build();\r\n      debugWidgetBuilderValue(widget, built);\r\n    } catch (e, stack) {\r\n      built = ErrorWidget.builder(\r\n        _debugReportException(\r\n          ErrorDescription('building $this'),\r\n          e,\r\n          stack,\r\n          informationCollector: () sync* {\r\n            yield DiagnosticsDebugCreator(DebugCreator(this));\r\n          },\r\n        ),\r\n      );\r\n    } finally {\r\n      \/\/ We delay marking the element as clean until after calling build() so\r\n      \/\/ that attempts to markNeedsBuild() during build() will be ignored.\r\n      _dirty = false;\r\n      assert(_debugSetAllowIgnoredCallsToMarkNeedsBuild(false));\r\n    }\r\n```\r\n\r\n进入`_debugReportException`：\r\n\r\n```dart\r\nFlutterErrorDetails _debugReportException(\r\n  DiagnosticsNode context,\r\n  dynamic exception,\r\n  StackTrace stack, {\r\n  InformationCollector informationCollector,\r\n}) {\r\n  final FlutterErrorDetails details = FlutterErrorDetails(\r\n    exception: exception,\r\n    stack: stack,\r\n    library: 'widgets library',\r\n    context: context,\r\n    informationCollector: informationCollector,\r\n  );\r\n  FlutterError.reportError(details);\r\n  return details;\r\n}\r\n```\r\n\r\n可以看到这里调用了`FlutterError.reportError(details);`。\r\n\r\n看样子这个类是专门处理错误相关的？\r\n\r\n看看`reportError`操作：\r\n\r\n```dart\r\n  \/\/\/ Calls [onError] with the given details, unless it is null.\r\n  static void reportError(FlutterErrorDetails details) {\r\n    assert(details != null);\r\n    assert(details.exception != null);\r\n    if (onError != null)\r\n      onError(details);\r\n  }\r\n```\r\n\r\n可以看到这里有个判断，\r\n\r\n如果`onError`不为空则调用该函数。\r\n\r\n而`onError`默认值是`static FlutterExceptionHandler onError = dumpErrorToConsole;`。\r\n\r\n看来默认是打印异常信息到控制台的，\r\n\r\n不过这是一个静态变量，我们也可以从新赋值处理的。\r\n\r\n我们可以在app启动时这样处理：\r\n\r\n```dart\r\n    FlutterError.onError = (FlutterErrorDetails details,) {\r\n      reportExp(details.exception,details.stack);\/\/上报异常堆栈信息\r\n    };\r\n```\r\n\r\n这样在所有Flutter页面`build`方法出现异常时，我们都会捕捉并上报。\r\n\r\n**注意：并不是Widget在`build`中声明，那异常信息就一定是在`build`中抛出。**\r\n\r\n比如\r\n\r\n```dart\r\nColumn(\r\n            children: <Widget>[\r\n              Positioned(child: Text(\"哈哈\")),\r\n              ]\r\n```\r\n\r\n在这样摆放Widget时，IDE不会出现错误，\r\n\r\n但是在运行时会出现异常，而且你设置了`FlutterError.onError`也无效。\r\n\r\n究其原因是在把子Widget加入到Widget树时会对子Widget进行类型检查。\r\n\r\n检查发现`Positioned`只能放在`Stack`中，\r\n\r\n这一过程发生在`mount`到`build`调用之间。\r\n\r\n\r\n\r\n## 逻辑异常\r\n\r\n上面介绍了UI异常处理，那其他异常怎么办呢？\r\n\r\n说到这可能你上来就是`try catch finally`素质三连。\r\n\r\n但是我想说这素质三连只能在同步异常中有效。\r\n\r\n异步代码需要另外处理。\r\n\r\n### 同步异常\r\n\r\nFlutter中同步异常我们可以使用`try catch finally`捕获。\r\n\r\n使用方法和Java一样，不在细说：\r\n\r\n```dart\r\ntry{\r\n      String a;\r\n      a.substring(10);\r\n    }catch(error,stackTrace){\r\n      reportExp(error,stackTrace);\/\/上报异常堆栈信息\r\n    }finally{\r\n    }\r\n```\r\n\r\n\r\n\r\n### 异步异常\r\n\r\n#### Future.catchError\r\n\r\nFlutter中异步异常是无法通过素质三连进行捕获的。\r\n\r\nFlutter的异步是基于`async await`关键字和`Future`类实现的。\r\n\r\n在`Future`中可以通过`catchError`进行异步异常捕获，\r\n\r\n具体操作是：\r\n\r\n```dart\r\nFuture(() {\r\n      String a;\r\n      a.substring(10);\r\n    }).catchError((error,stackTrace) {\r\n      reportExp(error,stackTrace);\/\/上报异常堆栈信息\r\n    });\r\n```\r\n\r\n**注意：如果在你使用`await`等待`Future`完成，**\r\n\r\n**此时你通过素质三连、`catchError`均可捕获异常。**\r\n\r\n**但是如果你同时使用素质三连和`catchError`,那么只有`catchError`捕获到异常。**\r\n\r\n如下代码只会打印`catch1`内容：\r\n\r\n```dart\r\n    try {\r\n      await Future(() {\r\n        String a;\r\n        a.substring(10);\r\n      }).catchError((error) {\r\n        print(\"catch1 == ${error.toString()}\");\r\n      });\r\n    } catch (e) {\r\n      print(\"catch2 == ${e.toString()}\");\r\n    }\r\n```\r\n\r\n#### runZoned\r\n\r\n异步异常处理的另一种方法是使用`Zone`。\r\n\r\n`Zone`相当于一个沙盒，\r\n\r\n```dart\r\nR runZoned<R>(R body(),\r\n    {Map zoneValues, ZoneSpecification zoneSpecification, Function onError}){\r\n    \r\n}\r\n```\r\n\r\n其中`body`方法作为代码块运行在沙盒环境中。\r\n\r\n可以看到函数参数`onError`，通过该参数来进行异常处理。\r\n\r\n如何把Flutter的代码放在沙盒环境中？\r\n\r\n```dart\r\nvoid main() {\r\n  runZoned(() {\r\n    runApp(MyApp());\r\n  }, onError: (error, StackTrace stackTrace) {\r\n      reportExp(error,stackTrace);\/\/上报异常堆栈信息\r\n  });\r\n}\r\n```\r\n\r\n把`runApp`作为`runZoned`的`body`代码块运行即可。\r\n\r\n这样，在未使用`catchError`的`Future`代码块中出现异常时，\r\n\r\n会自动被`runZoned`的`onError`捕获：\r\n\r\n```dart\r\n        onPressed: () {\r\n          Future(() {\r\n            String a;\r\n            a.substring(10);\r\n          });\r\n        }\r\n```\r\n\r\n\r\n\r\n通过`zoneSpecification`可以对`Zone`进行一些配置，这里不详述。\r\n\r\n\r\n\r\n# 0x02 异常收集\r\n\r\n通过上面的操作基本完成了对常见情况下异常捕获，\r\n\r\n捕获到异常后的上报操作基本都基于现有平台(Android,iOS)，\r\n\r\n这就需要使用平台通信。\r\n\r\n在通信前可以把异常、堆栈信息转为String以便传递：\r\n\r\n```dart\r\nvoid reportExp(err, StackTrace stackTrace) {\r\n  var data = {\r\n    'message': err.toString(),\r\n    'trace': null == stackTrace ? [] : _getTrace(stackTrace),\r\n  };\r\n  \/\/MethodChannel通信\r\n    \r\n}\r\n\r\n_getTrace(StackTrace stackTrace) {\r\n  return Trace.format(stackTrace);\r\n}\r\n```\r\n\r\n如果不打算传递堆栈，而只传递造成异常原因，\r\n\r\n可以通过`Trace.from(stackTrace).frames.first.toString();`。\r\n\r\n转换后的堆栈信息可以通过`MethodChannel`发送给相应平台。\r\n\r\n关于`MethodChannel`使用这里不详述。"
  },
  {
    "title" : "Flutter入门之实现可缩放移动的图片框架",
    "created_time" : "2020-02-25 17:27:30",
    "body" : "# 0x00 前言\r\n\r\n在图片预览页面一般都有图片缩放和移动功能，\r\n\r\n通过缩放和移动可以更容易的看起图片局部内容。\r\n\r\n在Flutter中一切皆是widget，其中`Transform`可以帮助我们实现widget的缩放和移动。\r\n\r\n# 0x01 Transform介绍\r\n\r\n`Transform`  是一个对子widget进行矩阵变换的控件。\r\n\r\n`Matrix4  `是使用的矩阵类。\r\n\r\n通过它来实现各种矩阵操作，如缩放、平移、旋转等。\r\n\r\n看下`Transform`  构造函数：\r\n\r\n```dart\r\n  const Transform({\r\n    Key key,\r\n    @required this.transform,\r\n    this.origin,\r\n    this.alignment,\r\n    this.transformHitTests = true,\r\n    Widget child,\r\n  })\r\n```\r\n\r\n参数`transform`是传递的矩阵设置，\r\n\r\n参数`child`是将要矩阵变换的子控件。\r\n\r\n参数`alignment`是矩阵变换围绕的中心点，可设置`Alignment  `。\r\n\r\n**这个构造函数是一个混合矩阵操作，就是说通过参数`transform`可以同时实现多种变换。**\r\n\r\n**如果要实现单一变换，可以使用相应静态函数：**\r\n\r\n**`Transform.rotate`旋转**\r\n\r\n**`Transform.translate`平移**\r\n\r\n**`Transform.scale`缩放**\r\n\r\n\r\n\r\n# 0x02 创建控件\r\n\r\n创建类`ScaleImageWidget`，继承`StatefulWidget`。\r\n\r\n因为内部要有缩放和平移变量，切随着变量的改变，Widget随着矩阵变换。\r\n\r\n```dart\r\nimport 'package:flutter\/material.dart';\r\n\r\n\/\/\/缩放图片\r\nclass ScaleImageWidget extends StatefulWidget {\r\n  final ImageProvider image;\r\n\r\n  const ScaleImageWidget({Key key, this.image}) : super(key: key);\r\n\r\n  @override\r\n  State<StatefulWidget> createState() => _State();\r\n}\r\n\r\nclass _State extends State<ScaleImageWidget> {\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return GestureDetector(\r\n      onTap: _onTap,\r\n      onLongPress: _onLongPress,\r\n      onScaleStart: _onScaleStart,\r\n      onScaleUpdate: _onScaleUpdate,\r\n      child: Transform(\r\n        transform: Matrix4.identity(),\r\n        alignment: Alignment.center,\r\n        child: Container(\r\n          color: Colors.red,\r\n          child: Center(\r\n            child: Image(image: widget.image),\r\n          ),\r\n        ),\r\n      ),\r\n    );\r\n  }\r\n\r\n  _onTap() {}\r\n\r\n  _onLongPress() {}\r\n\r\n  _onScaleStart(ScaleStartDetails details) {\r\n    print(\"_onScaleStart: focalPoint=${details.focalPoint}\");\r\n  }\r\n\r\n  _onScaleUpdate(ScaleUpdateDetails details) {\r\n    print(\"_onScaleUpdate: focalPoint=${details.focalPoint}\");\r\n    print(\"_onScaleUpdate: scale=${details.scale}\");\r\n  }\r\n}\r\n\r\n```\r\n\r\n上面是基本的框架内容。\r\n\r\n通过下面的调用：\r\n\r\n```dart\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return Scaffold(\r\n      appBar: AppBar(\r\n        title: Text(\"图片缩放\"),\r\n      ),\r\n      body: ScaleImageWidget(\r\n        image: AssetImage('images\/timg.jpg'),\r\n      ),\r\n    );\r\n  }\r\n```\r\n\r\n显示内容为：\r\n\r\n![image-20200325140009078](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200325140009078.png)\r\n\r\n当你在屏幕上做拖拽、缩放操作时，可以看到打印内容如下：\r\n\r\n```txt\r\nI\/flutter ( 4189): _onScaleStart: focalPoint=Offset(162.3, 455.8)\r\nI\/flutter ( 4189): _onScaleUpdate: focalPoint=Offset(162.3, 455.8)\r\nI\/flutter ( 4189): _onScaleUpdate: scale=1.5541888479517616\r\nI\/flutter ( 4189): _onScaleUpdate: focalPoint=Offset(162.3, 456.9)\r\nI\/flutter ( 4189): _onScaleUpdate: scale=1.5886558417246175\r\nI\/flutter ( 4189): _onScaleUpdate: focalPoint=Offset(162.1, 456.0)\r\nI\/flutter ( 4189): _onScaleUpdate: scale=1.6181237483206579\r\nI\/flutter ( 4189): _onScaleUpdate: focalPoint=Offset(162.3, 456.9)\r\nI\/flutter ( 4189): _onScaleUpdate: scale=1.6475941543845447\r\nI\/flutter ( 4189): _onScaleUpdate: focalPoint=Offset(162.1, 456.4)\r\nI\/flutter ( 4189): _onScaleUpdate: scale=1.665581750241805\r\nI\/flutter ( 4189): _onScaleUpdate: focalPoint=Offset(162.1, 457.1)\r\nI\/flutter ( 4189): _onScaleUpdate: scale=1.688553437419615\r\n```\r\n\r\n基础内容已经添加，下面看看具体如何实现。\r\n\r\n# 0x03 缩放实现\r\n\r\n矩阵变换我们这里说过使用`Matrix4`类，并没有使用`Transform`的静态方法。\r\n\r\n上面我们通过`Matrix4.identity()`得到了`Matrix4`实例，\r\n\r\n接着通过该实例实现缩放：\r\n\r\n```dart\r\nMatrix4.identity()\r\n          ..scale(x, y)\r\n```\r\n\r\n这里的`scale`函数接收2个参数，分别是x，y轴的缩放倍率。\r\n\r\n添加一个变量`_currentScale;`表示当前应该使用的倍率：\r\n\r\n```dart\r\ndouble _currentScale = 1.0;\r\nMatrix4.identity()\r\n          ..scale(_currentScale, _currentScale)\r\n```\r\n\r\n接下来要思考的就是在做缩放操作时，如何正确的变更`_currentScale`。\r\n\r\n通过上面日志可以看到\r\n\r\n**每次完整的缩放操作都会调用一次`_onScaleStart`及若干次`_onScaleUpdate`**\r\n\r\n其中`_onScaleUpdate`参数`ScaleUpdateDetails`包含的是缩放操作发生时，\r\n\r\n返回的缩放率`details.scale`。\r\n\r\n这时我们的想法一般是这样的：\r\n\r\n```dart\r\n  _onScaleUpdate(ScaleUpdateDetails details) {\r\n    print(\"_onScaleUpdate: focalPoint=${details.focalPoint}\");\r\n    print(\"_onScaleUpdate: scale=${details.scale}\");\r\n      setState(() {\r\n        _currentScale = details.scale;\r\n      });\r\n  }\r\n```\r\n\r\n运行后操作了下，会发现可以执行缩放了：\r\n\r\n![image-20200325180924466](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200325180924466.png)\r\n\r\n\r\n\r\n这么简单就完成了吗？\r\n\r\n其实多测试几次会发现，在单词缩放中目前是可以的。\r\n\r\n但是松开手后，想继续上次的大小继续缩放，\r\n\r\n**发现widget会先复原或者基本上先缩小，然后再缩放，这是个问题。**\r\n\r\n**这是因为我们缩放一次完成后，没有存储当前的倍率，让下一次缩放开始时使用当前倍率作为基数开始。**\r\n\r\n我们需要再额外添加变量`_lastScale`作为保存上次的倍率。\r\n\r\n在缩放发生时，即`_onScaleStart`调用时保存当前倍率。\r\n\r\n然后在缩放时，让上次的倍率和当前倍率乘积作为新的缩放倍率：\r\n\r\n所以目前代码为：\r\n\r\n```dart\r\n  double _currentScale = 1.0;\r\n  double _lastScale = 1.0;\r\n\r\n_onScaleStart(ScaleStartDetails details) {\r\n    print(\"_onScaleStart: focalPoint=${details.focalPoint}\");\r\n    _lastScale = _currentScale;\r\n  }  \r\n\r\n\r\n_onScaleUpdate(ScaleUpdateDetails details) {\r\n    print(\"_onScaleUpdate: focalPoint=${details.focalPoint}\");\r\n    print(\"_onScaleUpdate: scale=${details.scale}\");\r\n    var tmpScale = details.scale;\r\n    var currentScale = _lastScale * tmpScale;\r\n      setState(() {\r\n        _currentScale = currentScale;\r\n      });\r\n  }\r\n```\r\n\r\n然后再执行多次完整缩放操作，发现目前没有问题了。\r\n\r\n现在基本完成了图片的缩放操作。\r\n\r\n# 0x04 移动实现\r\n\r\n现在看看Widget平移的实现，\r\n\r\n首先创建一个变量`_currentOffset`表示当前的位置，\r\n\r\n有了没有保存上一次变量的教训，\r\n\r\n这次提交创建变量`_lastOffset`表示上一次移动的位置。\r\n\r\n平移操作同样交给`Matrix4`，目前代码为：\r\n\r\n```dart\r\n Offset _currentOffset = Offset.zero;\r\n Offset _lastOffset = Offset.zero;\r\n\r\n Transform(\r\n        transform: Matrix4.identity()\r\n          ..scale(_currentScale, _currentScale)\r\n          ..translate(_currentOffset.dx, _currentOffset.dy)\r\n     \r\n   _onScaleStart(ScaleStartDetails details) {\r\n    print(\"_onScaleStart: focalPoint=${details.focalPoint}\");\r\n    _lastScale = _currentScale;\r\n    _lastOffset = _currentOffset;\r\n  }    \r\n```\r\n\r\n接下来我们要做的就是计算好在什么时机刷新`_currentOffset`。\r\n\r\nWidget平移没有使用什么onDragxxx方法。\r\n\r\n这里仍然使用`_onScaleUpdate`方法。\r\n\r\n已经知道回调返回的参数`ScaleUpdateDetails`中带有缩放倍率。\r\n\r\n如果缩放倍率不为1说明我们正在执行缩放操作，\r\n\r\n如果缩放倍率为1说明我们只是在执行拖动操作。\r\n\r\n所以实现平移，我们需要添加倍率的判断操作：\r\n\r\n```dart\r\n  _onScaleUpdate(ScaleUpdateDetails details) {\r\n    var tmpScale = details.scale;\r\n    if (tmpScale == 1.0) {\r\n      var tmpFocalPoint = details.focalPoint;\r\n      var currentOffset;\/\/如何计算currentOffset\r\n      setState(() {\r\n        _currentOffset = currentOffset;\r\n      });\r\n    } else {\r\n      print(\"_onScaleUpdate: scale=${details.scale}\");\r\n      print(\"_onScaleUpdate: _lastScale=$_lastScale\");\r\n      var currentScale = _lastScale * tmpScale;\r\n      setState(() {\r\n        _currentScale = currentScale;\r\n      });\r\n    }\r\n  }\r\n```\r\n\r\n现在需要计算局部变量`currentOffset`的值。\r\n\r\n当我们在屏幕上滑动时，有个起始点就是`_onScaleStart`返回的`details.focalPoint`，\r\n\r\n有个更新点是`_onScaleUpdate`返回的`details.focalPoint`，\r\n\r\n**偏移量=更新点-起始点，**\r\n\r\n**但是偏移量并不是控件平移所需的最终值，**\r\n\r\n**而是应该使用上一次控件左上角的Offset即`_lastOffset`加上偏移量。**\r\n\r\n起始点的需要从`_onScaleStart`中计算，\r\n\r\n所以需要添加新的变量`_startOffset`，\r\n\r\n在`_onScaleStart`执行时为其赋值：`_startOffset = details.focalPoint;`\r\n\r\n现在更新`_onScaleUpdate`代码：\r\n\r\n```dart\r\n  _onScaleUpdate(ScaleUpdateDetails details) {\r\n    var tmpScale = details.scale;\r\n    if (tmpScale == 1.0) {\r\n      var tmpFocalPoint = details.focalPoint;\r\n      var currentOffset = _lastOffset + (tmpFocalPoint - _startOffset);\r\n      print(\"_onScaleUpdate: currentOffset=$currentOffset\");\r\n      setState(() {\r\n        _currentOffset = currentOffset;\r\n      });\r\n    } else {\r\n      var currentScale = _lastScale * tmpScale;\r\n      setState(() {\r\n        _currentScale = currentScale;\r\n      });\r\n      print(\"_onScaleUpdate: _currentScale=$_currentScale\");\r\n    }\r\n  }\r\n```\r\n\r\n运行代码基本没什么问题：\r\n\r\n![image-20200326012256347](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200326012256347.png)\r\n\r\n但是当放大或缩小到比较大的倍数时，进行拖动操作时会有漂移\/稍慢的现象\r\n\r\n因为可能是Widget已经被缩放过了，这个时候要考虑缩放因素，这里极端情况暂不考虑。\r\n\r\n\r\n\r\n\r\n\r\n# 0x05 恢复原图\r\n\r\n添加完了缩放和平移，现在添加恢复原样的功能。\r\n\r\n希望长按时恢复原样，\r\n\r\n这里恢复原样只要把用到的变量恢复默认值即可：\r\n\r\n```dart\r\n  _onLongPress() {\r\n    setState(() {\r\n      _resetToDefaultValues();\r\n    });\r\n  }\r\n    void _resetToDefaultValues() {\r\n    _startOffset = Offset.zero;\r\n    _lastOffset = Offset.zero;\r\n    _currentOffset = Offset.zero;\r\n    _lastScale = 1.0;\r\n    _currentScale = 1.0;\r\n  }\r\n```\r\n\r\n# 0x06 点击放大\r\n\r\n单击时调用的函数没有参数，所以单击放大倍率默认设置1.5。\r\n\r\n但是我们不能无限放大，当倍率大于16时，恢复原样。\r\n\r\n代码实现为：\r\n\r\n```dart\r\n  _onTap() {\r\n    double currentScale = _lastScale * 1.5;\r\n    if (currentScale > 16) {\r\n      currentScale = 1.0;\r\n      _resetToDefaultValues();\r\n    }\r\n    _lastScale = currentScale;\r\n    setState(() {\r\n      _currentScale = currentScale;\r\n    });\r\n  }\r\n```\r\n\r\n\r\n\r\n全部代码为：\r\n\r\n```dart\r\nimport 'package:flutter\/material.dart';\r\n\r\n\/\/\/缩放图片\r\nclass ScaleImageWidget extends StatefulWidget {\r\n  final ImageProvider image;\r\n\r\n  const ScaleImageWidget({Key key, this.image}) : super(key: key);\r\n\r\n  @override\r\n  State<StatefulWidget> createState() => _State();\r\n}\r\n\r\nclass _State extends State<ScaleImageWidget> {\r\n  double _currentScale = 1.0;\r\n  double _lastScale = 1.0;\r\n  double currentWidth = 0;\r\n  double currentHeight = 0;\r\n  Offset _currentOffset = Offset.zero;\r\n  Offset _lastOffset = Offset.zero;\r\n  Offset _startOffset = Offset.zero;\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return GestureDetector(\r\n      onTap: _onTap,\r\n      onLongPress: _onLongPress,\r\n      onScaleStart: _onScaleStart,\r\n      onScaleUpdate: _onScaleUpdate,\r\n      child: Transform(\r\n          transform: Matrix4.identity()\r\n            ..scale(_currentScale, _currentScale)\r\n            ..translate(_currentOffset.dx, _currentOffset.dy),\r\n          alignment: Alignment.center,\r\n          child: Container(\r\n            color: Colors.red,\r\n            child: Center(\r\n              child: LayoutBuilder(\r\n                builder: (BuildContext _context, BoxConstraints constraints) {\r\n                  if (currentWidth == 0) {\r\n                    currentWidth = constraints.maxWidth;\r\n                    currentHeight = constraints.maxHeight;\r\n                  }\r\n                  print(\r\n                      \"constraints,,,width=${constraints.maxWidth},,,height=${constraints.maxHeight}\");\r\n\r\n                  return Image(image: widget.image);\r\n                },\r\n              ),\r\n            ),\r\n          )),\r\n    );\r\n  }\r\n\r\n  void _resetToDefaultValues() {\r\n    _startOffset = Offset.zero;\r\n    _lastOffset = Offset.zero;\r\n    _currentOffset = Offset.zero;\r\n    _lastScale = 1.0;\r\n    _currentScale = 1.0;\r\n  }\r\n\r\n  _onTap() {\r\n    double currentScale = _lastScale * 1.5;\r\n    if (currentScale > 16) {\r\n      currentScale = 1.0;\r\n      _resetToDefaultValues();\r\n    }\r\n    _lastScale = currentScale;\r\n    setState(() {\r\n      _currentScale = currentScale;\r\n    });\r\n  }\r\n\r\n  _onLongPress() {\r\n    setState(() {\r\n      _resetToDefaultValues();\r\n    });\r\n  }\r\n\r\n  _onScaleStart(ScaleStartDetails details) {\r\n    print(\"_onScaleStart: focalPoint=${details.focalPoint}\");\r\n    _lastScale = _currentScale;\r\n    _lastOffset = _currentOffset;\r\n    _startOffset = details.focalPoint;\r\n  }\r\n\r\n  _onScaleUpdate(ScaleUpdateDetails details) {\r\n    print(\r\n        \"_onScaleUpdate: _lastScale=$_lastScale，，， _currentScale=$_currentScale\");\r\n    print(\r\n        \"_onScaleUpdate: _startOffset=$_startOffset，，， _lastOffset=$_lastOffset\");\r\n    var tmpScale = details.scale;\r\n    if (tmpScale == 1.0) {\r\n      var tmpFocalPoint = details.focalPoint;\r\n      var currentOffset = _lastOffset + (tmpFocalPoint - _startOffset);\r\n      print(\"_onScaleUpdate: currentOffset=$currentOffset\");\r\n      setState(() {\r\n        _currentOffset = currentOffset;\r\n      });\r\n    } else {\r\n      var currentScale = _lastScale * tmpScale;\r\n      setState(() {\r\n        _currentScale = currentScale;\r\n      });\r\n      print(\"_onScaleUpdate: _currentScale=$_currentScale\");\r\n    }\r\n  }\r\n}\r\n\r\n```"
  },
  {
    "title" : "Flutter入门之搜索输入框分析实现",
    "created_time" : "2020-04-16 14:29:38",
    "body" : "# 前言\r\n\r\n基本上有列表的地方就会有搜索，通过搜索可以快速找到想要的数据。\r\n\r\n在Flutter中我原以为会Framework会提供一个类似`SearchView`的Widget。\r\n\r\n但是当我输入`search`时IDE提示给我的并没有类似Widget。\r\n\r\n经过查看文档发现要实现搜索，可以使用`showSearch`方法，\r\n\r\n这倒是和`showDialog`、`showBottomSheet`如出一辙。\r\n\r\n下面看看`showSearch`是如何实现搜索功能的。\r\n\r\n# showSearch介绍\r\n\r\n## 函数参数\r\n\r\n`showSearch`函数源码如下：\r\n\r\n```dart\r\nFuture<T> showSearch<T>({\r\n  @required BuildContext context,\r\n  @required SearchDelegate<T> delegate,\r\n  String query = '',\r\n})\r\n```\r\n\r\n可以看到使用`showSearch`方法，\r\n\r\n只要传递`context`和`delegate`两个必须参数即可。\r\n\r\n其中`context`不用解释都知道，\r\n\r\n`query`是要查找的关键字，一般不用设值。\r\n\r\n而`delegate`类型为`SearchDelegate`，这是一个抽象类。\r\n\r\n所以我们需要自定义一个类继承该类，实现相关方法。\r\n\r\n## SearchDelegate\r\n\r\n自定义`AccountSearchDelegate`继承`SearchDelegate`:\r\n\r\n```dart\r\nclass AccountSearchDelegate extends SearchDelegate {\r\n\r\n  @override\r\n  List<Widget> buildActions(BuildContext context) {\r\n  }\r\n\r\n  @override\r\n  Widget buildLeading(BuildContext context) {\r\n  }\r\n\r\n  @override\r\n  Widget buildResults(BuildContext context) {\r\n  }\r\n\r\n  @override\r\n  Widget buildSuggestions(BuildContext context) {\r\n  }\r\n}\r\n```\r\n\r\n上面四个函数是需要重写的。\r\n\r\n下面分别看看这些函数的作用：\r\n\r\n`buildSuggestions`：返回搜索建议列表。\r\n\r\n在输入内容改变的时候回调该方法，根据不同的内容返回不同的建议列表。\r\n\r\n记住：如果你选择了某个建议列表，也要更新输入内容为建议内容。\r\n\r\n**这里还有一个用法：**\r\n\r\n**在该方法中判断输入内容，如果输入内容存在就根据输入内容给出建议列表。**\r\n\r\n**如果输入内容不存在，就显示一个过去的搜索历史。**\r\n\r\n`buildResults`：返回结果列表。\r\n\r\n当用户提交搜索内容时回调该方法，一般返回`ListView`列表内容。\r\n\r\n`buildLeading`：返回一个显示在输入框前面的Widget。\r\n\r\n一般返回一个返回按钮，可以退出搜索页面。\r\n\r\n`buildActions`：返回一个在输入框后面的Widget用于查询完后显示。\r\n\r\n一般如果输入内容不为空的话，可以显示一个清除按钮，用来清除输入框内容。\r\n\r\n# showSearch使用\r\n\r\n上面介绍了相关函数功能，\r\n\r\n现在根据实际需求看看到底如何应用搜索功能。\r\n\r\n这样一个需求：\r\n\r\n> 1、进入搜索页面后有一个返回按钮，\r\n>\r\n> 如果当前有输入内容，点击返回按钮时清空输入内容，显示搜索建议。\r\n>\r\n> 如果当前没有输入内容，点击返回按钮时退出搜索页面。\r\n>\r\n> 2、搜索执行后，要有清空搜索按钮\r\n>\r\n> 3、没有输入内容时显示搜索历史标签，\r\n>\r\n> 有输入内容时给出搜索建议列表。\r\n>\r\n> 4、搜索有结果时显示结果列表。\r\n\r\n这四个需求分别对应了四个重写方法。\r\n\r\n下面分别实现各个需求。\r\n\r\n### 需求1实现\r\n\r\n我们已经知道`buildLeading`可以添加返回按钮。\r\n\r\n那需求1只要在这个方法完善即可。\r\n\r\n我们只返回一个`IconButton`，根据需求完善点击事件：\r\n\r\n```dart\r\n  @override\r\n  Widget buildLeading(BuildContext context) {\r\n    return IconButton(\r\n      icon: Icon(Icons.arrow_back),\r\n      onPressed: () {\r\n        if (query.isEmpty) {\r\n          close(context, null);\r\n        } else {\r\n          query = \"\";\r\n          showSuggestions(context);\r\n        }\r\n      },\r\n    );\r\n  }\r\n```\r\n\r\n这里注意：\r\n\r\n`close`方法表示退出搜索页面，不需要我们调用`Navigator`。\r\n\r\n`showSuggestions`方法表示显示建议Widget。\r\n\r\n效果图：\r\n\r\n![image-20200416183535752](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200416183535752.png)\r\n\r\n### 需求2实现\r\n\r\n清空按钮实现更简单了，`buildActions`实现即可：\r\n\r\n```dart\r\n  @override\r\n  List<Widget> buildActions(BuildContext context) {\r\n    if (query.isEmpty) {\r\n      return [Container()];\r\n    } else\r\n      return [\r\n        IconButton(\r\n          icon: Icon(Icons.clear),\r\n          onPressed: () {\r\n            query = \"\";\r\n            showSuggestions(context);\r\n          },\r\n        ),\r\n      ];\r\n  }\r\n\r\n```\r\n\r\n效果图：\r\n\r\n![image-20200416183604976](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200416183604976.png)\r\n\r\n### 需求3实现\r\n\r\n没有输入内容时显示搜索历史标签，有输入内容时给出搜索建议列表。\r\n\r\n这里涉及到两种布局：标签布局和建议列表。\r\n\r\n布局的显示根据搜索内容判断：\r\n\r\n```dart\r\n@override\r\n  Widget buildSuggestions(BuildContext context) {\r\n    if (query.isEmpty) {\r\n      return getLables();\r\n    } else\r\n      return getSuggestions();\r\n  }\r\n\r\n  Widget getLabels() {\r\n    return Wrap(\r\n      spacing: 5,\r\n      children: <Widget>[\r\n        RaisedButton(\r\n            onPressed: () {}, child: Text(\"标签1\"), shape: StadiumBorder()),\r\n        RaisedButton(\r\n            onPressed: () {}, child: Text(\"标签2\"), shape: StadiumBorder()),\r\n        RaisedButton(\r\n            onPressed: () {}, child: Text(\"标签3\"), shape: StadiumBorder()),\r\n        RaisedButton(\r\n            onPressed: () {}, child: Text(\"标签4\"), shape: StadiumBorder()),\r\n        RaisedButton(\r\n            onPressed: () {}, child: Text(\"标签5\"), shape: StadiumBorder()),\r\n        RaisedButton(\r\n            onPressed: () {}, child: Text(\"标签6\"), shape: StadiumBorder()),\r\n      ],\r\n    );\r\n  }\r\n\r\n  Widget getSuggestions() {\r\n    return ListView(\r\n      children: <Widget>[\r\n        ListTile(\r\n          title: Text(\"我是建议1\"),\r\n        ),\r\n        ListTile(\r\n          title: Text(\"我是建议2\"),\r\n        ),\r\n        ListTile(\r\n          title: Text(\"我是建议3\"),\r\n        ),\r\n        ListTile(\r\n          title: Text(\"我是建议4\"),\r\n        ),\r\n        ListTile(\r\n          title: Text(\"我是建议5\"),\r\n        ),\r\n      ],\r\n    );\r\n  }\r\n```\r\n\r\n标签效果图：\r\n\r\n![image-20200416183656827](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200416183656827.png)\r\n\r\n建议效果图：\r\n\r\n![image-20200416183714266](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200416183714266.png)\r\n\r\n### 需求4实现\r\n\r\n搜索有结果时显示结果列表，没有结果时提示没有搜索到。\r\n\r\n```dart\r\n  @override\r\n  Widget buildResults(BuildContext context) {\r\n    return ListView(\r\n      children: <Widget>[\r\n        ListTile(\r\n          title: Text(\"我是结果1\"),\r\n        ),\r\n        ListTile(\r\n          title: Text(\"我是结果2\"),\r\n        ),\r\n        ListTile(\r\n          title: Text(\"我是结果3\"),\r\n        ),\r\n        ListTile(\r\n          title: Text(\"我是结果4\"),\r\n        ),\r\n        ListTile(\r\n          title: Text(\"我是结果5\"),\r\n        ),\r\n      ],\r\n    );\r\n  }\r\n```\r\n\r\n有内容结果图：\r\n\r\n![image-20200416184113935](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200416184113935.png)\r\n\r\n### 需求4完善\r\n\r\n本节的title是需求4的完善，\r\n\r\n之所以是完善是因为需求4中的实现在网上的例子太多了，\r\n\r\n因为这都是直接就返回了结果列表，没有进行耗时操作的模拟和实现。\r\n\r\n然鹅搜索这个流程最起码是本地文件\/数据库搜索，更多的是网络操作，\r\n\r\n也就是说其实`Widget buildResults(BuildContext context)`并不能立马得到搜索结果。\r\n\r\n既然得不到搜索结果，你又怎么知道该如何显示呢？\r\n\r\n也就是说回调`buildResults`时，你应该根据输入内容去进行耗时查询。\r\n\r\n所以现在应该是这样：\r\n\r\n```dart\r\n  @override\r\n  Widget buildResults(BuildContext context) {\r\n    final String text = query;\r\n    List data =await getDataFromNet(text); \r\n  \treturn build(data);\r\n  }\r\n```\r\n\r\n但是一旦在函数中使用了`await`，那么该函数就要被声明为`async`函数。\r\n\r\n而函数一旦声明`async`，函数返回类型就是`Future<T>`。\r\n\r\n这时IDE是报错的，因为这个函数是重写函数，不能修改返回值类型。\r\n\r\n既然同步方式实现不行，那就走异步方式，\r\n\r\n就是说我先判断数据集合是否为空，\r\n\r\n如果为空就执行网络请求，同时返回一个空Widget，\r\n\r\n等到网络执行完毕刷新Widget。\r\n\r\n如果不为空就直接使用数据创建结果列表。\r\n\r\n所以现在代码样式如下：\r\n\r\n```dart\r\nList data; \r\n@override\r\n  Widget buildResults(BuildContext context) {\r\n    final String text = query;\r\n    if(data==null){\r\n        getDataFromNet(text).then((value){\r\n            this.data = value;\r\n            showResults(context);\r\n        }); \r\n    }else\r\n  \t\treturn build(data);\r\n  }\r\n```\r\n\r\n其中`showResults`表示以结果列表的形式刷新搜索页。\r\n\r\n上面这种方式功能上没有问题，但是代码并不好。\r\n\r\n所以下面我们以更符合**响应式编程**方式来从新实现这块。\r\n\r\n首先创建一个枚举类：\r\n\r\n```dart\r\nenum FutureState {\r\n  wait,\r\n  done,\r\n}\r\n```\r\n\r\n`FutureState`表示Future执行状态，\r\n\r\n`wait`表示执行中，`done`表示执行完成，包括出现异常。\r\n\r\n然后创建一个包装类，包装泛型数据T和错误信息以及Future状态：\r\n\r\n```dart\r\nclass DataWrapper<T> {\r\n  final Object error;\r\n  final T data;\r\n  final FutureState state;\r\n\r\n  DataWrapper._(\r\n    this.state,\r\n    this.data,\r\n    this.error,\r\n  );\r\n\r\n  factory DataWrapper.wrap(\r\n    FutureState state,\r\n    T data,\r\n    Object error,\r\n  ) =>\r\n      DataWrapper._(state, data, error);\r\n\r\n  bool get hasError => this.error != null;\r\n}\r\n```\r\n\r\n命名一个新函数:\r\n\r\n```dart\r\ntypedef FutureWidgetBuilder = Widget Function(\r\n    BuildContext context, DataWrapper wrapper);\r\n```\r\n\r\n接下来是重点，\r\n\r\n创建`FutureBuild<T>`，它是一个有`StatefulWidget`。\r\n\r\n构造函数接收`Future`和`FutureWidgetBuilder`：\r\n\r\n```dart\r\nclass FutureBuild<T> extends StatefulWidget {\r\n  final FutureWidgetBuilder builder;\r\n  final Future future;\r\n\r\n  const FutureBuild({this.builder, this.future});\r\n\r\n  @override\r\n  State<StatefulWidget> createState() => _FutureBuildState<T>();\r\n}\r\n```\r\n\r\n创建对应的State，`_FutureBuildState<T>`：\r\n\r\n```dart\r\nclass _FutureBuildState<T> extends State<FutureBuild> {\r\n  DataWrapper<T> _wrapper;\r\n\r\n  @override\r\n  void initState() {\r\n    super.initState();\r\n    _wrapper = DataWrapper.wrap(FutureState.wait, null, null);\r\n    if (widget.future != null) {\r\n      final future = widget.future;\r\n      future.then((value) {\r\n        setState(() {\r\n          _wrapper = DataWrapper<T>.wrap(FutureState.done, value, null);\r\n        });\r\n      }).catchError((error) {\r\n        setState(() {\r\n          _wrapper = DataWrapper<T>.wrap(FutureState.done, null, error);\r\n        });\r\n      });\r\n    }\r\n  }\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return widget.builder(context, _wrapper);\r\n  }\r\n}\r\n```\r\n\r\n在State开始的时候会调用`initState`，\r\n\r\n这时给`_wrapper`赋初始值`DataWrapper.wrap(FutureState.wait, null, null);`。\r\n\r\n紧接着对`future`的`then`和`catchError`分别进行实现，重新对`_wrapper`赋值。\r\n\r\n这样不管执行的是`then`还是`catchError`，\r\n\r\n在调用`setState`时都会再次调用`build`，进而调用`FutureWidgetBuilder`。\r\n\r\n最后我们只需要根据`FutureState`和`wrapper.hasError`分别进行判断来返回不同的Widget即可：\r\n\r\n```dart\r\n  @override\r\n  Widget buildResults(BuildContext context) {\r\n    final String text = query;\r\n    return FutureBuild<List<AccountData>>(\r\n      future: AccountProvider.provider.queryByFilter(text),\r\n      builder: (BuildContext context, DataWrapper wrapper) {\r\n        if (wrapper.state == FutureState.wait) {\r\n          return Container();\r\n        } else {\r\n          if (wrapper.hasError) {\r\n            return Text(wrapper.error);\r\n          }\r\n          final data = wrapper.data;\r\n          return ListView.separated(\r\n              itemBuilder: (BuildContext context, int index) =>\r\n                  itemBuilder(context, data[index], null),\r\n              separatorBuilder: (BuildContext context, int index) => Divider(\r\n                    height: 1,\r\n                    color: Colors.grey,\r\n                  ),\r\n              itemCount: data.length);\r\n        }\r\n      },\r\n    );\r\n```\r\n\r\n这样的实现看起来代码量多了，\r\n\r\n但是这块封装适用于以后所有类似的异步请求。\r\n\r\n最关键的问题是通过封装把异步操作封装到FutureBuild的Widget里面。\r\n\r\n对于使用该Widget的人来说只要把注意力放在业务实现即可。\r\n\r\n但是其实Flutter已经想到了这一点，\r\n\r\n所以为我们提供了`FutureBuilder`，我们可以直接拿来使用。\r\n\r\n上面的自己封装代码如果你懂了，那么`FutureBuilder`实现原理你也就懂了。"
  },
  {
    "title" : "Flutter入门之如何判断dialog是否显示",
    "created_time" : "2020-04-30 09:40:13",
    "body" : "# 0x01 dialog中禁止返回键\r\n\r\n禁止返回键后，不用考虑显示loading过程中，突然返回键取消dialog。然后打开新的页面，这样会造成判断请求loading页面是否在栈顶准确性问题。\r\n\r\n首先弹出一个禁止返回键的dialog：\r\n\r\n```dart\r\n  void showdialog(BuildContext context) {\r\n    showDialog(\r\n        context: context,\r\n        barrierDismissible: false,\r\n        builder: (_context) {\r\n          return UnconstrainedBox(\r\n            constrainedAxis: Axis.vertical,\r\n            child: WillPopScope(\r\n                child: SizedBox(\r\n                  width: 250,\r\n                  child: Builder(builder: (__context) {\r\n                    return AlertDialog(\r\n                      elevation: 0,\r\n                      backgroundColor: Colors.transparent,\r\n                      content: Column(\r\n                        mainAxisSize: MainAxisSize.min,\r\n                        children: <Widget>[\r\n                          LoadingWidget(),\r\n                        ],\r\n                      ),\r\n                    );\r\n                  }),\r\n                ),\r\n                onWillPop: () async => false),\r\n          );\r\n        });\r\n  }\r\n```\r\n\r\n接下来判断请求loading的页面是否在栈顶，\r\n\r\n如果该页面在栈顶可以认为当前没有显示loading，\r\n\r\n如果该页面没有在栈顶可以认为当前loading还在显示。\r\n\r\n因为禁用了loading返回键，你不可能取消loading进入新页面。\r\n\r\n我们使用`ModalRoute`判断是否在栈顶：\r\n\r\n```dart\r\nModalRoute.of(context).isCurrent\r\n```\r\n\r\n注意一定要使用`isCurrent`，\r\n\r\n不要被它的兄弟属性`isFirst`和`isActive`迷惑。\r\n\r\n如果返回false，说明不在栈顶，那就间接说明有dialog；\r\n\r\n如果返回true，说明在栈顶，间接说明没有弹出dialog。\r\n\r\n# 0x02 不禁止返回键\r\n\r\n\r\n\r\n既然不禁止返回键，那上面取消dialog然后再进入新页面的情况就要考虑进去。\r\n\r\n我这里的解决方案是创建一个可以显示loadingDialog的基类`MyLoadingWidget`，\r\n\r\n所有需要显示loadingDialog的widget继承该类：\r\n\r\n相关state继承`MyLoadingState`：\r\n\r\n```dart\r\nimport 'package:flutter\/material.dart';\r\n\r\nimport 'LoadingWidget.dart';\r\n\r\nabstract class MyLoadingWidget extends StatefulWidget {\r\n  const MyLoadingWidget({Key key}) : super(key: key);\r\n\r\n  @override\r\n  MyLoadingState createState();\r\n}\r\n\r\nabstract class MyLoadingState<T extends MyLoadingWidget> extends State<T> {\r\n  BuildContext dialogContext;\r\n\r\n  void showdialog(BuildContext context) {\r\n    showDialog(\r\n        context: context,\r\n        barrierDismissible: false,\r\n        builder: (_context) {\r\n          return UnconstrainedBox(\r\n            constrainedAxis: Axis.vertical,\r\n            child: WillPopScope(\r\n                child: SizedBox(\r\n                  width: 250,\r\n                  child: Builder(builder: (__context) {\r\n                    dialogContext = __context;\r\n                    return AlertDialog(\r\n                      elevation: 0,\r\n                      backgroundColor: Colors.transparent,\r\n                      content: Column(\r\n                        mainAxisSize: MainAxisSize.min,\r\n                        children: <Widget>[\r\n                          LoadingWidget(),\r\n                        ],\r\n                      ),\r\n                    );\r\n                  }),\r\n                ),\r\n                onWillPop: () async {\r\n                  dialogContext = null;\r\n                  return true;\r\n                }),\r\n          );\r\n        });\r\n  }\r\n\r\n  bool isShow() {\r\n    if (dialogContext == null) return false;\r\n    return ModalRoute.of(dialogContext) is PopupRoute;\r\n  }\r\n}\r\n\r\n```\r\n\r\n通过`showdialog`显示dialog；\r\n\r\n通过`isShow`判断是否显示dialog；"
  },
  {
    "title" : "Flutter状态管理之Redux使用",
    "created_time" : "2020-05-01 11:59:53",
    "body" : "# 0x00 介绍\r\n\r\nRedux也是一个数据(状态)管理的框架。\r\n\r\n为啥要用**也**字？因为前面介绍的[Flutter框架之Provider源码分析](http:\/\/www.jenson.top\/post\/154\/)的也是一个数据管理的框架。\r\n\r\n通过前面Provider的源码分析了解到最终Provider的实现其实就是围绕**InheritedWidget**实现的。\r\n\r\n巧得很，Redux也是通过**InheritedWidget**来实现的。\r\n\r\n不过这里只介绍Redux的基本使用，关于源码分析留在后面。\r\n\r\n废话少说，直接看看Redux如何使用。\r\n\r\n# 0x01 使用\r\n\r\n介绍使用之前先看下谷歌搜到的一个Redux流程图：\r\n\r\n![redux流程](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/redux%E6%B5%81%E7%A8%8B.png)\r\n\r\n表达出来大概意思是：\r\n\r\n用户操作Widget时触发Action，\r\n\r\nReducer收到当前State和相应Action然后生成新的State。\r\n\r\n新的State保存到Store，\r\n\r\n保存后的Store通知Widget刷新为最新状态。\r\n\r\n其中Action是**dynamic**类型，\r\n\r\nReducer是纯函数，它接收State和Action然后返回新的State。\r\n\r\n## 创建State\r\n\r\n既然Redux也是基于**InheritedWidget**的。\r\n\r\n那也就是说我们应该和Provider一样，把自定义的State放在根Widget中。\r\n\r\n所以我们创建MyState类：\r\n\r\n```dart\r\nclass MyState {\r\n  int count;\r\n\r\n  MyState({this.count});\r\n\r\n  factory MyState.initial() {\r\n    return MyState(count: 110);\r\n  }\r\n}\r\n```\r\n\r\n## 创建Store\r\n\r\nState创建后需要由Store持有的，所以我们需要创建泛型为MyState的Store实例：\r\n\r\n```dart\r\n  var store = Store<MyState>(appReducer, initialState: MyState.initial());\r\n```\r\n\r\n参数**appReducer**：Reducer函数，接收State和Action然后返回新的State。\r\n\r\n参数**initialState**：默认初始化，提供默认值。\r\n\r\n## 创建reducer\r\n\r\n上面说了，reducer是接收State和Action然后根据Action返回新的State。\r\n\r\n所以这里实现为：\r\n\r\n```dart\r\nMyState appReducer(MyState myState, dynamic action) {\r\n  debugPrint(\"appReducer\");\r\n  var _count;\r\n  if ('inc' == action) {\r\n    _count = myState.count + 1;\r\n  } else if ('dec' == action) {\r\n    _count = myState.count - 1;\r\n  } else {\r\n    _count = myState.count;\r\n  }\r\n  return MyState(\r\n    count: _count,\r\n  );\r\n}\r\n```\r\n\r\n网上很多例子都是把Action设置为`enum`类型：\r\n\r\n```dart\r\nenum Action{\r\nINCREMENT,\r\n}\r\n```\r\n\r\n然后看官网demo时，发现也是如此，，所以当时我的第一感觉是Action只能是enum！！！\r\n\r\n唉，不想多说。\r\n\r\n但其实上面说了**Action是**dynamic**类型，可以是字符串，enum，也可以是对象。**\r\n\r\n## 保存Store到根Widget\r\n\r\n上面已经完成了创建Store所需工作，\r\n\r\n这里需要把Store实例保存到根Widget，以便其他页面可以来获取。\r\n\r\n其实只要使用**StoreProvider**包裹一下我们当前根Widget即可：\r\n\r\n```dart\r\nclass MyApp extends StatelessWidget {\r\n  final Store store;\r\n\r\n  const MyApp({Key key, this.store}) : super(key: key);\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return StoreProvider<MyState>(\r\n        store: store,\r\n        child: MaterialApp(\r\n          title: 'Flutter Demo',\r\n          theme: ThemeData(\r\n            primarySwatch: Colors.blue,\r\n            visualDensity: VisualDensity.adaptivePlatformDensity,\r\n          ),\r\n          home: MyHomePage(\r\n            title: \"增加数据\",\r\n          ),\r\n        ));\r\n  }\r\n}\r\n```\r\n\r\n然后在main函数中修改为：\r\n\r\n```dart\r\nvoid main() {\r\n  var store = Store<MyState>(appReducer, initialState: MyState.initial());\r\n  runApp(MyApp(\r\n    store: store,\r\n  ));\r\n}\r\n```\r\n\r\n## 获取数据\r\n\r\n获取数据可以通过**StoreConnector**和**StoreBuilder**。\r\n\r\n这里以**StoreConnector**为例，在MyHomePage代码为：\r\n\r\n```dart\r\n StoreConnector<MyState, int>(\r\n            builder: (ctx, count) {\r\n              debugPrint(\"build..StoreConnector\");\r\n              return Column(\r\n                mainAxisAlignment: MainAxisAlignment.center,\r\n                children: <Widget>[\r\n                  Text(\r\n                    'You have pushed the button this many times:',\r\n                  ),\r\n                  Text(\r\n                    '$count',\r\n                    style: Theme.of(context).textTheme.headline4,\r\n                  ),\r\n                ],\r\n              );\r\n            },\r\n            converter: (store) => store.state.count)\r\n```\r\n\r\n**StoreConnector**类为泛型`StoreConnector<S, ViewModel>`。\r\n\r\n其中`S`为我们定义的MyState类型；\r\n\r\n`ViewModel`为MyState中的某一(某些)属性类型。\r\n\r\n构造函数中，\r\n\r\n参数`converter`将Store类换到ViewModel类型的属性。\r\n\r\n参数`builder`负责根据ViewModel构建Widget。\r\n\r\n## 刷新数据\r\n\r\n上面介绍完了如何获取数据，\r\n\r\n但是数据并不是一成不变的，根据用户操作会呈现不同的样式。\r\n\r\n那么Redux如何刷新Widget呢？\r\n\r\n上面流程图已经介绍过了，\r\n\r\n用户操作触发Action，所以我们只要发送Action就好了：\r\n\r\n```dart\r\nStoreProvider.of<MyState>(context, listen: false).dispatch('inc')\r\n```\r\n\r\n这里的操作和Provider基本一样了。\r\n\r\n至此Redux最基本的使用流程基本讲完了。\r\n\r\n# 0x02 疑问\r\n\r\n## 如何存储多个State\r\n\r\n上面介绍完基本使用流程后就能在项目中直接使用了吗？\r\n\r\n告诉你并不能啊！！\r\n\r\n难道你的项目简单到只有一个State需要管理吗？\r\n\r\n在Provider中我们可以通过这样来管理多个状态类：\r\n\r\n```dart\r\nMultiProvider(\r\n      providers: [\r\n        ChangeNotifierProvider(create: (_) => ScreenSizeBean()),\r\n        ChangeNotifierProvider(create: (_) => UserBean()),\r\n        ChangeNotifierProvider(create: (_) => ChatUser()),\r\n      ],\r\n      child: MaterialApp(\r\n        onGenerateRoute: FindCatApp.router.generator,\r\n        localizationsDelegates: [\r\n          GlobalMaterialLocalizations.delegate,\r\n          GlobalWidgetsLocalizations.delegate,\r\n          CatLocalizationsDelegate()\r\n        ],\r\n        supportedLocales: [const Locale('en', 'US'), const Locale('zh', 'CN')],\r\n        theme: ThemeData(\r\n          primaryColor: Colors.yellow[700],\r\n        ),\r\n        home: HomePage(),\r\n      ),\r\n    )\r\n```\r\n\r\n**那Redux中如何管理多个State呢？**\r\n\r\n**抱歉，Redux中只有一个`Store`，而这一个`Store`只能管理一个`State`。。**\r\n\r\n**那如果还要UserInfo的登录信息要管理怎么办？**\r\n\r\n**往自定义`State`中塞属性！！**\r\n\r\n先定义好`UserInfo`：\r\n\r\n```dart\r\nclass UserInfo {\r\n  String name;\r\n  String pwd;\r\n  String mobile;\r\n\r\n  UserInfo({this.name, this.pwd, this.mobile});\r\n\r\n  factory UserInfo.empty() => UserInfo();\r\n\r\n  bool get isEmpty {\r\n    return (null == name || name.isEmpty) &&\r\n        (null == pwd || pwd.isEmpty) &&\r\n        (null == mobile || mobile.isEmpty);\r\n  }\r\n}\r\n```\r\n\r\n再定义MyState:\r\n\r\n```dart\r\nclass MyState {\r\n  int count;\r\n  UserInfo userInfo;\r\n\r\n  MyState({this.count, this.userInfo});\r\n\r\n  factory MyState.initial() {\r\n    return MyState(count: 110, userInfo: UserInfo.empty());\r\n  }\r\n}\r\n```\r\n\r\n上面我们已经创建好的Store可以不用改变，继续拿来使用。\r\n\r\n但是`appReducer`需要修改，因为现在已经有多个状态需要管理了，\r\n\r\n所以在大于一个状态时，我们需要为每个状态都提供单独的`reducer`：\r\n\r\n```dart\r\nMyState appReducer(MyState myState, dynamic action) {\r\n  debugPrint(\"appReducer\");\r\n  return MyState(\r\n    count: countReducer(myState, action),\r\n    userInfo: userReducer(myState, action),\r\n  );\r\n}\r\n\r\nUserInfo userReducer(MyState myState, action) {\r\n  if (action == 'logout') {\r\n    \/\/\/登出\r\n    return UserInfo.empty();\r\n  }\r\n  return myState.userInfo;\r\n}\r\n\r\nint countReducer(MyState myState, action) {\r\n  var _count;\r\n  if ('inc' == action) {\r\n    _count = myState.count + 1;\r\n  } else if ('dec' == action) {\r\n    _count = myState.count - 1;\r\n  } else {\r\n    _count = myState.count;\r\n  }\r\n  return _count;\r\n}\r\n```\r\n\r\n至此我们完成了多个State属性存储。\r\n\r\n## Action为对象类型如何操作\r\n\r\n上面我们完成了多State属性的存储，但是我们看到userReducer只判断enum，字符串的Action类型。\r\n\r\n如果我们要从Widget获取name、pwd和mobile值，然后封装到UserInfo中，\r\n\r\n那么我们的Action应该如何把新封装的UserInfo传递到`appReducer`呢？\r\n\r\n这时就涉及到对象类型的Action了。\r\n\r\n创建一个UserInfoUpdateAction类：\r\n\r\n```dart\r\nclass UserInfoUpdateAction {\r\n  final UserInfo userInfo;\r\n\r\n  UserInfoUpdateAction(this.userInfo);\r\n}\r\n```\r\n\r\n修改`userReducer`，添加`UserInfoUpdateAction`处理：\r\n\r\n```dart\r\nUserInfo userReducer(MyState myState, action) {\r\n  if (action == 'logout') {\r\n    \/\/\/登出\r\n    return UserInfo.empty();\r\n  }\r\n  if (action is UserInfoUpdateAction) {\r\n    return action.userInfo;\r\n  }\r\n  return myState.userInfo;\r\n}\r\n```\r\n\r\n**这里使用了**is**判断Action，**\r\n\r\n**有没有更好方式？**\r\n\r\n**Redux提供了**combineReducers  **，它接收`Reducer<State>列表`，返回`Reducer<State>`。**\r\n\r\n**列表中的item使用**TypedReducer**来定义,两个泛型参数为State、Action。**\r\n\r\n**构造函数接收纯函数`final State Function(State state, Action action) reducer;`**\r\n\r\n```dart\r\nfinal UserInfoAction = combineReducers<UserInfo>([\r\n  TypedReducer<UserInfo, UserInfoUpdateAction>(userUpdateAction),\r\n  \/\/\/其他Action\r\n \/\/\/其他Action\r\n]);\r\n\r\nUserInfo userUpdateAction(UserInfo userInfo, UserInfoUpdateAction action) {\r\n  return action.userInfo;\r\n}\r\n```\r\n\r\n所以`appReducer`修改为：\r\n\r\n```dart\r\nMyState appReducer(MyState myState, dynamic action) {\r\n  debugPrint(\"appReducer\");\r\n  return MyState(\r\n    count: countReducer(myState, action),\r\n    userInfo: userInfoAction(myState.userInfo, action),\r\n  );\r\n}\r\n```\r\n\r\n下面直接通过Action更新状态：\r\n\r\n```dart\r\n  void _updateUser() {\r\n    var userUpdateAction = UserInfoUpdateAction(\r\n        UserInfo(name: 'Jenson', pwd: '1234', mobile: '158013822222'));\r\n    StoreProvider.of<MyState>(context, listen: false)\r\n        .dispatch(userUpdateAction);\r\n  }\r\n```\r\n\r\n\r\n\r\n## 异步Action\/Store\r\n\r\n参考[redux_thunk](https:\/\/pub.dev\/packages\/redux_thunk)"
  },
  {
    "title" : "关于Flutter运行在windows桌面端",
    "created_time" : "2020-05-03 09:32:32",
    "body" : "# 0x00 前言\r\n\r\nFlutter除了移动端，还能运行在桌面(win,osx,linux)。\r\n\r\n本节以Windows为例，记录Flutter项目运行流程。\r\n\r\n# 0x01 安装Visual Studio\r\n\r\n安装Visual Studio时选择工作负载时选择**使用C++的桌面开发**。\r\n\r\n同时在单个组件中把**win10 SDK**的几个选项勾上。\r\n\r\n如图：\r\n\r\n![image-20200611171253015](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200611171253015.png)\r\n\r\n\r\n\r\n# 0x02 切换分支\r\n\r\n我们开发使用的分支一般是**stable**稳定分支，而**Flutter desktop**是新特性，\r\n\r\n在稳定分支是不存在的，所以需要切换到**master**。\r\n\r\n如果**Flutter desktop**已经是**stable**了，则忽略此步。\r\n\r\n使用`flutter channel`查看当前分支\r\n\r\n使用`flutter channel master`切换到master\r\n\r\n使用`flutter upgrade`升级\r\n\r\n使用`flutter doctor`检查环境\r\n\r\n其中使用`flutter doctor`检查时确保Visual Studio环境是绿色的，如下图：\r\n\r\n![image-20200611171839342](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200611171839342.png)\r\n\r\n# 0x03 下载\r\n\r\n克隆**flutter-desktop-embedding**：`git clone https:``\/\/github.com\/google\/flutter-desktop-embedding`\r\n\r\n我这里直接在**flutter安装目录下执行克隆**\r\n\r\n# 0x04 设置可用\r\n\r\n进入桌面端测试例子目录：`D:\\flutter\\flutter-desktop-embedding\\testbed`。\r\n\r\n执行`flutter config --enable-windows-desktop`\r\n\r\nhuo`flutter config --enable-linux-desktop`\r\n\r\n或`flutter config --enable-macos-desktop`。\r\n\r\n# 0x05 运行\r\n\r\n执行`flutter run`运行该例子到桌面端。\r\n\r\n启动后的桌面端如图：\r\n\r\n![image-20200611172752189](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200611172752189.png)\r\n\r\n# 0x06 异常\r\n\r\n如果出现Unable to find suitable Visual Studio toolchain. Please run `flutter doctor` for more details.\r\n\r\n说明你的Visual Studio安装有问题。\r\n\r\n解决方案参考：https:\/\/stackoverflow.com\/questions\/60334570\/unable-to-find-suitable-visual-studio-toolchain-please-run-flutter-doctor-for"
  },
  {
    "title" : "Android修改系统返回键颜色",
    "created_time" : "2020-05-16 06:22:58",
    "body" : "# 0x00 使用自定义toolbar\r\n\r\n\r\n\r\n通过`setSupportActionBar(toolbar)`设置使用\r\n\r\n# 0x01 设置系统返回键可用\r\n\r\n通过`supportActionBar.setDisplayHomeAsUpEnabled(true)`设置系统返回键可用。\r\n\r\n# 0x02 修改返回键颜色\r\n\r\n```kotlin\r\nval upArrow = ContextCompat.getDrawable(this, R.drawable.abc_ic_ab_back_material)\r\n                    upArrow?.setColorFilter(ContextCompat.getColor(this, android.R.color.black), PorterDuff.Mode.SRC_ATOP)\r\n                    supportActionBar?.setHomeAsUpIndicator(upArrow)\r\n```"
  },
  {
    "title" : "另一种方式实现Flutter国际化",
    "created_time" : "2020-06-18 15:58:27",
    "body" : "# 0x00 前言\r\n\r\n看了一下Flutter国际化实现，看的是Intl库。\r\n\r\n看资料过程发现需要使用命令行生成什么arb文件。\r\n\r\n然后还有几个其他不明所以的文件。\r\n\r\n看的一愣一愣的，遂放弃。\r\n\r\n印象中不论flutter_localization还是Intl都是需要\r\n\r\n在`MaterialApp`中声明**localizationsDelegates**和**supportedLocales**。\r\n\r\n既然这是每个库的共性，那索性进去看看里面大概实现是如何的。\r\n\r\n# 0x01流程分析\r\n\r\n流程开始前先看下大概流程图：\r\n\r\n![flutter国际化](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/flutter%E5%9B%BD%E9%99%85%E5%8C%96.jpg)\r\n\r\n接下来进入源码分析阶段：\r\n\r\n## 第一阶段：MaterialApp\r\n\r\n**localizationsDelegates**和**supportedLocales**首先被`MaterialApp`接收，\r\n\r\n但它是一个`StatefulWidget`，自己并不处理，交给对应`State`(`_MaterialAppState`)。\r\n\r\n在`_MaterialAppState`中，对`localizationsDelegates`和`DefaultMaterialLocalizations.delegate`、`DefaultCupertinoLocalizations.delegate`进行了合并处理，并将合并后的`Iterable`继续传递：\r\n\r\n```dart\r\n  Iterable<LocalizationsDelegate<dynamic>> get _localizationsDelegates sync* {\r\n    if (widget.localizationsDelegates != null)\r\n      yield* widget.localizationsDelegates;\r\n    yield DefaultMaterialLocalizations.delegate;\r\n    yield DefaultCupertinoLocalizations.delegate;\r\n  }\r\n```\r\n\r\n然后`supportedLocales`没有处理，和`Iterable`同样在`build`方法中传入到`WidgetsApp`中。\r\n\r\n## 第二阶段：WidgetsApp\r\n\r\n发现`WidgetsApp`也是一个`StatefulWidget`，\r\n\r\n所以直接进入对应`State`(`_WidgetsAppState`)的`build`中，\r\n\r\n查看`supportedLocales`和`localizationsDelegates`是否有处理:\r\n\r\n```\r\n  Iterable<LocalizationsDelegate<dynamic>> get _localizationsDelegates sync* {\r\n    if (widget.localizationsDelegates != null)\r\n      yield* widget.localizationsDelegates;\r\n    yield DefaultWidgetsLocalizations.delegate;\r\n  }\r\n```\r\n\r\n发现这里又一次进行了合并返回新的`Iterable`。\r\n\r\n而`supportedLocales`没有继续传递了，\r\n\r\n而是把`locale`和`supportedLocales`处理后返回一个`appLocale`和`Iterable`传递给`Localizations`:\r\n\r\n```dart\r\nLocalizations(\r\n              locale: appLocale,\r\n              delegates: _localizationsDelegates.toList(),\r\n              child: title,\r\n            )\r\n```\r\n\r\n这里返回`appLocale`的逻辑大概是\r\n\r\n**如果最开始设置了`locale`那么根据`locale`和`supportedLocales`返回一个传递。**\r\n\r\n**如果没有设置则根据系统支持(`WidgetsBinding.instance.window.locales`)和`supportedLocales`返回一个。**\r\n\r\n具体细节参考源码\r\n\r\n## 第三阶段：Localizations\r\n\r\n进入`Localizations`发现其仍然是一个`StatefulWidget`。\r\n\r\n直接去其对应的`_LocalizationsState`中`build`查看是否对\r\n\r\n`locale`和`delegates`有处理过：\r\n\r\n```dart\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    if (_locale == null)\r\n      return Container();\r\n    return Semantics(\r\n      textDirection: _textDirection,\r\n      child: _LocalizationsScope(\r\n        key: _localizedResourcesScopeKey,\r\n        locale: _locale,\r\n        localizationsState: this,\r\n        typeToResources: _typeToResources,\r\n        child: Directionality(\r\n          textDirection: _textDirection,\r\n          child: widget.child,\r\n        ),\r\n      ),\r\n    );\r\n  }\r\n```\r\n\r\n在这里我们看到并没有把传过来的参数继续传递。\r\n\r\n就目前情况来看如果继续传递是传递给`_LocalizationsScope`的。\r\n\r\n但是其接收的嫌疑参数只有`_locale`、`this`、`_typeToResources`。\r\n\r\n下面分别看看这三个参数有什么含义，\r\n\r\n`this`就是`_LocalizationsState`自身，\r\n\r\n我们发现`_locale`和`_typeToResources`赋值是在`load`函数进行的：\r\n\r\n```dart\r\n  @override\r\n  void initState() {\r\n    super.initState();\r\n    load(widget.locale);\r\n  }\r\n\r\nvoid load(Locale locale) {\r\n    final Iterable<LocalizationsDelegate<dynamic>> delegates = widget.delegates;\r\n    if (delegates == null || delegates.isEmpty) {\r\n      _locale = locale;\r\n      return;\r\n    }\r\n\r\n    Map<Type, dynamic> typeToResources;\r\n    final Future<Map<Type, dynamic>> typeToResourcesFuture = _loadAll(locale, delegates)\r\n      .then<Map<Type, dynamic>>((Map<Type, dynamic> value) {\r\n        return typeToResources = value;\r\n      });\r\n\r\n    if (typeToResources != null) {\r\n      \/\/ All of the delegates' resources loaded synchronously.\r\n      _typeToResources = typeToResources;\r\n      _locale = locale;\r\n    } else {\r\n      \/\/ - Don't rebuild the dependent widgets until the resources for the new locale\r\n      \/\/ have finished loading. Until then the old locale will continue to be used.\r\n      \/\/ - If we're running at app startup time then defer reporting the first\r\n      \/\/ \"useful\" frame until after the async load has completed.\r\n      RendererBinding.instance.deferFirstFrame();\r\n      typeToResourcesFuture.then<void>((Map<Type, dynamic> value) {\r\n        if (mounted) {\r\n          setState(() {\r\n            _typeToResources = value;\r\n            _locale = locale;\r\n          });\r\n        }\r\n        RendererBinding.instance.allowFirstFrame();\r\n      });\r\n    }\r\n  }\r\n```\r\n\r\n可以看到在State初始化时执行了`load`。\r\n\r\n函数大概意思就是把`widget.locale`赋值给`_locale`，\r\n\r\n遍历`delegates`,由于每个`delegate`都继承**LocalizationsDelegate**并实现了\r\n\r\n`bool isSupported(Locale locale)`\r\n\r\n`Future<T> load(Locale locale)`\r\n\r\n`bool shouldReload(covariant LocalizationsDelegate<T> old)`\r\n\r\n三个方法。\r\n\r\n遍历时调用`delegate.load()`返回泛型**Future<T>**实例。\r\n\r\n把**T**类型作为`key`，**T**实例作为`value`存入`Map<Type, dynamic>`返回赋值给`_typeToResources`。\r\n\r\n## 第四阶段：_LocalizationsScope\r\n\r\n上面已经了解了三个嫌疑参数的含义。\r\n\r\n接下来看看`_LocalizationsScope`，它继承了`InheritedWidget`。\r\n\r\n根据以前对`InheritedWidget`的分析，\r\n\r\n`_LocalizationsScope`对应`InheritedElement`的被存储到`_inheritedWidgets`中。\r\n\r\n我们应该通过`_LocalizationsScope`.of`方法返回该`Widget`进而拿到相关数据。\r\n\r\n但是这是一个隐藏类，我们不能使用。\r\n\r\n但是通过搜索发现`Localizations`中有如下方法：\r\n\r\n```dart\r\n  static T of<T>(BuildContext context, Type type) {\r\n    assert(context != null);\r\n    assert(type != null);\r\n    final _LocalizationsScope scope = context.dependOnInheritedWidgetOfExactType<_LocalizationsScope>();\r\n    return scope?.localizationsState?.resourcesFor<T>(type);\r\n  }\r\n```\r\n\r\n这里的`Type`为泛型T的类型，\r\n\r\n虽然`_LocalizationsScope`我们不能使用，但是`Localizations`已经为我们封装了现成可用方法。\r\n\r\n在分析Provider源码时说过，关于`InheritedWidget`主要掌握三个地方：\r\n\r\n保存数据、更新数据和获取数据。\r\n\r\n数据保存流程刚才已经分析完了，\r\n\r\n假设更新数据由切换系统语言自动触发，我们无需操作。\r\n\r\n那么我们只要获取数据就好了，这里通过`Localizations.of`也已经完成。\r\n\r\n## 第五阶段：如何实现多语言\r\n\r\n流程分析完了，但是系统是如何提供多语言呢？\r\n\r\n上面说了自定义Delegate要继承`LocalizationsDelegate<T>`重新三个方法。\r\n\r\n其中`Future<T> load(Locale locale)`根据不同`locale`加载不同的资源**T**。\r\n\r\n通过`_MaterialLocalizationsDelegate`类，我们看下具体实现：\r\n\r\n```dart\r\nclass _MaterialLocalizationsDelegate extends LocalizationsDelegate<MaterialLocalizations> {\r\n  const _MaterialLocalizationsDelegate();\r\n\r\n  @override\r\n  bool isSupported(Locale locale) => locale.languageCode == 'en';\r\n\r\n  @override\r\n  Future<MaterialLocalizations> load(Locale locale) => DefaultMaterialLocalizations.load(locale);\r\n\r\n  @override\r\n  bool shouldReload(_MaterialLocalizationsDelegate old) => false;\r\n\r\n  @override\r\n  String toString() => 'DefaultMaterialLocalizations.delegate(en_US)';\r\n}\r\n```\r\n\r\n其中`DefaultMaterialLocalizations.load(locale)`为：\r\n\r\n```dart\r\n  static Future<MaterialLocalizations> load(Locale locale) {\r\n    return SynchronousFuture<MaterialLocalizations>(const DefaultMaterialLocalizations());\r\n  }\r\n```\r\n\r\n这里的`DefaultMaterialLocalizations`为`MaterialLocalizations`子类，\r\n\r\n以`SynchronousFuture`方式返回。\r\n\r\n看看 `DefaultMaterialLocalizations`部分代码：\r\n\r\n```\r\n  @override\r\n  String get invalidDateFormatLabel => 'Invalid format.';\r\n\r\n  @override\r\n  String get invalidDateRangeLabel => 'Invalid range.';\r\n\r\n  @override\r\n  String get dateOutOfRangeLabel => 'Out of range.';\r\n\r\n  @override\r\n  String get saveButtonLabel => 'SAVE';\r\n\r\n  @override\r\n  String get datePickerHelpText => 'SELECT DATE';\r\n\r\n  @override\r\n  String get dateRangePickerHelpText => 'SELECT RANGE';\r\n```\r\n\r\n**子类重写了父类变量，也就是说可以根据不同的`Locale`返回不同的资源**T**。**\r\n\r\n# 0x02 实现国际化\r\n\r\n上面介绍了相关流程，\r\n\r\n接下来看看如何从另一种方式实现国际化\r\n\r\n## 创建资源T\r\n\r\n通过上面我们知道`LocalizationsDelegate<T>`带有泛型的。\r\n\r\n那我们就先实现这个泛型类：\r\n\r\n```dart\r\nclass MyLocalization{\r\n\r\n}\r\n```\r\n\r\n我们要在该类中添加我们app要支持的语言：\r\n\r\n```dart\r\n  \/\/\/支持的Locales\r\n  static List<Locale> get supportedLocales {\r\n    return const <Locale>[\r\n      Locale.fromSubtags(languageCode: 'zh'),\r\n      Locale.fromSubtags(languageCode: 'en'),\r\n    ];\r\n  }\r\n```\r\n\r\n然后封装能获取`MyLocalization`的方法：\r\n\r\n```dart\r\n  static MyLocalization of(BuildContext context) {\r\n    return Localizations.of<MyLocalization>(context, MyLocalization);\r\n  }\r\n```\r\n\r\n上面说了根据不同的`Locale`返回不同的资源**T**，\r\n\r\n所以我们这里`MyLocalization`要抽象化，提供未实现的属性，完整代码为：\r\n\r\n```dart\r\nabstract class MyLocalization {\r\n  \/\/\/支持的Locales\r\n  static List<Locale> get supportedLocales {\r\n    return const <Locale>[\r\n      Locale.fromSubtags(languageCode: 'zh'),\r\n      Locale.fromSubtags(languageCode: 'en'),\r\n    ];\r\n  }\r\n\r\n  static MyLocalization of(BuildContext context) {\r\n    return Localizations.of<MyLocalization>(context, MyLocalization);\r\n  }\r\n\r\n  String get title;\r\n\r\n  String get app_name;\r\n}\r\n```\r\n\r\n由于我们支持了中文和英文，所以还要有2个`MyLocalization`的实现类：\r\n\r\n`EnLocalization`和`CnLocalization`，代码实现为：\r\n\r\n```dart\r\nclass EnLocalization extends MyLocalization {\r\n  @override\r\n  String get title => \"international\";\r\n\r\n  @override\r\n  String get app_name => \"test international\";\r\n}\r\n\r\nclass CnLocalization extends MyLocalization {\r\n  @override\r\n  String get title => \"国际化\";\r\n\r\n  @override\r\n  String get app_name => \"测试国际化\";\r\n}\r\n```\r\n\r\n**注意：以后所有需要国际化的文本首先声明在`MyLocalization`然后在其子类予以实现即可。**\r\n\r\n## 创建delegate\r\n\r\n接下来创建自定义`MyDelegate`:\r\n\r\n```dart\r\nclass MyDelegate extends LocalizationsDelegate<MyLocalization> {\r\n  static MyDelegate delegate = MyDelegate();\r\n\r\n  const MyDelegate();\r\n\r\n  @override\r\n  bool isSupported(Locale locale) {\r\n    if (locale != null) {\r\n      for (var supportedLocale in MyLocalization.supportedLocales) {\r\n        if (supportedLocale.languageCode == locale.languageCode) {\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  @override\r\n  Future<MyLocalization> load(Locale locale) {\r\n    if (locale.languageCode == 'en') {\r\n      return SynchronousFuture<MyLocalization>(EnLocalization());\r\n    } else if (locale.languageCode == 'zh') {\r\n      return SynchronousFuture<MyLocalization>(CnLocalization());\r\n    }\r\n    return SynchronousFuture<MyLocalization>(CnLocalization());\r\n  }\r\n\r\n  @override\r\n  bool shouldReload(LocalizationsDelegate<MyLocalization> old) => false;\r\n}\r\n```\r\n\r\n`isSupported`中根据参数`locale`和`MyLocalization.supportedLocales`进行比较判断是否支持此`locale`\r\n\r\n`load`根据不同的`locale.languageCode`创建不同的语言资源。\r\n\r\n## 添加Delegate\r\n\r\n在`MaterialApp`中添加`localizationsDelegates`和`supportedLocales`：\r\n\r\n```\r\n MaterialApp(\r\n        localizationsDelegates: [\r\n          GlobalMaterialLocalizations.delegate,\r\n          GlobalWidgetsLocalizations.delegate,\r\n          MyDelegate.delegate,\r\n        ],\r\n        supportedLocales: MyLocalization.supportedLocales,\r\n        home: TestKeyPage(),\r\n      )\r\n```\r\n\r\n## 使用\r\n\r\n通过`MyLocalization.of(context).title`直接使用即可。\r\n\r\n## 优化\r\n\r\n在`load`方法中如果语言较多时，要写很多硬性诸如`zh`、`en`等比较\r\n\r\n而且每次都要从新创建`xxLocalization`，性能不好。\r\n\r\n所以在`MyLocalization`添加静态变量：\r\n\r\n```dart\r\n  static Map<String, MyLocalization> localizations = {\r\n    'zh': CnLocalization(),\r\n    'en': EnLocalization(),\r\n  };\r\n```\r\n\r\n`load`修改为：\r\n\r\n```dart\r\n  @override\r\n  Future<MyLocalization> load(Locale locale) {\r\n    if (MyLocalization.localizations.containsKey(locale.languageCode)) {\r\n      return SynchronousFuture(\r\n          MyLocalization.localizations[locale.languageCode]);\r\n    } else {\r\n      return SynchronousFuture(MyLocalization.localizations['zh']);\r\n    }\r\n  }\r\n```\r\n\r\n这样减少了过多的if else判断和硬性编码，也减少了每次创建`xxLocalization`对象。"
  },
  {
    "title" : "另一种方式实现Flutter国际化(二)之App内部语言切换",
    "created_time" : "2020-06-21 14:12:03",
    "body" : "# 0x00 前言\r\n\r\n在做语言切换的时候要注意你的语言切换是内部切换还是外部切换。\r\n\r\n内部切换是系统语言没有改变，单纯在app内的语言切换。\r\n\r\n外部切换是指系统语言切换导致的app语言切换。\r\n\r\n内部切换，切换后我们需要自己去刷新。\r\n\r\n外部切换，系统会自动回调，无需我们实现。\r\n\r\n下面分别说说这两种。\r\n\r\n# 0x01 外部切换\r\n\r\n[另一种方式实现Flutter国际化](http:\/\/www.jenson.top\/post\/166\/)里面的语言切换就是外部切换。\r\n\r\n但是我们App是怎么知道系统语言发生变化了呢？\r\n\r\n在`runApp`运行的时候回初始化`WidgetsFlutterBinding`:\r\n\r\n```dart\r\nvoid runApp(Widget app) {\r\n  WidgetsFlutterBinding.ensureInitialized()\r\n    ..scheduleAttachRootWidget(app)\r\n    ..scheduleWarmUpFrame();\r\n}\r\n```\r\n\r\n其中`ensureInitialized`调用了`WidgetsFlutterBinding()`。\r\n\r\n而构造函数调用的时候会调用`initInstances()`：\r\n\r\n```dart\r\n  @override\r\n  void initInstances() {\r\n    super.initInstances();\r\n    _instance = this;\r\n\r\n    assert(() {\r\n      _debugAddStackFilters();\r\n      return true;\r\n    }());\r\n\r\n    \/\/ Initialization of [_buildOwner] has to be done after\r\n    \/\/ [super.initInstances] is called, as it requires [ServicesBinding] to\r\n    \/\/ properly setup the [defaultBinaryMessenger] instance.\r\n    _buildOwner = BuildOwner();\r\n    buildOwner.onBuildScheduled = _handleBuildScheduled;\r\n    window.onLocaleChanged = handleLocaleChanged;\r\n    window.onAccessibilityFeaturesChanged = handleAccessibilityFeaturesChanged;\r\n    SystemChannels.navigation.setMethodCallHandler(_handleNavigationInvocation);\r\n    FlutterErrorDetails.propertiesTransformers.add(transformDebugCreator);\r\n  }\r\n```\r\n\r\n注意这里面为`window`设置了一个属性`onLocaleChanged`。\r\n\r\n这是一个函数类型，而`handleLocaleChanged`是这样：\r\n\r\n```dart\r\n  @protected\r\n  @mustCallSuper\r\n  void handleLocaleChanged() {\r\n    dispatchLocalesChanged(window.locales);\r\n  }\r\n\r\n```\r\n\r\n其中`window.locales`表示系统使用的语言列表，\r\n\r\n当我们修改系统语言时，`window.locales`的变化会回调`handleLocaleChanged`。\r\n\r\n```dart\r\n  @protected\r\n  @mustCallSuper\r\n  void dispatchLocalesChanged(List<Locale> locales) {\r\n    for (final WidgetsBindingObserver observer in _observers)\r\n      observer.didChangeLocales(locales);\r\n  }\r\n```\r\n\r\n遍历观察者，告知系统语言发生变化，注意处理。\r\n\r\n那么`_observers`中的数据是什么时候被添加进去的呢？\r\n\r\n[另一种方式实现Flutter国际化](http:\/\/www.jenson.top\/post\/166\/)里面有说到`WidgetsApp`,其对应`_WidgetsAppState`。\r\n\r\n其`initState`方法为：\r\n\r\n```dart\r\n  @override\r\n  void initState() {\r\n    super.initState();\r\n    _updateNavigator();\r\n    _locale = _resolveLocales(WidgetsBinding.instance.window.locales, widget.supportedLocales);\r\n    WidgetsBinding.instance.addObserver(this);\r\n  }\r\n```\r\n\r\n可以看到这里添加了Observer。\r\n\r\n当执行`observer.didChangeLocales(locales)`时，\r\n\r\n其实会调用`_WidgetsAppState`中的`didChangeLocales`：\r\n\r\n```dart\r\n  @override\r\n  void didChangeLocales(List<Locale> locales) {\r\n    final Locale newLocale = _resolveLocales(locales, widget.supportedLocales);\r\n    if (newLocale != _locale) {\r\n      setState(() {\r\n        _locale = newLocale;\r\n      });\r\n    }\r\n  }\r\n```\r\n\r\n既然调用了`setState`，那么接下来就是调用`build`。\r\n\r\n把新的`_locale`向下传递，导致页面根据新的`_locale`获取新的资源显示文本。\r\n\r\n这就完成了外部切换。\r\n\r\n# 0x02 内部切换\r\n\r\n内部切换最直接的方法就是切换语言时，我们执行`MaterialApp`参数`locale`的刷新。\r\n\r\n如何切换时刷新`locale`?\r\n\r\n当然是把`Locale`加入到状态管理。\r\n\r\n以`Provider`为例，\r\n\r\n## 创建`Locale`包裹类\r\n\r\n```dart\r\nclass LocaleWrap with ChangeNotifier {\r\n  Locale locale;\r\n\r\n\r\n  void update(Locale locale) {\r\n    this.locale = locale;\r\n    notifyListeners();\r\n  }\r\n}\r\n```\r\n\r\n## 添加到`MultiProvider`中\r\n\r\n```dart\r\n ChangeNotifierProvider(\r\n            create: (_) =>\r\n                LocaleWrap()..locale = Locale.fromSubtags(languageCode: 'zh'))\r\n```\r\n\r\n既然已经把`Locale`纳入了状态管理，接下来要做的就是\r\n\r\n## Provider提供locale\r\n\r\n`MaterialApp`中使用的`locale`的值需要从`Provider`中获取了：\r\n\r\n```dart\r\nConsumer<LocaleWrap>(builder: (ctx, data, child) {\r\n        return MaterialApp(\r\n          onGenerateRoute: FindCatApp.router.generator,\r\n          localizationsDelegates: [\r\n            CatDelegate.delegate,\r\n            GlobalMaterialLocalizations.delegate,\r\n            GlobalWidgetsLocalizations.delegate,\r\n          ],\r\n          locale: data.locale,\/\/\/使用状态管理提供的Locale\r\n          supportedLocales: BaseLocalization.supportedLocales,\r\n          theme: ThemeData(\r\n            primaryColor: Colors.yellow[700],\r\n          ),\r\n          home: HomePage(),\r\n        );\r\n      })\r\n```\r\n\r\n## 切换语言时发送刷新通知\r\n\r\n```dart\r\nProvider.of<LocaleWrap>(context, listen: false)\r\n                  .update(Locale.fromSubtags(languageCode: val));\r\n```"
  },
  {
    "title" : "Flutter状态管理之scoped_model源码分析",
    "created_time" : "2020-06-29 10:13:54",
    "body" : "# 0x00 前言\r\n\r\n状态管理对于Flutter这种响应式编程来说是很重要的。\r\n\r\n对于要入手状态管理框架，**scoped_model**是一个不错的选择。\r\n\r\n因为这个框架只有一个文件，6个类。\r\n\r\n学起来比较容易上手。\r\n\r\n这里首先看一下如何使用，然后在对其进行源码分析。\r\n\r\n# 0x01 使用\r\n\r\n**scoped_model**使用起来非常简单，因为它只有6个类。\r\n\r\n`Model`：我们的数据类继承该类，在数据变化需要通知其他使用该属性的Widget刷新时调用`notifyListeners`即可。\r\n\r\n`ScopedModel`：用作root widget，可以看做为我们提供数据的容器。\r\n\r\n`ScopedModelDescendant`：Descendant是后裔，子孙的意思。\r\n\r\n上面有提供数据的root widget。这个自然就是获取`Model`的widget。\r\n\r\n`_InheritedModel`：是`ScopedModel`可以被后裔获取的关键。\r\n\r\n`ModelFinder`：过时类，使用`ScopedModel.of`方法获取`Model`即可。\r\n\r\n`ScopedModelError`：错误类，获取不到`ScopedModel`时抛出该异常。\r\n\r\n可以看到后面三个是内部类、过时类和错误信息类。\r\n\r\n所以使用时，我们只需要使用前3个类。\r\n\r\n分析完这让我们使用更简单专注了。\r\n\r\n## 创建Model类\r\n\r\n\r\n\r\n```dart\r\nclass UserInfoByScoped extends Model {\r\n  String username;\r\n\r\n  UserInfoByScoped.empty() {\r\n    username = \"Jenson\";\r\n  }\r\n\r\n  void update(String name) {\r\n    username = name;\r\n    notifyListeners();\r\n  }\r\n}\r\n```\r\n\r\n**在你认为所有属性变更需要通知其他使用该属性地方的Widget时，调用`notifyListeners`。**\r\n\r\n## 添加ScopedModel\r\n\r\n添加`ScopedModel`在Root Widget。\r\n\r\n```dart\r\nWidget useScoped() {\r\n  return ScopedModel<UserInfoByScoped>(\r\n      model: UserInfoByScoped.empty(),\r\n      child: MaterialApp(\r\n        home: ScopedHomePage(),\r\n      ));\r\n}\r\n```\r\n\r\n## 添加ScopedModelDescendant\r\n\r\n```dart\r\nScopedModelDescendant<UserInfoByScoped>(\r\n              builder: (context, child, model) {\r\n            return Text(model.username);\r\n          })\r\n```\r\n\r\n## 获取Model并更新\r\n\r\n```dart\r\nRaisedButton(\r\n            onPressed: () {\r\n              var name = \"Jenson \" + DateTime.now().toString();\r\n              ScopedModel.of<UserInfoByScoped>(context).update(name);\r\n            },\r\n            child: Text(\"改变名称\"),\r\n          )\r\n```\r\n\r\n\r\n\r\n## 多个moudle情况\r\n\r\n### ScopedModel嵌套\r\n\r\n首先声明多个**moudle**：\r\n\r\n```dart\r\nclass UserInfoByScoped extends Model {\r\n  String username;\r\n\r\n  UserInfoByScoped.empty() {\r\n    username = \"Jenson\";\r\n  }\r\n\r\n  void update(String name) {\r\n    username = name;\r\n    notifyListeners();\r\n  }\r\n}\r\n\r\nclass Card extends Model {\r\n  List<String> goods = [];\r\n\r\n  void add(String good) {\r\n    goods.add(good);\r\n    notifyListeners();\r\n  }\r\n\r\n  void remove(String good) {\r\n    goods.remove(good);\r\n    notifyListeners();\r\n  }\r\n}\r\n```\r\n\r\n其次为了让后裔能获取多个moudle，但是每个**ScopedModel**只支持一个moudle。\r\n\r\n所以可以在root widget嵌套多个**ScopedModel**：\r\n\r\n```dart\r\nWidget useScoped() {\r\n  return ScopedModel<UserInfoByScoped>(\r\n      model: UserInfoByScoped.empty(),\r\n      child: ScopedModel<Card>(\r\n          model: Card(),\r\n          child: MaterialApp(\r\n            home: ScopedHomePage(),\r\n          )));\r\n}\r\n```\r\n\r\n使用时仍然使用`ScopedModelDescendant`。\r\n\r\n但是`ScopedModelDescendant`也只支持获取一个moudle，\r\n\r\n如果一个Widget使用到多个moudle，\r\n\r\n可以使用`ScopedModel.of<Card>(context)`和`ScopedModel.of<UserInfoByScoped>`分别获取需要的moudle。\r\n\r\n最后在Widget处组装：\r\n\r\n```dart\r\nvar cards = ScopedModel.of<Card>(context);\r\nvar name =ScopedModel.of<UserInfoByScoped>(context).username;\r\nText(\"$name的购物车清单：${cards.toString()}\");\r\n```\r\n\r\n### 多moudle混入方式\r\n\r\n多moudle混入方式就是根据不同的业务声明不同的**mixin**类：\r\n\r\n```dart\r\nmixin UserInfoByScoped on Model {\r\n  String username = \"Jenson\";\r\n\r\n  void update(String name) {\r\n    username = name;\r\n    notifyListeners();\r\n  }\r\n}\r\n\r\nmixin Card on Model {\r\n  List<String> goods = [];\r\n\r\n  void add(String good) {\r\n    goods.add(good);\r\n    notifyListeners();\r\n  }\r\n\r\n  void remove(String good) {\r\n    goods.remove(good);\r\n    notifyListeners();\r\n  }\r\n}\r\n```\r\n\r\n**注意这里的业务moudle一定要使用`mixin`修饰而不是`class`。**\r\n\r\n**如果使用`class`修饰，那么就需要`class Card  extends Model`。**\r\n\r\n**但是当**AppMoudle**在`mixin Card`时会出现如下异常：**\r\n\r\n**The class 'xxx' can't be used as a mixin because it extends a class other than Object.**\r\n\r\n\r\n\r\n最后声明一个全局的**AppMoudle**，继承moudle且混入其他业务moudle：\r\n\r\n```dart\r\nclass AppMoudle extends Model with Card, UserInfoByScoped {}\r\n\r\n```\r\n\r\n在root widget使用：\r\n\r\n```dart\r\nWidget useScoped() {\r\n  return ScopedModel<AppMoudle>(\r\n      model: AppMoudle(),\r\n      child: MaterialApp(\r\n        home: ScopedHomePage(),\r\n      ));\r\n}\r\n```\r\n\r\n在后裔widget获取：\r\n\r\n```dart\r\nColumn(\r\n        children: [\r\n          ScopedModelDescendant<AppMoudle>(builder: (context, child, model) {\r\n            return Text(model.username);\r\n          }),\r\n          RaisedButton(\r\n            onPressed: () {\r\n              var name = \"Jenson \" + DateTime.now().toString();\r\n              ScopedModel.of<AppMoudle>(context).update(name);\r\n            },\r\n            child: Text(\"改变名称\"),\r\n          ),\r\n          ScopedModelDescendant<AppMoudle>(builder: (context, child, model) {\r\n            return Text(model.goods.toString());\r\n          }),\r\n          RaisedButton(\r\n            onPressed: () {\r\n              var name = \"Jenson \" + DateTime.now().toString();\r\n              ScopedModel.of<AppMoudle>(context).add(name);\r\n            },\r\n            child: Text(\"改变名称\"),\r\n          ),\r\n        ],\r\n      )\r\n```\r\n\r\n# 0x02 分析\r\n\r\n\r\n\r\n## Model源码\r\n\r\n`Model`继承`Listenable`并实现了`addListener`，`removeListener`。\r\n\r\n当我们数据有更新时调用`notifyListeners`通知监听的Widget刷新。\r\n\r\n这里的Widget是指`AnimatedBuilder`。\r\n\r\n这在`ScopedModel`中有体现。\r\n\r\n看下Model源码：\r\n\r\n```dart\r\nabstract class Model extends Listenable {\r\n  final Set<VoidCallback> _listeners = Set<VoidCallback>();\r\n  int _version = 0;\r\n  int _microtaskVersion = 0;\r\n\r\n  \/\/\/ [listener] will be invoked when the model changes.\r\n  @override\r\n  void addListener(VoidCallback listener) {\r\n    _listeners.add(listener);\r\n  }\r\n\r\n  \/\/\/ [listener] will no longer be invoked when the model changes.\r\n  @override\r\n  void removeListener(VoidCallback listener) {\r\n    _listeners.remove(listener);\r\n  }\r\n\r\n  \/\/\/ Returns the number of listeners listening to this model.\r\n  int get listenerCount => _listeners.length;\r\n\r\n  \/\/\/ Should be called only by [Model] when the model has changed.\r\n  @protected\r\n  void notifyListeners() {\r\n    \/\/ We schedule a microtask to debounce multiple changes that can occur\r\n    \/\/ all at once.\r\n    if (_microtaskVersion == _version) {\r\n      _microtaskVersion++;\r\n      scheduleMicrotask(() {\r\n        _version++;\r\n        _microtaskVersion = _version;\r\n\r\n        \/\/ Convert the Set to a List before executing each listener. This\r\n        \/\/ prevents errors that can arise if a listener removes itself during\r\n        \/\/ invocation!\r\n        _listeners.toList().forEach((VoidCallback listener) => listener());\r\n      });\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n## ScopedModel源码\r\n\r\n`ScopedModel`的`build`方法中使用了`AnimatedBuilder`。\r\n\r\n```dart\r\nclass ScopedModel<T extends Model> extends StatelessWidget {\r\n  \/\/\/ The [Model] to provide to [child] and its descendants.\r\n  final T model;\r\n\r\n  \/\/\/ The [Widget] the [model] will be available to.\r\n  final Widget child;\r\n\r\n  ScopedModel({@required this.model, @required this.child})\r\n      : assert(model != null),\r\n        assert(child != null);\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return AnimatedBuilder(\r\n      animation: model,\r\n      builder: (context, _) => _InheritedModel<T>(model: model, child: child),\r\n    );\r\n  }\r\n  static T of<T extends Model>(\r\n    BuildContext context, {\r\n    bool rebuildOnChange = false,\r\n  }) {\r\n    final Type type = _type<_InheritedModel<T>>();\r\n\r\n    Widget widget = rebuildOnChange\r\n        ? context.inheritFromWidgetOfExactType(type)\r\n        : context.ancestorWidgetOfExactType(type);\r\n\r\n    if (widget == null) {\r\n      throw new ScopedModelError();\r\n    } else {\r\n      return (widget as _InheritedModel<T>).model;\r\n    }\r\n  }\r\n\r\n  static Type _type<T>() => T;\r\n}\r\n```\r\n\r\n`ScopedModel`并没有在自身方法中调用`Model`的`addListener`和`removeListener`。\r\n\r\n而是交给了`AnimatedBuilder`去处理，这时我们需要进去看看它是如何处理的。\r\n\r\n## AnimatedBuilder源码\r\n\r\n`AnimatedBuilder`很简单，只是在`build`方法中直接调用了外部实现的`builder`方法：\r\n\r\n```dart\r\nclass AnimatedBuilder extends AnimatedWidget {\r\n  const AnimatedBuilder({\r\n    Key key,\r\n    @required Listenable animation,\r\n    @required this.builder,\r\n    this.child,\r\n  }) : assert(animation != null),\r\n       assert(builder != null),\r\n       super(key: key, listenable: animation);\r\n\r\n  \/\/\/ Called every time the animation changes value.\r\n  final TransitionBuilder builder;\r\n  final Widget child;\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return builder(context, child);\r\n  }\r\n}\r\n```\r\n\r\n但是我们发现实参`model`在这里以`animation`名称继续向父类传递。\r\n\r\n那我们只能从其父类入手：\r\n\r\n```dart\r\nabstract class AnimatedWidget extends StatefulWidget {\r\n  \/\/\/ Creates a widget that rebuilds when the given listenable changes.\r\n  \/\/\/\r\n  \/\/\/ The [listenable] argument is required.\r\n  const AnimatedWidget({\r\n    Key key,\r\n    @required this.listenable,\r\n  }) : assert(listenable != null),\r\n       super(key: key);\r\n\r\n  \/\/\/ The [Listenable] to which this widget is listening.\r\n  \/\/\/\r\n  \/\/\/ Commonly an [Animation] or a [ChangeNotifier].\r\n  final Listenable listenable;\r\n\r\n  \/\/\/ Override this method to build widgets that depend on the state of the\r\n  \/\/\/ listenable (e.g., the current value of the animation).\r\n  @protected\r\n  Widget build(BuildContext context);\r\n\r\n  \/\/\/ Subclasses typically do not override this method.\r\n  @override\r\n  _AnimatedState createState() => _AnimatedState();\r\n\r\n  @override\r\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\r\n    super.debugFillProperties(properties);\r\n    properties.add(DiagnosticsProperty<Listenable>('animation', listenable));\r\n  }\r\n}\r\n\r\nclass _AnimatedState extends State<AnimatedWidget> {\r\n  @override\r\n  void initState() {\r\n    super.initState();\r\n    widget.listenable.addListener(_handleChange);\r\n  }\r\n\r\n  @override\r\n  void didUpdateWidget(AnimatedWidget oldWidget) {\r\n    super.didUpdateWidget(oldWidget);\r\n    if (widget.listenable != oldWidget.listenable) {\r\n      oldWidget.listenable.removeListener(_handleChange);\r\n      widget.listenable.addListener(_handleChange);\r\n    }\r\n  }\r\n\r\n  @override\r\n  void dispose() {\r\n    widget.listenable.removeListener(_handleChange);\r\n    super.dispose();\r\n  }\r\n\r\n  void _handleChange() {\r\n    setState(() {\r\n      \/\/ The listenable's state is our build state, and it changed already.\r\n    });\r\n  }\r\n\r\n  @override\r\n  Widget build(BuildContext context) => widget.build(context);\r\n}\r\n```\r\n\r\n由于`AnimatedWidget`是`StatefulWidget`，\r\n\r\n所以主要看`_AnimatedState`即可，\r\n\r\n我们发现在`initState`方法中调用了`addListener`,\r\n\r\n在`dispose`调用了`removeListener`，\r\n\r\n传入的函数参数是`_handleChange`：\r\n\r\n```\r\n  void _handleChange() {\r\n    setState(() {\r\n      \/\/ The listenable's state is our build state, and it changed already.\r\n    });\r\n  }\r\n```\r\n\r\n而这只是简单地调用了`setState`，意图rebuilt。\r\n\r\n目前为止的流程是使用`ScopedModel`时，会调用`addListener`添加事件监听。\r\n\r\n当我们调用`ScopedModel.of<AppMoudle>(context).update(name);`时，\r\n\r\n调用了`notifyListeners`，遍历出`VoidCallback`，这里是`_handleChange`调用函数。\r\n\r\n调用`setState`后标记当前Element为dirty。\r\n\r\n当`BuildOwner`遍历`_dirtyElements`执行`rebuild`时，调用到`performRebuild`：\r\n\r\n```dart\r\n @override\r\n  void performRebuild() {\r\n    if (!kReleaseMode && debugProfileBuildsEnabled)\r\n      Timeline.startSync('${widget.runtimeType}',  arguments: timelineWhitelistArguments);\r\n\r\n    assert(_debugSetAllowIgnoredCallsToMarkNeedsBuild(true));\r\n    Widget built;\r\n    try {\r\n      assert(() {\r\n        _debugDoingBuild = true;\r\n        return true;\r\n      }());\r\n      built = build();\r\n      assert(() {\r\n        _debugDoingBuild = false;\r\n        return true;\r\n      }());\r\n      debugWidgetBuilderValue(widget, built);\r\n    } catch (e, stack) {\r\n      _debugDoingBuild = false;\r\n      built = ErrorWidget.builder(\r\n        _debugReportException(\r\n          ErrorDescription('building $this'),\r\n          e,\r\n          stack,\r\n          informationCollector: () sync* {\r\n            yield DiagnosticsDebugCreator(DebugCreator(this));\r\n          },\r\n        ),\r\n      );\r\n    } finally {\r\n      \/\/ We delay marking the element as clean until after calling build() so\r\n      \/\/ that attempts to markNeedsBuild() during build() will be ignored.\r\n      _dirty = false;\r\n      assert(_debugSetAllowIgnoredCallsToMarkNeedsBuild(false));\r\n    }\r\n    try {\r\n      _child = updateChild(_child, built, slot);\r\n      assert(_child != null);\r\n    } catch (e, stack) {\r\n      built = ErrorWidget.builder(\r\n        _debugReportException(\r\n          ErrorDescription('building $this'),\r\n          e,\r\n          stack,\r\n          informationCollector: () sync* {\r\n            yield DiagnosticsDebugCreator(DebugCreator(this));\r\n          },\r\n        ),\r\n      );\r\n      _child = updateChild(null, built, slot);\r\n    }\r\n\r\n    if (!kReleaseMode && debugProfileBuildsEnabled)\r\n      Timeline.finishSync();\r\n  }\r\n```\r\n\r\n其中调用`built = build();`这里的`build`最终回调我们在`ScopedModel`中为 \r\n\r\n`AnimatedBuilder`实现的`builder`函数，此时`built`是`_InheritedModel`类型实例。\r\n\r\n接下来执行`updateChild`，由于是rebuild，所以`child!=null`。会执行下面的else if代码：\r\n\r\n```dart\r\n      if (hasSameSuperclass && child.widget == newWidget) {\r\n        if (child.slot != newSlot)\r\n          updateSlotForChild(child, newSlot);\r\n        newChild = child;\r\n      } else if (hasSameSuperclass && Widget.canUpdate(child.widget, newWidget)) {\r\n        if (child.slot != newSlot)\r\n          updateSlotForChild(child, newSlot);\r\n        child.update(newWidget);\r\n        assert(child.widget == newWidget);\r\n        assert(() {\r\n          child.owner._debugElementWasRebuilt(child);\r\n          return true;\r\n        }());\r\n        newChild = child;\r\n      } else {\r\n        deactivateChild(child);\r\n        assert(child._parent == null);\r\n        newChild = inflateWidget(newWidget, newSlot);\r\n      }\r\n```\r\n\r\n在调用` child.update(newWidget);`时，这里的`child`其实是`InheritedElement`，\r\n\r\n所以它的`update`实现为：\r\n\r\n```dart\r\n  @override\r\n  void update(ProxyWidget newWidget) {\r\n    final ProxyWidget oldWidget = widget;\r\n    assert(widget != null);\r\n    assert(widget != newWidget);\r\n    super.update(newWidget);\r\n    assert(widget == newWidget);\r\n    updated(oldWidget);\r\n    _dirty = true;\r\n    rebuild();\r\n  }\r\n```\r\n\r\n这里的流程很简单\r\n\r\n通过`super.update(newWidget);`把当前Element的`_widget`设置为`newWidget`。\r\n\r\n然后通过`updated(oldWidget);`调用`notifyClients`告知所有通过`ScopedModel.of`方式获取数据的Widget该刷新了。\r\n\r\n通过`ScopedModel.of`方式获取数据，除了我们直接使用这种方式，那么就剩下`ScopedModelDescendant`了。\r\n\r\n## ScopedModelDescendant源码\r\n\r\nScopedModelDescendant只是帮我们获取到了数据并通过`builder`函数返回给我们`Model`\r\n\r\n```dart\r\nclass ScopedModelDescendant<T extends Model> extends StatelessWidget {\r\n  \/\/\/ Called whenever the [Model] changes.\r\n  final ScopedModelDescendantBuilder<T> builder;\r\n\r\n  \/\/\/ An optional constant child that does not depend on the model.  This will\r\n  \/\/\/ be passed as the child of [builder].\r\n  final Widget child;\r\n\r\n  \/\/\/ An optional constant that determines whether the\r\n  final bool rebuildOnChange;\r\n\r\n  \/\/\/ Constructor.\r\n  ScopedModelDescendant({\r\n    @required this.builder,\r\n    this.child,\r\n    this.rebuildOnChange = true,\r\n  });\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return builder(\r\n      context,\r\n      child,\r\n      ScopedModel.of<T>(context, rebuildOnChange: rebuildOnChange),\r\n    );\r\n  }\r\n}\r\n```\r\n\r\n# 0x03 结尾\r\n\r\nscoped_model和使用起来和Provider基本一样。\r\n\r\n但是scoped_model实现精简，导致不能像Provider那样精细化控制某一个类乃至某一属性更新才刷新Widget。\r\n\r\n像上面实现的那样，当Card更新时，由于scoped_model实现，UserInfoByScoped相关Widget也会刷新，造成性能问题。"
  },
  {
    "title" : "为何Flutter状态管理框架只能用在root widget",
    "created_time" : "2020-07-02 09:47:54",
    "body" : "# 0x00 前言\r\n\r\n在试用状态框架时发现一个问题就是：\r\n\r\n**状态管理框架的xxProvider Widget只能用在Root Widget。**\r\n\r\n**用在HomePage时，其他Page获取不到。**\r\n\r\n现在就看看是什么原因造成的。\r\n\r\n# 0x01 分析\r\n\r\n\r\n\r\nApp启动时的Root Widget一般我们使用`MaterialApp`。\r\n\r\n所以分析就从这个Widget开始入手。\r\n\r\n## MaterialApp\r\n\r\nMaterialApp一般会设置home属性：\r\n\r\n```dart\r\nMaterialApp(\r\n            home: ScopedHomePage(),\r\n          )\r\n```\r\n\r\n它是一个`StatefulWidget`，\r\n\r\n在其对应的`_MaterialAppState`的`build`方法实现为：\r\n\r\n```dart\r\n @override\r\n  Widget build(BuildContext context) {\r\n    Widget result = HeroControllerScope(\r\n      controller: _heroController,\r\n      child: WidgetsApp(\r\n        key: GlobalObjectKey(this),\r\n        navigatorKey: widget.navigatorKey,\r\n        navigatorObservers: widget.navigatorObservers,\r\n        pageRouteBuilder: <T>(RouteSettings settings, WidgetBuilder builder) {\r\n          return MaterialPageRoute<T>(settings: settings, builder: builder);\r\n        },\r\n        home: widget.home,\r\n        routes: widget.routes,\r\n        initialRoute: widget.initialRoute,\r\n        onGenerateRoute: widget.onGenerateRoute,\r\n        onGenerateInitialRoutes: widget.onGenerateInitialRoutes,\r\n        onUnknownRoute: widget.onUnknownRoute,\r\n        builder: (BuildContext context, Widget child) {\r\n          \/\/ Use a light theme, dark theme, or fallback theme.\r\n          final ThemeMode mode = widget.themeMode ?? ThemeMode.system;\r\n          ThemeData theme;\r\n          if (widget.darkTheme != null) {\r\n            final ui.Brightness platformBrightness = MediaQuery.platformBrightnessOf(context);\r\n            if (mode == ThemeMode.dark ||\r\n              (mode == ThemeMode.system && platformBrightness == ui.Brightness.dark)) {\r\n              theme = widget.darkTheme;\r\n            }\r\n          }\r\n          theme ??= widget.theme ?? ThemeData.fallback();\r\n\r\n          return AnimatedTheme(\r\n            data: theme,\r\n            isMaterialAppTheme: true,\r\n            child: widget.builder != null\r\n              ? Builder(\r\n                  builder: (BuildContext context) {\r\n                    \/\/ Why are we surrounding a builder with a builder?\r\n                    \/\/\r\n                    \/\/ The widget.builder may contain code that invokes\r\n                    \/\/ Theme.of(), which should return the theme we selected\r\n                    \/\/ above in AnimatedTheme. However, if we invoke\r\n                    \/\/ widget.builder() directly as the child of AnimatedTheme\r\n                    \/\/ then there is no Context separating them, and the\r\n                    \/\/ widget.builder() will not find the theme. Therefore, we\r\n                    \/\/ surround widget.builder with yet another builder so that\r\n                    \/\/ a context separates them and Theme.of() correctly\r\n                    \/\/ resolves to the theme we passed to AnimatedTheme.\r\n                    return widget.builder(context, child);\r\n                  },\r\n                )\r\n              : child,\r\n          );\r\n        },\r\n        title: widget.title,\r\n        onGenerateTitle: widget.onGenerateTitle,\r\n        textStyle: _errorTextStyle,\r\n        \/\/ The color property is always pulled from the light theme, even if dark\r\n        \/\/ mode is activated. This was done to simplify the technical details\r\n        \/\/ of switching themes and it was deemed acceptable because this color\r\n        \/\/ property is only used on old Android OSes to color the app bar in\r\n        \/\/ Android's switcher UI.\r\n        \/\/\r\n        \/\/ blue is the primary color of the default theme\r\n        color: widget.color ?? widget.theme?.primaryColor ?? Colors.blue,\r\n        locale: widget.locale,\r\n        localizationsDelegates: _localizationsDelegates,\r\n        localeResolutionCallback: widget.localeResolutionCallback,\r\n        localeListResolutionCallback: widget.localeListResolutionCallback,\r\n        supportedLocales: widget.supportedLocales,\r\n        showPerformanceOverlay: widget.showPerformanceOverlay,\r\n        checkerboardRasterCacheImages: widget.checkerboardRasterCacheImages,\r\n        checkerboardOffscreenLayers: widget.checkerboardOffscreenLayers,\r\n        showSemanticsDebugger: widget.showSemanticsDebugger,\r\n        debugShowCheckedModeBanner: widget.debugShowCheckedModeBanner,\r\n        inspectorSelectButtonBuilder: (BuildContext context, VoidCallback onPressed) {\r\n          return FloatingActionButton(\r\n            child: const Icon(Icons.search),\r\n            onPressed: onPressed,\r\n            mini: true,\r\n          );\r\n        },\r\n        shortcuts: widget.shortcuts,\r\n        actions: widget.actions,\r\n      ),\r\n    );\r\n\r\n    assert(() {\r\n      if (widget.debugShowMaterialGrid) {\r\n        result = GridPaper(\r\n          color: const Color(0xE0F9BBE0),\r\n          interval: 8.0,\r\n          divisions: 2,\r\n          subdivisions: 1,\r\n          child: result,\r\n        );\r\n      }\r\n      return true;\r\n    }());\r\n\r\n    return ScrollConfiguration(\r\n      behavior: _MaterialScrollBehavior(),\r\n      child: result,\r\n    );\r\n  }\r\n```\r\n\r\n可以看到`HeroControllerScope`的`child`设置了`WidgetsApp`，\r\n\r\n在外层的`home`属性被设置到了`WidgetsApp`。\r\n\r\n\r\n\r\n## WidgetsApp\r\n\r\n`WidgetsApp`也是一个`StatefulWidget`，\r\n\r\n在其对应的`_WidgetsAppState`的`build`方法实现为：\r\n\r\n```dart\r\n@override\r\n  Widget build(BuildContext context) {\r\n    Widget navigator;\r\n    if (_navigator != null) {\r\n      navigator = Navigator(\r\n        key: _navigator,\r\n        \/\/ If window.defaultRouteName isn't '\/', we should assume it was set\r\n        \/\/ intentionally via `setInitialRoute`, and should override whatever\r\n        \/\/ is in [widget.initialRoute].\r\n        initialRoute: WidgetsBinding.instance.window.defaultRouteName != Navigator.defaultRouteName\r\n            ? WidgetsBinding.instance.window.defaultRouteName\r\n            : widget.initialRoute ?? WidgetsBinding.instance.window.defaultRouteName,\r\n        onGenerateRoute: _onGenerateRoute,\r\n        onGenerateInitialRoutes: widget.onGenerateInitialRoutes == null\r\n          ? Navigator.defaultGenerateInitialRoutes\r\n          : (NavigatorState navigator, String initialRouteName) {\r\n            return widget.onGenerateInitialRoutes(initialRouteName);\r\n          },\r\n        onUnknownRoute: _onUnknownRoute,\r\n        observers: widget.navigatorObservers,\r\n      );\r\n    }\r\n\r\n    Widget result;\r\n    if (widget.builder != null) {\r\n      result = Builder(\r\n        builder: (BuildContext context) {\r\n          return widget.builder(context, navigator);\r\n        },\r\n      );\r\n    } else {\r\n      assert(navigator != null);\r\n      result = navigator;\r\n    }\r\n\r\n    if (widget.textStyle != null) {\r\n      result = DefaultTextStyle(\r\n        style: widget.textStyle,\r\n        child: result,\r\n      );\r\n    }\r\n\r\n    PerformanceOverlay performanceOverlay;\r\n    \/\/ We need to push a performance overlay if any of the display or checkerboarding\r\n    \/\/ options are set.\r\n    if (widget.showPerformanceOverlay || WidgetsApp.showPerformanceOverlayOverride) {\r\n      performanceOverlay = PerformanceOverlay.allEnabled(\r\n        checkerboardRasterCacheImages: widget.checkerboardRasterCacheImages,\r\n        checkerboardOffscreenLayers: widget.checkerboardOffscreenLayers,\r\n      );\r\n    } else if (widget.checkerboardRasterCacheImages || widget.checkerboardOffscreenLayers) {\r\n      performanceOverlay = PerformanceOverlay(\r\n        checkerboardRasterCacheImages: widget.checkerboardRasterCacheImages,\r\n        checkerboardOffscreenLayers: widget.checkerboardOffscreenLayers,\r\n      );\r\n    }\r\n    if (performanceOverlay != null) {\r\n      result = Stack(\r\n        children: <Widget>[\r\n          result,\r\n          Positioned(top: 0.0, left: 0.0, right: 0.0, child: performanceOverlay),\r\n        ],\r\n      );\r\n    }\r\n\r\n    if (widget.showSemanticsDebugger) {\r\n      result = SemanticsDebugger(\r\n        child: result,\r\n      );\r\n    }\r\n\r\n    assert(() {\r\n      if (widget.debugShowWidgetInspector || WidgetsApp.debugShowWidgetInspectorOverride) {\r\n        result = WidgetInspector(\r\n          child: result,\r\n          selectButtonBuilder: widget.inspectorSelectButtonBuilder,\r\n        );\r\n      }\r\n      if (widget.debugShowCheckedModeBanner && WidgetsApp.debugAllowBannerOverride) {\r\n        result = CheckedModeBanner(\r\n          child: result,\r\n        );\r\n      }\r\n      return true;\r\n    }());\r\n\r\n    Widget title;\r\n    if (widget.onGenerateTitle != null) {\r\n      title = Builder(\r\n        \/\/ This Builder exists to provide a context below the Localizations widget.\r\n        \/\/ The onGenerateTitle callback can refer to Localizations via its context\r\n        \/\/ parameter.\r\n        builder: (BuildContext context) {\r\n          final String title = widget.onGenerateTitle(context);\r\n          assert(title != null, 'onGenerateTitle must return a non-null String');\r\n          return Title(\r\n            title: title,\r\n            color: widget.color,\r\n            child: result,\r\n          );\r\n        },\r\n      );\r\n    } else {\r\n      title = Title(\r\n        title: widget.title,\r\n        color: widget.color,\r\n        child: result,\r\n      );\r\n    }\r\n\r\n    final Locale appLocale = widget.locale != null\r\n      ? _resolveLocales(<Locale>[widget.locale], widget.supportedLocales)\r\n      : _locale;\r\n\r\n    assert(_debugCheckLocalizations(appLocale));\r\n    return Shortcuts(\r\n      shortcuts: widget.shortcuts ?? WidgetsApp.defaultShortcuts,\r\n      debugLabel: '<Default WidgetsApp Shortcuts>',\r\n      child: Actions(\r\n        actions: widget.actions ?? WidgetsApp.defaultActions,\r\n        child: FocusTraversalGroup(\r\n          policy: ReadingOrderTraversalPolicy(),\r\n          child: _MediaQueryFromWindow(\r\n            child: Localizations(\r\n              locale: appLocale,\r\n              delegates: _localizationsDelegates.toList(),\r\n              child: title,\r\n            ),\r\n          ),\r\n        ),\r\n      ),\r\n    );\r\n  }\r\n```\r\n\r\n`build`方法一开始就判断了`_navigator`是否为空，如果不为空则创建一个`Navigator`控件。\r\n\r\n那么`_navigator`到底为空吗？\r\n\r\n在`initState`中调用了`_updateNavigator`方法：\r\n\r\n```dart\r\n  void _updateNavigator() {\r\n    _navigator = widget.navigatorKey ?? GlobalObjectKey<NavigatorState>(this);\r\n  }\r\n```\r\n\r\n看来`_navigator`是有值的。\r\n\r\n那么就会执行：\r\n\r\n```dart\r\n      navigator = Navigator(\r\n        key: _navigator,\r\n        \/\/ If window.defaultRouteName isn't '\/', we should assume it was set\r\n        \/\/ intentionally via `setInitialRoute`, and should override whatever\r\n        \/\/ is in [widget.initialRoute].\r\n        initialRoute: WidgetsBinding.instance.window.defaultRouteName != Navigator.defaultRouteName\r\n            ? WidgetsBinding.instance.window.defaultRouteName\r\n            : widget.initialRoute ?? WidgetsBinding.instance.window.defaultRouteName,\r\n        onGenerateRoute: _onGenerateRoute,\r\n        onGenerateInitialRoutes: widget.onGenerateInitialRoutes == null\r\n          ? Navigator.defaultGenerateInitialRoutes\r\n          : (NavigatorState navigator, String initialRouteName) {\r\n            return widget.onGenerateInitialRoutes(initialRouteName);\r\n          },\r\n        onUnknownRoute: _onUnknownRoute,\r\n        observers: widget.navigatorObservers,\r\n      );\r\n```\r\n\r\n在这里有一个函数参数`onGenerateRoute`，给它的赋值`_onGenerateRoute`实现为：\r\n\r\n```dart\r\nRoute<dynamic> _onGenerateRoute(RouteSettings settings) {\r\n    final String name = settings.name;\r\n    final WidgetBuilder pageContentBuilder = name == Navigator.defaultRouteName && widget.home != null\r\n        ? (BuildContext context) => widget.home\r\n        : widget.routes[name];\r\n\r\n    if (pageContentBuilder != null) {\r\n      assert(widget.pageRouteBuilder != null,\r\n        'The default onGenerateRoute handler for WidgetsApp must have a '\r\n        'pageRouteBuilder set if the home or routes properties are set.');\r\n      final Route<dynamic> route = widget.pageRouteBuilder<dynamic>(\r\n        settings,\r\n        pageContentBuilder,\r\n      );\r\n      assert(route != null,\r\n        'The pageRouteBuilder for WidgetsApp must return a valid non-null Route.');\r\n      return route;\r\n    }\r\n    if (widget.onGenerateRoute != null)\r\n      return widget.onGenerateRoute(settings);\r\n    return null;\r\n  }\r\n```\r\n\r\n可以看到如果`name == Navigator.defaultRouteName && widget.home != null`成立，\r\n\r\n返回`(BuildContext context) => widget.home`赋值给`pageContentBuilder`。\r\n\r\n紧接着调用了`widget.pageRouteBuilder`，把得到的`pageContentBuilder`作为参数传入返回`route`。\r\n\r\n那么这个`widget.pageRouteBuilder`是如何实现的？\r\n\r\n看一下`MaterialApp`状态的`build`中有实现：\r\n\r\n```dart\r\npageRouteBuilder: <T>(RouteSettings settings, WidgetBuilder builder) {\r\n          return MaterialPageRoute<T>(settings: settings, builder: builder);\r\n        }\r\n```\r\n\r\n可以看到我们最初的`home`属性经过一些列操作被包装到了`MaterialPageRoute`。\r\n\r\n这个类熟悉吗？\r\n\r\n我们跳转打开新页面时经常使用的那句：\r\n\r\n```dart\r\nNavigator.of(context)\r\n                .push(MaterialPageRoute(builder: (_) => ScopedSecondPage()));\r\n```\r\n\r\n这`home`设置的页面和我们直接跳转是否有所不同，还不能直接下结论。\r\n\r\n回过头还要继续往下看。\r\n\r\n\r\n\r\n## Navigator\r\n\r\n它对应的`NavigatorState`。\r\n\r\n在`initState`有这样一段实现：\r\n\r\n```dart\r\nString initialRoute = widget.initialRoute;\r\n    if (widget.pages.isNotEmpty) {\r\n      _history.addAll(\r\n        widget.pages.map((Page<dynamic> page) => _RouteEntry(\r\n          page.createRoute(context),\r\n          initialState: _RouteLifecycle.add,\r\n        ))\r\n      );\r\n    } else {\r\n      \/\/ If there is no page provided, we will need to provide default route\r\n      \/\/ to initialize the navigator.\r\n      initialRoute = initialRoute ?? Navigator.defaultRouteName;\r\n    }\r\n    if (initialRoute != null) {\r\n      _history.addAll(\r\n        widget.onGenerateInitialRoutes(\r\n          this,\r\n          widget.initialRoute ?? Navigator.defaultRouteName\r\n        ).map((Route<dynamic> route) =>\r\n          _RouteEntry(\r\n            route,\r\n            initialState: _RouteLifecycle.add,\r\n          ),\r\n        ),\r\n      );\r\n    }\r\n```\r\n\r\n`initialRoute`在`WidgetsApp`中已经赋值了，所以这里不会为null。\r\n\r\n那么自然会执行`_history.addAll`，\r\n\r\n首先`widget.onGenerateInitialRoutes`生成`List<Route>`，通过`map`转成`_RouteEntry`。\r\n\r\n然后紧接着执行`_flushHistoryUpdates`方法，实现为：\r\n\r\n```dart\r\nvoid _flushHistoryUpdates({bool rearrangeOverlay = true}) {\r\n    assert(_debugLocked && !_debugUpdatingPage);\r\n    \/\/ Clean up the list, sending updates to the routes that changed. Notably,\r\n    \/\/ we don't send the didChangePrevious\/didChangeNext updates to those that\r\n    \/\/ did not change at this point, because we're not yet sure exactly what the\r\n    \/\/ routes will be at the end of the day (some might get disposed).\r\n    int index = _history.length - 1;\r\n    _RouteEntry next;\r\n    _RouteEntry entry = _history[index];\r\n    _RouteEntry previous = index > 0 ? _history[index - 1] : null;\r\n    bool canRemoveOrAdd = false; \/\/ Whether there is a fully opaque route on top to silently remove or add route underneath.\r\n    Route<dynamic> poppedRoute; \/\/ The route that should trigger didPopNext on the top active route.\r\n    bool seenTopActiveRoute = false; \/\/ Whether we've seen the route that would get didPopNext.\r\n    final List<_RouteEntry> toBeDisposed = <_RouteEntry>[];\r\n    while (index >= 0) {\r\n      switch (entry.currentState) {\r\n        case _RouteLifecycle.add:\r\n          assert(rearrangeOverlay);\r\n          entry.handleAdd(\r\n            navigator: this,\r\n            previousPresent: _getRouteBefore(index - 1, _RouteEntry.isPresentPredicate)?.route,\r\n          );\r\n          assert(entry.currentState == _RouteLifecycle.adding);\r\n          continue;\r\n        case _RouteLifecycle.adding:\r\n          if (canRemoveOrAdd || next == null) {\r\n            entry.didAdd(\r\n              navigator: this,\r\n              isNewFirst: next == null\r\n            );\r\n            assert(entry.currentState == _RouteLifecycle.idle);\r\n            continue;\r\n          }\r\n          break;\r\n        case _RouteLifecycle.push:\r\n        case _RouteLifecycle.pushReplace:\r\n        case _RouteLifecycle.replace:\r\n          assert(rearrangeOverlay);\r\n          entry.handlePush(\r\n            navigator: this,\r\n            previous: previous?.route,\r\n            previousPresent: _getRouteBefore(index - 1, _RouteEntry.isPresentPredicate)?.route,\r\n            isNewFirst: next == null,\r\n          );\r\n          assert(entry.currentState != _RouteLifecycle.push);\r\n          assert(entry.currentState != _RouteLifecycle.pushReplace);\r\n          assert(entry.currentState != _RouteLifecycle.replace);\r\n          if (entry.currentState == _RouteLifecycle.idle) {\r\n            continue;\r\n          }\r\n          break;\r\n        case _RouteLifecycle.pushing: \/\/ Will exit this state when animation completes.\r\n          if (!seenTopActiveRoute && poppedRoute != null)\r\n            entry.handleDidPopNext(poppedRoute);\r\n          seenTopActiveRoute = true;\r\n          break;\r\n        case _RouteLifecycle.idle:\r\n          if (!seenTopActiveRoute && poppedRoute != null)\r\n            entry.handleDidPopNext(poppedRoute);\r\n          seenTopActiveRoute = true;\r\n          \/\/ This route is idle, so we are allowed to remove subsequent (earlier)\r\n          \/\/ routes that are waiting to be removed silently:\r\n          canRemoveOrAdd = true;\r\n          break;\r\n        case _RouteLifecycle.pop:\r\n          if (!seenTopActiveRoute) {\r\n            if (poppedRoute != null)\r\n              entry.handleDidPopNext(poppedRoute);\r\n            poppedRoute = entry.route;\r\n          }\r\n          entry.handlePop(\r\n            navigator: this,\r\n            previousPresent: _getRouteBefore(index, _RouteEntry.willBePresentPredicate)?.route,\r\n          );\r\n          assert(entry.currentState == _RouteLifecycle.popping);\r\n          canRemoveOrAdd = true;\r\n          break;\r\n        case _RouteLifecycle.popping:\r\n          \/\/ Will exit this state when animation completes.\r\n          break;\r\n        case _RouteLifecycle.remove:\r\n          if (!seenTopActiveRoute) {\r\n            if (poppedRoute != null)\r\n              entry.route.didPopNext(poppedRoute);\r\n            poppedRoute = null;\r\n          }\r\n          entry.handleRemoval(\r\n            navigator: this,\r\n            previousPresent: _getRouteBefore(index, _RouteEntry.willBePresentPredicate)?.route,\r\n          );\r\n          assert(entry.currentState == _RouteLifecycle.removing);\r\n          continue;\r\n        case _RouteLifecycle.removing:\r\n          if (!canRemoveOrAdd && next != null) {\r\n            \/\/ We aren't allowed to remove this route yet.\r\n            break;\r\n          }\r\n          entry.currentState = _RouteLifecycle.dispose;\r\n          continue;\r\n        case _RouteLifecycle.dispose:\r\n          \/\/ Delay disposal until didChangeNext\/didChangePrevious have been sent.\r\n          toBeDisposed.add(_history.removeAt(index));\r\n          entry = next;\r\n          break;\r\n        case _RouteLifecycle.disposed:\r\n        case _RouteLifecycle.staging:\r\n          assert(false);\r\n          break;\r\n      }\r\n      index -= 1;\r\n      next = entry;\r\n      entry = previous;\r\n      previous = index > 0 ? _history[index - 1] : null;\r\n    }\r\n\r\n    \/\/ Informs navigator observers about route changes.\r\n    _flushObserverNotifications();\r\n\r\n    \/\/ Now that the list is clean, send the didChangeNext\/didChangePrevious\r\n    \/\/ notifications.\r\n    _flushRouteAnnouncement();\r\n\r\n    \/\/ Announces route name changes.\r\n    final _RouteEntry lastEntry = _history.lastWhere(_RouteEntry.isPresentPredicate, orElse: () => null);\r\n    final String routeName = lastEntry?.route?.settings?.name;\r\n    if (routeName != _lastAnnouncedRouteName) {\r\n      RouteNotificationMessages.maybeNotifyRouteChange(routeName, _lastAnnouncedRouteName);\r\n      _lastAnnouncedRouteName = routeName;\r\n    }\r\n\r\n    \/\/ Lastly, removes the overlay entries of all marked entries and disposes\r\n    \/\/ them.\r\n    for (final _RouteEntry entry in toBeDisposed) {\r\n      for (final OverlayEntry overlayEntry in entry.route.overlayEntries)\r\n        overlayEntry.remove();\r\n      entry.dispose();\r\n    }\r\n    if (rearrangeOverlay)\r\n      overlay?.rearrange(_allRouteOverlayEntries);\r\n  }\r\n```\r\n\r\n这个方法就是根据`_RouteLifecycle`不同的生命周期状态执行不同的操作。\r\n\r\n其中当我们执行到\r\n\r\n`_RouteLifecycle.add`、\r\n\r\n`_RouteLifecycle.push`、\r\n\r\n`_RouteLifecycle.pushReplace`\r\n\r\n`_RouteLifecycle.replace`这些操作时，会执行`route.install()`方法：\r\n\r\n```dart\r\n  @override\r\n  void install() {\r\n    assert(_overlayEntries.isEmpty);\r\n    _overlayEntries.addAll(createOverlayEntries());\r\n    super.install();\r\n  }\r\n```\r\n\r\n其中`createOverlayEntries`执行时会创建`OverlayEntry`。\r\n\r\n其中的参数`builder`赋值`_buildModalScope`，\r\n\r\n这里最终会回调到`MaterialPageRoute(builder: (_) => ScopedSecondPage())`中的`builder`。\r\n\r\n也就是说之前Page设置的Widget。现在被以`builder`函数形式存放到了**OverlayEntry**中。\r\n\r\n其中`_overlayEntries`就是当前`route`的属性，以`overlayEntries`名称对外提供。\r\n\r\n以上这些操作是在`initState`方法中进行的。\r\n\r\n下面看看`build`方法：\r\n\r\n```dart\r\n@override\r\n  Widget build(BuildContext context) {\r\n    assert(!_debugLocked);\r\n    assert(_history.isNotEmpty);\r\n    \/\/ Hides the HeroControllerScope for the widget subtree so that the other\r\n    \/\/ nested navigator underneath will not pick up the hero controller above\r\n    \/\/ this level.\r\n    return HeroControllerScope(\r\n      child: Listener(\r\n        onPointerDown: _handlePointerDown,\r\n        onPointerUp: _handlePointerUpOrCancel,\r\n        onPointerCancel: _handlePointerUpOrCancel,\r\n        child: AbsorbPointer(\r\n          absorbing: false, \/\/ it's mutated directly by _cancelActivePointers above\r\n          child: FocusScope(\r\n            node: focusScopeNode,\r\n            autofocus: true,\r\n            child: Overlay(\r\n              key: _overlayKey,\r\n              initialEntries: overlay == null ?  _allRouteOverlayEntries.toList(growable: false) : const <OverlayEntry>[],\r\n            ),\r\n          ),\r\n        ),\r\n      ),\r\n    );\r\n  }\r\n```\r\n\r\n可以看到终点是`Overlay`，通过`initialEntries`参数接收`_allRouteOverlayEntries`的值。\r\n\r\n这里的`_allRouteOverlayEntries`就是从上面创建的`overlayEntries`集合：\r\n\r\n```dart\r\n  Iterable<OverlayEntry> get _allRouteOverlayEntries sync* {\r\n    for (final _RouteEntry entry in _history)\r\n      yield* entry.route.overlayEntries;\r\n  }\r\n```\r\n\r\n\r\n\r\n## Overlay\r\n\r\n那么`Overlay`接收到`overlayEntries`如何处理的呢？\r\n\r\n在`OverlayState`中的`initState`里，把数据全部添加到了`List<OverlayEntry> _entries`。\r\n\r\n```dart\r\n @override\r\n  Widget build(BuildContext context) {\r\n    \/\/ This list is filled backwards and then reversed below before\r\n    \/\/ it is added to the tree.\r\n    final List<Widget> children = <Widget>[];\r\n    bool onstage = true;\r\n    int onstageCount = 0;\r\n    for (int i = _entries.length - 1; i >= 0; i -= 1) {\r\n      final OverlayEntry entry = _entries[i];\r\n      if (onstage) {\r\n        onstageCount += 1;\r\n        children.add(_OverlayEntryWidget(\r\n          key: entry._key,\r\n          entry: entry,\r\n        ));\r\n        if (entry.opaque)\r\n          onstage = false;\r\n      } else if (entry.maintainState) {\r\n        children.add(_OverlayEntryWidget(\r\n          key: entry._key,\r\n          entry: entry,\r\n          tickerEnabled: false,\r\n        ));\r\n      }\r\n    }\r\n    return _Theatre(\r\n      skipCount: children.length - onstageCount,\r\n      children: children.reversed.toList(growable: false),\r\n    );\r\n  }\r\n```\r\n\r\n在`build`中根据清情况遍历`_entries`，为每个`entry`外包裹一层`_OverlayEntryWidget`。\r\n\r\n并将`children`添加到`_Theatre`中。\r\n\r\n## _Theatre\r\n\r\n`_Theatre`是一种特殊的`Stack`。\r\n\r\n上面说了不管通过`home`属性设置还是通过`Navigator.of(context).push`都会调用`route.install`。\r\n\r\n而上面用到的`_entries`是所有`route`的`List<OverLayEntry>`集合。\r\n\r\n**由于`_Theatre`是一种`Stack`，**\r\n\r\n**也就是说`home`也好`push`也罢，所有页面都以children方式被`_Theatre`管理。**\r\n\r\n**所以所有页面是以兄弟形式存在，在Widget tree中它们是平级，**\r\n\r\n**所以在HomePage设置了xxProvider后，其他页面是不能获取到的**"
  },
  {
    "title" : "Flutter为什么需要做混合栈管理",
    "created_time" : "2020-07-13 14:31:25",
    "body" : "# 0x00 前言\r\n\r\nFlutter和Android都有自己的页面管理功能。\r\n\r\n在纯Android或者纯Flutter工程中，页面都由各端全权处理，没什么问题。\r\n\r\n如果是Android和Flutter混合工程，尤其是遇到页面互相穿插的情况下，\r\n\r\n比如native page1->flutter page1->native page2->flutter page2这样，\r\n\r\n这就有问题了。\r\n\r\n先看看Android如何打开Flutter页面，然后再看有什么问题。\r\n\r\n# 0x01 Android跳转Flutter\r\n\r\n## Android端\r\n\r\n\r\n\r\nAndroid和Flutter是宿主与寄生的关系。\r\n\r\nAndroid每启动一个FlutterActivity就会创建一个FlutterEngine实例，同时也会运行Flutter。\r\n\r\n通过命令行我们可以看到不管我们的Flutter页面如何切换，命令行我们看到的Activity只有\r\n\r\nMainActivity这一个。\r\n\r\n也就是所有的Flutter页面操作都是在MainActivity中完成的，\r\n\r\n具体点是MainActivity中的FlutterView。\r\n\r\n所以从Android跳转到Flutter页面，\r\n\r\n一个比较直接的方法是从新启动一个FlutterActivity，然后我们指定一个要在Flutter端启动的页面。\r\n\r\nAndroid端\r\n\r\n首先在androidManifest.xml中声明FlutterActivity：\r\n\r\n```xml\r\n<activity\r\n            android:name=\"io.flutter.embedding.android.FlutterActivity\"\r\n            android:hardwareAccelerated=\"true\"\r\n            android:windowSoftInputMode=\"adjustResize\" \/>\r\n```\r\n\r\n其次，点击事件跳转时使用`FlutterActivity`的静态方法跳转：\r\n\r\n```kotlin\r\nfindViewById<Button>(R.id.btn).setOnClickListener {\r\n            startActivity(FlutterActivity.withNewEngine().initialRoute(\"third_page\").build(this))\r\n        }\r\n```\r\n\r\n## Flutter端\r\n\r\nAndroid端设置了`initialRoute`，\r\n\r\n如果Flutter端不处理，默认启动后还是会显示Home的页面。\r\n\r\n所以Flutter端需要对`initialRoute`进行处理：\r\n\r\n通过`window.defaultRouteName`获取之前设置的`initialRoute`。\r\n\r\n根据`initialRoute`返回不同的Widget：\r\n\r\n```dart\r\nWidget _initHome() {\r\n  final routeName = window.defaultRouteName;\r\n  if (routeName == '\/') {\r\n    return ScopedHomePage();\r\n  } else if (routeName == 'third_page') {\r\n    return ThirdPage();\r\n  }\r\n}\r\n```\r\n\r\n# 0x02问题分析\r\n\r\n## 多FlutterEngine实例\r\n\r\n由于多次页面穿插，导致系统创建多个Engine实例。\r\n\r\nFlutterEngine是一个比较重的对象，创建耗费时间比较大，\r\n\r\n所以在调用`FlutterActivity.withNewEngine().initialRoute(\"third_page\").build(this)`时会有白屏现象。\r\n\r\n另外一些对象是存在Engine中的，如果每个Engine中都保存一份相同对象，那么内存是成倍增加的。\r\n\r\n## Plugin混乱\r\n\r\n如果启动了多个FlutterActivity，那么每个FlutterActivity都注册了一些Plugin的话，\r\n\r\n这会造成Plugin注册混乱，维护困难。\r\n\r\n# 结尾\r\n\r\n对于大型App来说混合开发很常见，所以不可避免的会遇到上面的问题。\r\n\r\n也就会逃不过要做混合栈处理。\r\n\r\n关于混合栈处理可以使用flutterboost"
  },
  {
    "title": "Dio不打印请求头信息",
    "created_time": "2020-08-13 14:31:25",
    "body": "DioInspector->DioPluggableState->_ResponseCard->_ResponseCardState->\n\n```dart\n  Widget _detailedContent(BuildContext context) {\n    return ValueListenableBuilder<bool>(\n      valueListenable: _isExpanded,\n      builder: (_, bool value, __) {\n        if (!value) {\n          return const SizedBox.shrink();\n        }\n        return Container(\n          padding: const EdgeInsets.symmetric(vertical: 8),\n          child: Column(\n            crossAxisAlignment: CrossAxisAlignment.start,\n            children: <Widget>[\n              //这里添加一行\n                _TagText(tag: 'Request header', content: _request.headers.toString()),\n\n              if (_requestDataBuilder != null)\n                _TagText(tag: 'Request data', content: _requestDataBuilder!),\n              _TagText(tag: 'Response body', content: _responseDataBuilder),\n              _TagText(\n                tag: 'Response headers',\n                content: '\\n${_response.headers}',\n              ),\n            ],\n          ),\n        );\n      },\n    );\n  }\n```"
  },
  {
    "title": "Get.put对象如何自动被回收的(源码分析)",
    "created_time": "2020-08-15 14:31:25",
    "body": "# put的存储流程\n\n首先调用 **GetInstance()** 的**put** 方法：\n\n```dart\nS put<S>(S dependency,\n          {String? tag,\n          bool permanent = false,\n          InstanceBuilderCallback<S>? builder}) =>\n      GetInstance().put<S>(dependency, tag: tag, permanent: permanent);\n```\n\n进入这个方法发现先是插入数据，然后再查找返回：\n\n```dart\n  S put<S>(\n    S dependency, {\n    String? tag,\n    bool permanent = false,\n    @deprecated InstanceBuilderCallback<S>? builder,\n  }) {\n    _insert(\n        isSingleton: true,\n        name: tag,\n        permanent: permanent,\n        builder: builder ?? (() => dependency));\n    return find<S>(tag: tag);\n  }\n```\n\n所以我们使用某个共享对象时使用**Object obj = Get.put(Object())**。\n\n继续分析，\n\n调用 **_insert** 方法时根据**S**和**tag** 生成**key**然后存入到\n\n**static final Map<String, _InstanceBuilderFactory> _singl = {}** 中：\n\n```dart\n  void _insert<S>({\n    bool? isSingleton,\n    String? name,\n    bool permanent = false,\n    required InstanceBuilderCallback<S> builder,\n    bool fenix = false,\n  }) {\n    final key = _getKey(S, name);\n\n    if (_singl.containsKey(key)) {\n      final dep = _singl[key];\n      if (dep != null && dep.isDirty) {\n        _singl[key] = _InstanceBuilderFactory<S>(\n          isSingleton,\n          builder,\n          permanent,\n          false,\n          fenix,\n          name,\n          lateRemove: dep as _InstanceBuilderFactory<S>,\n        );\n      }\n    } else {\n      _singl[key] = _InstanceBuilderFactory<S>(\n        isSingleton,\n        builder,\n        permanent,\n        false,\n        fenix,\n        name,\n      );\n    }\n  }\n```\n\n然后分析**find**方法：\n\n```dart\n  S find<S>({String? tag}) {\n    final key = _getKey(S, tag);\n    if (isRegistered<S>(tag: tag)) {\n      final dep = _singl[key];\n      if (dep == null) {\n        if (tag == null) {\n          throw 'Class \"$S\" is not registered';\n        } else {\n          throw 'Class \"$S\" with tag \"$tag\" is not registered';\n        }\n      }\n      final i = _initDependencies<S>(name: tag);\n      return i ?? dep.getDependency() as S;\n    } else {\n      // ignore: lines_longer_than_80_chars\n      throw '\"$S\" not found. You need to call \"Get.put($S())\" or \"Get.lazyPut(()=>$S())\"';\n    }\n  }\n```\n\n这个时候**isRegistered**是返回**true**的，所以会执行 **_initDependencies**方法：\n\n```dart\n  S? _initDependencies<S>({String? name}) {\n    final key = _getKey(S, name);\n    final isInit = _singl[key]!.isInit;\n    S? i;\n    if (!isInit) {\n      i = _startController<S>(tag: name);\n      if (_singl[key]!.isSingleton!) {\n        _singl[key]!.isInit = true;\n        if (Get.smartManagement != SmartManagement.onlyBuilder) {\n          RouterReportManager.reportDependencyLinkedToRoute(_getKey(S, name));\n        }\n      }\n    }\n    return i;\n  }\n```\n\n在 **_insert**方法中构建 **_InstanceBuilderFactory**时**isInit**是**false**。\n\n所以这个会执行**if**。由于**Get.smartManagement**默认值是**full**：\n\n```dart\nSmartManagement smartManagement = SmartManagement.full;\n```\n\n所以会调用`RouterReportManager.reportDependencyLinkedToRoute(_getKey(S, name));`\n\n看下这个方法实现：\n\n```dart\n  static void reportDependencyLinkedToRoute(String depedencyKey) {\n    if (_current == null) return;\n    if (_routesKey.containsKey(_current)) {\n      _routesKey[_current!]!.add(depedencyKey);\n    } else {\n      _routesKey[_current] = <String>[depedencyKey];\n    }\n  }\n```\n\n这里 **_current**类型为`static Route? _current;`也就是当前页面对象，\n\n**_routesKey**类型为`static final Map<Route?, List<String>> _routesKey = {};`,\n\n这个 **_routesKey**存储的是当前页面所有调用**Get.put**时通过**S**和**tag**生成的**key**。\n\n也就是说我通过 **_routesKey**根据当前页面能拿到所有**key**，\n\n在**static final Map<String, _InstanceBuilderFactory> _singl = {}** 里**String**为**key**，**_InstanceBuilderFactory**中存储着我们创建的对象。\n\n下面分析页面弹出时流程\n\n# Get.back弹出流程\n\n看下**back**方法：\n\n```dart\n  void back<T>({\n    T? result,\n    bool closeOverlays = false,\n    bool canPop = true,\n    int? id,\n  }) {\n    if (isSnackbarOpen && !closeOverlays) {\n      closeCurrentSnackbar();\n      return;\n    }\n\n    if (closeOverlays && isOverlaysOpen) {\n      if (isSnackbarOpen) {\n        closeAllSnackbars();\n      }\n      navigator?.popUntil((route) {\n        return (!isDialogOpen! && !isBottomSheetOpen!);\n      });\n    }\n    if (canPop) {\n      if (global(id).currentState?.canPop() == true) {\n        global(id).currentState?.pop<T>(result);\n      }\n    } else {\n      global(id).currentState?.pop<T>(result);\n    }\n  }\n```\n\n可以看到最后主要调用**pop**方法，看下实现：\n\n```dart\n  void pop<T extends Object?>([ T? result ]) {\n    final _RouteEntry entry = _history.lastWhere(_RouteEntry.isPresentPredicate);\n    if (entry.hasPage) {\n      if (widget.onPopPage!(entry.route, result) && entry.currentState == _RouteLifecycle.idle) {\n        entry.currentState = _RouteLifecycle.pop;\n      }\n    } else {\n      entry.pop<T>(result);\n      assert (entry.currentState == _RouteLifecycle.pop);\n    }\n    if (entry.currentState == _RouteLifecycle.pop)\n      _flushHistoryUpdates(rearrangeOverlay: false);\n    _afterNavigation(entry.route);\n  }\n```\n\n这里主要看`_flushHistoryUpdates`方法：\n\n```dart\n  void _flushHistoryUpdates({bool rearrangeOverlay = true}) {\n    assert(_debugLocked && !_debugUpdatingPage);\n    _flushingHistory = true;\n    // Clean up the list, sending updates to the routes that changed. Notably,\n    // we don't send the didChangePrevious/didChangeNext updates to those that\n    // did not change at this point, because we're not yet sure exactly what the\n    // routes will be at the end of the day (some might get disposed).\n    int index = _history.length - 1;\n    _RouteEntry? next;\n    _RouteEntry? entry = _history[index];\n    _RouteEntry? previous = index > 0 ? _history[index - 1] : null;\n    bool canRemoveOrAdd = false; // Whether there is a fully opaque route on top to silently remove or add route underneath.\n    Route<dynamic>? poppedRoute; // The route that should trigger didPopNext on the top active route.\n    bool seenTopActiveRoute = false; // Whether we've seen the route that would get didPopNext.\n    final List<_RouteEntry> toBeDisposed = <_RouteEntry>[];\n    while (index >= 0) {\n      switch (entry!.currentState) {\n        case _RouteLifecycle.add:\n          assert(rearrangeOverlay);\n          entry.handleAdd(\n            navigator: this,\n            previousPresent: _getRouteBefore(index - 1, _RouteEntry.isPresentPredicate)?.route,\n          );\n          assert(entry.currentState == _RouteLifecycle.adding);\n          continue;\n        case _RouteLifecycle.adding:\n          if (canRemoveOrAdd || next == null) {\n            entry.didAdd(\n              navigator: this,\n              isNewFirst: next == null,\n            );\n            assert(entry.currentState == _RouteLifecycle.idle);\n            continue;\n          }\n          break;\n        case _RouteLifecycle.push:\n        case _RouteLifecycle.pushReplace:\n        case _RouteLifecycle.replace:\n          assert(rearrangeOverlay);\n          entry.handlePush(\n            navigator: this,\n            previous: previous?.route,\n            previousPresent: _getRouteBefore(index - 1, _RouteEntry.isPresentPredicate)?.route,\n            isNewFirst: next == null,\n          );\n          assert(entry.currentState != _RouteLifecycle.push);\n          assert(entry.currentState != _RouteLifecycle.pushReplace);\n          assert(entry.currentState != _RouteLifecycle.replace);\n          if (entry.currentState == _RouteLifecycle.idle) {\n            continue;\n          }\n          break;\n        case _RouteLifecycle.pushing: // Will exit this state when animation completes.\n          if (!seenTopActiveRoute && poppedRoute != null)\n            entry.handleDidPopNext(poppedRoute);\n          seenTopActiveRoute = true;\n          break;\n        case _RouteLifecycle.idle:\n          if (!seenTopActiveRoute && poppedRoute != null)\n            entry.handleDidPopNext(poppedRoute);\n          seenTopActiveRoute = true;\n          // This route is idle, so we are allowed to remove subsequent (earlier)\n          // routes that are waiting to be removed silently:\n          canRemoveOrAdd = true;\n          break;\n        case _RouteLifecycle.pop:\n          if (!entry.handlePop(\n                navigator: this,\n                previousPresent: _getRouteBefore(index, _RouteEntry.willBePresentPredicate)?.route)){\n            assert(entry.currentState == _RouteLifecycle.idle);\n            continue;\n          }\n          if (!seenTopActiveRoute) {\n            if (poppedRoute != null)\n              entry.handleDidPopNext(poppedRoute);\n            poppedRoute = entry.route;\n          }\n          _observedRouteDeletions.add(\n            _NavigatorPopObservation(entry.route, _getRouteBefore(index, _RouteEntry.willBePresentPredicate)?.route),\n          );\n          if (entry.currentState == _RouteLifecycle.dispose) {\n            // The pop finished synchronously. This can happen if transition\n            // duration is zero.\n            continue;\n          }\n          assert(entry.currentState == _RouteLifecycle.popping);\n          canRemoveOrAdd = true;\n          break;\n        case _RouteLifecycle.popping:\n          // Will exit this state when animation completes.\n          break;\n        case _RouteLifecycle.complete:\n          entry.handleComplete();\n          assert(entry.currentState == _RouteLifecycle.remove);\n          continue;\n        case _RouteLifecycle.remove:\n          if (!seenTopActiveRoute) {\n            if (poppedRoute != null)\n              entry.route.didPopNext(poppedRoute);\n            poppedRoute = null;\n          }\n          entry.handleRemoval(\n            navigator: this,\n            previousPresent: _getRouteBefore(index, _RouteEntry.willBePresentPredicate)?.route,\n          );\n          assert(entry.currentState == _RouteLifecycle.removing);\n          continue;\n        case _RouteLifecycle.removing:\n          if (!canRemoveOrAdd && next != null) {\n            // We aren't allowed to remove this route yet.\n            break;\n          }\n          entry.currentState = _RouteLifecycle.dispose;\n          continue;\n        case _RouteLifecycle.dispose:\n          // Delay disposal until didChangeNext/didChangePrevious have been sent.\n          toBeDisposed.add(_history.removeAt(index));\n          entry = next;\n          break;\n        case _RouteLifecycle.disposed:\n        case _RouteLifecycle.staging:\n          assert(false);\n          break;\n      }\n      index -= 1;\n      next = entry;\n      entry = previous;\n      previous = index > 0 ? _history[index - 1] : null;\n    }\n    // Informs navigator observers about route changes.\n    _flushObserverNotifications();\n\n    // Now that the list is clean, send the didChangeNext/didChangePrevious\n    // notifications.\n    _flushRouteAnnouncement();\n\n    // Announce route name changes.\n    if (widget.reportsRouteUpdateToEngine) {\n      final _RouteEntry? lastEntry = _history.cast<_RouteEntry?>().lastWhere(\n        (_RouteEntry? e) => e != null && _RouteEntry.isPresentPredicate(e), orElse: () => null,\n      );\n      final String? routeName = lastEntry?.route.settings.name;\n      if (routeName != null && routeName != _lastAnnouncedRouteName) {\n        SystemNavigator.routeInformationUpdated(location: routeName);\n        _lastAnnouncedRouteName = routeName;\n      }\n    }\n\n    // Lastly, removes the overlay entries of all marked entries and disposes\n    // them.\n    for (final _RouteEntry entry in toBeDisposed) {\n      for (final OverlayEntry overlayEntry in entry.route.overlayEntries)\n        overlayEntry.remove();\n      entry.dispose();\n    }\n    if (rearrangeOverlay) {\n      overlay?.rearrange(_allRouteOverlayEntries);\n    }\n    if (bucket != null) {\n      _serializableHistory.update(_history);\n    }\n    _flushingHistory = false;\n  }\n```\n\n这个方法看着代码很多，但其实**switch**那一大段代码都是对不同操作的的处理比如**pop**。\n\n注意最后这一块：\n\n```dart\n// Lastly, removes the overlay entries of all marked entries and disposes\n    // them.\n    for (final _RouteEntry entry in toBeDisposed) {\n      for (final OverlayEntry overlayEntry in entry.route.overlayEntries)\n        overlayEntry.remove();\n      entry.dispose();\n    }\n```\n\n**entry**的**dispose**回调页面**route**的**dispose**方法：\n\n```dart\n  void dispose() {\n    assert(currentState.index < _RouteLifecycle.disposed.index);\n    currentState = _RouteLifecycle.disposed;\n\n    final Iterable<OverlayEntry> mountedEntries = route.overlayEntries.where((OverlayEntry e) => e.mounted);\n\n    if (mountedEntries.isEmpty) {\n      route.dispose();\n    } else {\n      int mounted = mountedEntries.length;\n      assert(mounted > 0);\n      for (final OverlayEntry entry in mountedEntries) {\n        late VoidCallback listener;\n        listener = () {\n          assert(mounted > 0);\n          assert(!entry.mounted);\n          mounted--;\n          entry.removeListener(listener);\n          if (mounted == 0) {\n            assert(route.overlayEntries.every((OverlayEntry e) => !e.mounted));\n            route.dispose();\n          }\n        };\n        entry.addListener(listener);\n      }\n    }\n  }\n```\n\n使用**Get**路由导航的页面都是使用了**GetPageRoute**,\n\n查看**dispose**中调用了`RouterReportManager.reportRouteDispose(this)`:\n\n```dart\n  static void reportRouteDispose(Route disposed) {\n    if (Get.smartManagement != SmartManagement.onlyBuilder) {\n      ambiguate(WidgetsBinding.instance)?.addPostFrameCallback((_) {\n        _removeDependencyByRoute(disposed);\n      });\n    }\n  }\n```\n\n看下 **_removeDependencyByRoute**实现：\n\n```dart\n  static void _removeDependencyByRoute(Route routeName) {\n    final keysToRemove = <String>[];\n\n    _routesKey[routeName]?.forEach(keysToRemove.add);\n\n    /// Removes `Get.create()` instances registered in `routeName`.\n    if (_routesByCreate.containsKey(routeName)) {\n      for (final onClose in _routesByCreate[routeName]!) {\n        // assure the [DisposableInterface] instance holding a reference\n        // to onClose() wasn't disposed.\n        onClose();\n      }\n      _routesByCreate[routeName]!.clear();\n      _routesByCreate.remove(routeName);\n    }\n\n    for (final element in keysToRemove) {\n      final value = GetInstance().delete(key: element);\n      if (value) {\n        _routesKey[routeName]?.remove(element);\n      }\n    }\n\n    keysToRemove.clear();\n  }\n```\n\n这个方法释放了当前页面产生的一些资源，\n\n`_routesKey[routeName]`在put流程有提到，\n\n根据**routeName**作为**key**，可以拿到所有的`Get.find`所需要的**key**集合。\n\n最后遍历的时候执行了`GetInstance().delete(key: element);`进行清理操作：\n\n```dart\n  bool delete<S>({String? tag, String? key, bool force = false}) {\n    final newKey = key ?? _getKey(S, tag);\n\n    if (!_singl.containsKey(newKey)) {\n      Get.log('Instance \"$newKey\" already removed.', isError: true);\n      return false;\n    }\n\n    final dep = _singl[newKey];\n\n    if (dep == null) return false;\n\n    final _InstanceBuilderFactory builder;\n    if (dep.isDirty) {\n      builder = dep.lateRemove ?? dep;\n    } else {\n      builder = dep;\n    }\n\n    if (builder.permanent && !force) {\n      Get.log(\n        // ignore: lines_longer_than_80_chars\n        '\"$newKey\" has been marked as permanent, SmartManagement is not authorized to delete it.',\n        isError: true,\n      );\n      return false;\n    }\n    final i = builder.dependency;\n\n    if (i is GetxServiceMixin && !force) {\n      return false;\n    }\n\n    if (i is GetLifeCycleBase) {\n      i.onDelete();\n      Get.log('\"$newKey\" onDelete() called');\n    }\n\n    if (builder.fenix) {\n      builder.dependency = null;\n      builder.isInit = false;\n      return true;\n    } else {\n      if (dep.lateRemove != null) {\n        dep.lateRemove = null;\n        Get.log('\"$newKey\" deleted from memory');\n        return false;\n      } else {\n        _singl.remove(newKey);\n        if (_singl.containsKey(newKey)) {\n          Get.log('Error removing object \"$newKey\"', isError: true);\n        } else {\n          Get.log('\"$newKey\" deleted from memory');\n        }\n        return true;\n      }\n    }\n  }\n```\n\n最后可以发现调用了`_singl.remove(newKey);`移除了通过**put**方法存储的对象。\n\n总结一下流程就是：\n\n**S**和**tag**生成了**key**，Map类型变量 **_singl**根据**key**存储了**S**实例的封装。\n\nMap类型变量 **_routesKey**根据当前页面route存储了**key**列表。\n\n因为一个页面可能使用多个业务实例(GetController)。\n\n当页面弹出时，清空 **_singl**和 **_routesKey_**。"
  },
  {
    "title": "Get如何通过arguments传递参数的(源码分析)",
    "created_time": "2020-08-18 14:31:25",
    "body": "# arguments从哪获取的数据\n\n看下`Get.arguments`实现：`dynamic get arguments => routing.args;`\n\n期中**routing**实现是`Routing get routing => _getxController.routing;`\n\n而 **_getxController** 实现是 `static GetMaterialController _getxController = GetMaterialController();`\n\n也就是**arguments**来自**GetMaterialController**的`final routing = Routing();`\n\n**Routing**构造函数：\n\n```dart\n  Routing({\n    this.current = '',\n    this.previous = '',\n    this.args,\n    this.removed = '',\n    this.route,\n    this.isBack,\n    // this.isSnackbar,\n    this.isBottomSheet,\n    this.isDialog,\n  });\n```\n\n可以看到**arguments**实际上就是**Routing**的**args**\n\n那接下来只要找到哪里给**Routing**的**args**赋值的即可。\n\n# args在哪赋值\n\n既然我们是调用`Get.toNamed()`时候传递的**arguments**。首先看看这个值的传递路径是怎样的。\n\n```dart\n  Future<T?>? toNamed<T>(\n    String page, {\n    dynamic arguments,\n    int? id,\n    bool preventDuplicates = true,\n    Map<String, String>? parameters,\n  }) {\n    if (preventDuplicates && page == currentRoute) {\n      return null;\n    }\n\n    if (parameters != null) {\n      final uri = Uri(path: page, queryParameters: parameters);\n      page = uri.toString();\n    }\n\n    return global(id).currentState?.pushNamed<T>(\n          page,\n          arguments: arguments,\n        );\n  }\n```\n\n最后一行调用了**pushNamed**：\n\n```dart\n  Future<T?> pushNamed<T extends Object?>(\n    String routeName, {\n    Object? arguments,\n  }) {\n    return push<T>(_routeNamed<T>(routeName, arguments: arguments)!);\n  }\n```\n\n可以看到**arguments**被 **_routeNamed**封装到了**Route**，然后调用了**push**方法。\n\n先进去看看是如何被封装的：\n\n```dart\n  Route<T>? _routeNamed<T>(String name, { required Object? arguments, bool allowNull = false }) {\n    assert(!_debugLocked);\n    assert(name != null);\n    if (allowNull && widget.onGenerateRoute == null)\n      return null;\n    assert(() {\n      if (widget.onGenerateRoute == null) {\n        throw FlutterError(\n          'Navigator.onGenerateRoute was null, but the route named \"$name\" was referenced.\\n'\n          'To use the Navigator API with named routes (pushNamed, pushReplacementNamed, or '\n          'pushNamedAndRemoveUntil), the Navigator must be provided with an '\n          'onGenerateRoute handler.\\n'\n          'The Navigator was:\\n'\n          '  $this',\n        );\n      }\n      return true;\n    }());\n    final RouteSettings settings = RouteSettings(\n      name: name,\n      arguments: arguments,\n    );\n    Route<T>? route = widget.onGenerateRoute!(settings) as Route<T>?;\n    if (route == null && !allowNull) {\n      assert(() {\n        if (widget.onUnknownRoute == null) {\n          throw FlutterError.fromParts(<DiagnosticsNode>[\n            ErrorSummary('Navigator.onGenerateRoute returned null when requested to build route \"$name\".'),\n            ErrorDescription(\n              'The onGenerateRoute callback must never return null, unless an onUnknownRoute '\n              'callback is provided as well.',\n            ),\n            DiagnosticsProperty<NavigatorState>('The Navigator was', this, style: DiagnosticsTreeStyle.errorProperty),\n          ]);\n        }\n        return true;\n      }());\n      route = widget.onUnknownRoute!(settings) as Route<T>?;\n      assert(() {\n        if (route == null) {\n          throw FlutterError.fromParts(<DiagnosticsNode>[\n            ErrorSummary('Navigator.onUnknownRoute returned null when requested to build route \"$name\".'),\n            ErrorDescription('The onUnknownRoute callback must never return null.'),\n            DiagnosticsProperty<NavigatorState>('The Navigator was', this, style: DiagnosticsTreeStyle.errorProperty),\n          ]);\n        }\n        return true;\n      }());\n    }\n    assert(route != null || allowNull);\n    return route;\n  }\n```\n\n可以看到**arguments**其实被封装到了**RouteSettings**。\n\n通过`widget.onGenerateRoute!(settings)`传入**settings**返回了**Route**。\n\n这个**Route**是个抽象类，`widget.onGenerateRoute`生成的应该是一个实现类。\n\n看看`widget.onGenerateRoute`如何实现的：\n\n我们使用路由功能时需要**GetMaterialApp**替代原来的**MaterialApp**，看下如何实现的：\n\n```dart\nMaterialApp(\n                key: _.unikey,\n                navigatorKey: (navigatorKey == null\n                    ? Get.key\n                    : Get.addKey(navigatorKey!)),\n                scaffoldMessengerKey:\n                    scaffoldMessengerKey ?? _.scaffoldMessengerKey,\n                home: home,\n                routes: routes ?? const <String, WidgetBuilder>{},\n                initialRoute: initialRoute,\n                onGenerateRoute:\n                    (getPages != null ? generator : onGenerateRoute),\n                onGenerateInitialRoutes: (getPages == null || home != null)\n                    ? onGenerateInitialRoutes\n                    : initialRoutesGenerate,\n                onUnknownRoute: onUnknownRoute,\n                navigatorObservers: (navigatorObservers == null\n                    ? <NavigatorObserver>[\n                        GetObserver(routingCallback, Get.routing)\n                      ]\n                    : <NavigatorObserver>[\n                        GetObserver(routingCallback, Get.routing)\n                      ]\n                  ..addAll(navigatorObservers!)),\n                builder: defaultBuilder,\n                title: title,\n                onGenerateTitle: onGenerateTitle,\n                color: color,\n                theme: _.theme ?? theme ?? ThemeData.fallback(),\n                darkTheme:\n                    _.darkTheme ?? darkTheme ?? theme ?? ThemeData.fallback(),\n                themeMode: _.themeMode ?? themeMode,\n                locale: Get.locale ?? locale,\n                localizationsDelegates: localizationsDelegates,\n                localeListResolutionCallback: localeListResolutionCallback,\n                localeResolutionCallback: localeResolutionCallback,\n                supportedLocales: supportedLocales,\n                debugShowMaterialGrid: debugShowMaterialGrid,\n                showPerformanceOverlay: showPerformanceOverlay,\n                checkerboardRasterCacheImages: checkerboardRasterCacheImages,\n                checkerboardOffscreenLayers: checkerboardOffscreenLayers,\n                showSemanticsDebugger: showSemanticsDebugger,\n                debugShowCheckedModeBanner: debugShowCheckedModeBanner,\n                shortcuts: shortcuts,\n                scrollBehavior: scrollBehavior,\n                useInheritedMediaQuery: useInheritedMediaQuery,\n                //   actions: actions,\n              )\n```\n\n在**build**方法中也是通过**MaterialApp**实现的，只是对其进行了封装。\n\n这里有两点属性要注意：\n\n首先是`onGenerateRoute:(getPages != null ? generator : onGenerateRoute)`。\n\n其次是\n\n```dart\nnavigatorObservers: (navigatorObservers == null\n    ? <NavigatorObserver>[\n        GetObserver(routingCallback, Get.routing)\n      ]\n    : <NavigatorObserver>[\n        GetObserver(routingCallback, Get.routing)\n      ]\n  ..addAll(navigatorObservers!))\n```\n\n由于设置了**getPages**所以这里传递的是**generator**函数：\n\n```dart\n Route<dynamic> generator(RouteSettings settings) {\n    return PageRedirect(settings: settings, unknownRoute: unknownRoute).page();\n  }\n```\n\n这两个属性又传递给了**WidgetsApp**,而**WidgetsApp**中又调用了**Navigator** Widget：\n\n```dart\nNavigator(\n        restorationScopeId: 'nav',\n        key: _navigator,\n        initialRoute: _initialRouteName,\n        onGenerateRoute: _onGenerateRoute,\n        onGenerateInitialRoutes: widget.onGenerateInitialRoutes == null\n          ? Navigator.defaultGenerateInitialRoutes\n          : (NavigatorState navigator, String initialRouteName) {\n            return widget.onGenerateInitialRoutes!(initialRouteName);\n          },\n        onUnknownRoute: _onUnknownRoute,\n        observers: widget.navigatorObservers!,\n        reportsRouteUpdateToEngine: true,\n      )\n```\n\n**Navigator**中的**observers**直接来自**GetMaterialApp**传递过来的，\n\n**onGenerateRoute**则是对传递过来的进行了封装：\n\n```dart\n  Route<dynamic>? _onGenerateRoute(RouteSettings settings) {\n    final String? name = settings.name;\n    final WidgetBuilder? pageContentBuilder = name == Navigator.defaultRouteName && widget.home != null\n        ? (BuildContext context) => widget.home!\n        : widget.routes![name];\n\n    if (pageContentBuilder != null) {\n      assert(\n        widget.pageRouteBuilder != null,\n        'The default onGenerateRoute handler for WidgetsApp must have a '\n        'pageRouteBuilder set if the home or routes properties are set.',\n      );\n      final Route<dynamic> route = widget.pageRouteBuilder!<dynamic>(\n        settings,\n        pageContentBuilder,\n      );\n      assert(route != null, 'The pageRouteBuilder for WidgetsApp must return a valid non-null Route.');\n      return route;\n    }\n    if (widget.onGenerateRoute != null)\n      return widget.onGenerateRoute!(settings);\n    return null;\n  }\n```\n\n可以看到虽然封装了但最终还是调用了外部传递的：\n\n```dart\nRoute<dynamic> generator(RouteSettings settings) {\n    return PageRedirect(settings: settings, unknownRoute: unknownRoute).page();\n  }\n```\n\n查看**page**方法：\n\n```dart\nGetPageRoute<T> page<T>() {\n    while (needRecheck()) {}\n    final _r = (isUnknown ? unknownRoute : route)!;\n    return GetPageRoute<T>(\n      page: _r.page,\n      parameter: _r.parameters,\n      settings: isUnknown\n          ? RouteSettings(\n              name: _r.name,\n              arguments: settings!.arguments,\n            )\n          : settings,\n      curve: _r.curve,\n      opaque: _r.opaque,\n      showCupertinoParallax: _r.showCupertinoParallax,\n      gestureWidth: _r.gestureWidth,\n      customTransition: _r.customTransition,\n      binding: _r.binding,\n      bindings: _r.bindings,\n      transitionDuration:\n          _r.transitionDuration ?? Get.defaultTransitionDuration,\n      transition: _r.transition,\n      popGesture: _r.popGesture,\n      fullscreenDialog: _r.fullscreenDialog,\n      middlewares: _r.middlewares,\n    );\n  }\n```\n\n看到**arguments**最终被封装到**GetPageRoute**中，而**GetPageRoute**就是**Route**子类。\n\n刚才说的第二个属性**navigatorObservers**传递到**Navigator**的**observers**属性。\n\n继续刚才的**push**流程：\n\n```dart\n  Future<T?> push<T extends Object?>(Route<T> route) {\n    assert(_debugCheckIsPagelessRoute(route));\n    _pushEntry(_RouteEntry(route, initialState: _RouteLifecycle.push));\n    return route.popped;\n  }\n```\n\n这里把刚才生成的**Route**又封装到了**RouteEntry**\n\n进入 **_pushEntry**:\n\n```dart\n  void _pushEntry(_RouteEntry entry) {\n    _history.add(entry);\n    _flushHistoryUpdates();\n    _afterNavigation(entry.route);\n  }\n```\n\n**_history**这是一个存储打开页面集合，加入到集合后通过 **_flushHistoryUpdates**执行相关操作：\n\n```dart\n        case _RouteLifecycle.push:\n        case _RouteLifecycle.pushReplace:\n        case _RouteLifecycle.replace:\n          assert(rearrangeOverlay);\n          entry.handlePush(\n            navigator: this,\n            previous: previous?.route,\n            previousPresent: _getRouteBefore(index - 1, _RouteEntry.isPresentPredicate)?.route,\n            isNewFirst: next == null,\n          );\n          assert(entry.currentState != _RouteLifecycle.push);\n          assert(entry.currentState != _RouteLifecycle.pushReplace);\n          assert(entry.currentState != _RouteLifecycle.replace);\n          if (entry.currentState == _RouteLifecycle.idle) {\n            continue;\n          }\n          break;\n\n    _flushObserverNotifications();\n```\n\n这是该方法部分代码，由于现在是**push**页面所以**switch**流程执行`case _RouteLifecycle.push:`\n\n调用`entry.handlePush`：\n\n```dart\n  void handlePush({ required NavigatorState navigator, required bool isNewFirst, required Route<dynamic>? previous, required Route<dynamic>? previousPresent }) {\n    assert(currentState == _RouteLifecycle.push || currentState == _RouteLifecycle.pushReplace || currentState == _RouteLifecycle.replace);\n    assert(navigator != null);\n    assert(navigator._debugLocked);\n    assert(\n      route._navigator == null,\n      'The pushed route has already been used. When pushing a route, a new '\n      'Route object must be provided.',\n    );\n    final _RouteLifecycle previousState = currentState;\n    route._navigator = navigator;\n    route.install();\n    assert(route.overlayEntries.isNotEmpty);\n    if (currentState == _RouteLifecycle.push || currentState == _RouteLifecycle.pushReplace) {\n      final TickerFuture routeFuture = route.didPush();\n      currentState = _RouteLifecycle.pushing;\n      routeFuture.whenCompleteOrCancel(() {\n        if (currentState == _RouteLifecycle.pushing) {\n          currentState = _RouteLifecycle.idle;\n          assert(!navigator._debugLocked);\n          assert(() { navigator._debugLocked = true; return true; }());\n          navigator._flushHistoryUpdates();\n          assert(() { navigator._debugLocked = false; return true; }());\n        }\n      });\n    } else {\n      assert(currentState == _RouteLifecycle.replace);\n      route.didReplace(previous);\n      currentState = _RouteLifecycle.idle;\n    }\n    if (isNewFirst) {\n      route.didChangeNext(null);\n    }\n\n    if (previousState == _RouteLifecycle.replace || previousState == _RouteLifecycle.pushReplace) {\n      navigator._observedRouteAdditions.add(\n        _NavigatorReplaceObservation(route, previousPresent),\n      );\n    } else {\n      assert(previousState == _RouteLifecycle.push);\n      navigator._observedRouteAdditions.add(\n        _NavigatorPushObservation(route, previousPresent),\n      );\n    }\n  }\n```\n\n这里会先调用`final TickerFuture routeFuture = route.didPush();`然后通过`whenCompleteOrCancel`等待完成回调。\n\n接着调用`navigator._observedRouteAdditions.add( _NavigatorPushObservation(route, previousPresent), );`\n\n等到页面**push**完成时回调时再次调用`navigator._flushHistoryUpdates();`\n\n该方法底部调用了`_flushObserverNotifications`：\n\n```dart\n  void _flushObserverNotifications() {\n    if (_effectiveObservers.isEmpty) {\n      _observedRouteDeletions.clear();\n      _observedRouteAdditions.clear();\n      return;\n    }\n    while (_observedRouteAdditions.isNotEmpty) {\n      final _NavigatorObservation observation = _observedRouteAdditions.removeLast();\n      _effectiveObservers.forEach(observation.notify);\n    }\n\n    while (_observedRouteDeletions.isNotEmpty) {\n      final _NavigatorObservation observation = _observedRouteDeletions.removeFirst();\n      _effectiveObservers.forEach(observation.notify);\n    }\n  }\n```\n\n方法中 **_effectiveObservers**的赋值：\n\n```\n  void initState() {\n    _effectiveObservers = widget.observers;\n}\n```\n\n这个**widget**是**Navigator**，上面说了**Navigator**中的**observers**直接来自**GetMaterialApp**传递过来的：\n\n```dart\n    navigatorObservers: (navigatorObservers == null\n                    ? <NavigatorObserver>[\n                        GetObserver(routingCallback, Get.routing)\n                      ]\n                    : <NavigatorObserver>[\n                        GetObserver(routingCallback, Get.routing)\n                      ]\n                  ..addAll(navigatorObservers!)),\n```\n\n所以 **_effectiveObservers**不为空，而 **_observedRouteAdditions**在**handlePush**添加了对象，\n\n所以调用`_effectiveObservers.forEach(observation.notify)`时进入 **_NavigatorPushObservation**的**notify**方法查看：\n\n```dart\nvoid notify(NavigatorObserver observer) {\n    observer.didPush(primaryRoute, secondaryRoute);\n  }\n```\n\n这里的**observer**为外部传递的**GetObserver**:\n\n```dart\n  void didPush(Route route, Route? previousRoute) {\n    super.didPush(route, previousRoute);\n    final newRoute = _RouteData.ofRoute(route);\n\n    if (newRoute.isBottomSheet || newRoute.isDialog) {\n      Get.log(\"OPEN ${newRoute.name}\");\n    } else if (newRoute.isGetPageRoute) {\n      Get.log(\"GOING TO ROUTE ${newRoute.name}\");\n    }\n\n    RouterReportManager.reportCurrentRoute(route);\n    _routeSend?.update((value) {\n      // Only PageRoute is allowed to change current value\n      if (route is PageRoute) {\n        value.current = newRoute.name ?? '';\n      }\n      final previousRouteName = _extractRouteName(previousRoute);\n      if (previousRouteName != null) {\n        value.previous = previousRouteName;\n      }\n\n      value.args = route.settings.arguments;\n      value.route = route;\n      value.isBack = false;\n      value.removed = '';\n      value.isBottomSheet =\n          newRoute.isBottomSheet ? true : value.isBottomSheet ?? false;\n      value.isDialog = newRoute.isDialog ? true : value.isDialog ?? false;\n    });\n\n    if (routing != null) {\n      routing!(_routeSend);\n    }\n  }\n```\n\n看到 **_routeSend**更新了自身的属性值拿到了`route.settings.arguments`。\n\n**_routeSend**来自构造函数`GetObserver([this.routing, this._routeSend])`。而在**GetMaterialApp**中传递时是这样的：\n\n```dart\nGetObserver(routingCallback, Get.routing)\n```\n\n也就是说 **_routeSend**就是**Get.routing**，也就是`Routing get routing => _getxController.routing`\n\n这和上一节**arguments从哪获取的数据**说到的**Routing**是同一个值。\n\n就是说本节在调用`Get.toNamed()`后通过一些列流程最后更新了`_getxController.routing`值。\n\n然后`Get.arguments`调用拿到该值。"
  },
  {
    "title": "Flutter web部署后显示中文乱码",
    "created_time": "2020-08-20 14:31:25",
    "body": "web部署运行后页面中文会先显示带叉号的方格，然后过一会又刷新正常。\n\n通过查找发现有2种方式可以修复乱码问题。\n\n# 更换渲染方式\n\nFlutter web有2种渲染方式：**html**和**canvaskit**。\n\n打包时可以指定编码方式，也可以不指定，使用**auto**即默认方式。\n\n点击运行按钮时就是**auto**方式，移动端使用**html**，pc端使用**canvaskit**。\n\n问题源自**canvaskit**渲染方式，所以切换为**html**就好了。\n\n更换渲染方式有2种方式：\n\n## 命令行切换\n\ndebug 模式（使用 chrome 浏览器）\n\n`flutter run -d chrome --web-renderer html`\n\ndebug 模式（不指定浏览器）\n\n`flutter run -d web-server --web-renderer html`\n\nrelease 模式\n\n`flutter build web --web-renderer html`\n\n`flutter build web --web-renderer html --release`\n\n`flutter build web --web-renderer canvaskit --release`\n\n## 页面切换\n\n在`web/index.html`的`script`中添加：\n\n```javascript\nwindow.flutterWebRenderer = \"html\";\n```\n\n# 更换字体\n\n更换渲染方式会有其他问题，所以采用更换字体方式更合适。\n\n## 下载Roboto-Mono字体，进行配置：\n\n```yaml\n  fonts:\n    - family: RobotoMono\n      fonts:\n        - asset: fonts/RobotoMono-Bold.ttf\n        - asset: fonts/RobotoMono-Italic.ttf\n        - asset: fonts/RobotoMono-Regular.ttf\n```\n\n## 根widget使用字体\n\n```dart\nGetMaterialApp(\n      debugShowCheckedModeBanner: false,\n      title: '笔记',\n      theme: ThemeData(\n        colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple),\n        useMaterial3: true,\n        fontFamily: 'RobotoMono'//配置字体\n      ),\n      home: const MyHomePage(title: '笔记'),\n    );\n```"
  },
  {
    "title": "Flutter性能优化",
    "created_time": "2021-08-20 14:31:25",
    "body": "# 减少不必要的UI绘制\n\n缩小Widget刷新范围，越小越好。例如Provider的selector。\n\n使用Builder缩小Context范围，避免在State范围内调用`setState`。\n\n# 减少build中耗时和widget数量。\n\n# const widget\n\n对于dart语法，需要分清楚final和const关键字的区别。\n\n关键字final的意思是一次赋值，不能改变；\n\n关键字const的意思是常量，确定的值。\n\n这两者的区别是final变量在第一次使用时被初始化，\n\n而const 变量是一个编译时替换为常量值。\n\n同样const widget的widget在编译阶段就已经确定，不会有状态的变化和成员变量更新。\n\nconst widget特别适合于标签、特殊Icon等可以复用的UI，性能开销较小。\n\n# 圆角使用BoxDecoration替换Clipxxx\n\n# 耗时计算放到Isolate\n\n# 超大图片检测\n\nFlutter Inspector：点击 “Highlight Oversizeded Images”，\n\n它会识别出那些解码大小超过展示大小的图片，并且系统会将其倒置，\n\n这些你就能更容易在 App 页面中找到它。\n\n针对这些图片，你可以指定 cacheWidth 和 cacheHeight 为展示大小，\n\n这样可以让 flutter 引擎以指定大小解析图片，减少内存消耗。\n\n# RepaintBoundary区分变与不变图层\n\n对于经常刷新的Widget使用RepaintBoundary包裹起来成为一个单独的layer。\n\n# Opacity减少使用\n\n特别是动画中，淡入效果可以使用AnimatedOpacity和FadeInImage,透明效果可以设置widget的背景颜色实现。\n\n# 避免调用 saveLayer\n\n（调用 saveLayer() 会开辟一片离屏缓冲区。将内容绘制到离屏缓冲区可能会触发渲染目标切换，这些切换在较早期的 GPU 中特别慢）\n\n1 ShaderMask\n\n2 ColorFilter\n\n3 Chip -- might cause call to saveLayer() if disabledColorAlpha != 0xff （简单的圆角效果可以使用Container 实现）\n\n4 Text -- might cause call to saveLayer() if there’s an overflowShader\n\n# 分帧渲染\n\n复杂列表或者长列表使用分帧渲染减少卡顿。\n\n分帧渲染的原理是将一棵Widget树中的部分绘制时间较长的节点\n\n在第一帧时只占位不绘制，等到下一帧开始时，节点替换占位UI，单独使用一帧时间绘制。\n\n# 内存泄露\n\n内存泄漏是一个比较严重的问题，\n\n在监控方面Flutter现在比较通用的方法就是利用Expando中的弱引用去监控是否有泄漏的对象，如果出现则从VM中获取其引用链接，从而分析其泄漏原因。\n\n另外通过Flutter的Dev tool中的内存监控工具也能实现对泄漏对象的发现。"
  },
  {
    "title": "Flutter事件分析",
    "created_time": "2021-09-20 14:31:25",
    "body": "Flutter事件主要分为两大块。\n\n一是事件发生时在触摸范围内收集所有符合条件的Widget，这一流程叫**hitTest**。\n\n二是对收集的所有Widget进行事件分发，这一流程叫**dispatchEvent**。\n\n# hitTest\n\n首先**RendererBinding**调用`hitTest`：\n\n```dart\n  @override\n  void hitTest(HitTestResult result, Offset position) {\n    renderView.hitTest(result, position: position);\n    super.hitTest(result, position);\n  }\n```\n\n进入**renderView**的`hittest`：\n\n```dart\n  bool hitTest(HitTestResult result, { required Offset position }) {\n    if (child != null) {\n      child!.hitTest(BoxHitTestResult.wrap(result), position: position);\n    }\n    result.add(HitTestEntry(this));\n    return true;\n  }\n```\n\n看到这里调用了子**RenderObject**的`hitTest`方法，然后把自己封装加入到了**HitTestResult**。\n\n查看**RenderObject**的`hittest`：\n\n```dart\n  bool hitTest(BoxHitTestResult result, { required Offset position }) {\n    if (_size!.contains(position)) {\n      if (hitTestChildren(result, position: position) || hitTestSelf(position)) {\n        result.add(BoxHitTestEntry(this, position));\n        return true;\n      }\n    }\n    return false;\n  }\n```\n\n判断如果触摸点位包含在**RenderObject**大小内，就进行所有子**RenderObject**的`hitTest`\n\n这里`hitTestChildren`为空方法，实际调用内容在`defaultHitTestChildren`：\n\n```dart\n  bool defaultHitTestChildren(BoxHitTestResult result, { required Offset position }) {\n    ChildType? child = lastChild;\n    while (child != null) {\n      // The x, y parameters have the top left of the node's box as the origin.\n      final ParentDataType childParentData = child.parentData! as ParentDataType;\n      final bool isHit = result.addWithPaintOffset(\n        offset: childParentData.offset,\n        position: position,\n        hitTest: (BoxHitTestResult result, Offset transformed) {\n          assert(transformed == position - childParentData.offset);\n          return child!.hitTest(result, position: transformed);\n        },\n      );\n      if (isHit) {\n        return true;\n      }\n      child = childParentData.previousSibling;\n    }\n    return false;\n  }\n```\n\n---\n\n这里的逻辑很简单，就是从最后一个child开始判断，只要有一个符合就退出循环。\n\n为什么会有这种操作，估计是包含多个情况下，要么兄弟Widget之间位置不同，要么像**Stack**这种有重叠，但是实际看到的只有最后面的那个Widget。所以为了节省时间只取一个符合条件的。现在看来是没毛病的。\n\n返回上面的**hittest**看一下`\n\n```dart\n  if (hitTestChildren(result, position: position) || hitTestSelf(position)) {`\n```\n\n如果子RenderObject有符合条件德尔或者设置了**hitTestSelf返回true**，那么父RenderObject本身也会加入到**result**。\n\n这就形成了一条顺序链`HitTestResult._path`。\n\nhitTest采取深度优先原则符合条件的封装加入到**HitTestResult**\n\n越深的越排序靠前，遍历时最先取出。\n\n# dispatchEvent\n\n**GestureBinding**调用`dispatchEvent`\n\n```dart\n  void dispatchEvent(PointerEvent event, HitTestResult? hitTestResult) {\n    for (final HitTestEntry entry in hitTestResult.path) {\n      try {\n        entry.target.handleEvent(event.transformed(entry.transform), entry);\n      } catch (exception, stack) {\n        FlutterError.reportError(FlutterErrorDetailsForPointerEventDispatcher(\n          exception: exception,\n          stack: stack,\n          library: 'gesture library',\n          context: ErrorDescription('while dispatching a pointer event'),\n          event: event,\n          hitTestEntry: entry,\n          informationCollector: () => <DiagnosticsNode>[\n            DiagnosticsProperty<PointerEvent>('Event', event, style: DiagnosticsTreeStyle.errorProperty),\n            DiagnosticsProperty<HitTestTarget>('Target', entry.target, style: DiagnosticsTreeStyle.errorProperty),\n          ],\n        ));\n      }\n    }\n  }\n```\n\n遍历`hitTestResult`调用`handleEvent`处理事件，\n\n这里的**target**是**RenderObject**子类**RenderPointerListener**：\n\n```dart\n  @override\n  void handleEvent(PointerEvent event, HitTestEntry entry) {\n    assert(debugHandleEvent(event, entry));\n    if (event is PointerDownEvent) {\n      return onPointerDown?.call(event);\n    }\n    if (event is PointerMoveEvent) {\n      return onPointerMove?.call(event);\n    }\n    if (event is PointerUpEvent) {\n      return onPointerUp?.call(event);\n    }\n    if (event is PointerHoverEvent) {\n      return onPointerHover?.call(event);\n    }\n    if (event is PointerCancelEvent) {\n      return onPointerCancel?.call(event);\n    }\n    if (event is PointerPanZoomStartEvent) {\n      return onPointerPanZoomStart?.call(event);\n    }\n    if (event is PointerPanZoomUpdateEvent) {\n      return onPointerPanZoomUpdate?.call(event);\n    }\n    if (event is PointerPanZoomEndEvent) {\n      return onPointerPanZoomEnd?.call(event);\n    }\n    if (event is PointerSignalEvent) {\n      return onPointerSignal?.call(event);\n    }\n  }\n```\n\n这里所有**onPointerxxx**变量都是从构造函数传过来的。\n\n创建RenderObject对象是由Widget调用的，比如**Listener**：\n\n```dart\n  @override\n  RenderPointerListener createRenderObject(BuildContext context) {\n    return RenderPointerListener(\n      onPointerDown: onPointerDown,\n      onPointerMove: onPointerMove,\n      onPointerUp: onPointerUp,\n      onPointerHover: onPointerHover,\n      onPointerCancel: onPointerCancel,\n      onPointerPanZoomStart: onPointerPanZoomStart,\n      onPointerPanZoomUpdate: onPointerPanZoomUpdate,\n      onPointerPanZoomEnd: onPointerPanZoomEnd,\n      onPointerSignal: onPointerSignal,\n      behavior: behavior,\n    );\n  }\n```\n\n所以这里就是调用从**Listener**传递过来的事件进行响应。\n\n## listener测试\n\n嵌套一个Listener进行事件测试：\n\n```dart\n  Listener buildListener() {\n    return Listener(\n      onPointerUp: (event) {\n        print('父 onPointerUp');\n      },\n      onPointerDown: (event) {\n        print('父 onPointerDown');\n      },\n      child: Listener(\n        onPointerUp: (event) {\n          print('子 onPointerUp');\n        },\n        onPointerDown: (event) {\n          print('子 onPointerDown');\n        },\n        child: const Text(\n          'Listener测试',\n        ),\n      ),\n    );\n  }\n```\n\n```\n2023-09-14 11:12:10.681 11012-11040 flutter                 com.example.untitled                 I  子 onPointerDown\n2023-09-14 11:12:10.681 11012-11040 flutter                 com.example.untitled                 I  父 onPointerDown\n2023-09-14 11:12:10.743 11012-11040 flutter                 com.example.untitled                 I  子 onPointerUp\n2023-09-14 11:12:10.743 11012-11040 flutter                 com.example.untitled                 I  父 onPointerUp\n```\n\n可以看到先调用了子Widget再调用了父Widget，这符合**hittest**中的深度优先。\n\n## 手势竞技\n\n基本流程完了，但是好像还没有看到手势竞技代码。\n\n手势竞技需要在有手势分析处理的Widget才有，比如**GestureDetector**：\n\n```dart\n  Widget build(BuildContext context) {\n    final Map<Type, GestureRecognizerFactory> gestures = <Type, GestureRecognizerFactory>{};\n    final DeviceGestureSettings? gestureSettings = MediaQuery.maybeGestureSettingsOf(context);\n\n    if (onTapDown != null ||\n        onTapUp != null ||\n        onTap != null ||\n        onTapCancel != null ||\n        onSecondaryTap != null ||\n        onSecondaryTapDown != null ||\n        onSecondaryTapUp != null ||\n        onSecondaryTapCancel != null||\n        onTertiaryTapDown != null ||\n        onTertiaryTapUp != null ||\n        onTertiaryTapCancel != null\n    ) {\n      gestures[TapGestureRecognizer] = GestureRecognizerFactoryWithHandlers<TapGestureRecognizer>(\n        () => TapGestureRecognizer(debugOwner: this, supportedDevices: supportedDevices),\n        (TapGestureRecognizer instance) {\n          instance\n            ..onTapDown = onTapDown\n            ..onTapUp = onTapUp\n            ..onTap = onTap\n            ..onTapCancel = onTapCancel\n            ..onSecondaryTap = onSecondaryTap\n            ..onSecondaryTapDown = onSecondaryTapDown\n            ..onSecondaryTapUp = onSecondaryTapUp\n            ..onSecondaryTapCancel = onSecondaryTapCancel\n            ..onTertiaryTapDown = onTertiaryTapDown\n            ..onTertiaryTapUp = onTertiaryTapUp\n            ..onTertiaryTapCancel = onTertiaryTapCancel\n            ..gestureSettings = gestureSettings\n            ..supportedDevices = supportedDevices;\n        },\n      );\n    }\n\n    if (onDoubleTap != null ||\n        onDoubleTapDown != null ||\n        onDoubleTapCancel != null) {\n      gestures[DoubleTapGestureRecognizer] = GestureRecognizerFactoryWithHandlers<DoubleTapGestureRecognizer>(\n        () => DoubleTapGestureRecognizer(debugOwner: this, supportedDevices: supportedDevices),\n        (DoubleTapGestureRecognizer instance) {\n          instance\n            ..onDoubleTapDown = onDoubleTapDown\n            ..onDoubleTap = onDoubleTap\n            ..onDoubleTapCancel = onDoubleTapCancel\n            ..gestureSettings = gestureSettings\n            ..supportedDevices = supportedDevices;\n        },\n      );\n    }\n\n    if (onLongPressDown != null ||\n        onLongPressCancel != null ||\n        onLongPress != null ||\n        onLongPressStart != null ||\n        onLongPressMoveUpdate != null ||\n        onLongPressUp != null ||\n        onLongPressEnd != null ||\n        onSecondaryLongPressDown != null ||\n        onSecondaryLongPressCancel != null ||\n        onSecondaryLongPress != null ||\n        onSecondaryLongPressStart != null ||\n        onSecondaryLongPressMoveUpdate != null ||\n        onSecondaryLongPressUp != null ||\n        onSecondaryLongPressEnd != null ||\n        onTertiaryLongPressDown != null ||\n        onTertiaryLongPressCancel != null ||\n        onTertiaryLongPress != null ||\n        onTertiaryLongPressStart != null ||\n        onTertiaryLongPressMoveUpdate != null ||\n        onTertiaryLongPressUp != null ||\n        onTertiaryLongPressEnd != null) {\n      gestures[LongPressGestureRecognizer] = GestureRecognizerFactoryWithHandlers<LongPressGestureRecognizer>(\n        () => LongPressGestureRecognizer(debugOwner: this, supportedDevices: supportedDevices),\n        (LongPressGestureRecognizer instance) {\n          instance\n            ..onLongPressDown = onLongPressDown\n            ..onLongPressCancel = onLongPressCancel\n            ..onLongPress = onLongPress\n            ..onLongPressStart = onLongPressStart\n            ..onLongPressMoveUpdate = onLongPressMoveUpdate\n            ..onLongPressUp = onLongPressUp\n            ..onLongPressEnd = onLongPressEnd\n            ..onSecondaryLongPressDown = onSecondaryLongPressDown\n            ..onSecondaryLongPressCancel = onSecondaryLongPressCancel\n            ..onSecondaryLongPress = onSecondaryLongPress\n            ..onSecondaryLongPressStart = onSecondaryLongPressStart\n            ..onSecondaryLongPressMoveUpdate = onSecondaryLongPressMoveUpdate\n            ..onSecondaryLongPressUp = onSecondaryLongPressUp\n            ..onSecondaryLongPressEnd = onSecondaryLongPressEnd\n            ..onTertiaryLongPressDown = onTertiaryLongPressDown\n            ..onTertiaryLongPressCancel = onTertiaryLongPressCancel\n            ..onTertiaryLongPress = onTertiaryLongPress\n            ..onTertiaryLongPressStart = onTertiaryLongPressStart\n            ..onTertiaryLongPressMoveUpdate = onTertiaryLongPressMoveUpdate\n            ..onTertiaryLongPressUp = onTertiaryLongPressUp\n            ..onTertiaryLongPressEnd = onTertiaryLongPressEnd\n            ..gestureSettings = gestureSettings\n            ..supportedDevices = supportedDevices;\n        },\n      );\n    }\n\n    if (onVerticalDragDown != null ||\n        onVerticalDragStart != null ||\n        onVerticalDragUpdate != null ||\n        onVerticalDragEnd != null ||\n        onVerticalDragCancel != null) {\n      gestures[VerticalDragGestureRecognizer] = GestureRecognizerFactoryWithHandlers<VerticalDragGestureRecognizer>(\n        () => VerticalDragGestureRecognizer(debugOwner: this, supportedDevices: supportedDevices),\n        (VerticalDragGestureRecognizer instance) {\n          instance\n            ..onDown = onVerticalDragDown\n            ..onStart = onVerticalDragStart\n            ..onUpdate = onVerticalDragUpdate\n            ..onEnd = onVerticalDragEnd\n            ..onCancel = onVerticalDragCancel\n            ..dragStartBehavior = dragStartBehavior\n            ..gestureSettings = gestureSettings\n            ..supportedDevices = supportedDevices;\n        },\n      );\n    }\n\n    if (onHorizontalDragDown != null ||\n        onHorizontalDragStart != null ||\n        onHorizontalDragUpdate != null ||\n        onHorizontalDragEnd != null ||\n        onHorizontalDragCancel != null) {\n      gestures[HorizontalDragGestureRecognizer] = GestureRecognizerFactoryWithHandlers<HorizontalDragGestureRecognizer>(\n        () => HorizontalDragGestureRecognizer(debugOwner: this, supportedDevices: supportedDevices),\n        (HorizontalDragGestureRecognizer instance) {\n          instance\n            ..onDown = onHorizontalDragDown\n            ..onStart = onHorizontalDragStart\n            ..onUpdate = onHorizontalDragUpdate\n            ..onEnd = onHorizontalDragEnd\n            ..onCancel = onHorizontalDragCancel\n            ..dragStartBehavior = dragStartBehavior\n            ..gestureSettings = gestureSettings\n            ..supportedDevices = supportedDevices;\n        },\n      );\n    }\n\n    if (onPanDown != null ||\n        onPanStart != null ||\n        onPanUpdate != null ||\n        onPanEnd != null ||\n        onPanCancel != null) {\n      gestures[PanGestureRecognizer] = GestureRecognizerFactoryWithHandlers<PanGestureRecognizer>(\n        () => PanGestureRecognizer(debugOwner: this, supportedDevices: supportedDevices),\n        (PanGestureRecognizer instance) {\n          instance\n            ..onDown = onPanDown\n            ..onStart = onPanStart\n            ..onUpdate = onPanUpdate\n            ..onEnd = onPanEnd\n            ..onCancel = onPanCancel\n            ..dragStartBehavior = dragStartBehavior\n            ..gestureSettings = gestureSettings\n            ..supportedDevices = supportedDevices;\n        },\n      );\n    }\n\n    if (onScaleStart != null || onScaleUpdate != null || onScaleEnd != null) {\n      gestures[ScaleGestureRecognizer] = GestureRecognizerFactoryWithHandlers<ScaleGestureRecognizer>(\n        () => ScaleGestureRecognizer(debugOwner: this, supportedDevices: supportedDevices),\n        (ScaleGestureRecognizer instance) {\n          instance\n            ..onStart = onScaleStart\n            ..onUpdate = onScaleUpdate\n            ..onEnd = onScaleEnd\n            ..dragStartBehavior = dragStartBehavior\n            ..gestureSettings = gestureSettings\n            ..trackpadScrollCausesScale = trackpadScrollCausesScale\n            ..trackpadScrollToScaleFactor = trackpadScrollToScaleFactor\n            ..supportedDevices = supportedDevices;\n        },\n      );\n    }\n\n    if (onForcePressStart != null ||\n        onForcePressPeak != null ||\n        onForcePressUpdate != null ||\n        onForcePressEnd != null) {\n      gestures[ForcePressGestureRecognizer] = GestureRecognizerFactoryWithHandlers<ForcePressGestureRecognizer>(\n        () => ForcePressGestureRecognizer(debugOwner: this, supportedDevices: supportedDevices),\n        (ForcePressGestureRecognizer instance) {\n          instance\n            ..onStart = onForcePressStart\n            ..onPeak = onForcePressPeak\n            ..onUpdate = onForcePressUpdate\n            ..onEnd = onForcePressEnd\n            ..gestureSettings = gestureSettings\n            ..supportedDevices = supportedDevices;\n        },\n      );\n    }\n\n    return RawGestureDetector(\n      gestures: gestures,\n      behavior: behavior,\n      excludeFromSemantics: excludeFromSemantics,\n      child: child,\n    );\n  }\n```\n\ns上面代码尝试把几种手势识别如**TapGestureRecognizer**存到**gestures**，传给**RawGestureDetector**，这是一个**StatefulWidget**，查看它的State **RawGestureDetectorState**\n\n```dart\n  @override\n  void initState() {\n    super.initState();\n    _semantics = widget.semantics ?? _DefaultSemanticsGestureDelegate(this);\n    _syncAll(widget.gestures);\n  }\n  \n    void _syncAll(Map<Type, GestureRecognizerFactory> gestures) {\n    assert(_recognizers != null);\n    final Map<Type, GestureRecognizer> oldRecognizers = _recognizers!;\n    _recognizers = <Type, GestureRecognizer>{};\n    for (final Type type in gestures.keys) {\n      assert(gestures[type] != null);\n      assert(gestures[type]!._debugAssertTypeMatches(type));\n      assert(!_recognizers!.containsKey(type));\n      _recognizers![type] = oldRecognizers[type] ?? gestures[type]!.constructor();\n      assert(_recognizers![type].runtimeType == type, 'GestureRecognizerFactory of type $type created a GestureRecognizer of type ${_recognizers![type].runtimeType}. The GestureRecognizerFactory must be specialized with the type of the class that it returns from its constructor method.');\n      gestures[type]!.initializer(_recognizers![type]!);\n    }\n    for (final Type type in oldRecognizers.keys) {\n      if (!_recognizers!.containsKey(type)) {\n        oldRecognizers[type]!.dispose();\n      }\n    }\n  }\n```\n\n这里的 **_syncAll**把**gestures**转存到了 **_recognizers**。\n\n查看**build**：\n\n```dart\n  @override\n  Widget build(BuildContext context) {\n    Widget result = Listener(\n      onPointerDown: _handlePointerDown,\n      onPointerPanZoomStart: _handlePointerPanZoomStart,\n      behavior: widget.behavior ?? _defaultBehavior,\n      child: widget.child,\n    );\n    if (!widget.excludeFromSemantics) {\n      result = _GestureSemantics(\n        behavior: widget.behavior ?? _defaultBehavior,\n        assignSemantics: _updateSemanticsForRenderObject,\n        child: result,\n      );\n    }\n    return result;\n  }\n```\n\n这里同样调用了**Listener**控件，看看 **_handlePointerDown**：\n\n```dart\n  void _handlePointerDown(PointerDownEvent event) {\n    assert(_recognizers != null);\n    for (final GestureRecognizer recognizer in _recognizers!.values) {\n      recognizer.addPointer(event);\n    }\n  }\n```\n\n把事件添加到对应的**recognizer**，如果只设置了**onTap**事件，那么这里的**recognizer**就是**TapGestureRecognizer**。\n\n```dart\n  void addPointer(PointerDownEvent event) {\n    _pointerToKind[event.pointer] = event.kind;\n    if (isPointerAllowed(event)) {\n      addAllowedPointer(event);\n    } else {\n      handleNonAllowedPointer(event);\n    }\n  }\n```\n\n这里的**addAllowedPointer**实现在**BaseTapGestureRecognizer**：\n\n```dart\n  @override\n  void addAllowedPointer(PointerDownEvent event) {\n    if (state == GestureRecognizerState.ready) {\n      // If there is no result in the previous gesture arena,\n      // we ignore them and prepare to accept a new pointer.\n      if (_down != null && _up != null) {\n        assert(_down!.pointer == _up!.pointer);\n        _reset();\n      }\n\n      assert(_down == null && _up == null);\n      // `_down` must be assigned in this method instead of `handlePrimaryPointer`,\n      // because `acceptGesture` might be called before `handlePrimaryPointer`,\n      // which relies on `_down` to call `handleTapDown`.\n      _down = event;\n    }\n    if (_down != null) {\n      // This happens when this tap gesture has been rejected while the pointer\n      // is down (i.e. due to movement), when another allowed pointer is added,\n      // in which case all pointers are ignored. The `_down` being null\n      // means that _reset() has been called, since it is always set at the\n      // first allowed down event and will not be cleared except for reset(),\n      super.addAllowedPointer(event);\n    }\n  }\n```\n\n经过连续调用到了**OneSequenceGestureRecognizer**的**startTrackingPointer**：\n\n```dart\n  @protected\n  void startTrackingPointer(int pointer, [Matrix4? transform]) {\n    GestureBinding.instance.pointerRouter.addRoute(pointer, handleEvent, transform);\n    _trackedPointers.add(pointer);\n    // TODO(goderbauer): Enable assert after recognizers properly clean up their defunct `_entries`, see https://github.com/flutter/flutter/issues/117356.\n    // assert(!_entries.containsKey(pointer));\n    _entries[pointer] = _addPointerToArena(pointer);\n  }\n```\n\n这里就做了两件事：\n\n`GestureBinding.instance.pointerRouter.addRoute(pointer, handleEvent, transform);`加入到**pointerRouter**的 **_routeMap**。\n\n`GestureBinding.instance.gestureArena.add(pointer, this);`加入到**GestureArenaManager**的 **_arenas**。\n\n## GestureBinding\n\n上面把事件加入到那两个Map里就完事了，但是竞技还没开始，\n\n回到最开始的**RenderBinding**的**hittest**：\n\n```dart\n  @override\n  void hitTest(HitTestResult result, Offset position) {\n    renderView.hitTest(result, position: position);\n    super.hitTest(result, position);\n  }\n```\n\n这里的**super.hitTest**就是**GestureBinding**：\n\n```dart\n    result.add(HitTestEntry(this));\n```\n\n**GestureBinding**把自己加入到了最后，那么看看它的**handleEvent**：\n\n```dart\n  @override // from HitTestTarget\n  void handleEvent(PointerEvent event, HitTestEntry entry) {\n    pointerRouter.route(event);\n    if (event is PointerDownEvent || event is PointerPanZoomStartEvent) {\n      gestureArena.close(event.pointer);\n    } else if (event is PointerUpEvent || event is PointerPanZoomEndEvent) {\n      gestureArena.sweep(event.pointer);\n    } else if (event is PointerSignalEvent) {\n      pointerSignalResolver.resolve(event);\n    }\n  }\n```\n\n## PointerDownEvent\n\n如果是**PointerDownEvent**，看下**close**方法：\n\n```dart\n  void close(int pointer) {\n    final _GestureArena? state = _arenas[pointer];\n    if (state == null) {\n      return; // This arena either never existed or has been resolved.\n    }\n    state.isOpen = false;\n    assert(_debugLogDiagnostic(pointer, 'Closing', state));\n    _tryToResolveArena(pointer, state);\n  }\n```\n\n如果像Listener测试里只使用Listener控件时，没有涉及手势和竞技场添加，所以这里**state==null**，不会继续执行的。\n\n相反如果使用**GestureDetector**涉及了手势，会执行 **_tryToResolveArena**：\n\n```dart\n  void _tryToResolveArena(int pointer, _GestureArena state) {\n    assert(_arenas[pointer] == state);\n    assert(!state.isOpen);\n    if (state.members.length == 1) {\n      scheduleMicrotask(() => _resolveByDefault(pointer, state));\n    } else if (state.members.isEmpty) {\n      _arenas.remove(pointer);\n      assert(_debugLogDiagnostic(pointer, 'Arena empty.'));\n    } else if (state.eagerWinner != null) {\n      assert(_debugLogDiagnostic(pointer, 'Eager winner: ${state.eagerWinner}'));\n      _resolveInFavorOf(pointer, state, state.eagerWinner!);\n    }\n  }\n```\n\n如果是**PointerDownEvent**且竞技场成员只有一个，那么胜出者就是它，否则胜出者是**eagerWinner**。\n\n## PointerUpEvent\n\n看下**sweep**方法：\n\n```dart\n  void sweep(int pointer) {\n    final _GestureArena? state = _arenas[pointer];\n    if (state == null) {\n      return; // This arena either never existed or has been resolved.\n    }\n    assert(!state.isOpen);\n    if (state.isHeld) {\n      state.hasPendingSweep = true;\n      assert(_debugLogDiagnostic(pointer, 'Delaying sweep', state));\n      return; // This arena is being held for a long-lived member.\n    }\n    assert(_debugLogDiagnostic(pointer, 'Sweeping', state));\n    _arenas.remove(pointer);\n    if (state.members.isNotEmpty) {\n      // First member wins.\n      assert(_debugLogDiagnostic(pointer, 'Winner: ${state.members.first}'));\n      state.members.first.acceptGesture(pointer);\n      // Give all the other members the bad news.\n      for (int i = 1; i < state.members.length; i++) {\n        state.members[i].rejectGesture(pointer);\n      }\n    }\n  }\n```\n\n触摸抬起时，成员不为空，强制第一个成员接收事件。\n\n也就是说如果**GestureDetector**嵌套了，那么只会调用最深层的**GestureDetector**相关事件，比如**onTapUp**。"
  }
]