[
  {
    "title": "5L杯子和3L杯子取出4L水的问题",
    "created_time": "2017-09-20 17:23:02",
    "body": "# 0x00 前言\r\n\r\n这道题和我之前的农夫过河、四人过桥问题都是一个类型的，不过该题较之前两道题更简单，因为涉及 元素更少。\r\n\r\n下面直接说下思路\r\n\r\n<!-- more -->\r\n\r\n# 0x01 思路\r\n\r\n4L和5L、3L的杯子有什么关系？找到关系，再从关系入手\r\n\r\n譬如4L可以用1L和3L合并得来，而3L可以直接通过3L杯子拿到。\r\n\r\n接下来就是如何拿到1L的量，而这又可以通过3L-2L得到，那么再继续2L又是如何得到呢？\r\n\r\n有现成的5L和3L，简单的就可以得到2L，所以实现步骤就很简单了：\r\n\r\n|  步骤  |   操作   | 5L杯子 | 3L杯子 |\r\n| :--: | :----: | :--: | :--: |\r\n|  1   |  3L装满  |  0   |  3   |\r\n|  2   | 3L倒入5L |  3   |  0   |\r\n|  3   |  3L装满  |  3   |  3   |\r\n|  4   | 3L倒入5L |  5   |  1   |\r\n|  5   |  5L清空  |  0   |  1   |\r\n|  6   | 3L倒入5L |  1   |  0   |\r\n|  7   |  3L装满  |  1   |  3   |\r\n|  8   | 3L倒入5L |  4   |  0   |\r\n|  9   |   完成   |  4   |  0   |\r\n\r\n上面是通过1L和3L合并得来的，下面通过5L-1L得到4L，下面看看实现步骤：\r\n\r\n| 步骤   | 操作     | 5L杯子 | 3L杯子 |\r\n| ---- | ------ | ---- | ---- |\r\n| 1    | 5L装满   | 5    | 0    |\r\n| 2    | 5L倒入3L | 2    | 3    |\r\n| 3    | 3L清空   | 2    | 0    |\r\n| 4    | 5L倒入3L | 0    | 2    |\r\n| 5    | 5L装满   | 5    | 2    |\r\n| 6    | 5L倒入3L | 4    | 3    |\r\n| 7    | 完成     | 4    | 3    |\r\n|      |        |      |      |\r\n\r\n这种方式实现步骤更简单一些。细想一下会发现，这两种方式都有点类似递归"
  },
  {
    "title": "反转字符串",
    "created_time": "2017-07-27 13:28:07",
    "body": "# 0x00 前言\r\n\r\n比如abc，反转后cba\r\n\r\n\r\n\r\n# 0x01 实现\r\n\r\n```java\r\n\tpublic static String reverseStr(String str) {\r\n\t\tStringBuilder sb = new StringBuilder();\r\n\t\tfor (int i = str.length() - 1; i >= 0; i--) {\r\n\t\t\tsb.append(str.charAt(i));\r\n\t\t}\r\n\t\treturn sb.toString();\r\n\t}\r\n```\r\n\r\n上面这种是遍历所有字符串长度，复杂度为O(n)。\r\n\r\n<!-- more -->\r\n\r\n应该还有更好的方法:\r\n\r\n```java\r\n\tpublic static String reverse(String str) {\r\n\t\tint len = str.length();\r\n\t\tint max = len - 1;\r\n\t\tchar[] chars = str.toCharArray();\r\n\t\tfor (int i = 0; i < (len >> 1); i++) {\r\n\t\t\tchar pre = str.charAt(i);\r\n\t\t\tchar last = str.charAt(max);\r\n\t\t\tchars[i] = last;\r\n\t\t\tchars[max] = pre;\r\n\t\t\tmax--;\r\n\t\t}\r\n\t\treturn String.valueOf(chars);\r\n\t}\r\n```"
  },
  {
    "title": "垃圾回收机制~关于GC",
    "created_time": "2017-07-26 20:25:26",
    "body": "# 0x00 前言\r\n\r\n很多人通过Java才听说GC的，甚至刚开始做开发时以为GC是Java独有的。其实不然，GC是一项很古老的技术，与Lisp语言在20世纪60年代一同出现的。\r\n\r\n虽然GC不是Java独有的，但是不得不承认，GC很大成分上是因为Java的广泛应用才被广大开发者所熟知的。\r\n\r\n说到GC不得不提一个人：John McCarthy，Lisp语言之父和人工智能之父，同时还是GC之父，其论文中提到的算法就是标记-清除算法。\r\n\r\n如果是一门语言可以从基础语法学起，但是GC该如何学习呢？\r\n\r\n**其实问答形式就是最好的学习方式**\r\n\r\n# 0x01 什么是GC\r\n\r\nGC(垃圾回收)，通过查找无效对象释放空间达到自动管理内存的目的。\r\n\r\n<!-- more -->\r\n\r\n# 0x02 如何确定垃圾\r\n\r\n要查找垃圾对象，首先要知道什么样对象才算是垃圾对象才好对症下药。\r\n\r\n**在内存中，不再被引用的对象就称为垃圾对象**\r\n\r\n现在的问题又转到如何确定一个对象是否被引用？\r\n\r\n首先想到一种方法是给每个对象都添加一个计数器功能，这个计数器用例记录引用自己的指针数量，每多一个引用数量计数器就增加1，每减少一个引用数量计数器就减少1，如果计数器为0，说明没有其他对象引用当前对象，那么这个对象就是垃圾对象，可以被回收。这种方式叫做**引用计数法**\r\n\r\n引用计数法虽然容易理解，但是因为缺点也很明显，所以不得不另寻它法。这时**可达性分析法**就登场了。\r\n\r\n**可达性分析法**也可以称为**跟踪收集器法**，找一个对象作为GC的根节点(Root)，通过对对象的连续引用形成一条引用链，如果一个对象能够通过直接或间接的到达Root称为对象可达，否则称为对象不可达。对于不可达对象就可以判定为垃圾对象。\r\n\r\n\r\n\r\n# 0x03 如何回收垃圾\r\n\r\n上一节知道了哪些对象是垃圾，现在该讨论有哪些方式能回收垃圾了。\r\n\r\n常用的GC算法有**标记-清除算法**、**标记-整理算法**、**复制算法**、**分代GC**、**G1 GC**。\r\n\r\n## 标记-清除算法\r\n\r\n**标记-清除算法(Mark-Weep)**看名字就知道分为标记和清除两个阶段。\r\n\r\n**注意一点这里的标记是指标记活着的对象，而非死对象。**\r\n\r\n**标记阶段**从Root开始首先标记Root能直接访问的对象，然后递归通过指针能访问到得对象，同时把这些对象做标记。\r\n\r\n**清除阶段**遍历堆内存，把未被标记的对象清除以达到垃圾回收目的。\r\n\r\n图片表示如下：\r\n\r\n![标记清除](http:\/\/othg5ggzi.bkt.clouddn.com\/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4.png)\r\n\r\n图中问题很明显：回收后会产生大量的内存碎片，不利于对内存连续要求的数据结构的使用，譬如数组。\r\n\r\n\r\n\r\n## 标记-整理算法\r\n\r\n**标记-整理算法也叫标记-压缩**，这里的标记阶段和上面的标记-清除的标记阶段完全一样，不同的是整理阶段是对清除阶段的改进。\r\n\r\n整理阶段简单来说就是把活着的对象移动到一端，然后从边界处清除另一端所有空间。\r\n\r\n图片表示如下：\r\n\r\n![标记整理](http:\/\/othg5ggzi.bkt.clouddn.com\/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86.png)\r\n\r\n\r\n\r\n优点是有效利用堆，但又不会产生内存碎片。\r\n\r\n缺点是浪费时间，整理阶段要搜索三次堆内存，而标记-清除算法的清除阶段只搜索一次堆内存。\r\n\r\n\r\n\r\n## 复制算法\r\n\r\n**复制算法**是把堆内存分为两块空间标识为from和to。当from空间被占满时，GC把活着的对象复制到to空间，复制完成后把from和to标识互换，GC结束。为了保证from空间对象都能复制到to空间，须要保证from和to空间大小一致。\r\n\r\n图片表示如下：\r\n\r\n![复制算法](http:\/\/othg5ggzi.bkt.clouddn.com\/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png)\r\n\r\n\r\n\r\n复制算法吞吐量优秀，分配内存速度快，没有碎片，但是堆内存利用率低下\r\n\r\n\r\n\r\n## 分代GC\r\n\r\n根据日常研发总结出一个经验“大部分对象在生成后不久就变成垃圾，很少能活的久”。据此经验，分代GC引入了“年龄”的概念。经历过一次GC后活下来的对象年龄+1。\r\n\r\n**分代GC**把内存分为新生代和老年代，针对不同的年代使用不同的GC算法。刚生产的对象称为新生代对象，活到一定年龄的称为老年代对象。\r\n\r\n我们把对新对象执行的GC称为**新生代GC(minor GC)**， 把老年代对象执行的GC称为**老年代GC(major GC)**。\r\n\r\n**分代GC属于综合性GC，对上面GC算法的综合使用。**\r\n\r\n图片表示如下：\r\n\r\n![分代GC](http:\/\/othg5ggzi.bkt.clouddn.com\/%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6.png)\r\n\r\n如图所示：**新生代空间包括Eden，S0和S1三个区，老年代空间是Old区**\r\n\r\n其中新生代每次回收只有少数对象存活，可以使用复制算法，而老年代对象存活率高也没用额外空间，可以使用标记-整理和标记清除算法。\r\n\r\n刚开始时，Eden用来存放刚创建的对象，S0和S1为空，如果发生GC，Eden区幸存对象转移到S0区，如果S0区已有数据前提下再次进行GC时，会把Eden和S0区存活对象转移到S1区，同时清空Eden和S0，然后交换S0和S1标识。经过一定次数的GC仍然存活的对象转移到老年代。\r\n\r\n\r\n\r\n## G1 GC\r\n\r\n\r\n\r\n\r\n\r\n# 0x04 谁来回收垃圾\r\n\r\n知道了哪些对象是垃圾，也知道了用哪些算法来回收垃圾，然后呢？直接满地调用算法回收垃圾吗？\r\n\r\n当然不是！GC要分时机且统一来回收垃圾，这里是由垃圾收集器来来根据时机统一回收垃圾对象。\r\n\r\n由于各方面需求原因，垃圾收集器也是有多种的。\r\n\r\n\r\n\r\n未完待续......."
  },
  {
    "title": "了解Http",
    "created_time": "2017-08-30 11:57:11",
    "body": "# 0x00 前言\r\n\r\n只要是编程，无论学哪种语言，网络就是逃不开的话题，而Http又是网络上层协议应用最广泛的一种。\r\n\r\n那么该如何学习Http？下图是个人总结的学习Http比较容易让人记忆的思维导图。下面的介绍也是按照该四维导图来说明。\r\n\r\n![了解Http](http:\/\/othg5ggzi.bkt.clouddn.com\/%E4%BA%86%E8%A7%A3http.png)\r\n\r\n<!-- more -->\r\n\r\n# 0x01 Http历史\r\n\r\n## 一次web请求\r\n\r\n当我们在浏览器URL窗口输入www.jensondev.me时，就会看到我们需要的内容。这期间发生了什么？\r\n\r\n懂一点的人会说浏览器收到URL请求，发送给服务器，然后接收服务器内容并显示。\r\n\r\n更懂一点的人会说浏览器收到URL进行DNS解析，发送给服务器，然后接收服务器内容并显示\r\n\r\n那么什么是DNS，什么又是URL，又都有什么用？\r\n\r\n## DNS\r\n\r\nDNS，全名Domain Name System，域名解析系统。\r\n\r\n域名的出现是为了方便记忆，但是通过网络定位到对应服务器需要的是IP，DNS就是提供域名到IP得解析服务。\r\n\r\n## URL和URI\r\n\r\nURL，Uniform Resource Locator，统一资源定位符，URL就是浏览器访问页面输入的网址。\r\n\r\nURI，Uniform Resource Identifier ，统一资源标识符，\r\n\r\nURI表示互联网中某一资源，而URL表示资源的地点。URL是URI子集。\r\n\r\nURI格式如图：\r\n\r\n![URI格式](http:\/\/othg5ggzi.bkt.clouddn.com\/URI%E6%A0%BC%E5%BC%8F.png)\r\n\r\n## Http诞生\r\n\r\n1989年CERN的Tim Berners-Lee提出让身处两地的研究者进行交流和知识共享的设想。\r\n\r\n当时的理念很简单很纯粹：就是借助多文档相互关联形成一个超文本，形成可以相互参阅的WWW。\r\n\r\n这一理念的实现需要三个技术共同支撑：指定文档地址的URL，标记文本的语言HTML，传输文档的协议Http。\r\n\r\n1990年CERN研发世界第一台Web服务器和浏览器。同年Http协议诞生，但是没有作为标准被建立，所以这个时候版本是1.0以前，被称为Http0.9。\r\n\r\n1995年6月Http标准被公布，正式命名为Http1.0\r\n\r\n1997年1月Http1.1公布，也是目前的主流版本。\r\n\r\n\r\n\r\n## TCP\/IP\r\n\r\n上面介绍了Http的历史信息，但是Http是基于TCPIP的，要了解Http还要了解下TCPIP。\r\n\r\n电脑之间如何通信？\r\n\r\n要实现电脑之间通信要适用不同的硬件、不同的语言、不同的系统。而这需要一个通用的协议。\r\n\r\nTCPIP就是在这基础上诞生的，TCPIP从上至下分为4层：应用层、传输层、网络层和数据链路层。\r\n\r\n![TCPIP分层](http:\/\/othg5ggzi.bkt.clouddn.com\/TCPIP%E5%88%86%E5%B1%82.png)\r\n\r\n把 TCP\/IP 层次化是有好处的。比如，如果互联网只由一个协议统筹，某个地方需要改变设计时，就必须把所有部分整体替换掉。而分层之后只需把变动的层替换掉即可。把各层之间的接口部分规划好之后，每个层次内部的设计就能够自由改动了。\r\n\r\n数据流每经过一层都会添加当前层首部信息：\r\n\r\n![tcpip首部](http:\/\/othg5ggzi.bkt.clouddn.com\/TCPIP%E5%88%86%E5%B1%82%E9%A6%96%E9%83%A8.png)\r\n\r\n\r\n\r\n\r\n\r\n# 0x02 初涉Http\r\n\r\n## 无状态\r\n\r\nHttp协议设计简洁，仅仅实现数据交互，所以也是无状态协议。HTTP 协议自身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理。\r\n\r\n但是随着web的发展，很多网站需要状态保存，所以引入了cookie技术。\r\n\r\n## 请求方法\r\n\r\nHttp协议通过请求和响应进行通信交互，在请求时不同的方法有不同的应用场景。\r\n\r\n先看下方法分类：\r\n\r\n| 方法      | 说明          | 支持版本    |\r\n| ------- | ----------- | ------- |\r\n| GET     | 获取资源        | 1.0、1.1 |\r\n| POST    | 传输实体主体      | 1.0、1.1 |\r\n| PUT     | 传输文件        | 1.0、1.1 |\r\n| HEAD    | 获得报文首部      | 1.0、1.1 |\r\n| DELETE  | 删除文件        | 1.0、1.1 |\r\n| OPTIONS | 询问支持的方法     | 1.1     |\r\n| TRACE   | 追踪路径        | 1.1     |\r\n| CONNECT | 要求用隧道协议连接代理 | 1.1     |\r\n| LINK    | 建立和资源之间的联系  | 1.0     |\r\n| UNLINK  | 断开连接关系      | 1.0     |\r\n\r\n- GET：获取资源\r\n- POST：传输实体主体\r\n- PUT：传输文件\r\n- HEAD：获得报文首部\r\n- DELETE：删除文件\r\n- OPTIONS：询问支持的方法\r\n- TRACE：追踪路径\r\n- CONNECT：要求用隧道协议连接代理\r\n\r\n## 持久连接\r\n\r\nHTTP 协议的初始版本中，每进行一次 HTTP 通信就要断开一次TCP 连接，这种情况在早期传输的都是小型文本消息时性能上不显优劣。但是随着近年互联网的发展，通信数据愈来愈大，每次通信都要新建和断开连接，耗费时间增加的同时也增加了通信开销。\r\n\r\n为了解决TCP这个问题，HTTP\/1.1 和一部分的 HTTP\/1.0 想出了持久连接（HTTP Persistent Connections，也称为 HTTP keep-alive 或HTTP connection reuse）的方法。\r\n\r\n持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。\r\n\r\n持久连接的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。另外，减少开销的那部分时间，使HTTP 请求和响应能够更早地结束，这样 Web 页面的显示速度也就相应提高了。\r\n在 HTTP\/1.1 中，所有的连接默认都是持久连接，但在 HTTP\/1.0 内并未标准化，可以通过首部的**connection = keep-alive**属性实现持久连接。\r\n\r\n\r\n\r\n# 0x03 报文\r\n\r\n用于 HTTP 协议交互的信息被称为 HTTP 报文，所以在Http中分为请求报文和响应报文两种。\r\n\r\n而 报文又分为报文首部和报文主体两块。\r\n\r\n## 首部\r\n\r\n**根据请求报文和相应报文，首部也分为请求首部和响应首部。**\r\n\r\n**请求首部**包括请求行、请求首部字段、通用首部字段、实体首部字段\r\n\r\n**响应首部**包括状态行、响应首部字段、通用首部字段、实体首部字段\r\n\r\n请求报文和响应报文结构如图：\r\n\r\n![请求报文和响应报文结构](http:\/\/othg5ggzi.bkt.clouddn.com\/%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E5%92%8C%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E7%9A%84%E7%BB%93%E6%9E%84.png)\r\n\r\n请求报文和响应报文结构实例如图：\r\n\r\n![请求报文和响应报文结构实例](http:\/\/othg5ggzi.bkt.clouddn.com\/%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E5%92%8C%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E7%9A%84%E7%BB%93%E6%9E%84%E5%AE%9E%E4%BE%8B.png)\r\n\r\n\r\n\r\n\r\n\r\n## 状态码\r\n\r\n状态码的任务就是对返回结果的描述。\r\n\r\n![状态码](http:\/\/othg5ggzi.bkt.clouddn.com\/%E7%8A%B6%E6%80%81%E7%A0%81.png)\r\n\r\n通过状态码我们可以知道服务器是否正确处理了我们的请求，如果出错了，那原因是什么。\r\n\r\n状态码以3位数字和短语组成，数字第一位指定响应类别，响应类别主要有5种：\r\n\r\n| 状态码  | 名称                     | 原因短语          |\r\n| ---- | ---------------------- | ------------- |\r\n| 1XX  | Informational（信息性状态码）  | 接收的请求正在处理     |\r\n| 2XX  | Success（成功状态码）         | 请求正常处理完毕      |\r\n| 3XX  | Redirection（重定向状态码）    | 需要进行附加操作以完成请求 |\r\n| 4XX  | Client Error（客户端错误状态码） | 服务器无法处理请求     |\r\n| 5XX  | Server Error（服务器错误状态码） | 服务器处理请求出错     |\r\n\r\n### 2XX\r\n\r\n- 200\u0007 OK \r\n\r\n  表示从客户端发来的请求在服务器端被正常处理了\r\n\r\n- 204\u0007 No\u0007Content\r\n\r\n  该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体。比如，当从浏览器发出请求处理后，返回 204 响应，那么浏览器显示的页面不发生更新\r\n\r\n- 206\u0007 Partial\u0007Content\r\n\r\n  该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。\r\n\r\n### 3XX\r\n\r\n- 301 Moved\u0007Permanently\r\n\r\n  永久性重定向。该状态码表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。也就是说，如果已经把资源对应的 URI保存为书签了，这时应该按 Location 首部字段提示的 URI 重新保存。像下方给出的请求 URI，当指定资源路径的最后忘记添加斜杠“ \/”，就会产生 301 状态码\r\n\r\n- 302\u0007 Found\r\n\r\n  临时性重定向。该状态码表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问。\r\n\r\n  和 301 Moved Permanently 状态码相似，但 302 状态码代表的资源不是被永久移动，只是临时性质的。换句话说，已移动的资源对应的URI 将来还有可能发生改变。比如，用户把 URI 保存成书签，但不会像301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码的页面对应的 URI。\r\n\r\n- 303\u0007 See\u0007Other\r\n\r\n  该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET方法定向获取请求的资源。\r\n  303 状态码和 302 Found 状态码有着相同的功能，但 303 状态码明确表示客户端应当采用 GET 方法获取资源，这点与 302 状态码有区别。比如，当使用 POST 方法访问 CGI 程序，其执行后的处理结果是希望客户端能以 GET 方法重定向到另一个 URI 上去时，返回 303 状态码。虽然 302 Found 状态码也可以实现相同的功能，但这里使用 303 状态码是最理想的。 \r\n\r\n- 304\u0007 Not\u0007Modified\r\n\r\n  该状态码表示客户端发送附带条件的请求 A 时，服务器端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回 304 NotModified（服务器端资源未改变，可直接使用客户端未过期的缓存）。\r\n  304 状态码返回时，不包含任何响应的主体部分。 **304 虽然被划分在3XX 类别中，但是和重定向没有关系**\r\n\r\n- 307\u0007 Temporary\u0007Redirect\r\n\r\n  临时重定向。该状态码与 302 Found 有着相同的含义。尽管 302 标准禁止 POST 变换成 GET，但实际使用时大家并不遵守。307 会遵照浏览器标准，不会从 POST 变成 GET。但是，对于处理\r\n  响应时的行为，每种浏览器有可能出现不同的情况。\r\n\r\n### 4XX\r\n\r\n- 400\u0007 Bad\u0007Request\r\n\r\n  该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码\r\n\r\n- 401\u0007 Unauthorized\r\n\r\n  该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。另外若之前已进行过 1 次请求，则表示用户认证失败。返回含有 401 的响应必须包含一个适用于被请求资源的WWWAuthenticate 首部用以质询（challenge）用户信息。当浏览器初次接收到 401 响应，会弹出认证用的对话窗口。\r\n\r\n- 403\u0007 Forbidden\r\n\r\n  该状态码表明对请求资源的访问被服务器拒绝了。服务器端没有必要给出拒绝的详细理由，但如果想作说明的话，可以在实体的主体部分对原因进行描述，这样就能让用户看到了。未获得文件系统的访问授权，访问权限出现某些问题（从未授权的发送源 IP 地址试图访问）等列举的情况都可能是发生 403 的原因。\r\n\r\n- 404\u0007 Not\u0007Found\r\n\r\n  该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用\r\n\r\n\r\n\r\n### 5XX\r\n\r\n- 500\u0007 Internal\u0007Server\u0007Error\r\n\r\n  该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web应用存在的 bug 或某些临时的故障\r\n\r\n- 503 \u0007Service\u0007Unavailable\r\n\r\n  该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入 RetryAfter 首部字段再返回给客户端\r\n\r\n## 认证\r\n\r\n认证有什么用？\r\n\r\n用来限制某些页面只想让特定人查看，为此，服务器就要通过某种方式能知晓用户身份是否符合该特定人群来给出适合的响应。\r\n\r\nHttp1.1中使用的认证方式有：\r\n\r\n- BASIC 认证（基本认证）\r\n- DIGEST 认证（摘要认证）\r\n- SSL 客户端认证\r\n- FormBase 认证（基于表单认证）\r\n\r\n这里主要讲下基本认证和摘要认证\r\n\r\n### BASIC 认证（基本认证）\r\n\r\nBASIC认证是从Http1.0就定义的认证方式。\r\n\r\n首先看下基本认证流程：\r\n\r\n![基本认证流程](http:\/\/othg5ggzi.bkt.clouddn.com\/%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B.png)\r\n\r\n从流程图很容易看出，操作a中直接向服务器请求图片时，由于服务器开启了基本认证，而客户端没有携带认证信息，这时操作b中给客户端返回了401，在上面状态码中我们了解到401Unauthorizeds是由于没有认证信息才出现的情况。\r\n\r\n那么如何添加Basic认证信息呢？看操作c，在请求头首部中添加**Authorization: Basic YnJpYW4tdG90dHk6T3ch**首部信息，其中YnJpYW4tdG90dHk6T3ch这个乱码为使用Base64编码后生成的字符串。一般来说参与编码的是用户名和密码，且用户名和密码之间使用冒号：隔开，即base64（username:pwd）==YnJpYW4tdG90dHk6T3ch。\r\n\r\n最后操作d接受基本认证信息，返回正确响应报文。\r\n\r\n**注意：基本认证简单但不安全，base64只是一直编码而非加密，很容易被有恶意的人通过解码得知用户名密码。所以通过基本认证发送的信息可以说是明文发送。为了保证数据安全最好配合SSL一起使用。**\r\n\r\n另外就算密码不被切取，一旦认证信息被拦截，第三者就可以凭借拿到的认证信息进行重放攻击，这时本该该用户看到的文档权限被第三者一览无余。\r\n\r\n### DIGEST 认证（摘要认证）\r\n\r\n可以认为摘要认证是对基本认证的一个改进：\r\n\r\n永远不会以明文方式在网络上发送密码。\r\n可以防止恶意用户捕获并重放认证的握手过程。\r\n可以有选择地防止对报文内容的篡改。\r\n防范其他几种常见的攻击方式。\r\n\r\n看下摘要认证流程图：\r\n\r\n![摘要认证流程](http:\/\/othg5ggzi.bkt.clouddn.com\/%E6%91%98%E8%A6%81%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B.png)\r\n\r\n摘要认证中传递的信息不是密码本身，而是通过一个算法取得的密码摘要部分内容。这样防止了密码被切取的风险。为了防止重放攻击，服务器会生成一个nonce随机数，客户端使用密码和随机数通过算法计算出摘要，这样每次请求的摘要都是不一样的。\r\n\r\n\r\n\r\n## Https\r\n\r\n\r\n\r\n未完待续。。。。\r\n\r\n# 0x04 其他\r\n\r\n\r\n\r\n## web内容\r\n\r\n\r\n\r\n## web攻击\r\n\r\n\r\n\r\n## 其他功能\r\n\r\n\r\n\r\n### Http2.0\r\n\r\n\r\n\r\n### SPDY\r\n\r\n\r\n\r\n### WebSocket"
  },
  {
    "title": "两个栈实现队列功能",
    "created_time": "2017-05-18 16:28:16",
    "body": "# 0x00 前言\r\n\r\n用2个栈实现队列，首先要明白栈和队列的区别：栈是FILO，队列是FIFO。明白了这两点就比较容易实现了。\r\n\r\n\r\n\r\n# 0x01 分析 \r\n\r\n栈是一端开口，队列是两端开口，如果要让栈实现队列功能，需要2个栈一个负责进数据，一个负责出数据。为了保证出数据的顺序，在出数据栈不为空时，入数据的栈中数据不能往出数据的栈里存。\r\n\r\n<!-- more -->\r\n\r\n# 0x02 实现\r\n\r\n在2个栈数据都为空时注意抛出异常。\r\n\r\n```\r\n\r\nimport java.util.Stack;\r\n\r\n\/**\r\n * 两个栈实现队列功能\r\n * @author jenson\r\n *\/\r\npublic class StackToQueue {\r\n\tprivate Stack<Integer> inStack = new Stack<>();\r\n\tprivate Stack<Integer> outStack = new Stack<>();\r\n\r\n\t\/**\r\n\t * 添加元素\r\n\t * @param value\r\n\t *\/\r\n\tpublic void add(int value) {\r\n\t\tinStack.push(value);\r\n\t}\r\n\r\n\t\/**\r\n\t * 出队列\r\n\t * @return\r\n\t *\/\r\n\tpublic int poll() {\r\n\t\tif (inStack.isEmpty() && outStack.isEmpty()) {\r\n\t\t\tqueueEmptyException();\r\n\t\t} else {\r\n\t\t\tif (outStack.isEmpty()) {\r\n\t\t\t\treverse();\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn outStack.pop();\r\n\t}\r\n\r\n\t\/**\r\n\t * 查看队列头的元素 <\/br>\r\n\t * 注意一点：如果出栈队列为空，则把入栈数据倒入到处栈，然后从出栈取<br>\r\n\t * 如果两个栈都为空抛异常\r\n\t * \r\n\t *\/\r\n\tpublic int peek() {\r\n\t\tif (inStack.isEmpty() && outStack.isEmpty()) {\r\n\t\t\tqueueEmptyException();\r\n\t\t} else {\r\n\t\t\tif (outStack.isEmpty()) {\r\n\t\t\t\treverse();\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn outStack.peek();\r\n\r\n\t}\r\n\r\n\t\/**\r\n\t * 入栈数据倒入到出栈\r\n\t *\/\r\n\tprivate void reverse() {\r\n\t\twhile (!inStack.isEmpty()) {\r\n\t\t\toutStack.push(inStack.pop());\r\n\t\t}\r\n\t}\r\n\r\n\tprivate void queueEmptyException() {\r\n\t\tthrow new RuntimeException(\"队列为空\");\r\n\t}\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tStackToQueue stackToQueue = new StackToQueue();\r\n\t\tstackToQueue.add(9);\r\n\t\tstackToQueue.add(5);\r\n\t\tstackToQueue.add(2);\r\n\t\tstackToQueue.add(7);\r\n\r\n\t\tSystem.out.println(stackToQueue.peek());\r\n\t\tSystem.out.println(stackToQueue.poll());\r\n\t}\r\n}\r\n\r\n```"
  },
  {
    "title": "农夫带着狼、羊和白菜过河问题",
    "created_time": "2017-05-10 17:55:25",
    "body": "一个农夫带着一只狼，一只羊和一棵白菜来到河边要过河，船只狭小，一次农夫只能带一样物品过河，如果农夫不在场，狼会吃羊，羊也会吃白菜。那么农夫如何才能过河或者证明出无解。\r\n\r\n\r\n\r\n这是一道自古有之的谜题，但是一些公司也有把这作为笔试题...\r\n\r\n看到这个题我的第一个想法就是船上系一根绳，把狼和白菜一起放船上，待漂到对岸后再用绳子拉过来，然后农夫抱着羊过河。不过这太投机取巧了啊哈哈。还是来点务实的吧：\r\n\r\n<!-- more -->\r\n\r\n务实的想法就是要农夫一直和船一起。毕竟不能指望顺风船自动漂对岸然后狼羊白菜自动下船吧。\r\n\r\n食物链是这样的：狼>羊>白菜\r\n\r\n农夫只要离开，食物链就会发生吞食，所以要让食物链隔开。\r\n\r\n那么第一步做法就明白了：必须带羊过河~~\r\n\r\n我们假设A为现在所在岸边，B为目的岸边\r\n\r\n\r\n\r\n| 步骤        | A    | B      |\r\n| --------- | ---- | ------ |\r\n| ①农夫带着羊过河  | 狼和白菜 | 羊      |\r\n| ②农夫独自返回A  |      |        |\r\n| ③农夫带着白菜过河 | 狼    | 羊和白菜   |\r\n| ④农夫带着羊返回  | 羊和狼  | 白菜     |\r\n| ⑤农夫带着狼过河  | 羊    | 白菜和狼   |\r\n| ⑥农夫独自返回A  |      |        |\r\n| ⑦农夫带着羊过河  |      | 白菜、狼和羊 |\r\n\r\n\r\n\r\n其实这个解法不是唯一的。\r\n\r\n虽然第一步都是要带着羊过河，但是第三步带着白菜和带狼都是可以的。\r\n\r\n| 步骤        | A    | B      |\r\n| --------- | ---- | ------ |\r\n| ③农夫带着狼过河  | 白菜   | 羊和狼    |\r\n| ④农夫带着羊返回A | 白菜和羊 | 狼      |\r\n| ⑤农夫带着白菜过河 | 羊    | 狼和白菜   |\r\n| ⑥农夫独自返回A  |      |        |\r\n| ⑦农夫带着羊过河  |      | 狼、白菜和羊 |\r\n|           |      |        |"
  },
  {
    "title": "求解1到n中1的个数",
    "created_time": "2017-07-28 00:11:31",
    "body": "# 0x00 前言\r\n\r\n注意一点的是不管有几位数，每位都要检查是否为1.\r\n\r\n\r\n\r\n# 0x01 暴力实现\r\n\r\n最简单暴力的方法就是直接遍历判断：\r\n\r\n```java\r\n\t\/**\r\n\t * 暴力求解1-n中有多少个1\r\n\t * \r\n\t * @param value\r\n\t * @return\r\n\t *\/\r\n\tpublic static int getOne(int value) {\r\n\t\tint result = 0;\r\n\t\tfor (int i = 1; i <= value; i++) {\r\n\t\t\tint val = i;\r\n\t\t\twhile (val == 1 || val >= 10) {\r\n\t\t\t\tresult += val % 10 == 1 ? 1 : 0;\r\n\t\t\t\tval \/= 10;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n```\r\n\r\n打印`\t\tSystem.out.println(getOne(11));`结果为4。正确\r\n\r\n<!-- more -->\r\n\r\n# 0x02 递归实现\r\n\r\n\r\n\r\n```java\r\n\tpublic static int getOnes(int value, int count) {\r\n\t\tif (value == 1) {\r\n\t\t\treturn ++count;\r\n\t\t} else {\r\n\t\t\t\/\/ 计算当前数不为1时，所有位包含1的个数。\r\n\t\t\tint val = value;\r\n\t\t\twhile (val == 1 || val >= 10) {\r\n\t\t\t\tcount += val % 10 == 1 ? 1 : 0;\r\n\t\t\t\tval \/= 10;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn getOnes(--value, count);\r\n\t}\r\n```\r\n\r\n\r\n\r\n# 0x003 其他思想\r\n\r\n本段内容来自[简书](http:\/\/www.jianshu.com\/p\/ce709a24bd22)：\r\n\r\n1. 此位大于1，这一位上1的个数有 ([n \/ 10 ^ (b + 1) ] + 1) * 10^b\r\n2. 此位等于0，为 ([n \/ 10^(b+1) ] ) * 10^b\r\n3. 此位等于1，在0的基础上加上n mod 10^b + 1\r\n\r\n举个例子，我们来分析 N=30143 的情况：\r\n\r\n1. 由于3>1,则个位上出现1的次数为(3014+1)*1\r\n2. 由于4>1,则十位上出现1的次数为(301+1)*10\r\n3. 由于1=1，则百位上出现1次数为30*100+(43+1)\r\n4. 由于千位为0，则千位上出现1次数为3*1000\r\n\r\n仔细观察，不难明白其中的道理。以百位为例：100到199共有100个1，而除以100以后位30，所以共有30个100到199，这就构成了300 * 100。最后，当对于千位和万位为0的情况，还有100到143这44个数，所以总共为30*100 + 43 + 1。同样，不难理解，对于十位，有10到19共10个1，共有301个百位以上不为0的情况，最后加上百位以上都是0的情况，则为 （301+1）* 10。\r\n\r\n至于代码按规律如何实现，暂时没有思考"
  },
  {
    "title": "设计一个有获取元素最小值getMin的栈",
    "created_time": "2017-05-17 16:24:42",
    "body": "# 0x00 前言\r\n\r\n栈可以看成一个瓶子，只有一个口，另一端被封底。这样数据进出都只能从一个口经过。这样就导致的一个直接结果就是数据FILO问题。要找到栈中最小数据，单靠一个栈不能完成，需要外部提供辅助。\r\n\r\n# 0x01 分析\r\n\r\n\r\n\r\n一个存好数据的栈，要从里面找到最小数值，不可避免的要把数据出栈，然后进行对比。这时有个问题就来了，找到最小数值后，其他数据还有用吗？换句话说，其他数据还要不要了？如果不要的话，比较完成后不用再次存储，如果要德话，比较期间还要注意数据的保存。这里注意要分这两种情况来考虑。\r\n\r\n<!-- more -->\r\n\r\n# 0x02 不要其他数据的实现\r\n\r\n既然不需要其他数据，那就直接把数据弹出栈就好了，每次弹栈时对比临时值，如果当前弹栈数据比临时值大则直接弹栈，否则就把值赋给临时值。\r\n\r\n```\r\npublic class StackMin {\r\n\tprivate Stack<Integer> stack = new Stack<>();\r\n\r\n\tpublic int getStackMin() {\r\n\t\tint min = 0;\r\n\t\twhile (!stack.isEmpty()) {\r\n\t\t\tint current = stack.pop();\r\n\t\t\tif (min != 0) {\r\n\t\t\t\tif (min > current) {\r\n\t\t\t\t\tmin = current;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tmin = current;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn min;\r\n\t}\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tStackMin stackMin = new StackMin();\r\n\t\tstackMin.stack.push(9);\r\n\t\tstackMin.stack.push(5);\r\n\t\tstackMin.stack.push(2);\r\n\t\tstackMin.stack.push(7);\r\n\t\tSystem.out.println(stackMin.getStackMin());\r\n\t}\r\n}\r\n\r\n```\r\n\r\n这里代码只实现了getStackMin方法，栈的其他方法就直接定义一个方法后直接调用Stack方法即可。\r\n\r\n# 0x03 需要其他数据的实现\r\n\r\n如果要保留栈的数据，那最直接的想法是在弹栈比较期间，把弹出栈的数据顺路给入道一个新的栈中，这里相比上面，需要多一个栈即可实现。\r\n\r\n```\r\npublic class StackMin {\r\n\tprivate Stack<Integer> stack = new Stack<>();\r\n\tprivate Stack<Integer> backUp = new Stack<>();\/\/备份栈\r\n\r\n\tpublic int getStackMin() {\r\n\t\tint min = 0;\r\n\t\twhile (!stack.isEmpty()) {\r\n\t\t\tint current = stack.pop();\r\n\t\t\tif (min != 0) {\r\n\t\t\t\tif (min > current) {\r\n\t\t\t\t\tmin = current;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tmin = current;\r\n\t\t\t}\r\n\t\t\tbackUp.push(current);\/\/弹出栈时进入备份栈\r\n\t\t}\r\n\t\treturn min;\r\n\t}\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tStackMin stackMin = new StackMin();\r\n\t\tstackMin.stack.push(9);\r\n\t\tstackMin.stack.push(5);\r\n\t\tstackMin.stack.push(2);\r\n\t\tstackMin.stack.push(7);\r\n\t\tSystem.out.println(stackMin.getStackMin());\r\n\t}\r\n}\r\n\r\n```"
  },
  {
    "title": "使用sychronized注意事项",
    "created_time": "2017-08-10 21:43:15",
    "body": "# 0x00 前言\r\n\r\nJava编程中多线程并发是一个举足轻重的模块，所以加深对这一块的理解是很有必要的。\r\n\r\n# 0x01锁定对象而非函数或代码块 \r\n\r\n- 当sychronized修饰实例方法时，锁定的是调用该方法的对象\r\n\r\n  如下代码：\r\n\r\n  ```java\r\n  class Text{\r\n    public sychronized void method1(){\r\n    }\r\n  }\r\n  ```\r\n\r\n- 当sychronized锁定this时，锁定的也是当前对象\r\n\r\n  ```java\r\n  class Text{\r\n    public void method2(){\r\n      sychronized(this){ \r\n      }\r\n    }\r\n  }\r\n  ```\r\n\r\n  <!-- more -->\r\n\r\n  既然锁定的是对象，也就意味着调用该函数的线程A会获得该对象lock，同样的，线程B在调用该对象的函数时也要获得该对象的lock，但是该对象的lock此时被线程A持有，所以线程B就要处于阻塞状态，直到lock被线程A释放。**\r\n\r\n  看看下面代码有何问题：\r\n\r\n  ```java\r\n  static class TThread extends Thread {\r\n  \t\tprivate int key;\r\n\r\n  \t\tpublic TThread(int key) {\r\n  \t\t\tthis.key = key;\r\n  \t\t}\r\n\r\n  \t\t@Override\r\n  \t\tpublic void run() {\r\n  \t\t\tgo(this.key);\r\n  \t\t}\r\n\r\n  \t\tpublic synchronized void go(int key) {\r\n  \t\t\twhile (true) {\r\n  \t\t\t\tSystem.out.println(key);\r\n  \t\t\t\ttry {\r\n  \t\t\t\t\tThread.currentThread().sleep(1000);\r\n  \t\t\t\t} catch (InterruptedException e) {\r\n  \t\t\t\t\te.printStackTrace();\r\n  \t\t\t\t}\r\n  \t\t\t}\r\n  \t\t}\r\n  \t}\r\n\r\n  \tstatic class SecondThread extends Thread {\r\n  \t\tTThread tt;\r\n\r\n  \t\tpublic SecondThread(TThread tt) {\r\n  \t\t\tthis.tt = tt;\r\n  \t\t}\r\n\r\n  \t\t@Override\r\n  \t\tpublic void run() {\r\n  \t\t\tthis.tt.go(3);\r\n  \t\t}\r\n  \t}\r\n\r\n  \tpublic static void main(String[] args) {\r\n  \t\tTThread t1 = new TThread(1);\r\n  \t\tt1.start();\r\n  \t\tSecondThread st = new SecondThread(t1);\r\n  \t\tst.start();\r\n  \t\tTThread t2 = new TThread(2);\r\n  \t\tt2.start();\r\n  \t}\r\n  ```\r\n\r\n  上述代码会打印1和2，但是却不会打印3。因为synchronized锁定的是线程对象，而t1和t2是两个不同的对象，所以可以并发执行。而实例st中run方法实际执行的是t1的同步方法，因而1和3不会同时打印。\r\n\r\n  **另一方面，既然是锁定对象，意味着每个对象都有自己的lock，如果是同一个类的不同实例在多个线程间调用时，仍然会并发执行。**\r\n\r\n# 0x02 锁定类Class对象\r\n\r\n- 当sychronized修饰static方法时，锁定的是该class的Class对象\r\n\r\n  ```java\r\n  class Text{\r\n    public sychronized static void method1(){\r\n    }\r\n  }\r\n  ```\r\n\r\n- 当sychronized锁定xx.class时，锁定的也是该class的Class对象\r\n\r\n  ```java\r\n  class Text{\r\n    public void method2(){\r\n      sychronized(Text.class){\r\n      }\r\n    }\r\n  }\r\n  ```\r\n\r\n  如下代码有何问题：\r\n\r\n  ```java\r\n  \tstatic class TThread extends Thread {\r\n\r\n  \t\t@Override\r\n  \t\tpublic void run() {\r\n  \t\t\tgo1();\r\n  \t\t}\r\n\r\n  \t\tprivate synchronized void go1() {\r\n  \t\t\twhile (true) {\r\n  \t\t\t\tSystem.out.println(1);\r\n  \t\t\t\ttry {\r\n  \t\t\t\t\tThread.currentThread().sleep(1000);\r\n  \t\t\t\t} catch (InterruptedException e) {\r\n  \t\t\t\t\te.printStackTrace();\r\n  \t\t\t\t}\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\tpublic synchronized static void go2() {\r\n  \t\t\twhile (true) {\r\n  \t\t\t\tSystem.out.println(2);\r\n  \t\t\t\ttry {\r\n  \t\t\t\t\tThread.currentThread().sleep(1000);\r\n  \t\t\t\t} catch (InterruptedException e) {\r\n  \t\t\t\t\te.printStackTrace();\r\n  \t\t\t\t}\r\n  \t\t\t}\r\n  \t\t}\r\n  \t}\r\n\r\n  \tpublic static void main(String[] args) {\r\n  \t\tTThread t1 = new TThread();\r\n  \t\tt1.start();\r\n  \t\tt1.go2();\r\n  \t}\r\n  ```\r\n\r\n  go1函数是实例函数，go2是类函数。尽管上述两个函数都声明为synchronized，它们并非线程安全的。因为两个线程获取的是不同的lock。\r\n\r\n  因此上述代码执行时，打印1和2交替执行。\r\n\r\n  **时刻注意对象锁和类锁的区分，不要为了实现某些数据同步而同时使用两种方法。因为这两种方法获取的是不同的锁**\r\n\r\n# 0x03 避免因权限导致锁无效\r\n\r\n直接看如下代码有何问题：\r\n\r\n```java\r\n\tpublic int[] intArr = new int[10];\r\n\r\n\tpublic synchronized void addArr(int[] arr) {\r\n\t\tint len = intArr.length;\r\n\t\tif (len == arr.length) {\r\n\t\t\tfor (int i = 0; i < len; i++) {\r\n\t\t\t\tintArr[i] += arr[i];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tpublic synchronized void subtrackArr(int[] arr) {\r\n\t\tint len = intArr.length;\r\n\t\tif (len == arr.length) {\r\n\t\t\tfor (int i = 0; i < len; i++) {\r\n\t\t\t\tintArr[i] -= arr[i];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n```\r\n\r\n上面代码是线程安全的吗？\r\n\r\n当然不是。虽然两个实例方法实现了线程同步，但是还有其他漏洞。\r\n\r\n首先要明白同步的目的是保证**intArr**的准确性。但是因为该实例属性权限是**public**状态。这导致无须通过同步方法，也能修改数组。所以应该修改权限为私有状态。\r\n\r\n**有时看似添加了同步方法就以为万无一失了，但是就因为权限开放导致线程安全没有生效**\r\n\r\n# 0x04 避免无谓的同步导致性能降低\r\n\r\n看看如下代码正确吗：\r\n\r\n```Java\r\n\tprivate int[] arr1;\r\n\tprivate int[] arr2;\r\n\tprivate int[] arr3;\r\n\tprivate int[] arr4;\r\n\r\n\tpublic synchronized void method1() {\r\n\t\t\/\/ 操作arr1和arr2\r\n\t}\r\n\r\n\tpublic synchronized void method2() {\r\n\t\t\/\/ 操作arr1和arr2\r\n\t}\r\n\r\n\tpublic synchronized void method3() {\r\n\t\t\/\/ 操作arr3和arr4\r\n\t}\r\n\r\n\tpublic synchronized void method4() {\r\n\t\t\/\/ 操作arr3和arr4\r\n\t}\r\n```\r\n\r\n上述操作无疑是线程安全的，但是这种方法同步带来了很大的性能问题。\r\n\r\n因为同步所以互斥，这也就决定了四个方法不能并发，但是逻辑上，method1和method2由于都操作了arr1和arr2，所以应该互斥，但是不应该和method3、method4互斥。\r\n\r\n但是现在的结果是操作arr1和arr2的时候就不能操作arr3和arr4。造成了性能下降。\r\n\r\n要避免这种情况可以缩小锁范围，**创建专门的对象锁以替代方法所属对象的锁**\r\n\r\n如下修改：\r\n\r\n```java\r\n\tprivate int[] arr1;\r\n\tprivate int[] arr2;\r\n\tprivate int[] arr3;\r\n\tprivate int[] arr4;\r\n\tprivate byte[] lock1 = new byte[0];\r\n\tprivate byte[] lock2 = new byte[0];\r\n\r\n\tpublic void method1() {\r\n\t\t\/\/ 操作arr1和arr2\r\n\t\tsynchronized (lock1) {\r\n\t\t}\r\n\t}\r\n\r\n\tpublic void method2() {\r\n\t\t\/\/ 操作arr1和arr2\r\n\t\tsynchronized (lock1) {\r\n\t\t}\r\n\t}\r\n\r\n\tpublic void method3() {\r\n\t\t\/\/ 操作arr3和arr4\r\n\t\tsynchronized (lock2) {\r\n\t\t}\r\n\t}\r\n\r\n\tpublic void method4() {\r\n\t\t\/\/ 操作arr3和arr4\r\n\t\tsynchronized (lock2) {\r\n\t\t}\r\n\t}\r\n```\r\n\r\n# 0x05 避免多个锁顺序不同导致死锁\r\n\r\n要避免死锁首先要知道什么是死锁，以及死锁如何发生得。\r\n\r\n**线程A申请一个对象锁，但是对象锁被线程B持有了，而线程B申请的对象锁又被线程A持有了，这样导致两个线程分别阻塞了对方，这就是死锁。**\r\n\r\n死锁是如何形成的？\r\n\r\n**死锁一般是由于多个锁对象在不同的线程中获取对象锁顺序不同造成的**\r\n\r\n看如下代码：\r\n\r\n```java\r\n\tstatic class TT {\r\n\t\tpublic void method1(int[] arr1, int[] arr2) {\r\n\t\t\t\/\/ 操作arr1和arr2\r\n\t\t\tsynchronized (arr1) {\r\n\t\t\t\tsynchronized (arr2) {\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tTT tt = new TT();\r\n\t\tint[] arr1 = new int[10];\r\n\t\tint[] arr2 = new int[10];\r\n\t\ttt.method1(arr1, arr2);\r\n\t\ttt.method1(arr2, arr1);\r\n\r\n\t}\r\n```\r\n\r\n在method1的方法调用中，因为两个数组参数的顺序调换，导致了多线程情况下获取对象锁顺序不同，导致死锁发生。\r\n\r\n如何解决死锁？\r\n\r\n**一种简单的方法就是保证不同线程中多个锁对象获取锁的顺序是相同的。**"
  },
  {
    "title": "数学归纳法",
    "created_time": "2017-05-16 14:08:56",
    "body": "# 什么是数学归纳法\r\n\r\n数学归纳法就是证明一个命题在自然数范围内成立\r\n\r\n这里命题也可以当成是断言。\r\n\r\n比如断言自然数n，nx2为偶数。\r\n\r\n<!-- more -->\r\n\r\n# 求储蓄罐里的钱\r\n\r\n有一个空储蓄罐，\r\n\r\n第一天，往里面存1元钱；\r\n\r\n第二天，往里面存2元钱；\r\n\r\n第三天，往里面存3元钱；\r\n\r\n第四天，往里面存4元钱；\r\n\r\n。\r\n\r\n。\r\n\r\n。\r\n\r\n每天都存钱，第一百天时储蓄罐里一共有多少钱？\r\n\r\n这个问题如何求解呢？其实最直接的方法就是从1开始加，一直加到100，但是这种暴力求解效率极差。\r\n\r\n 德国9岁孩子高斯也遇到了同样问题，但是他却马上得出了答案。\r\n\r\n他是这么考虑的：\r\n\r\n1+2+3…+100顺序计算结果和100+99+98...+1这样的逆序结果是一样的。\r\n\r\n这样的话，顺序的1+逆序的100，顺序的2+逆序的99，顺序的3+逆序的98，这样最后结果是100个101相加 = 100x101 = 10100 。因为逆序和顺序相等，所以这个和是2倍的顺序，所以顺序的和为10100\/2 =5050。最终得出1加到100的和为5050。\r\n\r\n高斯据此得出以下公式：\r\n\r\n1+2+3…+100 = （100+1）x100\/2；\r\n\r\n当然上面只是求1到100的和，那如果要求1到1000，到10000呢，公式是不是仍然成立？\r\n\r\n高斯断言：对于任意自然数n：1+2+3…+n = （n+1)xn\/2都成立；\r\n\r\n接下来要证明高斯的断言是否成立。\r\n\r\n# 数学归纳法证明\r\n\r\n最简单的数学归纳法是证明当n等于任意一个自然数时断言成立，证明包括两步：\r\n\r\n1.证明n=1时，断言p(1)成立\r\n\r\n2.证明n=k为任何自然数时，若p(k)成立，则p(k+1)也成立。\r\n\r\n\r\n\r\n由此，关于高斯公式的证明如下：\r\n\r\n1.当n=1时， 1 = （1+1）x1\/2 = 1，高斯公式成立；\r\n\r\n2.当n=k时，1+2+...+k = (k+1)xk\/2 成立;\r\n\r\n3.当n=k+1时，证明1+2+...+k+(k+1) = ((k+1)+1)x(k+1)\/2成立；\r\n\r\n因为2成立，所以3中公式代入后：\r\n\r\n (k+1)xk\/2+（k+1） = ((k+1)+1)x(k+1)\/2\r\n\r\n（k+1）x（k+2）\/2 =  （k+1）x（k+2）\/2 \r\n\r\n左右两边相等，\r\n\r\n得出结论：对于自然数n，断言p(n)都成立。\r\n\r\n\r\n\r\n# 为什么数学归纳法只证明两步就成立了\r\n\r\n\r\n\r\n1.证明断言p(1)成立，也就是n=1成立；\r\n\r\n2.通过p(m)成立推导出p(m+1)也成立。\r\n\r\n3.根据上面结论，p(1+1)也就是p(2)成立；\r\n\r\n4.p(2+1)也就是p(3)成立；\r\n\r\n5.p(3+1)也就是p(4)成立；\r\n\r\n6.循环推导，最终推导出值为n时p(n)成立。"
  },
  {
    "title": "四个人过桥问题",
    "created_time": "2017-05-11 15:55:37",
    "body": "有甲乙丙丁4个人要过桥，他们都在桥一端，他们只有17分钟时间过桥。时间在晚上，过桥需要用到手电筒，而且手电筒必须来回都用到且手电筒不能扔来扔去，一次只能有2个人同时过桥。每个人走路速度不同，甲过桥需要1分钟，乙过桥需要2分钟，丙过桥需要5分钟，丁过桥需要10分钟。两个人一起走路，速度决定于走的慢的那个。请你给这四人规划合适的搭配过桥。\r\n\r\n<!-- more -->\r\n\r\n\r\n\r\n看到这道题脑子第一想法是：5和10分钟不能分开，如果分开，这俩人就占了15分钟。然而刚让这俩一起过桥，然后就让5分钟的哥们拿着手电筒回来了~~~一脸懵逼试了好几种都没有通过。后来发现我又被自己看问题角度给局限住了，每2个人过桥后，就一直一门心思的让刚过来的2个人中的一个人送手电筒返回，其实送手电筒的这个人只要在同一岸边的就行。说到这里，答案以及开始浮出水面了：\r\n\r\n\r\n\r\n| 步骤              | A    | B    |\r\n| --------------- | ---- | ---- |\r\n| ①甲和乙一起过河，花费2分钟  | 丙丁   | 甲乙   |\r\n| ②甲带手电筒返回，花费1分钟  | 甲丙丁  | 乙    |\r\n| ③丙和丁一起过河，花费10分钟 | 甲    | 乙丙丁  |\r\n| ④乙带手电筒返回，花费2分钟  | 甲乙   | 丙丁   |\r\n| ⑤甲和乙一起过河，花费2分钟  |      | 甲乙丙丁 |\r\n\r\n\r\n\r\n上面5个步骤刚好四人全部过桥，花费时间17分钟，当然②中也可以由乙带手电筒返回，不过④要由甲带手电筒。这样也是17分钟，其他时间应该是大于17分钟的。\r\n\r\n> 其实这道题和农夫过河一样，都不难，只要看问题时，眼界要能钻进问题角落深入分析，又能抽出眼界，站在一定高度俯视问题全局。\r\n\r\n\r\n\r\n网上据说这道题在西雅图一个有名软件公司的考官面试时也出过这道题，怎么样你答对了吗？"
  },
  {
    "title": "算法查找之二分查找",
    "created_time": "2017-05-03 22:52:40",
    "body": "# 实现目标\r\n\r\n查看24是否在数组{ 8，14，24，28，30，31，32 }中，\r\n\r\n如果在数组中则返回数组元素下标，否则返回-1 。\r\n\r\n数组下标从0开始，查找24时最终返回下标2。\r\n\r\n<!-- more -->\r\n\r\n# 实现分析\r\n\r\n- 说明\r\n\r\n  二分法前提是数组是有序的；\r\n\r\n  要查找的数我们称为关键值\r\n\r\n- 阐述实现\r\n\r\n  在一个有序数组中二分查找一个数，数组长度为n。\r\n\r\n  1、设置左右下标变量：left，right，初始时left为0，right为n-1。\r\n\r\n  2、求出中间下标，得到中间数\r\n\r\n  3、如果中间数等于关键值则直接返回下标，\r\n\r\n  ​\t如果中间数大于关键值则 right为中间下标-1\r\n\r\n  ​\t如果中间数小于关键值则 left为中间下标+1\r\n\r\n  4、如果未结束，则重复步骤2和3，重复的前提是不管left和right的值\t\t\t如何改变，都要保证left<right。\r\n\r\n- 阐述转换通用代码\r\n\r\n  步骤1：` int left=0,right =n-1;`\r\n\r\n  步骤4中说重复2和3步，说明这是一个循环，循环条件是left<right，\r\n\r\n  所以使用` while(left<right)`\r\n\r\n\r\n\r\n# 代码实现\r\n\r\n```\r\n\tpublic static int binarySearch(int[] arr, int key) {\r\n\t\tint left = 0, right = arr.length - 1;\r\n\t\twhile (left < right) {\r\n\t\t\tint mid = (left + right) >> 1;\r\n\t\t\tif (arr[mid] == key) {\r\n\t\t\t\treturn mid;\r\n\t\t\t} else if (arr[mid] > key) {\r\n\t\t\t\tright = mid - 1;\r\n\t\t\t} else {\r\n\t\t\t\tleft = mid + 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn -1;\r\n\t}\r\n```"
  },
  {
    "title": "算法排序之归并",
    "created_time": "2017-10-17 22:05:51",
    "body": "# 0x00 前言\r\n\r\n归并排序也叫合并排序，基于分治思想。\r\n\r\n# 0x01 实现\r\n\r\n```java\r\npublic class MergeSort {\r\n\r\n\t\/**\r\n\t * 合并\r\n\t * \r\n\t * @param arr\r\n\t * @param low\r\n\t * @param high\r\n\t * @param mid\r\n\t *\/\r\n\tpublic static void merge(int[] arr, int low, int high, int mid) {\r\n\t\tint[] tmp = new int[high - low + 1];\r\n\t\tint i = low, j = mid + 1, k = 0;\r\n\t\twhile (i <= mid && j <= high) {\r\n\t\t\tif (arr[i] <= arr[j]) {\r\n\t\t\t\ttmp[k++] = arr[i++];\r\n\t\t\t} else {\r\n\t\t\t\ttmp[k++] = arr[j++];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\twhile (i <= mid) {\r\n\t\t\ttmp[k++] = arr[i++];\r\n\t\t}\r\n\t\twhile (j <= high) {\r\n\t\t\ttmp[k++] = arr[j++];\r\n\t\t}\r\n\r\n\t\tk = 0;\r\n\t\twhile (low <= high) {\r\n\t\t\tarr[low++] = tmp[k++];\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static void mergeSort(int[] arr, int low, int high) {\r\n\t\tif (low < high) {\r\n\t\t\tint mid = (low + high) >> 1;\r\n\t\t\tmergeSort(arr, low, mid);\r\n\t\t\tmergeSort(arr, mid + 1, high);\r\n\t\t\tmerge(arr, low, high, mid);\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tint[] arr_sort = { 156, 141, 35, 94, 88, 61, 111 };\r\n\t\tmergeSort(arr_sort, 0, arr_sort.length - 1);\r\n\t\tConstant.printArr(arr_sort);\r\n\t}\r\n}\r\n\r\n```\r\n\r\n<!--more-->\r\n\r\n# 算法复杂度\r\n\r\n当n=1时，T(n) = 1 ;\r\n\r\n当n>1时，T(n) = 2T(n\/2)+n;\r\n\r\nT(n) = 2(2T(n\/4)+n\/2)+n\r\n\r\n​\t=4T(n\/4)+2n\r\n\r\n​\t=8T(n\/8)+3n\r\n\r\n​\t=16T(n\/16)+4n\r\n\r\n​\t=2^xT(n\/2^x)+xn\r\n\r\n当数列切分到1时不可切分，此时T(1)=T(n\/2^x)，所以n=2^x，所以x=logn\r\n\r\nT(n) = nT(1)+logn *n;\r\n\r\n由于T(1) = 1,所以T(n) = n+lognO(n)；如果n较大时，lognO(n)>n，所以T(n)=  O(nlogn);"
  },
  {
    "title": "算法排序之交换排序",
    "created_time": "2017-05-03 21:04:13",
    "body": "# 实现目标\r\n\r\n本例中希望通过交换排序，使得数组最终按非递减顺序排列。\r\n\r\n数组初始值为：{ 156, 141, 35, 94, 88, 61, 111 }\r\n\r\n数组最终值为：{ 35, 61, 88, 94, 111, 141, 156 }\r\n\r\n<!-- more -->\r\n\r\n# 实现分析\r\n\r\n- 说明\r\n\r\n  希望数组按非递减顺序排列，我们可以得到两点消息：1、数组中可能会有重复的元素，所以才说是非递减。2、排序后第一个元素是最小值 ，最后一个元素是最大值。\r\n\r\n- 阐述实现\r\n\r\n  第一轮，第一个元素分别与后面的每个元素比较，如果大于后面的元素则进行交换，把较小值交换到第一个元素位置，本轮结束后的第一个元素就是数组中最小值。\r\n\r\n  第二轮，由于第一轮的第一个元素已经求出了最小值，所以第二轮从第二个元素开始，与后面的每个元素分别比较，如果大于后面的元素则进行交换，把较小值交换到第二个元素位置，本轮结束后的第二个元素就是数组中倒数第二小的值。\r\n\r\n  以此类推，进行n-1轮比较，n为数组长度。之所以是n-1轮而不是n轮，是因为第i轮的i个元素要和后面的元素进行比较，如果是n轮，它本身就是最后的元素，不需要比较了。\r\n\r\n- 阐述转换通用代码\r\n\r\n  交换方法提取：\r\n\r\n  ```\r\n  void swap(int[] arr, int i,int j){\r\n    int tmp = arr[i];\r\n    arr[i] = arr[j];\r\n    arr[j] = tmp ;\r\n  }\r\n  ```\r\n\r\n  第一轮：\r\n\r\n  ```\r\n  int i=0；\r\n  for(int j=i+1;j<n;j++){\r\n    if(arr[i]>arr[j]){\r\n      swap(arr,i,j);\r\n    }\r\n  }\r\n  ```\r\n\r\n  第二轮：\r\n\r\n  ```\r\n  int i=1；\r\n  for(int j=i+1;j<n;j++){\r\n    if(arr[i]>arr[j]){\r\n      swap(arr,i,j);\r\n    }\r\n  }\r\n  ```\r\n\r\n  每轮遍历出一个当前未排序中最小值，以此类推，遍历n-1轮：\r\n\r\n  ```\r\n  for(int i=0;i<n-1;i++){\r\n    \r\n  }\r\n  ```\r\n\r\n  ​\r\n\r\n\r\n\r\n# 代码实现\r\n\r\n```\r\n\tpublic static void swapSort(int[] arr) {\r\n\t\tint length = arr.length;\r\n\t\tfor (int i = 0; i < length-1 ; i++) {\r\n\t\t\tfor (int j = i + 1; j < length; j++) {\r\n\t\t\t\tif (arr[i] >  arr[j]) {\r\n\t\t\t\t\tint tmp = arr[i];\r\n\t\t\t\t\tarr[i] = arr[j];\r\n\t\t\t\t\tarr[j] = tmp;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n```"
  },
  {
    "title": "算法排序之快速排序",
    "created_time": "2017-05-16 18:21:50",
    "body": "# 实现目标\r\n\r\n本例中希望通过快速排序，使得数组最终按非递减顺序排列。\r\n\r\n数组初始值为：{ 156, 141, 35, 94, 88, 61, 111 }\r\n\r\n数组最终值为：{ 35, 61, 88, 94, 111, 141, 156 }\r\n\r\n<!-- more -->\r\n\r\n# 实现分析\r\n\r\n快排是根据分治思想，\r\n\r\n①选取一个基数，\r\n\r\n②将无序数组分为大小两个数组，其中一个数组值全都比基数小，另一个数组值全都比基数大。\r\n\r\n③然后将这两个数组分别再次分组，递归重复①②的步骤直到每个拆分后的数组不可再分割为止。也就是说最后每个元素单独为一个数组为止。\r\n\r\n④最后得出数组就是排序好的。\r\n\r\n\r\n\r\n# 代码实现\r\n\r\n```\r\n\tpublic static int partition3(int[] arr, int low, int high) {\r\n\t\tint i, j;\r\n\t\ti = low;\r\n\t\tint base = arr[i];\r\n\t\tfor (j = i + 1; j <= high; j++) {\r\n\t\t\tif (arr[j] < base) {\r\n\t\t\t\ti++;\r\n\t\t\t\tswap(arr, i, j);\r\n\t\t\t}\r\n\t\t}\r\n\t\tswap(arr, low, i);\r\n\t\treturn i;\r\n\t}\r\n\r\n\t\/**\r\n\t*交换数组中两个值\r\n\t**\/\r\n\tpublic static void swap(int[] arr, int i, int j) {\r\n\t\tif (i != j) {\r\n\t\t\tint tmp = arr[i];\r\n\t\t\tarr[i] = arr[j];\r\n\t\t\tarr[j] = tmp;\r\n\t\t}\r\n\t}\r\n\r\n\t\/**\r\n\t*right为数组最大下标而不是数组长度\r\n\t**\/\r\n\tpublic static void quickSort(int[] arr, int left, int right) {\r\n\t\tif (left < right) {\r\n\t\t\tint piv = partition3(arr, left, right);\r\n\t\t\tquickSort(arr, left, piv - 1);\r\n\t\t\tquickSort(arr, piv + 1, right);\r\n\t\t}\r\n\r\n\t}\r\n```"
  },
  {
    "title": "算法之朴素模式匹配",
    "created_time": "2017-05-25 15:49:26",
    "body": "# 0x00 前言\r\n\r\n不论英文还是中文，在看文章时经常会遇到查找某个单词或字组的时候，把一篇文章看作是一个大的字符串，要查找的内容作为子串，这种在大串中查找子串的操作叫做串的模式匹配。\r\n\r\n我们知道了这种行为叫串的模式匹配，但我们不清楚的是到底如何匹配，具体的操作是什么？\r\n\r\n# 0x01 我如何操作\r\n\r\n在我看来要从大串中寻找子串，最直接的方法就是从大串起始位置开始，挨个字符比对，如果存在子串总会找出来。这种简单直接的方法称为 **朴素的模式匹配算法**\r\n\r\n<!-- more -->\r\n\r\n# 0x02 代码实现\r\n\r\n如果借用字符串截取操作，直接实现子串的查找就比较方便：\r\n\r\n```\r\n\tpublic static int index(String s, String t, int pos) {\r\n\t\tint m = s.length();\r\n\t\tint n = t.length();\r\n\t\twhile (pos <= (m - n + 1)) {\r\n\t\t\tString sub = s.substring(pos, n);\r\n\t\t\t\/\/直接在对比位置截取和子串相同长度的一个串来和子串对比\r\n\t\t\tif (t.equals(sub)) {\r\n\t\t\t\treturn pos;\r\n\t\t\t} else {\r\n\t\t\t\tpos++;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn 0;\r\n\t}\r\n```"
  },
  {
    "title": "为什么我在工作线程刷新UI没报错？",
    "created_time": "2017-04-21 20:55:54",
    "body": ">从做Android开发以来就一直被灌输“只能在主线程刷新UI”的思想，但是这两天发现个问题，在onCreate中创建工作线程并刷新UI没有报错。代码是这样的：\r\n\r\n```\r\n    @Override\r\n    protected void onCreate(Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n        setContentView(R.layout.activity_main);\r\n       final TextView tv = (TextView) findViewById(R.id.sample_text);\r\n       new Thread(new Runnable() {\r\n           @Override\r\n           public void run() {\r\n               tv.setText(\"来自\"+Thread.currentThread().getName()+\"线程的更新\");\r\n           }\r\n       }).start();\r\n    }\r\n```\r\n<!-- more -->\r\n\r\n期待已久的crash没有出现，反而页面是这样显示的：\r\n\r\n![屏幕快照 2017-03-26 下午7.14.46.png](http:\/\/upload-images.jianshu.io\/upload_images\/1796052-7be6319d0fc94867.png?imageMogr2\/auto-orient\/strip%7CimageView2\/2\/w\/1240)\r\n不禁让人陷入深思···\r\n![思考.jpg](http:\/\/upload-images.jianshu.io\/upload_images\/1796052-8a0ce88639c31d1d.jpg?imageMogr2\/auto-orient\/strip%7CimageView2\/2\/w\/1240)\r\n\r\n第一步，分析问题原因。以前工作线程刷新UI会出现异常并提示只能在UI线程刷新UI。所以假设有个地方(函数)会在刷新UI前判断当前线程是不是主线程，那么现在问题就是验证下是否真的存在这么个地方。问题是从setText引起的，那就从这里出发看看。\r\n点进去看下发现又调用了其重载函数：\r\n```\r\n    @android.view.RemotableViewMethod\r\n    public final void setText(CharSequence text) {\r\n        setText(text, mBufferType);\r\n    }\r\n```\r\n继续深入发现这个方法代码挺多的，但是不用过于关注细节，粗略浏览下不难发现前面大部分代码大多是对text文本格式的一些处理判断，无关刷新UI，直到            checkForRelayout()方法执行，从名字看是“从新布局”，根据view绘制流程测量、布局、绘制，那布局完了不是就绘制刷新了吗？所以决定去checkForRelayout方法看看。\r\n\r\n```\r\n    private void setText(CharSequence text, BufferType type,\r\n                         boolean notifyBefore, int oldlen) {\r\n        if (text == null) {\r\n            text = \"\";\r\n        }\r\n\r\n        \/\/ If suggestions are not enabled, remove the suggestion spans from the text\r\n        if (!isSuggestionsEnabled()) {\r\n            text = removeSuggestionSpans(text);\r\n        }\r\n\r\n        if (!mUserSetTextScaleX) mTextPaint.setTextScaleX(1.0f);\r\n\r\n        if (text instanceof Spanned &&\r\n            ((Spanned) text).getSpanStart(TextUtils.TruncateAt.MARQUEE) >= 0) {\r\n            if (ViewConfiguration.get(mContext).isFadingMarqueeEnabled()) {\r\n                setHorizontalFadingEdgeEnabled(true);\r\n                mMarqueeFadeMode = MARQUEE_FADE_NORMAL;\r\n            } else {\r\n                setHorizontalFadingEdgeEnabled(false);\r\n                mMarqueeFadeMode = MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS;\r\n            }\r\n            setEllipsize(TextUtils.TruncateAt.MARQUEE);\r\n        }\r\n\r\n        int n = mFilters.length;\r\n        for (int i = 0; i < n; i++) {\r\n            CharSequence out = mFilters[i].filter(text, 0, text.length(), EMPTY_SPANNED, 0, 0);\r\n            if (out != null) {\r\n                text = out;\r\n            }\r\n        }\r\n\r\n        if (notifyBefore) {\r\n            if (mText != null) {\r\n                oldlen = mText.length();\r\n                sendBeforeTextChanged(mText, 0, oldlen, text.length());\r\n            } else {\r\n                sendBeforeTextChanged(\"\", 0, 0, text.length());\r\n            }\r\n        }\r\n\r\n        boolean needEditableForNotification = false;\r\n\r\n        if (mListeners != null && mListeners.size() != 0) {\r\n            needEditableForNotification = true;\r\n        }\r\n\r\n        if (type == BufferType.EDITABLE || getKeyListener() != null ||\r\n                needEditableForNotification) {\r\n            createEditorIfNeeded();\r\n            Editable t = mEditableFactory.newEditable(text);\r\n            text = t;\r\n            setFilters(t, mFilters);\r\n            InputMethodManager imm = InputMethodManager.peekInstance();\r\n            if (imm != null) imm.restartInput(this);\r\n        } else if (type == BufferType.SPANNABLE || mMovement != null) {\r\n            text = mSpannableFactory.newSpannable(text);\r\n        } else if (!(text instanceof CharWrapper)) {\r\n            text = TextUtils.stringOrSpannedString(text);\r\n        }\r\n\r\n        if (mAutoLinkMask != 0) {\r\n            Spannable s2;\r\n\r\n            if (type == BufferType.EDITABLE || text instanceof Spannable) {\r\n                s2 = (Spannable) text;\r\n            } else {\r\n                s2 = mSpannableFactory.newSpannable(text);\r\n            }\r\n\r\n            if (Linkify.addLinks(s2, mAutoLinkMask)) {\r\n                text = s2;\r\n                type = (type == BufferType.EDITABLE) ? BufferType.EDITABLE : BufferType.SPANNABLE;\r\n\r\n                \/*\r\n                 * We must go ahead and set the text before changing the\r\n                 * movement method, because setMovementMethod() may call\r\n                 * setText() again to try to upgrade the buffer type.\r\n                 *\/\r\n                mText = text;\r\n\r\n                \/\/ Do not change the movement method for text that support text selection as it\r\n                \/\/ would prevent an arbitrary cursor displacement.\r\n                if (mLinksClickable && !textCanBeSelected()) {\r\n                    setMovementMethod(LinkMovementMethod.getInstance());\r\n                }\r\n            }\r\n        }\r\n\r\n        mBufferType = type;\r\n        mText = text;\r\n\r\n        if (mTransformation == null) {\r\n            mTransformed = text;\r\n        } else {\r\n            mTransformed = mTransformation.getTransformation(text, this);\r\n        }\r\n\r\n        final int textLength = text.length();\r\n\r\n        if (text instanceof Spannable && !mAllowTransformationLengthChange) {\r\n            Spannable sp = (Spannable) text;\r\n\r\n            \/\/ Remove any ChangeWatchers that might have come from other TextViews.\r\n            final ChangeWatcher[] watchers = sp.getSpans(0, sp.length(), ChangeWatcher.class);\r\n            final int count = watchers.length;\r\n            for (int i = 0; i < count; i++) {\r\n                sp.removeSpan(watchers[i]);\r\n            }\r\n\r\n            if (mChangeWatcher == null) mChangeWatcher = new ChangeWatcher();\r\n\r\n            sp.setSpan(mChangeWatcher, 0, textLength, Spanned.SPAN_INCLUSIVE_INCLUSIVE |\r\n                       (CHANGE_WATCHER_PRIORITY << Spanned.SPAN_PRIORITY_SHIFT));\r\n\r\n            if (mEditor != null) mEditor.addSpanWatchers(sp);\r\n\r\n            if (mTransformation != null) {\r\n                sp.setSpan(mTransformation, 0, textLength, Spanned.SPAN_INCLUSIVE_INCLUSIVE);\r\n            }\r\n\r\n            if (mMovement != null) {\r\n                mMovement.initialize(this, (Spannable) text);\r\n\r\n                \/*\r\n                 * Initializing the movement method will have set the\r\n                 * selection, so reset mSelectionMoved to keep that from\r\n                 * interfering with the normal on-focus selection-setting.\r\n                 *\/\r\n                if (mEditor != null) mEditor.mSelectionMoved = false;\r\n            }\r\n        }\r\n\r\n        if (mLayout != null) {\r\n            checkForRelayout();\r\n        }\r\n\r\n        sendOnTextChanged(text, 0, oldlen, textLength);\r\n        onTextChanged(text, 0, oldlen, textLength);\r\n\r\n        notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_TEXT);\r\n\r\n        if (needEditableForNotification) {\r\n            sendAfterTextChanged((Editable) text);\r\n        }\r\n\r\n        \/\/ SelectionModifierCursorController depends on textCanBeSelected, which depends on text\r\n        if (mEditor != null) mEditor.prepareCursorControllers();\r\n    }\r\n```\r\n\r\n找到checkForRelayout方法查看：\r\n\r\n```\r\n    private void checkForRelayout() {\r\n        \/\/ If we have a fixed width, we can just swap in a new text layout\r\n        \/\/ if the text height stays the same or if the view height is fixed.\r\n\r\n        if ((mLayoutParams.width != LayoutParams.WRAP_CONTENT ||\r\n                (mMaxWidthMode == mMinWidthMode && mMaxWidth == mMinWidth)) &&\r\n                (mHint == null || mHintLayout != null) &&\r\n                (mRight - mLeft - getCompoundPaddingLeft() - getCompoundPaddingRight() > 0)) {\r\n            \/\/ Static width, so try making a new text layout.\r\n\r\n            int oldht = mLayout.getHeight();\r\n            int want = mLayout.getWidth();\r\n            int hintWant = mHintLayout == null ? 0 : mHintLayout.getWidth();\r\n\r\n            \/*\r\n             * No need to bring the text into view, since the size is not\r\n             * changing (unless we do the requestLayout(), in which case it\r\n             * will happen at measure).\r\n             *\/\r\n            makeNewLayout(want, hintWant, UNKNOWN_BORING, UNKNOWN_BORING,\r\n                          mRight - mLeft - getCompoundPaddingLeft() - getCompoundPaddingRight(),\r\n                          false);\r\n\r\n            if (mEllipsize != TextUtils.TruncateAt.MARQUEE) {\r\n                \/\/ In a fixed-height view, so use our new text layout.\r\n                if (mLayoutParams.height != LayoutParams.WRAP_CONTENT &&\r\n                    mLayoutParams.height != LayoutParams.MATCH_PARENT) {\r\n                    invalidate();\r\n                    return;\r\n                }\r\n\r\n                \/\/ Dynamic height, but height has stayed the same,\r\n                \/\/ so use our new text layout.\r\n                if (mLayout.getHeight() == oldht &&\r\n                    (mHintLayout == null || mHintLayout.getHeight() == oldht)) {\r\n                    invalidate();\r\n                    return;\r\n                }\r\n            }\r\n\r\n            \/\/ We lose: the height has changed and we have a dynamic height.\r\n            \/\/ Request a new view layout using our new text layout.\r\n            requestLayout();\r\n            invalidate();\r\n        } else {\r\n            \/\/ Dynamic width, so we have no choice but to request a new\r\n            \/\/ view layout with a new text layout.\r\n            nullLayouts();\r\n            requestLayout();\r\n            invalidate();\r\n        }\r\n    }\r\n```\r\n发现不管是if还是else，都要执行invalidate()，那就进去看看，一路进展比较顺利，好像离真理更进一步了。经过连续的三连调跳转到了invalidateInternal方法：\r\n\r\n```\r\n public void invalidate() {\r\n        invalidate(true);\r\n    }\r\n\r\n    \/**\r\n     * This is where the invalidate() work actually happens. A full invalidate()\r\n     * causes the drawing cache to be invalidated, but this function can be\r\n     * called with invalidateCache set to false to skip that invalidation step\r\n     * for cases that do not need it (for example, a component that remains at\r\n     * the same dimensions with the same content).\r\n     *\r\n     * @param invalidateCache Whether the drawing cache for this view should be\r\n     *            invalidated as well. This is usually true for a full\r\n     *            invalidate, but may be set to false if the View's contents or\r\n     *            dimensions have not changed.\r\n     *\/\r\n    void invalidate(boolean invalidateCache) {\r\n        invalidateInternal(0, 0, mRight - mLeft, mBottom - mTop, invalidateCache, true);\r\n    }\r\n\r\n   void invalidateInternal(int l, int t, int r, int b, boolean invalidateCache,\r\n            boolean fullInvalidate) {\r\n        if (mGhostView != null) {\r\n            mGhostView.invalidate(true);\r\n            return;\r\n        }\r\n\r\n        if (skipInvalidate()) {\r\n            return;\r\n        }\r\n\r\n        if ((mPrivateFlags & (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)) == (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)\r\n                || (invalidateCache && (mPrivateFlags & PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID)\r\n                || (mPrivateFlags & PFLAG_INVALIDATED) != PFLAG_INVALIDATED\r\n                || (fullInvalidate && isOpaque() != mLastIsOpaque)) {\r\n            if (fullInvalidate) {\r\n                mLastIsOpaque = isOpaque();\r\n                mPrivateFlags &= ~PFLAG_DRAWN;\r\n            }\r\n\r\n            mPrivateFlags |= PFLAG_DIRTY;\r\n\r\n            if (invalidateCache) {\r\n                mPrivateFlags |= PFLAG_INVALIDATED;\r\n                mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;\r\n            }\r\n\r\n            \/\/ Propagate the damage rectangle to the parent view.\r\n            final AttachInfo ai = mAttachInfo;\r\n            final ViewParent p = mParent;\r\n            if (p != null && ai != null && l < r && t < b) {\r\n                final Rect damage = ai.mTmpInvalRect;\r\n                damage.set(l, t, r, b);\r\n                p.invalidateChild(this, damage);\r\n            }\r\n\r\n            \/\/ Damage the entire projection receiver, if necessary.\r\n            if (mBackground != null && mBackground.isProjected()) {\r\n                final View receiver = getProjectionReceiver();\r\n                if (receiver != null) {\r\n                    receiver.damageInParent();\r\n                }\r\n            }\r\n\r\n            \/\/ Damage the entire IsolatedZVolume receiving this view's shadow.\r\n            if (isHardwareAccelerated() && getZ() != 0) {\r\n                damageShadowReceiver();\r\n            }\r\n        }\r\n    }\r\n```\r\n重点看invalidateChild()这个方法，方法里面有do while循环，每次循环出当前view的parent，最后一次循环返回的parent时ViewRootImpl类实例：\r\n\r\n```\r\n public final void invalidateChild(View child, final Rect dirty) {\r\n        ViewParent parent = this;\r\n\r\n        final AttachInfo attachInfo = mAttachInfo;\r\n        if (attachInfo != null) {\r\n            \/\/ If the child is drawing an animation, we want to copy this flag onto\r\n            \/\/ ourselves and the parent to make sure the invalidate request goes\r\n            \/\/ through\r\n            final boolean drawAnimation = (child.mPrivateFlags & PFLAG_DRAW_ANIMATION)\r\n                    == PFLAG_DRAW_ANIMATION;\r\n\r\n            \/\/ Check whether the child that requests the invalidate is fully opaque\r\n            \/\/ Views being animated or transformed are not considered opaque because we may\r\n            \/\/ be invalidating their old position and need the parent to paint behind them.\r\n            Matrix childMatrix = child.getMatrix();\r\n            final boolean isOpaque = child.isOpaque() && !drawAnimation &&\r\n                    child.getAnimation() == null && childMatrix.isIdentity();\r\n            \/\/ Mark the child as dirty, using the appropriate flag\r\n            \/\/ Make sure we do not set both flags at the same time\r\n            int opaqueFlag = isOpaque ? PFLAG_DIRTY_OPAQUE : PFLAG_DIRTY;\r\n\r\n            if (child.mLayerType != LAYER_TYPE_NONE) {\r\n                mPrivateFlags |= PFLAG_INVALIDATED;\r\n                mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;\r\n            }\r\n\r\n            final int[] location = attachInfo.mInvalidateChildLocation;\r\n            location[CHILD_LEFT_INDEX] = child.mLeft;\r\n            location[CHILD_TOP_INDEX] = child.mTop;\r\n            if (!childMatrix.isIdentity() ||\r\n                    (mGroupFlags & ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) {\r\n                RectF boundingRect = attachInfo.mTmpTransformRect;\r\n                boundingRect.set(dirty);\r\n                Matrix transformMatrix;\r\n                if ((mGroupFlags & ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) {\r\n                    Transformation t = attachInfo.mTmpTransformation;\r\n                    boolean transformed = getChildStaticTransformation(child, t);\r\n                    if (transformed) {\r\n                        transformMatrix = attachInfo.mTmpMatrix;\r\n                        transformMatrix.set(t.getMatrix());\r\n                        if (!childMatrix.isIdentity()) {\r\n                            transformMatrix.preConcat(childMatrix);\r\n                        }\r\n                    } else {\r\n                        transformMatrix = childMatrix;\r\n                    }\r\n                } else {\r\n                    transformMatrix = childMatrix;\r\n                }\r\n                transformMatrix.mapRect(boundingRect);\r\n                dirty.set((int) (boundingRect.left - 0.5f),\r\n                        (int) (boundingRect.top - 0.5f),\r\n                        (int) (boundingRect.right + 0.5f),\r\n                        (int) (boundingRect.bottom + 0.5f));\r\n            }\r\n\r\n            do {\r\n                View view = null;\r\n                if (parent instanceof View) {\r\n                    view = (View) parent;\r\n                }\r\n\r\n                if (drawAnimation) {\r\n                    if (view != null) {\r\n                        view.mPrivateFlags |= PFLAG_DRAW_ANIMATION;\r\n                    } else if (parent instanceof ViewRootImpl) {\r\n                        ((ViewRootImpl) parent).mIsAnimating = true;\r\n                    }\r\n                }\r\n\r\n                \/\/ If the parent is dirty opaque or not dirty, mark it dirty with the opaque\r\n                \/\/ flag coming from the child that initiated the invalidate\r\n                if (view != null) {\r\n                    if ((view.mViewFlags & FADING_EDGE_MASK) != 0 &&\r\n                            view.getSolidColor() == 0) {\r\n                        opaqueFlag = PFLAG_DIRTY;\r\n                    }\r\n                    if ((view.mPrivateFlags & PFLAG_DIRTY_MASK) != PFLAG_DIRTY) {\r\n                        view.mPrivateFlags = (view.mPrivateFlags & ~PFLAG_DIRTY_MASK) | opaqueFlag;\r\n                    }\r\n                }\r\n\r\n                parent = parent.invalidateChildInParent(location, dirty);\r\n                if (view != null) {\r\n                    \/\/ Account for transform on current parent\r\n                    Matrix m = view.getMatrix();\r\n                    if (!m.isIdentity()) {\r\n                        RectF boundingRect = attachInfo.mTmpTransformRect;\r\n                        boundingRect.set(dirty);\r\n                        m.mapRect(boundingRect);\r\n                        dirty.set((int) (boundingRect.left - 0.5f),\r\n                                (int) (boundingRect.top - 0.5f),\r\n                                (int) (boundingRect.right + 0.5f),\r\n                                (int) (boundingRect.bottom + 0.5f));\r\n                    }\r\n                }\r\n            } while (parent != null);\r\n        }\r\n    }\r\n```\r\n现在查看ViewRootImpl类的invalidateChildInParent()方法：\r\n\r\n```\r\n    @Override\r\n    public ViewParent invalidateChildInParent(int[] location, Rect dirty) {\r\n        checkThread();\r\n        if (DEBUG_DRAW) Log.v(TAG, \"Invalidate child: \" + dirty);\r\n\r\n        if (dirty == null) {\r\n            invalidate();\r\n            return null;\r\n        } else if (dirty.isEmpty() && !mIsAnimating) {\r\n            return null;\r\n        }\r\n\r\n        if (mCurScrollY != 0 || mTranslator != null) {\r\n            mTempRect.set(dirty);\r\n            dirty = mTempRect;\r\n            if (mCurScrollY != 0) {\r\n                dirty.offset(0, -mCurScrollY);\r\n            }\r\n            if (mTranslator != null) {\r\n                mTranslator.translateRectInAppWindowToScreen(dirty);\r\n            }\r\n            if (mAttachInfo.mScalingRequired) {\r\n                dirty.inset(-1, -1);\r\n            }\r\n        }\r\n\r\n        final Rect localDirty = mDirty;\r\n        if (!localDirty.isEmpty() && !localDirty.contains(dirty)) {\r\n            mAttachInfo.mSetIgnoreDirtyState = true;\r\n            mAttachInfo.mIgnoreDirtyState = true;\r\n        }\r\n\r\n        \/\/ Add the new dirty rect to the current one\r\n        localDirty.union(dirty.left, dirty.top, dirty.right, dirty.bottom);\r\n        \/\/ Intersect with the bounds of the window to skip\r\n        \/\/ updates that lie outside of the visible region\r\n        final float appScale = mAttachInfo.mApplicationScale;\r\n        final boolean intersected = localDirty.intersect(0, 0,\r\n                (int) (mWidth * appScale + 0.5f), (int) (mHeight * appScale + 0.5f));\r\n        if (!intersected) {\r\n            localDirty.setEmpty();\r\n        }\r\n        if (!mWillDrawSoon && (intersected || mIsAnimating)) {\r\n            scheduleTraversals();\r\n        }\r\n\r\n        return null;\r\n    }\r\n```\r\n方法块的第一行好像就是我们要找的验证线程的地方checkThread()，而该方法内容也很简单，看到抛出的异常就很熟悉了：\r\n\r\n```\r\n    void checkThread() {\r\n        if (mThread != Thread.currentThread()) {\r\n            throw new CalledFromWrongThreadException(\r\n                    \"Only the original thread that created a view hierarchy can touch its views.\");\r\n        }\r\n    }\r\n```\r\n第二步，验证线程地方已经找到了，假设得到了证实，那么为什么该有的异常没有出现呢？现在再次假设是不是因为某些原因导致checkThread()没有执行呢？\r\n\r\n有人可能会问会不会是mThread == Thread.currentThread()？其实这是不可能的 ，先看下mThread赋值：\r\n\r\n```\r\n    public ViewRootImpl(Context context, Display display) {\r\n        mContext = context;\r\n        mWindowSession = WindowManagerGlobal.getWindowSession();\r\n        mDisplay = display;\r\n        mBasePackageName = context.getBasePackageName();\r\n\r\n        mDisplayAdjustments = display.getDisplayAdjustments();\r\n\r\n        mThread = Thread.currentThread();\r\n```\r\nViewRootImpl类实例化是在Activity启动时的主线程创建的，所以mThread是主线程实例，而checkThread()中的Thread.currentThread()，最初是由textView.setText()调用的一系列方法栈，并且setText是在子线程调用。\r\n\r\n继续刚才的假设，不过现在要逆推回去，checkThread()方法没有执行，可以认为ViewRootImpl的invalidateChildInParent()方法没有执行，它又是在ViewGroup中invalidateChild()方法里的do while中调用，要使do while不被调用，继续往上看，如果attachInfo为null，进不去if语句块也就不会执行checkThread()了，这是第一个可能的原因。记录下，继续逆推。\r\n\r\nView中的invalidateInternal()方法：\r\n\r\n```\r\n      \/\/ Propagate the damage rectangle to the parent view.\r\n            final AttachInfo ai = mAttachInfo;\r\n            final ViewParent p = mParent;\r\n            if (p != null && ai != null && l < r && t < b) {\r\n                final Rect damage = ai.mTmpInvalRect;\r\n                damage.set(l, t, r, b);\r\n                p.invalidateChild(this, damage);\r\n            }\r\n```\r\n根据判断条件，如果p即mParent或者ai即mAttachInfo 任一为null，都不会执行invalidateChild，这是第二个可能原因，这里的ai和第一个原因的attachInfo是一样的，所以第一个原因可能忽略，精力关注在第二个原因上。\r\n\r\n>现在的关注点是实例p和ai是什么时候创建的，有没有为null的现象？\r\n\r\n```\r\n     final AttachInfo ai = mAttachInfo;\r\n```\r\n而mAttachInfo是在View的dispatchAttachedToWindow()方法中赋值的：\r\n\r\n```\r\n void dispatchAttachedToWindow(AttachInfo info, int visibility) {\r\n        \/\/System.out.println(\"Attached! \" + this);\r\n        mAttachInfo = info;\r\n}\r\n```\r\nView的dispatchAttachedToWindow()方法是在ViewRootImpl中的performTraversals()方法调用，这个方法是遍历View Tree\r\n\r\n```\r\n private void performTraversals() {\r\n        \/\/ cache mView since it is used so much below...\r\n        final View host = mView;\r\n        ·······\r\n        host.dispatchAttachedToWindow(mAttachInfo, 0);\r\n\r\n```\r\n可见View中的mAttachInfo来自ViewrootImpl的mAttachInfo，而ViewrootImpl的mAttachInfo是在其构造方法中被赋值的：\r\n\r\n```\r\n\r\n    public ViewRootImpl(Context context, Display display) {\r\n        mContext = context;\r\n        mWindowSession = WindowManagerGlobal.getWindowSession();\r\n        mDisplay = display;\r\n        mBasePackageName = context.getBasePackageName();\r\n\r\n        mDisplayAdjustments = display.getDisplayAdjustments();\r\n\r\n        mThread = Thread.currentThread();\r\n        mLocation = new WindowLeaked(null);\r\n        mLocation.fillInStackTrace();\r\n        mWidth = -1;\r\n        mHeight = -1;\r\n        mDirty = new Rect();\r\n        mTempRect = new Rect();\r\n        mVisRect = new Rect();\r\n        mWinFrame = new Rect();\r\n        mWindow = new W(this);\r\n        mTargetSdkVersion = context.getApplicationInfo().targetSdkVersion;\r\n        mViewVisibility = View.GONE;\r\n        mTransparentRegion = new Region();\r\n        mPreviousTransparentRegion = new Region();\r\n        mFirst = true; \/\/ true for the first time the view is added\r\n        mAdded = false;\r\n        mAttachInfo = new View.AttachInfo(mWindowSession, mWindow, display, this, mHandler, this);\r\n       \r\n    }\r\n```\r\n\r\n之前说了ViewRootImpl实例是在Activity启动时创建的，现在看看具体是启动的什么时候:在向window添加view的时候即：WindowManagerGlobal的addView方法中创建ViewrootImpl实例：\r\n\r\n```\r\n public void addView(View view, ViewGroup.LayoutParams params,\r\n            Display display, Window parentWindow) {\r\n        if (view == null) {\r\n            throw new IllegalArgumentException(\"view must not be null\");\r\n        }\r\n        if (display == null) {\r\n            throw new IllegalArgumentException(\"display must not be null\");\r\n        }\r\n        if (!(params instanceof WindowManager.LayoutParams)) {\r\n            throw new IllegalArgumentException(\"Params must be WindowManager.LayoutParams\");\r\n        }\r\n\r\n        final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams)params;\r\n        if (parentWindow != null) {\r\n            parentWindow.adjustLayoutParamsForSubWindow(wparams);\r\n        } else {\r\n            \/\/ If there's no parent and we're running on L or above (or in the\r\n            \/\/ system context), assume we want hardware acceleration.\r\n            final Context context = view.getContext();\r\n            if (context != null\r\n                    && context.getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.LOLLIPOP) {\r\n                wparams.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;\r\n            }\r\n        }\r\n\r\n        ViewRootImpl root;\r\n        View panelParentView = null;\r\n\r\n        synchronized (mLock) {\r\n            \/\/ Start watching for system property changes.\r\n            if (mSystemPropertyUpdater == null) {\r\n                mSystemPropertyUpdater = new Runnable() {\r\n                    @Override public void run() {\r\n                        synchronized (mLock) {\r\n                            for (int i = mRoots.size() - 1; i >= 0; --i) {\r\n                                mRoots.get(i).loadSystemProperties();\r\n                            }\r\n                        }\r\n                    }\r\n                };\r\n                SystemProperties.addChangeCallback(mSystemPropertyUpdater);\r\n            }\r\n\r\n            int index = findViewLocked(view, false);\r\n            if (index >= 0) {\r\n                if (mDyingViews.contains(view)) {\r\n                    \/\/ Don't wait for MSG_DIE to make it's way through root's queue.\r\n                    mRoots.get(index).doDie();\r\n                } else {\r\n                    throw new IllegalStateException(\"View \" + view\r\n                            + \" has already been added to the window manager.\");\r\n                }\r\n                \/\/ The previous removeView() had not completed executing. Now it has.\r\n            }\r\n\r\n            \/\/ If this is a panel window, then find the window it is being\r\n            \/\/ attached to for future reference.\r\n            if (wparams.type >= WindowManager.LayoutParams.FIRST_SUB_WINDOW &&\r\n                    wparams.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {\r\n                final int count = mViews.size();\r\n                for (int i = 0; i < count; i++) {\r\n                    if (mRoots.get(i).mWindow.asBinder() == wparams.token) {\r\n                        panelParentView = mViews.get(i);\r\n                    }\r\n                }\r\n            }\r\n\r\n            root = new ViewRootImpl(view.getContext(), display);\r\n\r\n            view.setLayoutParams(wparams);\r\n\r\n            mViews.add(view);\r\n            mRoots.add(root);\r\n            mParams.add(wparams);\r\n        }\r\n\r\n        \/\/ do this last because it fires off messages to start doing things\r\n        try {\r\n            root.setView(view, wparams, panelParentView);\r\n        } catch (RuntimeException e) {\r\n            \/\/ BadTokenException or InvalidDisplayException, clean up.\r\n            synchronized (mLock) {\r\n                final int index = findViewLocked(view, false);\r\n                if (index >= 0) {\r\n                    removeViewLocked(index, true);\r\n                }\r\n            }\r\n            throw e;\r\n        }\r\n    }\r\n\r\n```\r\n\r\n而调用addView()方法是在ActivityThread类的handleResumeActivity()方法：\r\n\r\n```\r\n\r\n    final void handleResumeActivity(IBinder token,\r\n            boolean clearHide, boolean isForward, boolean reallyResume) {\r\n        \/\/ If we are getting ready to gc after going to the background, well\r\n        \/\/ we are back active so skip it.\r\n        unscheduleGcIdler();\r\n        mSomeActivitiesChanged = true;\r\n\r\n        \/\/ TODO Push resumeArgs into the activity for consideration\r\n        ActivityClientRecord r = performResumeActivity(token, clearHide);\r\n\r\n        if (r != null) {\r\n            final Activity a = r.activity;\r\n\r\n            if (localLOGV) Slog.v(\r\n                TAG, \"Resume \" + r + \" started activity: \" +\r\n                a.mStartedActivity + \", hideForNow: \" + r.hideForNow\r\n                + \", finished: \" + a.mFinished);\r\n\r\n            final int forwardBit = isForward ?\r\n                    WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0;\r\n\r\n            \/\/ If the window hasn't yet been added to the window manager,\r\n            \/\/ and this guy didn't finish itself or start another activity,\r\n            \/\/ then go ahead and add the window.\r\n            boolean willBeVisible = !a.mStartedActivity;\r\n            if (!willBeVisible) {\r\n                try {\r\n                    willBeVisible = ActivityManagerNative.getDefault().willActivityBeVisible(\r\n                            a.getActivityToken());\r\n                } catch (RemoteException e) {\r\n                }\r\n            }\r\n            if (r.window == null && !a.mFinished && willBeVisible) {\r\n                r.window = r.activity.getWindow();\r\n                View decor = r.window.getDecorView();\r\n                decor.setVisibility(View.INVISIBLE);\r\n                ViewManager wm = a.getWindowManager();\r\n                WindowManager.LayoutParams l = r.window.getAttributes();\r\n                a.mDecor = decor;\r\n                l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;\r\n                l.softInputMode |= forwardBit;\r\n                if (a.mVisibleFromClient) {\r\n                    a.mWindowAdded = true;\r\n                    wm.addView(decor, l);\r\n                }\r\n\r\n            \/\/ If the window has already been added, but during resume\r\n            \/\/ we started another activity, then don't yet make the\r\n            \/\/ window visible.\r\n            } else if (!willBeVisible) {\r\n                if (localLOGV) Slog.v(\r\n                    TAG, \"Launch \" + r + \" mStartedActivity set\");\r\n                r.hideForNow = true;\r\n            }\r\n\r\n            \/\/ Get rid of anything left hanging around.\r\n            cleanUpPendingRemoveWindows(r);\r\n\r\n            \/\/ The window is now visible if it has been added, we are not\r\n            \/\/ simply finishing, and we are not starting another activity.\r\n            if (!r.activity.mFinished && willBeVisible\r\n                    && r.activity.mDecor != null && !r.hideForNow) {\r\n                if (r.newConfig != null) {\r\n                    if (DEBUG_CONFIGURATION) Slog.v(TAG, \"Resuming activity \"\r\n                            + r.activityInfo.name + \" with newConfig \" + r.newConfig);\r\n                    performConfigurationChanged(r.activity, r.newConfig);\r\n                    freeTextLayoutCachesIfNeeded(r.activity.mCurrentConfig.diff(r.newConfig));\r\n                    r.newConfig = null;\r\n                }\r\n                if (localLOGV) Slog.v(TAG, \"Resuming \" + r + \" with isForward=\"\r\n                        + isForward);\r\n                WindowManager.LayoutParams l = r.window.getAttributes();\r\n                if ((l.softInputMode\r\n                        & WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)\r\n                        != forwardBit) {\r\n                    l.softInputMode = (l.softInputMode\r\n                            & (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION))\r\n                            | forwardBit;\r\n                    if (r.activity.mVisibleFromClient) {\r\n                        ViewManager wm = a.getWindowManager();\r\n                        View decor = r.window.getDecorView();\r\n                        wm.updateViewLayout(decor, l);\r\n                    }\r\n                }\r\n                r.activity.mVisibleFromServer = true;\r\n                mNumVisibleActivities++;\r\n                if (r.activity.mVisibleFromClient) {\r\n                    r.activity.makeVisible();\r\n                }\r\n            }\r\n\r\n            if (!r.onlyLocalRequest) {\r\n                r.nextIdle = mNewActivities;\r\n                mNewActivities = r;\r\n                if (localLOGV) Slog.v(\r\n                    TAG, \"Scheduling idle handler for \" + r);\r\n                Looper.myQueue().addIdleHandler(new Idler());\r\n            }\r\n            r.onlyLocalRequest = false;\r\n\r\n            \/\/ Tell the activity manager we have resumed.\r\n            if (reallyResume) {\r\n                try {\r\n                    ActivityManagerNative.getDefault().activityResumed(token);\r\n                } catch (RemoteException ex) {\r\n                }\r\n            }\r\n\r\n        } else {\r\n            \/\/ If an exception was thrown when trying to resume, then\r\n            \/\/ just end this activity.\r\n            try {\r\n                ActivityManagerNative.getDefault()\r\n                    .finishActivity(token, Activity.RESULT_CANCELED, null, false);\r\n            } catch (RemoteException ex) {\r\n            }\r\n        }\r\n    }\r\n```\r\n\r\n看到上面的方法有些人心里可能有底儿了，handleResumeActivity()方法是不是让Activity回调onResume？如果是的话一切就都明了了，因为ViewrootImpl是在onReume期间创建，而AttachInfo是在ViewRootImpl实例化时创建，我们的工作线程是在onCreate时刷新UI的，那时候还没有实例化AttachInfo，导致mAttachInfo为null，最终if条件判断失败没有进入。然而这一切都是在YY，实践才是检验真理的唯一标准，动起来：\r\n\r\n看到这一行代码```\r\nActivityClientRecord r = performResumeActivity(token, clearHide);\r\n```微微一笑，点进去看看，\r\n\r\n```\r\n    public final ActivityClientRecord performResumeActivity(IBinder token,\r\n            boolean clearHide) {\r\n        ActivityClientRecord r = mActivities.get(token);\r\n        if (localLOGV) Slog.v(TAG, \"Performing resume of \" + r\r\n                + \" finished=\" + r.activity.mFinished);\r\n        if (r != null && !r.activity.mFinished) {\r\n            if (clearHide) {\r\n                r.hideForNow = false;\r\n                r.activity.mStartedActivity = false;\r\n            }\r\n            try {\r\n                r.activity.mFragments.noteStateNotSaved();\r\n                if (r.pendingIntents != null) {\r\n                    deliverNewIntents(r, r.pendingIntents);\r\n                    r.pendingIntents = null;\r\n                }\r\n                if (r.pendingResults != null) {\r\n                    deliverResults(r, r.pendingResults);\r\n                    r.pendingResults = null;\r\n                }\r\n                r.activity.performResume();\r\n    \r\n                EventLog.writeEvent(LOG_ON_RESUME_CALLED,\r\n                        UserHandle.myUserId(), r.activity.getComponentName().getClassName());\r\n    \r\n                r.paused = false;\r\n                r.stopped = false;\r\n                r.state = null;\r\n                r.persistentState = null;\r\n            } catch (Exception e) {\r\n                if (!mInstrumentation.onException(r.activity, e)) {\r\n                    throw new RuntimeException(\r\n                        \"Unable to resume activity \"\r\n                        + r.intent.getComponent().toShortString()\r\n                        + \": \" + e.toString(), e);\r\n                }\r\n            }\r\n        }\r\n        return r;\r\n    }\r\n```\r\n代码很短，很容易提取有用信息：``` r.activity.performResume();```在进去看看：\r\n\r\n```\r\n\r\n    final void performResume() {\r\n        performRestart();\r\n    \r\n        mFragments.execPendingActions();\r\n    \r\n        mLastNonConfigurationInstances = null;\r\n    \r\n        mCalled = false;\r\n        \/\/ mResumed is set by the instrumentation\r\n        mInstrumentation.callActivityOnResume(this);\r\n        if (!mCalled) {\r\n            throw new SuperNotCalledException(\r\n                \"Activity \" + mComponent.toShortString() +\r\n                \" did not call through to super.onResume()\");\r\n        }\r\n    \r\n        \/\/ Now really resume, and install the current status bar and menu.\r\n        mCalled = false;\r\n    \r\n        mFragments.dispatchResume();\r\n        mFragments.execPendingActions();\r\n    \r\n        onPostResume();\r\n        if (!mCalled) {\r\n            throw new SuperNotCalledException(\r\n                \"Activity \" + mComponent.toShortString() +\r\n                \" did not call through to super.onPostResume()\");\r\n        }\r\n    }\r\n```\r\n看到```mInstrumentation```这个属性就能感觉到越来越接近SDK API层了，看看它的```callActivityOnResume()```方法做了什么：\r\n\r\n```\r\n    public void callActivityOnResume(Activity activity) {\r\n        activity.mResumed = true;\r\n        activity.onResume();\r\n        \r\n        if (mActivityMonitors != null) {\r\n            synchronized (mSync) {\r\n                final int N = mActivityMonitors.size();\r\n                for (int i=0; i<N; i++) {\r\n                    final ActivityMonitor am = mActivityMonitors.get(i);\r\n                    am.match(activity, activity, activity.getIntent());\r\n                }\r\n            }\r\n        }\r\n    }\r\n```\r\n\r\n一行```activity.onResume();```已经水落石出。\r\n回到handleResumeActivity代码中，我精简下：\r\n\r\n```\r\n final void handleResumeActivity(IBinder token,\r\n            boolean clearHide, boolean isForward, boolean reallyResume) {\r\n   \/\/这里是最终回调Activity的onResume()方法\r\n        ActivityClientRecord r = performResumeActivity(token, clearHide);\r\n\/\/省略若干\r\n        if (r != null) {\r\n            final Activity a = r.activity;\r\n            final int forwardBit = isForward ?\r\n            WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0;\r\n            boolean willBeVisible = !a.mStartedActivity;\r\n    \r\n            if (r.window == null && !a.mFinished && willBeVisible) {\r\n                r.window = r.activity.getWindow();\r\n                View decor = r.window.getDecorView();\r\n                decor.setVisibility(View.INVISIBLE);\r\n                ViewManager wm = a.getWindowManager();\r\n                WindowManager.LayoutParams l = r.window.getAttributes();\r\n                a.mDecor = decor;\r\n                l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;\r\n                l.softInputMode |= forwardBit;\r\n                if (a.mVisibleFromClient) {\r\n                    a.mWindowAdded = true;\r\n\/\/这里是调用WindowManagerGlobal的addView()方法最终实例化ViewRootImpl，进而实例化AttachInfo\r\n                    wm.addView(decor, l);\r\n                }\r\n       \r\n            } else if (!willBeVisible) {\r\n                if (localLOGV) Slog.v(\r\n                    TAG, \"Launch \" + r + \" mStartedActivity set\");\r\n                r.hideForNow = true;\r\n            }\r\n        }\r\n    }\r\n```\r\n\r\n\r\n另外关于阅读源码问题，win下当然使用SourceInsight不二选，如果是在mac下可以参考我的[osx下如何使用SublimeText阅读Android系统源码](http:\/\/www.jianshu.com\/p\/c295d2729ecf).。\r\n```"
  },
  {
    "title": "为什么相对布局比线性布局性能低",
    "created_time": "2017-07-19 10:53:28",
    "body": "# 0x00 前言\r\n\r\nUI优化原则之一：如果使用线性布局和相对布局的层级一样，那么优先使用线性布局。\r\n\r\n经常说出这个原则的时候就会顺便被问到为什么。为了避免尴尬还是抽时间把源码大概看了一下。\r\n\r\n<!-- more -->\r\n\r\n# 0x01 View绘制流程简述 \r\n\r\n看过源码的应该知道，View的绘制是从`ViewRootImpl.performTraversals()`方法开始的。\r\n\r\n先后经历`performMeasure`、`performLayout`和`performDraw`三个阶段，就是常说的测量、布局和绘制。\r\n\r\n- performMeasure会调用根View的measure，进而调用onMeasure方法\r\n- performLayout调用根View的layout，进而调用onLayout方法\r\n- performDraw调用根View的draw，进而调用onDraw方法\r\n\r\n鉴于两个都是ViewGroup，所以可以忽略onDraw\r\n\r\n有对比才有伤害，要比较这两个布局性能，要先看看这两个布局分别在onMeasure，onLayout都做了什么。\r\n\r\n# 0x02 LinearLayout分析\r\n\r\nLinearLayout的onMeasure方法内容很简单，就是判断方向然后分别调用:\r\n\r\n```java\r\n   @Override\r\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\r\n        if (mOrientation == VERTICAL) {\r\n            measureVertical(widthMeasureSpec, heightMeasureSpec);\r\n        } else {\r\n            measureHorizontal(widthMeasureSpec, heightMeasureSpec);\r\n        }\r\n    }\r\n```\r\n\r\n那就随便看看`measureVertical`方法里面干了些什么：\r\n\r\n```Java\r\n        \/\/ See how tall everyone is. Also remember max width.\r\n        for (int i = 0; i < count; ++i) {\r\n            final View child = getVirtualChildAt(i);\r\n\r\n            if (child == null) {\r\n                mTotalLength += measureNullChild(i);\r\n                continue;\r\n            }\r\n\r\n            if (child.getVisibility() == View.GONE) {\r\n               i += getChildrenSkipCount(child, i);\r\n               continue;\r\n            }\r\n\r\n            if (hasDividerBeforeChildAt(i)) {\r\n                mTotalLength += mDividerHeight;\r\n            }\r\n\r\n            LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();\r\n\r\n            totalWeight += lp.weight;\r\n            \r\n            if (heightMode == MeasureSpec.EXACTLY && lp.height == 0 && lp.weight > 0) {\r\n                \/\/ Optimization: don't bother measuring children who are going to use\r\n                \/\/ leftover space. These views will get measured again down below if\r\n                \/\/ there is any leftover space.\r\n                final int totalLength = mTotalLength;\r\n                mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);\r\n                skippedMeasure = true;\r\n            } else {\r\n                int oldHeight = Integer.MIN_VALUE;\r\n\r\n                if (lp.height == 0 && lp.weight > 0) {\r\n                    \/\/ heightMode is either UNSPECIFIED or AT_MOST, and this\r\n                    \/\/ child wanted to stretch to fill available space.\r\n                    \/\/ Translate that to WRAP_CONTENT so that it does not end up\r\n                    \/\/ with a height of 0\r\n                    oldHeight = 0;\r\n                    lp.height = LayoutParams.WRAP_CONTENT;\r\n                }\r\n\r\n                \/\/ Determine how big this child would like to be. If this or\r\n                \/\/ previous children have given a weight, then we allow it to\r\n                \/\/ use all available space (and we will shrink things later\r\n                \/\/ if needed).\r\n                measureChildBeforeLayout(\r\n                       child, i, widthMeasureSpec, 0, heightMeasureSpec,\r\n                       totalWeight == 0 ? mTotalLength : 0);\r\n\r\n                if (oldHeight != Integer.MIN_VALUE) {\r\n                   lp.height = oldHeight;\r\n                }\r\n\r\n                final int childHeight = child.getMeasuredHeight();\r\n                final int totalLength = mTotalLength;\r\n                mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin +\r\n                       lp.bottomMargin + getNextLocationOffset(child));\r\n\r\n                if (useLargestChild) {\r\n                    largestChildHeight = Math.max(childHeight, largestChildHeight);\r\n                }\r\n            }\r\n\r\n            \/**\r\n             * If applicable, compute the additional offset to the child's baseline\r\n             * we'll need later when asked {@link #getBaseline}.\r\n             *\/\r\n            if ((baselineChildIndex >= 0) && (baselineChildIndex == i + 1)) {\r\n               mBaselineChildTop = mTotalLength;\r\n            }\r\n\r\n            \/\/ if we are trying to use a child index for our baseline, the above\r\n            \/\/ book keeping only works if there are no children above it with\r\n            \/\/ weight.  fail fast to aid the developer.\r\n            if (i < baselineChildIndex && lp.weight > 0) {\r\n                throw new RuntimeException(\"A child of LinearLayout with index \"\r\n                        + \"less than mBaselineAlignedChildIndex has weight > 0, which \"\r\n                        + \"won't work.  Either remove the weight, or don't set \"\r\n                        + \"mBaselineAlignedChildIndex.\");\r\n            }\r\n\r\n            boolean matchWidthLocally = false;\r\n            if (widthMode != MeasureSpec.EXACTLY && lp.width == LayoutParams.MATCH_PARENT) {\r\n                \/\/ The width of the linear layout will scale, and at least one\r\n                \/\/ child said it wanted to match our width. Set a flag\r\n                \/\/ indicating that we need to remeasure at least that view when\r\n                \/\/ we know our width.\r\n                matchWidth = true;\r\n                matchWidthLocally = true;\r\n            }\r\n\r\n            final int margin = lp.leftMargin + lp.rightMargin;\r\n            final int measuredWidth = child.getMeasuredWidth() + margin;\r\n            maxWidth = Math.max(maxWidth, measuredWidth);\r\n            childState = combineMeasuredStates(childState, child.getMeasuredState());\r\n\r\n            allFillParent = allFillParent && lp.width == LayoutParams.MATCH_PARENT;\r\n            if (lp.weight > 0) {\r\n                \/*\r\n                 * Widths of weighted Views are bogus if we end up\r\n                 * remeasuring, so keep them separate.\r\n                 *\/\r\n                weightedMaxWidth = Math.max(weightedMaxWidth,\r\n                        matchWidthLocally ? margin : measuredWidth);\r\n            } else {\r\n                alternativeMaxWidth = Math.max(alternativeMaxWidth,\r\n                        matchWidthLocally ? margin : measuredWidth);\r\n            }\r\n\r\n            i += getChildrenSkipCount(child, i);\r\n        }  \r\n```\r\n\r\n这个方法主要是for循环中通过`measureChildBeforeLayout`测量子View高度，把每次测量的高度都累加到`mTotalLength`。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 0x03 RelativeLayout分析\r\n\r\n看看RelativeLayout的onMeasure方法：\r\n\r\n```java\r\n       View[] views = mSortedHorizontalChildren;\r\n        int count = views.length;\r\n\r\n        for (int i = 0; i < count; i++) {\r\n            View child = views[i];\r\n            if (child.getVisibility() != GONE) {\r\n                LayoutParams params = (LayoutParams) child.getLayoutParams();\r\n                int[] rules = params.getRules(layoutDirection);\r\n\r\n                applyHorizontalSizeRules(params, myWidth, rules);\r\n                measureChildHorizontal(child, params, myWidth, myHeight);\r\n\r\n                if (positionChildHorizontal(child, params, myWidth, isWrapContentWidth)) {\r\n                    offsetHorizontalAxis = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        views = mSortedVerticalChildren;\r\n        count = views.length;\r\n        final int targetSdkVersion = getContext().getApplicationInfo().targetSdkVersion;\r\n\r\n        for (int i = 0; i < count; i++) {\r\n            View child = views[i];\r\n            if (child.getVisibility() != GONE) {\r\n                LayoutParams params = (LayoutParams) child.getLayoutParams();\r\n                \r\n                applyVerticalSizeRules(params, myHeight);\r\n                measureChild(child, params, myWidth, myHeight);\r\n                if (positionChildVertical(child, params, myHeight, isWrapContentHeight)) {\r\n                    offsetVerticalAxis = true;\r\n                }\r\n\r\n                if (isWrapContentWidth) {\r\n                    if (isLayoutRtl()) {\r\n                        if (targetSdkVersion < Build.VERSION_CODES.KITKAT) {\r\n                            width = Math.max(width, myWidth - params.mLeft);\r\n                        } else {\r\n                            width = Math.max(width, myWidth - params.mLeft - params.leftMargin);\r\n                        }\r\n                    } else {\r\n                        if (targetSdkVersion < Build.VERSION_CODES.KITKAT) {\r\n                            width = Math.max(width, params.mRight);\r\n                        } else {\r\n                            width = Math.max(width, params.mRight + params.rightMargin);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (isWrapContentHeight) {\r\n                    if (targetSdkVersion < Build.VERSION_CODES.KITKAT) {\r\n                        height = Math.max(height, params.mBottom);\r\n                    } else {\r\n                        height = Math.max(height, params.mBottom + params.bottomMargin);\r\n                    }\r\n                }\r\n\r\n                if (child != ignore || verticalGravity) {\r\n                    left = Math.min(left, params.mLeft - params.leftMargin);\r\n                    top = Math.min(top, params.mTop - params.topMargin);\r\n                }\r\n\r\n                if (child != ignore || horizontalGravity) {\r\n                    right = Math.max(right, params.mRight + params.rightMargin);\r\n                    bottom = Math.max(bottom, params.mBottom + params.bottomMargin);\r\n                }\r\n            }\r\n        }\r\n```\r\n\r\n第一个for循环中`measureChildHorizontal`方法实现如下：\r\n\r\n```Java\r\n     int childWidthMeasureSpec = getChildMeasureSpec(params.mLeft,\r\n                params.mRight, params.width,\r\n                params.leftMargin, params.rightMargin,\r\n                mPaddingLeft, mPaddingRight,\r\n                myWidth);\r\n        int maxHeight = myHeight;\r\n        if (mMeasureVerticalWithPaddingMargin) {\r\n            maxHeight = Math.max(0, myHeight - mPaddingTop - mPaddingBottom -\r\n                    params.topMargin - params.bottomMargin);\r\n        }\r\n        int childHeightMeasureSpec;\r\n        if (myHeight < 0 && !mAllowBrokenMeasureSpecs) {\r\n            if (params.height >= 0) {\r\n                childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(\r\n                        params.height, MeasureSpec.EXACTLY);\r\n            } else {\r\n                \/\/ Negative values in a mySize\/myWidth\/myWidth value in RelativeLayout measurement\r\n                \/\/ is code for, \"we got an unspecified mode in the RelativeLayout's measurespec.\"\r\n                \/\/ Carry it forward.\r\n                childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);\r\n            }\r\n        } else if (params.width == LayoutParams.MATCH_PARENT) {\r\n            childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(maxHeight, MeasureSpec.EXACTLY);\r\n        } else {\r\n            childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(maxHeight, MeasureSpec.AT_MOST);\r\n        }\r\n        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);\r\n```\r\n\r\n\r\n\r\n第二个for循环中`measureChild`实现如下：\r\n\r\n```Java\r\nint childWidthMeasureSpec = getChildMeasureSpec(params.mLeft,\r\n                params.mRight, params.width,\r\n                params.leftMargin, params.rightMargin,\r\n                mPaddingLeft, mPaddingRight,\r\n                myWidth);\r\n        int childHeightMeasureSpec = getChildMeasureSpec(params.mTop,\r\n                params.mBottom, params.height,\r\n                params.topMargin, params.bottomMargin,\r\n                mPaddingTop, mPaddingBottom,\r\n                myHeight);\r\n        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);\r\n```\r\n\r\n两个for循环中都执行了`child.measure(childWidthMeasureSpec, childHeightMeasureSpec);`这意味着子View测量执行了两遍。\r\n\r\n为什么RelativeLayout要测量两遍？\r\n\r\n> 因为RelativeLayout并不像LinearLayout那样有着方向单一性。RelativeLayout的灵活性就在于允许纵横双向的，这样view直接不仅横向依赖，还有纵向依赖，每个方向都要测量一遍。导致性能略差。"
  },
  {
    "title": "为什么Android中很多int常量使用十六进制表示",
    "created_time": "2017-07-19 10:12:21",
    "body": "# 0x00 前言\r\n\r\n在Java或者Android中，发现很多涉及框架和源码地方，很多int常量都是使用十六进制表示的，而不是我们日常开发中直接使用我们最熟悉的十进制。这是为什么呢？换个问法，这样做有什么好处呢？\r\n\r\n```java\r\n    public static final int FLAG_DEBUG_TRIAGED_MISSING = 0x00000100;\r\n    public static final int FLAG_IGNORE_EPHEMERAL = 0x00000200;\r\n    public static final int FLAG_ACTIVITY_NO_HISTORY = 0x40000000;\r\n    public static final int FLAG_ACTIVITY_NEW_TASK = 0x10000000;\r\n    public static final int FLAG_ACTIVITY_MULTIPLE_TASK = 0x08000000;\r\n    public static final int FLAG_ACTIVITY_CLEAR_TASK = 0X00008000;\r\n    public static final int FLAG_ACTIVITY_TASK_ON_HOME = 0X00004000;\r\n\r\n```\r\n\r\n<!-- more -->\r\n\r\n猜测可能的原因：\r\n\r\n①为了美观\r\n\r\n②为了方便位运算\r\n\r\n③关于①我是瞎说的\r\n\r\n既然多采用十六进制，那就先简单看看什么是十六进制\r\n\r\n# 0x01 十六进制简单介绍\r\n\r\n以0x或0X开头，使用数字0~9及字符A~F表示16个可能的值，这种进制方式一般称为十六进制。\r\n\r\n一个int占4个字节，32位。\r\n\r\n十六进制中0xF最大，二进制表示：1111，用4位即可表示出来，所以在用十六进制表示int时，通常0x后面跟8位数字\/字符，这样就可以表示满一个int值。也就是前言中所看到的。\r\n\r\n# 0x02 发现规律\r\n\r\n通过前言中的代码可以发现基本上频繁出现的只有1，2，4，8几个数字而其他位置都是0占位。为什么会出现这种情况呢？\r\n\r\n首先把上面的十六进制转换成二进制看一下：\r\n\r\n`0x00000100`转换二进制`0001 0000 0000`\r\n\r\n`0x00000200`转换二进制`0010 0000 0000` \r\n\r\n`0X00004000`转换二进制`0100 0000 0000 0000`\r\n\r\n`0X00008000`转换二进制`1000 0000 0000`\r\n\r\n转换后可以发现，1，2，4，8这几个值很特殊，在二进制中表示这几个数时都只要某一位为1，其他位用0占位即可表示。\r\n\r\n换句话说，二进制的4位表示十六进制中的一个数字，而这4位中若只有其中一位为1的话，那么可能的值情况为1=2º，2=2¹，4=2²，8=2³。\r\n\r\n\r\n\r\n这样做有什么好处呢？\r\n\r\n# 0x03 这样做的好处\r\n\r\n- 拿位移来说因为只有一个数字带值，其他都是0占位，位移时大脑中快速把十六进制转为二进制然后补0位即可。\r\n\r\n  拿0x200来说，换算二进制我只要把2用二进制0010在大脑中展示出来，然后后面跟8个0就换算完成。如果0x200>>1,右移1位，相当于1后面的9个0被砍掉一个，左边高位补0。\r\n\r\n  二进制表示由`0010 0000 0000`变成了`0001 0000 000`。值由512变成了256，可见右移1位相当于除以2。前面十六进制和二进制转换是在大脑中完成，转换到十进制我是笔算的，可能这是采用十六进制表示int原因之一吧。\r\n\r\n  同样左移思路也是如此。\r\n\r\n- 位与&\/位或|\r\n\r\n  位与\/位或是对参与运算的数的二进制进行位与\/位或。\r\n\r\n  位与&：两数二进制对应位均为1时结果才为1，其余为0\r\n\r\n  位或|：两数二进制对应位有一个为1时，结果位就为1\r\n\r\n  在源码和框架中，很多时候需要存储一些状态组合，比如：\r\n\r\n  ```java\r\n     public Intent addFlags(int flags) {\r\n          mFlags |= flags;\r\n          return this;\r\n      }\r\n  ```\r\n\r\n  最后在一些地方会根据状态组合的不同值来做出不同的响应。这时使用1，2，4，8这种格式的十六进制就很方便，因为不同的状态值只是在二进制的不同位上用1标记而已。这样最后可以根据mFlags的值二进制有多少位为1，基本就能判断有多少种状态。当然这里说的是位或。"
  },
  {
    "title": "详解设计模式之单例模式",
    "created_time": "2017-04-21 22:22:50",
    "body": "# 1、什么是单例?\r\n\r\n单例顾名思义就是单个实例。日常工作都是自由的通过构造方法创建对象的，所以听到单例时，我们应该意识到其下是暗含了2层意思的，①构造方法不在为你所用，你不需要知道如何创建对象。②我会给你提供获取实例的方法，不需要你自己动手创建。\r\n\r\n![单例示意图.png](http:\/\/upload-images.jianshu.io\/upload_images\/1796052-fc54578715942157.png?imageMogr2\/auto-orient\/strip%7CimageView2\/2\/w\/1240)\r\n\r\n不清楚uml类关系的请移步[UML--类图详解](http:\/\/www.jianshu.com\/p\/bf23234d5d2b)\r\n\r\n<!-- more -->\r\n\r\n# 2、\b什么情况下使用单例?\r\n\r\n当你需要内存中只有一个对象的时候。\r\n\r\n# 3、为什么使用单例？\r\n\r\n单例保证了内存中数据的唯一性，同时也降低了内存的开销。\r\n# 4、\b如何实现单例？\r\n\r\n在1中了解到两层含义后，对我们创建单例类是有帮助的，总结下就是：①私有化构造方法  ②对外提供获取实例方法\r\n\r\n## 饿汉式\r\n\r\n所谓饿汉式，就是在类加载的时候就迫不及待的创建对象，等到调用获取实例方法直接拿到对象返回即可。\r\n看实现代码：\r\n\r\n```java\r\npublic class HungarySingleton {\r\n\tprivate static HungarySingleton intance = new HungarySingleton();\r\n\t\r\n\tprivate HungarySingleton(){\r\n\t\t\r\n\t}\r\n\tpublic static HungarySingleton getInstance(){\r\n\t\treturn intance;\r\n\t}\r\n}\r\n```\r\n*懒汉式是最简单的单例模式，在类加载的时候就实例化，避免了多线程问题的同时保证了实例唯一性。缺点是即使不需要时候也会被实例，会占用内存。所以推荐在实例占用内存不多的情况下使用，否则请使用下面几种方式。*\r\n\r\n## 懒汉式\r\n\r\n懒汉式，就是在首次调用的时候才会创建实例，相比饿汉式，延迟了初始化。\r\n\r\n```java\r\npublic class LayzySingleton {\r\n\tprivate static LayzySingleton instance = null;\r\n\r\n\tprivate LayzySingleton() {\r\n\r\n\t}\r\n\tpublic LayzySingleton getInstatnce() {\r\n\t\tif (null == instance) {\r\n\t\t\tinstance = new LayzySingleton();\r\n\t\t}\r\n\t\treturn instance;\r\n\t}\r\n}\r\n```\r\n上面代码有个问题，就是在多线程调用中会有产生多个实例的隐患，所以需要使用线程同步：\r\n\r\n```java\r\npublic class LayzySingleton {\r\n\tprivate static LayzySingleton instance = null;\r\n\r\n\tprivate LayzySingleton() {\r\n\r\n\t}\r\n\tpublic synchronized LayzySingleton getInstatnce() {\r\n\t\tif (null == instance) {\r\n\t\t\tinstance = new LayzySingleton();\r\n\t\t}\r\n\t\treturn instance;\r\n\t}\r\n}\r\n```\r\n*synchronized的加入虽然解决了多实例的隐患，但是又带来了性能低下的问题，因为我们只需要在首次创建对象时让同步产生作用即可，其后的调用无需同步，现在只要是调用该方法就同步，看来还需要改进*\r\n下面使用双重校验加锁(DCL)：\r\n\r\n```java\r\npublic class LayzySingleton {\r\n\tprivate static LayzySingleton instance = null;\r\n\r\n\tprivate LayzySingleton() {\r\n\r\n\t}\r\n\tpublic  LayzySingleton getInstatnce() {\r\n\t\tif (null == instance) {\r\n\t\t\tsynchronized(LayzySingleton.class){\r\n\t\t\t\tif (null == instance) {\r\n\t\t\t\t\tinstance = new LayzySingleton();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn instance;\r\n\t}\r\n}\r\n```\r\n现在多线程问题解决了，性能也得到优化了是不是双重校验加锁就完美了呢？\r\nNO~\r\n在Java并发编程中的指令重排序中有讲到双重校验加锁失效问题。\r\n要禁止指令重排序需要使用volatile修饰变量\r\n\r\n\r\n```java\r\n\tprivate volatile static LayzySingleton instance = null;\r\n```\r\n\r\n## 静态内部类\r\n\r\n如果觉得饿汉式占内存，懒汉式又要考虑多线程问题，那么可以使用静态内部类可能是你想要的：\r\n\r\n```java\r\npublic class Singleton {\r\n\t\r\n\tprivate Singleton(){\r\n\t\t\r\n\t}\r\n\tpublic Singleton getInstance(){\r\n\t\treturn Holder.instance;\r\n\t}\r\n\tprivate class Holder{\r\n\t\tprivate  static final  Singleton instance = new Singleton();\r\n\t}\r\n}\r\n```\r\n*静态内部类避免了加载Singleton类时就初始化问题，只有在调用getInstance时才会致使Holder类被加载并初始化，同时也避免了线程安全问题和性能问题，推荐使用此方法。*\r\n\r\n## 枚举式\r\n\r\n如果觉得上面的还是麻烦，可以使用枚举单例，\r\n代码实现：\r\n\r\n```java\r\npublic enum EnumSingleton {\r\n\t\r\n\tINSTANCE ;\r\n\t\r\n\tint num = 33;\r\n\tString config = \"jenson\";\r\n\t\r\n\tpublic void doSomething(){\r\n\t\t\r\n\t}\r\n}\r\n```\r\n*枚举单例也可以有属性可以有方法，重要的是枚举默认就是线程安全的。*"
  },
  {
    "title": "详解设计模式之简单工厂模式",
    "created_time": "2017-04-21 22:22:50",
    "body": "####1、什么是简单工厂模式？\r\n把一些相关类的对象的创建封装在另一个类中，这样在上层的客户端不需要明白相关类对象是如何创建的，只需要调用另一个类的相关方法获取实例即可。另一个类就是所说的工厂类。为了避免每次使用工厂时都创建工厂实例，获取相关类实例的方法一般使用静态方法，所以简单工厂一般也叫静态工厂。\r\n\r\n####2、\b什么时候使用工厂模式？\r\n当你要对上层隐藏一些对象从而达到解耦的效果时可以使用简单工厂。\r\n\r\n<!-- more -->\r\n\r\n####3、\b如何使用工厂模式？\r\n- 先看下不使用模式如何创建接口实例\r\n\r\n![不使用模式.png](http:\/\/upload-images.jianshu.io\/upload_images\/1796052-6f2ed596ea68547b.png?imageMogr2\/auto-orient\/strip%7CimageView2\/2\/w\/1240)\r\n汽车接口代码：\r\n```\r\npublic interface CarApi {\r\n\tpublic void run();\r\n}\r\n```\r\n起亚汽车实现代码：\r\n\r\n```\r\npublic class KiaImpl implements CarApi {\r\n\r\n\t@Override\r\n\tpublic void run() {\r\n\t\t\/\/ TODO Auto-generated method stub\r\n\t\tSystem.out.println(\"起亚跑起来\");\r\n\t}\r\n\r\n}\r\n```\r\n客户端代码：\r\n\r\n\r\n```\r\npublic class Client {\r\n\tpublic static void main(String[] args) {\r\n\t\tCarApi carApi = new KiaImpl();\r\n\t\tcarApi.run();\r\n\t}\r\n}\r\n```\r\n如上，不使用模式的时候，客户端不仅依赖接口，更知道了接口的实现类是KiaImpl。要知道Java面向接口编程就是为了封装隔离，达到解耦模块的目的。这里虽然使用了接口，但是充其量只用到了其多态，至于封装隔离还是没影的事儿。\r\n- 看下使用简单工厂是如何实现的\r\n\r\n![使用模式.png](http:\/\/upload-images.jianshu.io\/upload_images\/1796052-cc51abbba4547d5b.png?imageMogr2\/auto-orient\/strip%7CimageView2\/2\/w\/1240)\r\n汽车接口和起亚实现代码如上不变，宝马实现代码如下：\r\n\r\n```\r\npublic class BmwImpl implements CarApi {\r\n\r\n\t@Override\r\n\tpublic void run() {\r\n\t\t\/\/ TODO Auto-generated method stub\r\n\t\tSystem.out.println(\"宝马跑起来\");\r\n\t}\r\n\r\n}\r\n```\r\n汽车工厂代码如下：\r\n\r\n```\r\npublic class CarFactory {\r\n\tpublic static CarApi getCar(int type) {\r\n\t\tCarApi car;\r\n\t\tif (type == 0) {\r\n\t\t\tcar = new KiaImpl();\r\n\t\t} else {\r\n\t\t\tcar = new BmwImpl();\r\n\t\t}\r\n\t\treturn car;\r\n\t}\r\n}\r\n```\r\n客户端代码如下：\r\n\r\n```\r\n public class Client {\r\n\tpublic static void main(String[] args) {\r\n\/\/\t\tCarApi carApi = new KiaImpl();\r\n\/\/\t\tcarApi.run();\r\n\t\tCarApi kia = CarFactory.getCar(0);\r\n\t\tkia.run();\r\n\t\tCarApi bmw = CarFactory.getCar(1);\r\n\t\tbmw.run();\r\n\t}\r\n}\r\n```\r\n\r\n通过客户端代码可知，把实现类封装在工厂后，客户端只需要调用工厂静态方法就能拿到实现类实例，而不需要知道这些实现类是如何创建实现的，达到了解耦的目的。\r\n\r\n有一点要注意：如果接口有多个实现类，在工厂中如何确定想要获取哪个实例？这时就要在静态方法中传入参数，这时客户端就要知道参数类型代表的意思。所以此时底层要向上层暴露一些信息以供使用。"
  },
  {
    "title": "详解设计模式之责任链模式",
    "created_time": "2017-05-10 12:36:14",
    "body": "# 说在前面的话\r\n\r\n责任链模式也叫职责链，抛开设计模式不谈，单看“责任链”这三个字，关注点一下子就放到了“链”字上了。链即锁链、链条，像链子一样环环相扣的东西。比如我们数据结构中的链表，当前对象持有下一个对象的地址。同样，设计模式中的责任链也是如此，任务一环套一环，环环相扣。\r\n\r\n<!-- more -->\r\n\r\n# 面试流程分析\r\n\r\n作为技术人员离职再就业少不了要面试的，那么我们就拿面试流程来细说。假设面试流程分为三步：组长面试，CTO面试，HR终面，一共三面。\r\n\r\n## 不考虑其他任何方面的优化，一个人的面试如何实现？\r\n\r\n```\r\n\t\/\/面试类\r\n\tstatic class Viewer {\r\n\t\tpublic void interview(int level) {\r\n\r\n\t\t\tif (0 == level) {\/\/ 组长面试\r\n\t\t\t\t\/\/ TODO\r\n\t\t\t} else if (1 == level) {\/\/ CTO面试\r\n\t\t\t\t\/\/ TODO\r\n\t\t\t} else if (2 == level) {\/\/ HR终面\r\n\t\t\t\t\/\/ TODO\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n```\r\n\r\n```\r\n\t\/\/客户端\r\n\tpublic static void main(String[] args) {\r\n\r\n\t\tViewer viewer = new Viewer();\r\n\t\tviewer.interview(0);\r\n\t\tviewer.interview(1);\r\n\t\tviewer.interview(2);\r\n\r\n\t}\r\n```\r\n\r\n从上面实现方式可以看出，面试方法，如果要面试三次，那么客户端要调用三次，面试方法interview中对level判断，不同级别有不同人面试，如果以后增加四面，那么就要修改interview方法。\r\n\r\n另外每次的面试 `viewer.interview` 都在客户端调用，但是按照正常流程组长面试完，如果觉得可以，应该流程传递到CTO哪里了，CTO谈完了觉得技术良好，最后交给HR谈待遇，流程抽象提取后是这样：\r\n\r\n\r\n\r\n![屏幕快照 2017-05-10 下午4.21.27](详解设计模式之责任链模式\/屏幕快照 2017-05-10 下午4.21.27.png)\r\n\r\n这不就是开头说的“链”吗？\r\n\r\n## 下面看看用链如何实现面试的：\r\n\r\n\r\n\r\n先定义一个链接口来控制面试流程：\r\n\r\n```\r\npublic interface Chain {\r\n\r\n\t\/**\r\n\t * 面试方法\r\n\t * \r\n\t * @param level\r\n\t *\/\r\n\tvoid interview();\r\n\r\n\t\/**\r\n\t * 是否通过\r\n\t * \r\n\t * @return\r\n\t *\/\r\n\tboolean isCross();\r\n\r\n\t\/**\r\n\t * 下一个面试官\r\n\t * \r\n\t * @param chain\r\n\t *\/\r\n\tvoid next(Chain chain);\r\n}\r\n```\r\n\r\n然后定义组长Grouper、CTO、HR三个面试官类实现Chain接口。\r\n\r\n```\r\n\tstatic class Grouper implements Chain {\r\n\t\tprivate Chain next = null;\r\n\r\n\t\t@Override\r\n\t\tpublic void interview() {\r\n\t\t\t\/\/ TODO Auto-generated method stub\r\n\r\n\t\t\tif (isCross() && next != null) {\r\n\t\t\t\tSystem.out.println(\"组长面试通过\");\r\n\t\t\t\tnext.interview();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic boolean isCross() {\r\n\t\t\t\/\/ TODO Auto-generated method stub\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic void next(Chain chain) {\r\n\t\t\t\/\/ TODO Auto-generated method stub\r\n\t\t\tthis.next = chain;\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tstatic class CTO implements Chain {\r\n\t\tprivate Chain next = null;\r\n\r\n\t\t@Override\r\n\t\tpublic void interview() {\r\n\t\t\t\/\/ TODO Auto-generated method stub\r\n\t\t\tif (isCross() && next != null) {\r\n\t\t\t\tSystem.out.println(\"CTO面试通过\");\r\n\t\t\t\tnext.interview();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic boolean isCross() {\r\n\t\t\t\/\/ TODO Auto-generated method stub\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic void next(Chain chain) {\r\n\t\t\t\/\/ TODO Auto-generated method stub\r\n\t\t\tthis.next = chain;\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tstatic class HR implements Chain {\r\n\t\tprivate Chain next = null;\r\n\r\n\t\t@Override\r\n\t\tpublic void interview() {\r\n\t\t\t\/\/ TODO Auto-generated method stub\r\n\t\t\tSystem.out.println(\"HR面试通过\");\r\n\t\t\tif (isCross() && next != null) {\r\n\t\t\t\tnext.interview();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic boolean isCross() {\r\n\t\t\t\/\/ TODO Auto-generated method stub\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic void next(Chain chain) {\r\n\t\t\t\/\/ TODO Auto-generated method stub\r\n\r\n\t\t}\r\n\r\n\t}\r\n```\r\n\r\n然后看看客户端调用：\r\n\r\n```\r\n\tpublic static void main(String[] args) {\r\n\t\tGrouper grouper = new Grouper();\r\n\t\tCTO cto = new CTO();\r\n\t\tHR hr = new HR();\r\n\t\tgrouper.next(cto);\r\n\t\tcto.next(hr);\r\n\t\tgrouper.interview();\r\n\t}\r\n```\r\n\r\n通过` grouper.next(cto);`和`cto.next(hr);` 设置完链式关系，最后只要通过`grouper.interview();` 调用一次面试就可以了。因为grouper最为链首，其中存储了下一个链元素next。只要条件达成（本次面试通过），则自动执行下一个任务，这就是任务链的好处。\r\n\r\n可能还有一个疑问：`grouper.next(cto);` 等流程还是在客户端设置的，这无疑要增加了客户端对底层这些类的认知度。\r\n\r\n其实完全可以把这些细节隐藏在底层的。比如我们把流程在Grouper构造方法中设置：\r\n\r\n```\r\n\t\tpublic Grouper() {\r\n\t\t\tCTO cto = new CTO();\r\n\t\t\tHR hr = new HR();\r\n\t\t\tnext(cto);\r\n\t\t\tcto.next(hr);\r\n\t\t}\r\n```\r\n\r\n这时客户端是如此的简洁：\r\n\r\n```\r\n\tpublic static void main(String[] args) {\r\n\t\tGrouper grouper = new Grouper();\r\n\t\tgrouper.interview();\r\n\t}\r\n```\r\n\r\n其实上面的一般方法还有其他的实现方法，但是无疑常见的实现要么耦合性较强，要么需要客户端对底层认知度高。\r\n\r\n说了半天，现在来步入主题看看到底什么是责任链\r\n\r\n\r\n\r\n# 责任链模式\r\n\r\n- 模式出现意图\r\n\r\n  让多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象串成一条链，并沿着链传递请求，直到有一个对象处理它或者处理完毕为止。\r\n\r\n\r\n\r\n- 责任链uml图\r\n\r\n![屏幕快照 2017-05-10 下午5.17.19](详解设计模式之责任链模式\/屏幕快照 2017-05-10 下午5.17.19.png)"
  },
  {
    "title": "向上取整、向下取整和素数",
    "created_time": "2017-09-19 17:09:52",
    "body": "# 0x00 前言\r\n\r\n在看算法书时看到几个数学上的定义：向上取整、向下取整和素数。\r\n\r\n不知道这几个定义就难以理解文章意思。所以查了资料后做个记录，防止下次还不会。\r\n\r\n<!-- more -->\r\n\r\n# 0x01 解释\r\n\r\n- 素数\r\n\r\n  这个在初高中时候就学过，因为素数就是质数的别称，质数就是只能被1和数字本身整除的数。\r\n\r\n  ​\r\n\r\n- 向上取整、向下取整\r\n\r\n  向上取整、向下取整的前提是要先有个基数整数\r\n\r\n  比如数列1，3，4，6，7，9，11，以6为基数，其向下取整为4，向上取整为7\r\n\r\n  **对基数x向下取整为小于等于x的最大整数，对基数x向上取整为大于等于x的最小整数**"
  },
  {
    "title": "字符串前的r和u",
    "created_time": "2017-08-06 16:55:54",
    "body": "# 前言\r\n\r\n在看python代码时经常看到这样的代码\r\n\r\n```python\r\nprint(r\"aa\\nbb\")\r\nprint(u\"aa\\nbb\")\r\n```\r\n\r\n字符串使用时直接引用就好了，前面的r和u这两个前缀是什么鬼？有什么作用？\r\n\r\n纸上得来终觉浅，绝知此事要躬行。\r\n\r\n要了解r和u的作用还是实际操作来看看。\r\n\r\n<!-- more -->\r\n\r\n# 说明\r\n\r\n- r的作用\r\n\r\n  首先看看r的作用，执行如下代码看看结果：\r\n\r\n  ```python\r\n  print(\"aa\\nbb\")\r\n  print(r\"aa\\nbb\")\r\n  ```\r\n\r\n  打印结果是这样子：\r\n\r\n  ```\r\n  aa\r\n  bb\r\n  aa\\nbb\r\n  ```\r\n\r\n  第一个打印，**\\n**把字符串截开了，而第二个打印是全部打印。\r\n\r\n  在python中，**\\n**是换行符作用。所以第一个打印才是正常的。\r\n\r\n  第二个打印中的**r作用就是取消字符串中的转移字符的作用，让其老老实实作为一个普通字符串**。\r\n\r\n  接下来看看u的作用：\r\n\r\n- u的作用\r\n\r\n  u表示将后面跟的字符串以unicode格式存储，否则会使用源文件的默认编码格式来编码字符串"
  },
  {
    "title": "bytes和str转换",
    "created_time": "2017-08-13 16:27:54",
    "body": "# 前言\r\n\r\n日常开发中很多时候要用到bytes和str的互相转换，每次都查浪费时间。干脆整理一次记在脑子里。\r\n\r\n# bytes转str\r\n\r\n- 默认解码 bytes.decode()\r\n- gbk方式解码 bytes.decode(‘gbk’)\r\n\r\n# str转bytes\r\n\r\n- utf8方式编码 str.encode(encoding=\"utf-8\")\r\n- gbk方式编码 str.encode(encoding=\"gbk\")"
  },
  {
    "title": "CSS浮动float引起布局错乱",
    "created_time": "2017-09-12 21:09:42",
    "body": "# 0x00 前言\r\n\r\nhtml默认是流式布局从上到下，但是使用float后可以让当前标签跳出流式布局限制，但同时下面的标签可能会和float标签产生重叠情况，如下：\r\n\r\n\r\n\r\n![css浮动引起重叠](http:\/\/othg5ggzi.bkt.clouddn.com\/css%E6%B5%AE%E5%8A%A8%E5%BC%95%E8%B5%B7%E9%87%8D%E5%8F%A0.png)\r\n\r\n图中可以看到表单和右边的导航栏重叠了造成布局混乱。\r\n\r\n<!-- more -->\r\n\r\n# 0x00 解决\r\n\r\n如果由CSS浮动造成的布局重叠混乱，可以在浮动标签下新建一个空div：\r\n\r\n```html\r\n<div class=\"clear\"><\/div>\r\n```\r\n\r\n给该div设置样式：\r\n\r\n```css\r\n .clear {\r\n            clear: both;\r\n        }\r\n```\r\n\r\n最终显示结果如图：\r\n\r\n![css浮动错乱修复](http:\/\/othg5ggzi.bkt.clouddn.com\/css%E6%B5%AE%E5%8A%A8%E4%BF%AE%E5%A4%8D.png)\r\n\r\n如果不想使用clear方法也可以使用多个空div+` text-align: right; `属性"
  },
  {
    "title": "Java wait，notify和notifyAll使用分析",
    "created_time": "2017-07-21 13:00:51",
    "body": "# 0x00 前言\r\n\r\n提起多线程想当然的就会想到`synchronized` 。但是`synchronized`只能用于线程同步，如果是线程交替执行(生产者\/消费者)，`synchronized`也无能为力了。这时wait，notify和notifyAll派上用场了。\r\n\r\n# 0x01 它们只是Object里的方法\r\n\r\n点开源码发现这三个方法只是object里面的方法，和多线程有神马关系呢？我相信不止我一个人曾经有过这个疑问。\r\n\r\n不只是object里的方法，而且还都是native方法。这是Java有意为之。因为Java设计之初就是要每个对象都有一个监控锁(Monitor)。而wait，notify和notifyAll三个方法也必须要在当前线程已经持有监控锁状态下才能执行，否则就会报`java.lang.IllegalMonitorStateException`。\r\n\r\n<!-- more -->\r\n\r\n# 0x02 怎么知道线程是否持有状态锁\r\n\r\n线程同步原理就是利用了锁的互斥，所以在`synchronized`代码块内能确定是持有锁的。也就是说wait，notify和notifyAll方法需要在`synchronized`代码块内使用。\r\n\r\n具体来说有三种方式：\r\n\r\n- 同步对象方法持有锁\r\n\r\n  ```java\r\n  \tpublic synchronized void sync_1() {\r\n  \t} \r\n  ```\r\n\r\n- 同步静态方法持有锁\r\n\r\n  ```java\r\n  \tpublic static synchronized void sync_2() {\r\n  \t}\r\n  ```\r\n\r\n  ​\r\n\r\n- 同步代码块持有锁\r\n\r\n  ```java\r\n  \tpublic  void sync_3() {\r\n  \t\tsynchronized(lock){\r\n  \t\t}\r\n  \t}\r\n  ```\r\n\r\n# 0x03 三个方法都有什么用\r\n\r\n- wait后会让当前线程处于阻塞状态\r\n\r\n  能调用wait是因为当前线程持有Monitor，但是调用wait后，当前线程会释放锁，给予其他线程执行的机会。\r\n\r\n- notify会唤醒一个因为该对象阻塞的线程\r\n\r\n  同样notify能正常调用是因为当前线程持有锁，当notify执行后会唤醒其他阻塞线程，但是那些阻塞线程并不会立即执行，因为Monitor被notify线程持有。被唤醒的线程要等`synchronized`代码块执行完毕释放Monitor后才能执行。\r\n\r\n- notifyAll会唤醒所有因为该对象阻塞的线程\r\n\r\n  同notify。\r\n\r\n# 0x04 使用示例\r\n\r\n```java\r\n\tpublic static void main(String[] args) {\r\n\t\tThread t1 = new Thread(new Runnable() {\r\n\t\t\t@Override\r\n\t\t\tpublic void run() {\r\n\t\t\t\tSystem.out.println(\"start-t1\");\r\n\t\t\t\tsynchronized (lock) {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tSystem.out.println(\"t1等待唤醒\");\r\n\t\t\t\t\t\tlock.wait();\r\n\t\t\t\t\t} catch (Exception e) {\r\n\t\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tSystem.out.println(\"t1被唤醒持有锁\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tThread t2 = new Thread(new Runnable() {\r\n\t\t\t@Override\r\n\t\t\tpublic void run() {\r\n\t\t\t\tSystem.out.println(\"start-t2\");\r\n\t\t\t\ttry {\r\n\t\t\t\t\tThread.currentThread().sleep(3000);\r\n\t\t\t\t} catch (InterruptedException e1) {\r\n\t\t\t\t\te1.printStackTrace();\r\n\t\t\t\t}\r\n\t\t\t\tsynchronized (lock) {\r\n\t\t\t\t\tlock.notify();\/\/ 唤醒\r\n\t\t\t\t\tSystem.out.println(\"t2持有锁，唤醒t1\");\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tThread.currentThread().sleep(3000);\r\n\t\t\t\t\t} catch (InterruptedException e) {\r\n\t\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tSystem.out.println(\"t2休眠3s\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t\tt1.start();\r\n\t\tt2.start();\r\n\t}\r\n```\r\n\r\n执行结果如下：\r\n\r\nstart-t2\r\nstart-t1\r\nt1等待唤醒\r\nt2持有锁，唤醒t1\r\nt2休眠3s\r\nt1被唤醒持有锁\r\n\r\n在t2中调用notify唤醒t1后，t2又休眠了3s钟，期间t1仍然没有执行，可见确实如上所说，唤醒的线程要在notify线程释放Monitor后才能执行。"
  },
  {
    "title": "Java参数到底是值传递还是引用传递",
    "created_time": "2017-08-10 13:55:54",
    "body": "# 0x00前言\r\n\r\n基本类型是值传递，引用类型是引用传递，在此前很长的一段时间内，我一直是这么认为的！\r\n\r\n然鹅，这个错误的想法竟然伴随多年，仿佛多年的Java白学了。\r\n\r\n<!-- more -->\r\n\r\n# 0x01 说明\r\n\r\n**其实Java中参数的传递都是byValue方式传递**。\r\n\r\n讲道理先通过虚拟机机制来说明下：\r\n\r\n![讲道理](http:\/\/othg5ggzi.bkt.clouddn.com\/%E8%AE%B2%E9%81%93%E7%90%86.jpg)\r\n\r\n\r\n\r\n虚拟机在内存中有一块区域叫Java栈，也叫虚拟机栈。栈里面装的是什么？\r\n\r\n栈中存放的是栈帧，栈帧里面又装的是什么？是局部变量表、操作数栈和方法返回地址等信息。\r\n\r\n其实一个Java线程运行时就会产生一个Java栈，每次的方法调用就会产生一个栈帧入栈，方法执行完毕则出栈。其中栈帧中的局部变量表存储的是参数和局部变量信息。\r\n\r\n当方法执行完毕，栈帧出栈内存就会被释放，如果引用类型的参数是直接把函数外的引用直接传递过来，那么出栈时，岂不是连函数外的这个变量也一同给释放掉了吗？\r\n\r\n所以为了避免这种情况发生，**引用类型的参数传递，只是对引用类型值的一个拷贝。**\r\n\r\n就是说**函数外的变量和参数是两个不同的变量，只是它们指向的地址是一样的**：\r\n\r\n![参数引用类型传递](http:\/\/othg5ggzi.bkt.clouddn.com\/%E5%8F%82%E6%95%B0%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%BC%A0%E9%80%92.png)\r\n\r\n\r\n\r\n说到底，引用类型也躲不过值传递的命运。\r\n\r\n下面用示例来验证下外部变量和参数是两个不同的变量：\r\n\r\n# 0x02 示例\r\n\r\n```Java\r\npublic class ReTest {\r\n\tstatic void setStu(Student stu, int x) {\r\n      \tSystem.out.println(\"改变前stu变量：\"+stu+\"##x值：\"+x);\r\n\t\tstu = new Student(\"lisi\", 21);\r\n\t\tx=20;\r\n\t\tSystem.out.println(\"stu变量：\"+stu+\"##x值：\"+x);\r\n\t}\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tStudent p = new Student(\"jenson\", 10);\r\n\t\tint i = 10;\r\n\t\tSystem.out.println(\"改变前p变量：\"+p+\"##i值：\"+i);\r\n\t\tsetStu(p, i);\r\n\t\tSystem.out.println(\"改变后p变量：\"+p+\"##i值：\"+i);\r\n\t}\r\n\r\n\tstatic class Student {\r\n\t\tint age;\r\n\t\tString name;\r\n\r\n\t\tStudent(String name, int age) {\r\n\t\t\tthis.age = age;\r\n\t\t\tthis.name = name;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n```\r\n\r\n代码很简单，打印结果如下：\r\n\r\n```\r\n改变前p变量：thread.ReTest$Student@7852e922##i值：10\r\n改变前stu变量：thread.ReTest$Student@7852e922##x值：10\r\nstu变量：thread.ReTest$Student@4e25154f##x值：20\r\n改变后p变量：thread.ReTest$Student@7852e922##i值：10\r\n```\r\n\r\n参考打印结果可以发现：\r\n\r\n**基本类型是值传递，而引用类型为Student变量p和参数stu是两个不同的变量但指向同一块内存，在函数setStu中给参数stu从新赋值时，不影响变量p的引用。证明了参数stu是p变量的一个值拷贝。**"
  },
  {
    "title": "Java字符串压缩去重",
    "created_time": "2017-05-03 17:42:06",
    "body": "# 说在前面的话\r\n\r\n去一家公司面试，开始就一道笔试题，做对了就继续，做不对就不用往下面了。内容是读取文件内容并压缩内容去重，压缩去重意思是如果内容为ABBCCCCAA压缩后字符串显示为A1B2C3A2。以此类推。其实这道题不难，但是我脑子转悠慢，读取文件和遍历字符做出来了，但是其余的没有做出了，或者说大概思路对了，但是卡在某一个点。总之有点废物就是了。。\r\n\r\n<!-- more -->\r\n\r\n# 我的做法\r\n\r\n```\r\n\tpublic static String compress(String str){\r\n\t\tStringBuffer mystr = new StringBuffer();\r\n\t\t\/\/我这里是从0开始的\r\n\t\tint count = 0;\r\n\t\t\/\/而这也是初始为0，这样的设置导致下面判断时候一直\r\n\t\t\/\/无所适从，对于何时该给count++，\r\n\t\t\/\/何时该给mystr.append有点混乱\r\n\t\tchar last = 0;\r\n\t\tint length = str.length();\r\n\t\tfor(int i=0;i<length;i++){\r\n\t\t\tchar c = str.charAt(i);\r\n\t\t\tif(last!=c){\r\n\t\t\t\tlast = c;\r\n\t\t\t\tcount++;\r\n\t\t\t\tmystr.append(last);\r\n\t\t\t\tmystr.append(count);\r\n\t\t\t}else{\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn mystr.toString();\r\n\t}\r\n```\r\n\r\n# 正确地做法\r\n\r\n- 直接使用string做法\r\n\r\n  ```\r\n  public String compressBad (String str)  \r\n  {  \r\n      String mystr = \" \";  \r\n      int count = 1;  \r\n      char last = str.charAt(0);  \r\n      for (int i = 1; i < str.length(); i++)  \r\n      {  \r\n          if (last == str.charAt(i))  \r\n          {  \r\n              count++;  \r\n          }  \r\n          else  \r\n          {  \r\n              mystr += last + count;  \r\n              last = str.charAt(i);  \r\n              count = 1;                \r\n          }  \r\n      }  \r\n      return mystr += last + count;  \r\n  }  \r\n  ```\r\n\r\n  ​\r\n\r\n\r\n\r\n- 使用StringBuffer\r\n\r\n  ```\r\n  \tpublic static  String compressBetter(String str) {\r\n  \t\tStringBuffer mystr = new StringBuffer();\r\n  \t\tint count = 1;\r\n  \t\t\/\/取出第一个字符作为比较字符\r\n  \t\tchar last = str.charAt(0);\r\n  \t\tfor (int i = 1; i < str.length(); i++) {\r\n  \t\t\t\/\/如果当前字符和之前的字符相同，说明是重复的，\r\n  \t\t\t\/\/直接在数量值+1；\r\n  \t\t\tif (last == str.charAt(i)) {\r\n  \t\t\t\tcount++;\r\n  \t\t\t} else {\r\n  \t\t\t\t\/\/如果不相同，说明开始了一个新的字符，\r\n  \t\t\t\t\/\/这时要做的只有两件事：\r\n  \t\t\t\t\/\/1、结束上格字符计数并添加字符串，\r\n  \t\t\t\tmystr.append(last);\r\n  \t\t\t\tmystr.append(count);\r\n  \t\t\t\t\/\/2、2、开始新的字符计数\r\n  \t\t\t\tlast = str.charAt(i);\r\n  \t\t\t\tcount = 1;\r\n  \t\t\t}\r\n  \t\t}\r\n  \t\t\/\/最后一个字符计数并显示\r\n  \t\tmystr.append(last);\r\n  \t\tmystr.append(count);\r\n  \t\treturn mystr.toString();\r\n  \t}\r\n  ```\r\n\r\n  ​\r\n\r\n# 感想\r\n\r\n作为IT从业者，大部分时间都在写业务逻辑，很多基本功已经近乎荒废了，这是非常不可取的。眼光放长远些，我们的技术不应该局限于某一种语言，而应该把重心放在跨语言的那些通用技术。比如：操作系统、算法和数据结构、网络及设计模式重构思想等，这些东西在任何语言中都会用到而且也会是重点。"
  },
  {
    "title": "Linux命令行大全笔记",
    "created_time": "2017-09-25 20:41:28",
    "body": "# 0x00 前言\r\n\r\n本章是关于**Linux命令行大全**的读书笔记，随读随记。\r\n\r\n# 0x01 第1章 shell是什么\r\n\r\n- sh最初是Unix shell程序，bash是sh的增强版\r\n- shell是一个接收由键盘输入的命令，并将命令传递给操作系统来执行的程序。\r\n- `date`显示当前系统时间和日期\r\n- `df`查看磁盘驱动器当前可用空间\r\n- `cal`查看当月日历\r\n- `free`查看可用内存\r\n- `exit`退出终端\r\n\r\n<!--more-->\r\n\r\n# 0x02 第2章 导航\r\n\r\n- `pwd`查看当前工作目录\r\n\r\n- `cd`更改目录\r\n\r\n  **.**代表工作目录，**..**代表工作目录的父目录\r\n\r\n  `cd -`将工作目录变为上一个工作目录，**这里的上一个是历史的上一个目录，而不是父级目录**，就是说通过**该命令可以实现2个目录之间来回切换**。\r\n\r\n- `ls`列出目录内容\r\n\r\n# 0x03 第3章 Linux系统\r\n\r\n**命令完整格式：command -options  arguments。命令后面还可以使用选项和参数来进行限定，以精细达到所需结果**\r\n\r\n- `ls`列出目录内容\r\n\r\n  **选项区分大小写**\r\n\r\n  |  选项  |       长选项        |                    含义                    |\r\n  | :--: | :--------------: | :--------------------------------------: |\r\n  |  -a  |      --all       |           列出所有文件，包括以点号开头的隐藏文件            |\r\n  |  -d  |   --directory    | 通常如果指定了一个目录，ls会列出目录中的内容而不是目录本身，此选项与-l结合使用，可查看目录详细信息，而不是目录中内容。 |\r\n  |  -F  |    --classify    |      选项会在每个所列出的名字后面加上类型指示符，如果是目录加斜杠      |\r\n  |  -h  | --human-readable |       以长格式列出，以人们可读的方式而不是字节数来显示文件大小       |\r\n  |  -l  |                  |                使用长格式显示结果                 |\r\n  |  -r  |    --reverse     |          以相反的顺序显示结果，ls通常按字母升序显示          |\r\n  |  -S  |                  |                按文件大小对结果排序                |\r\n  |  -t  |                  |                 按修改时间排序                  |\r\n\r\n  ​\r\n\r\n- `file`确定文件类型\r\n\r\n  输入命令`file _config.yml`\r\n\r\n  结果`_config.yml: UTF-8 Unicode text, with CRLF line terminators`\r\n\r\n- `less`查看文件内容\r\n\r\n  |    命令    |  功能  |\r\n  | :------: | :--: |\r\n  |  pageup  | 向下翻页 |\r\n  | pagedown | 向上翻页 |\r\n  |   上箭头    | 上一行  |\r\n  |   下箭头    | 下一行  |\r\n  |    q     |  退出  |\r\n\r\n- 符号链接又叫软链接或symlink\r\n\r\n\r\n\r\n\r\n\r\n# 0x04 第4章 操作文件与目录\r\n\r\n- `cp`复制文件和目录\r\n\r\n  `cp item1 item2`将单个文件或目录item1复制到文件或目录item2中\r\n\r\n  `cp item1 item2 item3 dir`将多个项目复制到一个目录dir中\r\n\r\n- `mv`移动或重命名文件和目录\r\n\r\n  和cp用法基本一致\r\n\r\n- `mkdir`创建目录\r\n\r\n  `mkdir dir1`创建单个dir1目录\r\n\r\n  `mkdir dir1 dir2 dir3`创建多个目录\r\n\r\n- `rm`删除文件和目录\r\n\r\n  **注意：当rm与通配符一起使用时，要仔细检查内容，可使用ls命令与通配符配合使用进行测试，这时将显示要删除的文件。紧接着使用rm替换ls，避免不恰当的删除造成不可挽回的后果。因为一旦使用rm命令，就彻底的删除了**\r\n\r\n  ​\r\n\r\n- `in`创建硬链接和符号链接\r\n\r\n\r\n\r\n# 0x05 第五章"
  },
  {
    "title": "Mac版eclipse中每次重启电脑后字体自动变小",
    "created_time": "2017-04-22 18:50:50",
    "body": "如题每次开机后打开eclipse时，发现上次调好的字体又变小了。每次都这样，比较影响心情。今天决定把这个问题解决掉。\r\n\b网友的做法是：\r\n打开 应用程序\/Eclipse.app\/Contents\/Eclipse\/eclipse.ini 文件中，\r\n把文中“-Dorg.eclipse.swt.internal.carbon.smallFonts”删掉。\r\n这样可以避免Eclipse里面的字体奇怪地自动变小。。\r\n\r\n发现很久以前就存在这个问题，不过当时的fix方法和最新的不一样。\r\n[传送通道](http:\/\/t-machine.org\/index.php\/2011\/08\/21\/fix-eclipses-fonts-on-os-x\/)\r\n\r\n但是上面的2方法好像对我来说没有效果(我只试了第一种)。后来在偏好设置里发现Theme为mac时使用的是Reduced Palette这个选项，我好奇的把选项改为了Default。然后点了确认再调整好需要的字体并重启。然后真的没有再恢复小字体了。\r\n\r\n![屏幕快照 2017-03-08 下午12.04.34.png](http:\/\/upload-images.jianshu.io\/upload_images\/1796052-3ea1ef0bbc0ed211.png?imageMogr2\/auto-orient\/strip%7CimageView2\/2\/w\/1240)"
  },
  {
    "title": "osx下如何使用SublimeText阅读Android系统源码",
    "created_time": "2017-04-22 18:55:54",
    "body": ">以前用win系统时使用sourceinsight阅读源码方便至极，但是自从换到mac下，尝试了很多方法很多工具，比如understand、比如vscode、比如wine下安装sourceinsight。总是有各种问题，所以这次尝试使用SublimeText\r\n\r\n平时使用Sublimetext都是打开单个文件，这次要导入几万个文件，这在一些ide中称为project。同样在Sublime中也是如此。\r\n\r\n#### 1. 创建工程\r\n\r\n　　Project > Add Folder to Project 选择源码目录即可\r\n　　这时在\b窗口左边栏中将出现刚刚添加的文件目录，如果还需要添加其他目录，则重复这一操作即可。\r\n\r\n<!-- more -->\r\n\r\n#### 2. 保存工程\r\n\r\n　　Project > Save Project As\r\n　　点击保存后Sublime Text将自动生成两个文件：\r\nproject_name.sumlime-project：包含工程定义，该文件会被记录到版本控制里。\r\nproject_name.sublim-workspace：包含了用户的工程数据，例如打开的文件和修改等，该文件不会被记录到版本控制里。\r\n　　在*.sublime-project文件中，你可以定义工程配置。例如你可以定义多个目录路径，或者哪些目录或文件需要排除在外。例如：\r\n　　以上*.sublime-project文件中定义了两个目录，而“name”标签是该目录在Sublime Text的\b左边栏中显示的名字。通过定义“name”，你可以将一些长路径或者名字很长的目录以更简洁的名称显示在\b左边栏中。\r\n\r\n#### 3、添加索引\r\n\r\n- 安装Package Control插件\r\n  1.打开控制台\r\n       方法1：View->show console \r\n       方法2：ctrl+~\r\n    2.输入代码：\r\n  python2.x代码:\r\n\r\n```\r\nimport urllib2,os;pf='Package Control.sublime-package';ipp=sublime.installed_packages_path();os.makedirs(ipp) if not os.path.exists(ipp) else None;open(os.path.join(ipp,pf),'wb').write(urllib2.urlopen('http:\/\/sublime.wbond.net\/'+pf.replace(' ','%20')).read())  \r\n```\r\npython3.x代码：\r\n\r\n```\r\nimport urllib.request,os;pf='Package Control.sublime-package';ipp=sublime.installed_packages_path();os.makedirs(ipp) if not os.path.exists(ipp) else None;open(os.path.join(ipp,pf),'wb').write(urllib.request.urlopen('http:\/\/sublime.wbond.net\/'+pf.replace(' ','%20')).read())\r\n```\r\n- 安装CTags\r\n  - 1. 首先 Preference -> Browser Packages... 查看是否已经安装了CTags Package，如果没有则继续下面步骤\r\n  - 2. Preference -> Package control, 输入“install package”，它会找出你可以安装的插件，在列表中选择ctag插件进行安装\r\n\r\n   - 3.创建索引\r\n\r\n![屏幕快照 2017-03-22 下午2.55.23.png](http:\/\/upload-images.jianshu.io\/upload_images\/1796052-38f35a1199d9e85a.png?imageMogr2\/auto-orient\/strip%7CimageView2\/2\/w\/1240)\r\n\r\n#### 4、异常处理\r\n\r\n- 期间出现Package Control:There are no packages available for installation弹窗提示\r\n  选择Preference->Browser Packages打开文件夹后\r\n  删除Package Control目录、删除User目录下相关Package Control名称文件等，再次安装。\r\n- ctag rebuild时弹窗异常如图：\r\n\r\n![屏幕快照 2017-03-22 下午3.01.14.png](http:\/\/upload-images.jianshu.io\/upload_images\/1796052-ad6b9e4b667a7b5b.png?imageMogr2\/auto-orient\/strip%7CimageView2\/2\/w\/1240)\r\n\r\n这是因为我们还没有安装和配置ctags\r\n下载ctags-5.8.tar.gz解压并编译，依次执行如下命令：\r\n\r\n`tar xzvf ctags-5.8.tar.gz`\r\n\r\n`cd ctags-5.8`\r\n\r\n`.\/configure`\r\n\r\n`make`\r\n\r\n`sudo make install`\r\n\r\n打开Preference ->Package settings->ctags->settings-user和settings-default\r\n把default中的配置全部复制到user中，然后改一下command配置项，为ctags的可执行文件路径\/usr\/local\/bin\/ctags（可以通过which ctags命令查看ctags路径）\r\n#### 5、快捷键\r\n- 修改跳转\r\n  默认函数跳转：Ctrl+shift+左键; 跳转返回：Ctrl+shift+右键。修改方法：\r\n   Perference->Package Settings->CTags->Mouse Binding Default->复制到Mouse Binding User，把里面的\"ctrl+shift\"，修改为“command”，这样就可以用“command+左键”跳转了：\r\n\r\n```\r\n        Command+P：查找文件\r\n        Command+R：查找方法\r\n        Command+左键：文件或函数跳转        \r\n        Command+右键：返回文件或函数跳转的原始位置\r\n```\r\n\r\n至此Android源码项目创建完成并创建索引，代码跳转也反应迅速。\r\n参考：https:\/\/jingyan.baidu.com\/article\/48206aeafba820216ad6b3f5.html"
  },
  {
    "title": "WireShark the capture session could not be initiated (you don't have",
    "created_time": "2017-08-03 19:07:11",
    "body": "# 前言\r\n\r\n异常信息如下：**the capture session could not be initiated (you don't have permission to capture on that device)**\r\n\r\n在WireShark启动后，选择网卡设备时，出现这个异常。\r\n\r\n\r\n\r\n# 解决\r\n\r\n由于是Mac系统，所以直接终端窗口命令行解决：\r\n\r\n**sudo chmod 777 \/dev\/bpf***。"
  },
  {
    "title": "图片本地打开显示正常但页面打开是倒了的",
    "created_time": "2017-10-31 07:16:27",
    "body": "# 0x00 前言\r\n\r\n一个宽小于高的图片，在本地打开时显示正常，但是在页面中**img**标签中打开时自动旋转了90度。\r\n\r\n这就导致竖着拍出来的照片不能正常显示就很难看。\r\n\r\n这是因为图片的 EXIF 里标记了旋转 `Rotate 90 CW`\r\n\r\n# 0x01 解决\r\n\r\n由于采用的是七牛云图床，而七牛云给了解决方法：**在链接后添加 imageMogr2\/auto-orient 参数，即可根据原图EXIF信息自动旋正**\r\n\r\n[七牛云图片高级处理](https:\/\/developer.qiniu.com\/dora\/manual\/1270\/the-advanced-treatment-of-images-imagemogr2)"
  },
  {
    "title": "猫扑素数",
    "created_time": "2017-11-14 06:33:28",
    "body": "# 前言\r\n\r\n关于**猫扑素数**，首先我有2个定义不明白：\r\n\r\n什么是素数？\r\n\r\n怎么才算猫扑素数？\r\n\r\n或许弄清这两个问题就方便下手了。\r\n\r\n# 素数\r\n\r\n说素数不懂，但是换个说法，质数，应该很多人就明白了。\r\n\r\n百科里这样定义：*质数*（prime number）又称*素数*，有无限个。*质数*定义为在大于1的自然数中，除了1和它本身以外不再有其他因数，这样的数称为*质数*。\r\n\r\n这样一下子就明朗起来了，质数的定义在中学就学过了。\r\n\r\n3，5，7是质数，9不是，所以可以认为质数一定是奇数，但是奇数不一定是质数。\r\n\r\n# 猫扑素数\r\n\r\n关于猫扑素数的来源没有在网络上找到，不知道为什么起了个这样名字。\r\n\r\n所以只能强制记住以2开头，后面根若干个3的如23，233，23333这样的就是猫扑素数。\r\n\r\n不过233333不是，因为233333=353x661。\r\n\r\n# 实现\r\n\r\n\r\n\r\n```python\r\nimport math\r\n\r\n\r\ndef isPrime(value):\r\n    \"\"\"\r\n    是否为素数\r\n    :param value:\r\n    :return:\r\n    \"\"\"\r\n    isPrime = True\r\n    if value < 2:\r\n        isPrime = False\r\n    else:\r\n        sq = int(math.sqrt(value))\r\n        for i in range(2, sq):\r\n            if (value % i == 0):\r\n                isPrime = False\r\n                break\r\n    return isPrime\r\n\r\n\r\ndef isMop(value):\r\n    \"\"\"\r\n    是否为猫扑素数\r\n    :param value:\r\n    :return:\r\n    \"\"\"\r\n    if value < 10:\r\n        return value == 2\r\n    else:\r\n        if value % 10 == 3:\r\n            return isMop(int(value \/ 10))\r\n        else:\r\n            return False\r\n\r\n\r\ndef numIsMop(value):\r\n    if isMop(value):\r\n        if isPrime(value):\r\n            print(value)\r\n\r\n\r\nfor i in range(1, 1000000):\r\n    numIsMop(i)\r\n```\r\n\r\n打印结果为：\r\n\r\n```\r\n2\r\n23\r\n233\r\n2333\r\n23333\r\n```"
  },
  {
    "title": "关于反射入门",
    "created_time": "2019-01-03 04:00:44",
    "body": "### 反射相关类\r\n\r\n在Java中一些情况下我们需要访问某些类的对象的属性、方法等，但是没有权限这么做，这时就需要反射了。\r\n\r\n和反射相关的类有如下一些：\r\n\r\njava.lang.Class一一类的创建：\r\njava.lang.reflect. Constructor一一反射类中构造方法；\r\njava.lang.re flect.Field一一反射属性；\r\njava.lang.reflect.Method一一反射方法；\r\njava.lang.reflect.Modifier 访问修饰符的信息。 \r\n\r\n### 反射常用方法\r\n\r\n示例代码：\r\n\r\n```java\r\npublic class People {\r\n    private static final String DATA = \"2019\";\r\n    String name;\r\n    int age;\r\n\r\n\r\n    public static void play() {\r\n        System.out.println(\"play\");\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public int getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(int age) {\r\n        this.age = age;\r\n    }\r\n\r\n    public People() {\r\n    }\r\n\r\n    public People(String name, int age) {\r\n        this.name = name;\r\n        this.age = age;\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n#### 获取Class\r\n\r\n- Class.forName\r\n- People.class\r\n- people.getClass\r\n\r\n\r\n\r\n#### 调用构造方法创建对象\r\n\r\nclass只能调用无参构造，\r\n\r\n```java\r\n Class clzz = Class.forName(\"People\");\r\n Object object = clzz.newInstance();\r\n People people = (People) object;\r\n\r\n```\r\n\r\n如果要调用有参构造需要获取Constructor：\r\n\r\n```java\r\n Class clzz = Class.forName(\"People\");\r\n Class<?>[] types = {String.class, int.class};\r\n Constructor constructor = clzz.getDeclaredConstructor(types);\r\n Object object = constructor.newInstance(\"jenson\", 30);\r\n```\r\n\r\n\r\n\r\n#### 调用方法\r\n\r\n- 调用实例方法\r\n\r\n\r\n\r\n  ```java\r\n  Class clzz = Class.forName(\"People\");\r\n  Object object = clzz.newInstance();\r\n  Method method = clzz.getDeclaredMethod(\"setName\", String.class);\r\n  method.setAccessible(true);\r\n  Object[] arg = {\"jenson\"};\r\n  method.invoke(object, arg);\r\n  ```\r\n\r\n  调用实例方法时，在invoke的第一个参数一定是类的实例，第二个参数是正常调用方法时所传递的参数\r\n\r\n- 调用静态方法\r\n\r\n\r\n\r\n  ```java\r\n  Class clzz = Class.forName(\"People\");\r\n  Method method = clzz.getDeclaredMethod(\"play\");\r\n  method.setAccessible(true);\r\n  method.invoke(null);\r\n  ```\r\n\r\n  调用静态方法时，invoke参数的对象实例为null即可，静态方法隶属于类，而不是某个对象\r\n\r\n#### 设置\/获取属性\r\n\r\n- 设置属性\r\n\r\n\r\n\r\n  ```java\r\n  Class clzz = Class.forName(\"People\");\r\n  Object object = clzz.newInstance();\r\n  Field field = clzz.getDeclaredField(\"name\");\r\n  field.setAccessible(true);\r\n  field.set(object, \"Jenson\");\r\n  ```\r\n\r\n  设置对象属性时，`field.set`方法首个参数一定是要修改对象，第二个参数为属性值\r\n\r\n- 获取属性\r\n\r\n\r\n\r\n  ```java\r\n  Class clzz = Class.forName(\"People\");\r\n  Object object = clzz.newInstance();\r\n  Field field = clzz.getDeclaredField(\"name\");\r\n  field.setAccessible(true);\r\n  field.set(object, \"史密斯\");\r\n  field.get(object)\r\n  ```\r\n\r\n  获取对象属性时，`field.get`方法参数是要从哪个对象获取属性值。\r\n\r\n### JOOR\r\n\r\n#### 介绍\r\n\r\nGit地址：https:\/\/github.com\/jOOQ\/jOOR\r\n\r\n一般反射的使用无非就是调用构造函数创建对象，设置\/获取属性值，调用实例方法、静态方法。\r\n\r\n但是使用上述的方法实现功能时，感觉还是让人凌乱，有没有一种封装好的框架可以让反射变得简单易用？\r\n\r\nJOOR就是这么一个框架，其核心类只有`Reflect.java`和`ReflectException.java`两个类\r\n\r\n由于只有2个文件，所以一般使用时直接把这两个文件拖到项目中使用即可，无需添加项目依赖。\r\n\r\n#### 使用\r\n\r\n日常使用主要接触`Reflect.java`类，其中主要方法有：\r\n\r\n- on 包裹一个类或实例，和上面的“获取class”一节对应\r\n- create调用构造函数创建对象\r\n- call 方法调用包括静态方法\r\n- set 设置属性值\r\n- get 获取属性值\r\n\r\n下面看看如何使用JOOR重写上面示例：\r\n\r\n```java\r\n\/\/调用无参构造\r\nReflect reflect = Reflect.on(People.class).create()\r\n\/\/设置属性值\r\nreflect.set(\"name\", \"jenson\").set(\"age\", 30);\r\nPeople people = reflect.get();\r\nSystem.out.println(people.getName() + \"####\" + people.getAge());\/\/jenson####30\r\n\/\/获取属性值\r\nreflect.get(\"name\")；\r\n\/\/调用实例方法\r\nreflect.call(\"setName\", \"Jenson\").call(\"setAge\", 30);\r\n\/\/调用静态方法\r\nReflect.on(People.class).call(\"play\");\r\n\r\nObject[] arg = {\"jenson\", 30};\r\n\/\/调用有参构造\r\nReflect reflect = Reflect.on(People.class).create(arg);\r\n```\r\n\r\n#### 问题\r\n\r\n即便如此好用的JOOR也不是完美的，其创建之初只是针对Java，在Android开发中使用时，遇到Final字段时会出现异常。\r\n\r\n看看`Reflect.java`设置属性值源码:\r\n\r\n```java\r\n public Reflect set(String name, Object value) throws ReflectException {\r\n        try {\r\n            Field field = field0(name);\r\n\r\n            if ((field.getModifiers() & Modifier.FINAL) == Modifier.FINAL) {\r\n                try {\r\n                    Field modifiersField = Field.class.getDeclaredField(\"modifiers\");\r\n                    modifiersField.setAccessible(true);\r\n                    modifiersField.setInt(field, field.getModifiers() & ~Modifier.FINAL);\r\n                }\r\n\r\n                \/\/ [#48] E.g. Android doesn't have this field\r\n                catch (NoSuchFieldException ignore) {}\r\n            }\r\n\r\n            field.set(object, unwrap(value));\r\n            return this;\r\n        }\r\n        catch (Exception e) {\r\n            throw new ReflectException(e);\r\n        }\r\n    }\r\n```\r\n\r\n从源码可以看出，如果set的是final字段则会执行`Field.class.getDeclaredField(\"modifiers\")`\r\n\r\n这在Java项目中是没有问题，因为Field类中有该属性存在：`private int  modifiers;`\r\n\r\n如果在Android项目中，Field类没有该属性：\r\n\r\n```java\r\n    public int getModifiers() {\r\n        return accessFlags & 0xffff;  \/\/ mask out bits not used by Java\r\n    }\r\n```\r\n\r\n在Android中使用了`accessFlags`。\r\n\r\n经过测试，要解决这个问题，在Android项目中，注释掉判断`final`那段代码就可以了：\r\n\r\n```java\r\n    public Reflect set(String name, Object value) throws ReflectException {\r\n        try {\r\n            Field field = field0(name);\r\n\r\n\/\/            if ((field.getModifiers() & Modifier.FINAL) == Modifier.FINAL) {\r\n\/\/                try {\r\n\/\/                    Field modifiersField = Field.class.getDeclaredField(\"modifiers\");\r\n\/\/                    modifiersField.setAccessible(true);\r\n\/\/                    modifiersField.setInt(field, field.getModifiers() & ~Modifier.FINAL);\r\n\/\/                }\r\n\/\/\r\n\/\/                \/\/ [#48] E.g. Android doesn't have this field\r\n\/\/                catch (NoSuchFieldException ignore) {}\r\n\/\/            }\r\n\r\n            field.set(object, unwrap(value));\r\n            return this;\r\n        }\r\n        catch (Exception e) {\r\n            throw new ReflectException(e);\r\n        }\r\n    }\r\n```"
  },
  {
    "title": "关于代理模式介绍",
    "created_time": "2019-01-15 10:46:20",
    "body": "### 前言\r\n\r\n**代码实现为Kotlin**\r\n\r\n代理模式就是控制对某个对象的访问。\r\n\r\n通过代理对象间接访问被代理的对象，从而在真正调用被代理对象前做一些其他操作。\r\n\r\n所以代理对象和被代理对象实现同一接口，且代理对象持有被代理对象的引用。\r\n\r\n代理模式分为静态代理和动态代理。\r\n\r\n### 静态代理\r\n\r\n每为一个类型添加静态代理，都要创建一个代理类型，\r\n\r\n优点是通俗易懂，但缺点更明显：造成代理类过多，冗余\r\n\r\n示例：\r\n\r\n定义一个开会接口:\r\n\r\n```kotlin\r\ninterface IMeeting {\r\n    fun meet()\r\n}\r\n```\r\n\r\n老板和秘书分别实现接口:\r\n\r\n```kotlin\r\n\/**\r\n * 老板\r\n *\/\r\nclass Manager : IMeeting {\r\n    override fun meet() {\r\n        Log.e(\"IMeeting\", \"老板开会\")\r\n    }\r\n\r\n}\r\n\r\n\/**\r\n * 秘书\r\n *\/\r\nclass SecretaryProxy(private var manager: Manager) : IMeeting {\r\n    override fun meet() {\r\n        Log.e(\"IMeeting\", \"代理调用\")\r\n        manager.meet()\r\n    }\r\n}\r\n```\r\n\r\n代理处理：\r\n\r\n```kotlin\r\nclass MainActivity : Activity() {\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_main)\r\n        val manager = Manager()\r\n        \/\/静态代理\r\n        val secretaryProxy = SecretaryProxy(manager)\r\n        secretaryProxy.meet()\r\n    }\r\n}\r\n```\r\n\r\n很容易发现，如果此时创建一个Student类，那么要代理就要再创建一个学生代理类StudentProxy，代理方法不同，但逻辑类似。为了避免代码冗余，Java提供了动态代理。\r\n\r\n\r\n\r\n### 动态代理\r\n\r\n动态代理使用Proxy类的`newProxyInstance `方法，涉及三个参数：\r\n\r\n```java\r\n    public static Object newProxyInstance(ClassLoader loader,\r\n                                          Class<?>[] interfaces,\r\n                                          InvocationHandler h)\r\n```\r\n\r\n`loader`为被代理对象的类加载器\r\n\r\n`interfaces`为被代理对象的类继承的接口，数组形式\r\n\r\n`h`为动态代理核心，通常要继承`InvocationHandler`重写`invoke`方法：\r\n\r\n```kotlin\r\nclass ProxyHandler(var target: Any) : InvocationHandler {\r\n    override fun invoke(proxy: Any?, method: Method?, args: Array<out Any>?): Any? {\r\n        return null\r\n    }\r\n}\r\n```\r\n\r\n其中构造函数中的`target`为被代理的对象。\r\n\r\n`invoke`函数中`proxy`为创建的代理对象，\r\n\r\n`invoke`函数中`method`为要执行的函数\r\n\r\n`invoke`函数中`args`为执行函数所需的参数\r\n\r\n动态代理实现为：\r\n\r\n```kotlin\r\nclass ProxyHandler(var target: Any) : InvocationHandler {\r\n\r\n    override fun invoke(proxy: Any?, method: Method?, args: Array<out Any>?): Any? {\r\n        Log.e(\"IMeeting\", \"代理开始\")\r\n        Log.e(\"IMeeting\", \"代理方法：${method?.name}\")\r\n        val result = method?.invoke(target)\r\n        Log.e(\"IMeeting\", \"代理结束\")\r\n        return result\r\n    }\r\n}\r\n```\r\n\r\n```kotlin\r\nclass MainActivity : Activity() {\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_main)\r\n        val manager = Manager()\r\n        \/\/动态代理\r\n        val proxy = Proxy.newProxyInstance(\r\n            manager.javaClass.classLoader,\r\n            manager.javaClass.interfaces,\r\n            ProxyHandler(manager)\r\n        ) as IMeeting\r\n        proxy.meet()\r\n    }\r\n}\r\n```"
  },
  {
    "title": "Kotlin动态代理method.invoke异常",
    "created_time": "2019-01-16 09:26:02",
    "body": "### 前言\r\n\r\n在使用Kotlin做动态代理时候，重写`InvocationHandler`类的`invoke`方法时，\r\n\r\n执行`method.invoke`过程中一直出现异常。\r\n\r\n异常日志可能有多种情况：\r\n\r\n如果没有参数时，信息如下：\r\n\r\n**java.lang.IllegalArgumentException: wrong number of arguments\r\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)**\r\n\r\n有参数时，信息根据参数类型可能有不同，如下：\r\n\r\n**argument 1 has type android.os.IBinder, got java.lang.Object[]**\r\n\r\n意思就是参数没有对上。\r\n\r\n\r\n\r\n### 解决\r\n\r\n`invoke`方法中第二个参数为可变长参，在Java中使用***...***表示\r\n\r\n> Kotlin 的可变参数与 Java 类似，但语法略有不同：\r\n> Kotlin 在该类型之后不会再使用 三个点，而是在参数上使用 `vararg` 修饰符 。\r\n> Kotlin 和 Java 之间的另 一 个区别是，当需要传递的参数己经包装在数组中时，\r\n> 调用该函数的语法 ，在 Java 中，可以按原样传递数组，而 Kotlin 则要求你显式地解\r\n> 包数组，以便每个数组元素在函数中能作为单独的参数来调用 。 \r\n\r\n从技术的角度来讲，这个功能被称为展开运算符，而使用的时候，不过是在对应的参数前面放一个`*`:\r\n\r\n```kotlin\r\nfun main(args: Array<String〉）｛\r\n\tval list = listOf(\"args:\",*args)\r\n\tprintln(list)\r\n}\r\n```\r\n\r\n\r\n\r\n当然使用`*`解包的前提是`args`不为空，\r\n\r\n而在动态代理中代码如下：\r\n\r\n```kotlin\r\nclass ProxyHandler(var target: Any) : InvocationHandler {\r\n\r\n    override fun invoke(proxy: Any?, method: Method?, args: Array<out Any>?): Any? {\r\n        Log.e(\"invoke\", \"代理开始\")\r\n        Log.e(\"invoke\", \"代理方法：${method?.name}\")\r\n        var result = method?.invoke(target, args)\r\n        Log.e(\"invoke\", \"代理结束\")\r\n        return result\r\n    }\r\n}\r\n```\r\n\r\n可见动态代理中`args`是Nullable的，所以不能直接解包，\r\n\r\n这里引入了Elvis运算符`?:`\r\n\r\n如果运算符左侧为null则返回右侧，否则返回左侧，\r\n\r\n修改后的动态代理代码如下：\r\n\r\n```kotlin\r\nclass ProxyHandler(var target: Any) : InvocationHandler {\r\n\r\n    override fun invoke(proxy: Any?, method: Method?, args: Array<out Any>?): Any? {\r\n        Log.e(\"invoke\", \"代理开始\")\r\n        Log.e(\"invoke\", \"代理方法：${method?.name}\")\r\n        var result = method?.invoke(target, *(args ?: emptyArray()))\r\n        Log.e(\"invoke\", \"代理结束\")\r\n        return result\r\n    }\r\n}\r\n```"
  },
  {
    "title": "Kotlin协程入门",
    "created_time": "2019-03-14 11:49:41",
    "body": "### 协程介绍\r\n\r\n#### 协程支持添加\r\n\r\nKotlin基础库中没有包含协程库，所以使用协程库需要单独添加。\r\n\r\nAndroid项目添加协程支持：\r\n\r\n- 项目的build.gradle文件中添加协程版本\r\n\r\n  ```groovy\r\n  buildscript {\r\n      ext.kotlin_version = '1.3.20'\r\n      ext.anko_version = '0.10.8'\r\n      ext.coroutine_version = '1.1.1'\r\n      repositories {\r\n          jcenter()\r\n          google()\r\n      }\r\n      dependencies {\r\n          classpath 'com.android.tools.build:gradle:3.1.3'\r\n          classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\"\r\n      }\r\n  }\r\n  ```\r\n\r\n  \r\n\r\n- 在模块中添加协程库依赖\r\n\r\n  ```groovy\r\n  dependencies {\r\n      implementation fileTree(dir: 'libs', include: ['*.jar'])\r\n      implementation \"org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version\"\r\n      implementation \"org.jetbrains.kotlinx:kotlinx-coroutines-core:$coroutine_version\"\r\n      implementation \"org.jetbrains.kotlinx:kotlinx-coroutines-android:$coroutine_version\"\r\n  }\r\n  ```\r\n\r\n  \r\n\r\n#### 协程启动方式\r\n\r\n##### runBlocking()\r\n\r\n一般用在main方法和单元测试。阻塞线程直到协程运行完毕。\r\n\r\n```kotlin\r\nfun main() = runBlocking {\r\n}\r\n```\r\n\r\n##### launch()\r\n\r\n只返回Job对象，无法自定义返回对象。\r\n\r\n```kotlin\r\n    val job = GlobalScope.launch {\r\n    }\r\n```\r\n\r\n##### async()\r\n\r\n返回Deferred<T>泛型对象，允许自定义返回对象，适用于带返回结果的请求。\r\n\r\n```kotlin\r\n val deff = GlobalScope.async<People> {\r\n        val p = People()\r\n        return@async p\r\n    }\r\n```\r\n\r\n\r\n\r\n### 协程生命周期\r\n\r\n协程和线程一样是有生命周期的，\r\n\r\n协程这里介绍6种生命周期及状态(《Learning Concurrency in Kotlin》一书中说有5中，而《mastering-high-performance-kotlin》和《hands-design-patterns-kotlin》两本书中介绍说有6种，多出`Completing `：Waiting to finish executing children before completing )\r\n\r\nDeferred继承于Job，所以其生命周期是一致的。\r\n\r\n#### NEW\r\n\r\n创建job对象但没有执行。\r\n\r\n正常情况使用launch创建job后自动运行了，\r\n要让其不自动运行可使用 ：` CoroutineStart.LAZY`，\r\n\r\n##### 如何运行延迟的Job：\r\n\r\n通过 `start()`或`join()`方法执行job：\r\n\r\n```kotlin\r\nval job = GlobalScope.launch(start = CoroutineStart.LAZY) {\r\n}\r\njob.start()\r\n\/\/job.join()\r\n```\r\n\r\n#### Active\r\n\r\n调用`start()`方法后处于Active状态。\r\n\r\n#### Cancelling\r\n\r\n调用cancel()方法后，但是没有取消完成，取消是需要时间的，该状态介于Active和Cancelled，可以认为这是一个瞬时状态。\r\n\r\n##### 如何取消Job：\r\n\r\n| job.cancel()                              |                                                        |\r\n| ----------------------------------------- | ------------------------------------------------------ |\r\n| job.cancel(cause = Exception(\"Timeout!\")) |                                                        |\r\n| job.cancelAndJoin()                       | 像名字说的那样，取消运行并且阻塞当前协程直到完成取消。 |\r\n\r\n#### Cancelled\r\n\r\n完成取消，成功取消的Job也可以看成是Completed\r\n\r\n#### Completeing\r\n\r\nDeferred获得结果完成计算前。\r\n\r\n#### Completed\r\n\r\n执行完成。\r\n\r\n任何已停止的job都可以看成是completed。\r\n它适用于任何正常结束、取消或异常结束情况。\r\n由此可见，cancelled 状态可以看成是completed的一个子状态。\r\n\r\n### 挂起函数\r\n\r\n`suspend`修饰的方法为挂起函数\r\n\r\n挂起函数只能被其他挂起函数调用，不能直接在普通函数中调用，否则编译不过。\r\n\r\n挂起函数能直接调用其他挂起函数 比如delay()，不需要再包裹内部协程，使代码整洁、易读。\r\n\r\n### 协程上下文\r\n\r\n就像Android运行期间有Context上下文，协程运行期间也有上下文叫：`CoroutineContext`。\r\n\r\n这是一个接口，有很多实现类。比如CoroutineDispatcher、CoroutineExceptionHandler。\r\n\r\n#### Dispatcher\r\n\r\n协程可以看成是轻量级线程。一个线程可以运行多个协程，这就需要调度器来负责调度控制。\r\n\r\n| 常量使用               | 描述                 |\r\n| ---------------------- | -------------------- |\r\n| Dispatcher.Default     | 默认调度器           |\r\n| Dispatchers.Main       | 适用于Android UI线程 |\r\n| Dispatchers.Unconfined |                      |\r\n| Dispatchers.IO         |                      |\r\n\r\n\r\n\r\n##### CommonPool\r\n\r\ncommonPool是一个由FrameWork自动创建的计算密集型线程池。它的最大数量是cpu核心数减一。\r\n现在，它作为默认的调度器使用。\r\n\r\n要使用默认调度器，只要不设置新的调度器就可以。\r\n\r\n##### Unconfined\r\n\r\n这个调度器会使协程运行在当前线程，除非到达了第一个挂起点。\r\n挂起后，会在挂起时调用的挂起计算所使用的线程中恢复协程。\r\n\r\n##### Single thread context\r\n\r\n这个调度器确保在任何时候，协程都运行在一个指定线程。\r\n可使用`newSingleThreadContext(name=\"xxx\")`创建该调度器：\r\n\r\n```kotlin\r\nprivate val single = newSingleThreadContext(\"single\")\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_main)\r\n        GlobalScope.launch(context = single) {\r\n        }\r\n    }\r\n```\r\n\r\n\r\n\r\n##### Thread pool\r\n\r\n这个调度器持有一个线程池，开始和恢复的协程都会运行在线程池中可用的线程。\r\n运行时环境负责决定哪个线程可用，也决定如何分配负载，作为程序员的我们不需要考虑其他工作。\r\n\r\n```kotlin\r\nprivate val dispatcher = newFixedThreadPoolContext(4, \"myPool\")\r\n\r\n   override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_main)\r\n        GlobalScope.launch(context = dispatcher) {\r\n        }\r\n    }\r\n```\r\n\r\n\r\n\r\n#### 异常处理\r\n\r\n有代码的地方就有异常，Kotlin协程出现异常时并不会导致其所在线程整体崩溃，其影响范围只是出现异常所在协程本身。\r\n\r\n关于异常Job和Deferred有不同的处理方式：`Job直接抛出异常，而Deferred则吞噬异常`，由于异常吞噬所以如果没有良好的异常处理手段，异常信息不会抛出到log造成难以调试的结果。\r\n\r\n##### Deferred吞噬异常\r\n\r\nJob：\r\n\r\n```kotlin\r\n val job = GlobalScope.launch {\r\n        TODO()\r\n    }\r\n```\r\n\r\n直接抛出异常：\r\n\r\nException in thread \"DefaultDispatcher-worker-1\" kotlin.NotImplementedError: An operation is not implemented.\r\n\r\nDeferred：\r\n\r\n```kotlin\r\n    val deff = GlobalScope.async<People> {\r\n        TODO()\r\n    }\r\n```\r\n\r\n则执行成功：Process finished with exit code 0，其异常信息被封装在返回值中而不会被捕获并打印出来。\r\n\r\n##### Deferred抛出异常\r\n\r\n通过Deferred的 await() 方法可以使其直接抛出异常：\r\n\r\n```Kotlin\r\nval deff = GlobalScope.async<People> {\r\n        TODO()\r\n    }\r\n deff.await()\r\n```\r\n\r\n##### getCancellationException()获取异常信息\r\n\r\n取消一个job后，可以通过getCancellationException()方法获取cancel信息。\r\n这个函数会返回CancellationException，如果设置了的话，通过它可以获取造成cancel异常的原因。\r\n\r\n代码如下：\r\n\r\n```kotlin\r\njob.cancel(cause = Exception(\"Tired of waiting\"))\/\/设置cancel的异常信息\r\nval cancellation = job.getCancellationException()\r\ncancellation.cause \/\/ Exception(\"Tired of waiting\")\r\n```\r\n\r\n##### invokeOnCompletion()获取异常信息\r\n\r\n通过调用job的invokeOnCompletion()方法，获取异常信息。\r\n\r\n```kotlin\r\n GlobalScope.launch {\r\n        TODO(\"没有实现\")\r\n    }.invokeOnCompletion { cause: Throwable? -> cause?.let { println(cause.message) } }\r\n```\r\n\r\n\r\n\r\n##### 设置CoroutineExceptionHandler\r\n\r\n协程上下文另一个重要用途是定义未捕获异常行为。可以通过CoroutineExceptionHandler创建这种上下文。\r\n\r\n```kotlin\r\nval exceptionHandler = CoroutineExceptionHandler { _: CoroutineContext, throwable: Throwable ->\r\n        println(\"Job cancelled due to ${throwable.message}\")\r\n    }\r\nGlobalScope.launch(context = exceptionHandler) {\r\n        TODO(\"Not Implemented!\")\r\n}\r\n```\r\n\r\n\r\n\r\n#### 混合上下文\r\n\r\n上面可以知道通过设置协程的`context`参数可以设置调度器和异常处理。但是如果两者都想设置怎么办，设置完了之后又想从中移除某个又如何？\r\n\r\nKotlin为我们提供了`Combining contexts`和`Separating contexts`,可以说是考虑很周到了。\r\n\r\n##### 组合上下文\r\n\r\n使用+操作符组合多个context为一个多功能混合context：\r\n\r\n比如设置一个单线程调度器和异常处理：\r\n\r\n```kotlin\r\n    val singleThreadContext = newSingleThreadContext(\"single\")\r\n    val exceptionHandlerContext = CoroutineExceptionHandler { _: CoroutineContext, throwable: Throwable ->\r\n        println(\"Job cancelled due to ${throwable.message}\")\r\n    }\r\n\/\/使用+号 Combining contexts\r\n    val context = singleThreadContext + exceptionHandlerContext\r\n    GlobalScope.launch(context = context) {\r\n        TODO(\"Not Implemented!\")\r\n    }\r\n```\r\n\r\n\r\n\r\n##### 分离上下文\r\n\r\n通过`CoroutineContext.minusKey`移除指定上下文：\r\n\r\n```Kotlin\r\n    \/\/接上面内容\r\n    val lastContext = context.minusKey(singleThreadContext.key)\r\n\r\n```\r\n\r\n\r\n\r\n### 协程间通信--Channel\r\n\r\n由于共享内存状态，所以多线程是比较难理解也比较容易出错的地方，为此Kotlin提供了Channel代替共享内存帮助我们编写协程高并发代码。\r\n\r\n通道是并发代码之间安全通信的工具。它们允许并发代码通过发送信息进行通信。\r\n通道可以看成是不同协程间安全发送和接受信息的管道，不管他们运行在哪个线程。\r\n\r\n#### 无缓冲通道\r\n\r\n##### RendezvousChannel\r\n\r\n目前唯一一个无缓冲通道是RendezvousChannel。这个通道实现类没有缓冲，所以调用send()后将会挂起直到接收者使用通道调用receive()。\r\n\r\n该类为internal修饰，只有其模块可见，我们只能通过Channel基类创建其实例。\r\n\r\n创建实例：\r\n\r\n```kotlin\r\n    val channel = Channel<Int>()\r\n    val channel = Channel<Int>(0)\r\n    val channel = Channel<Int>(Channel.RENDEZVOUS)\r\n```\r\n\r\n\r\n\r\n#### 有缓冲通道\r\n\r\n##### LinkedListChannel\r\n\r\n无限(Int.MAX_VALUE)缓冲的通道。当通道中数据量达到缓冲区大小时，这个通道会挂起发送者代码。\r\n\r\n创建实例：\r\n\r\n```kotlin\r\n    val channel = Channel<Int>(Channel.UNLIMITED)\r\n```\r\n\r\n\r\n\r\n##### ArrayChannel\r\n\r\n缓冲大小介于0到Int.MAX_VALUE-1，当元素数量达到缓冲大小时会挂起sender。\r\n可以通过调用Channel为其设置一个小于Int最大值的正数作为参数来实例化数组通道。\r\n当缓冲满的时候会挂起sender，当有至少一组数据被接受时候会恢复。\r\n\r\n创建实例：\r\n\r\n```kotlin\r\n    val channel = Channel<Int>(22)\r\n```\r\n\r\n\r\n\r\n##### ConflatedChannel\r\n\r\n这是第三种类型的缓冲通道。\r\n\r\n这种通道只有一个元素大小的缓冲，当发送一个新元素时，上一个元素就会丢失，发送的元素丢了也没关系。\r\n这也就意味着发送者永远不会被挂起。\r\n\r\n创建实例：\r\n\r\n```kotlin\r\n    val channel = Channel<Int>(Channel.CONFLATED)\r\n```\r\n\r\n#### 发送通道常用方法\r\n\r\n##### channel.isClosedForSend\r\n\r\n##### channel.isFull \r\n\r\n##### channel.send(1)\r\n\r\n##### channel.offer(2)\r\n\r\n非挂起函数，允许你在某些情况下通过通道发送元素。\r\n这个offer()函数接受一个元素尝试加入到队列 并返回boolean值或根据通道状态抛出异常。\r\n\r\n如果通道关闭，offer()出现异常：\r\n\r\n如果缓冲满了，offer会返回false：\r\n\r\n如果通道打开并且没有充满，offer()会把元素添加到队列。\r\n这是唯一一种像通道添加元素而又不挂起的方法。\r\n\r\n#### 接收通道常用方法\r\n\r\n##### channel.isClosedForReceive\r\n\r\n##### channel.receive()\r\n\r\n##### channel.isEmpty\r\n\r\n\r\n\r\n### Thread Confinement, Actors, and Mutexes\r\n\r\n#### Thread Confinement\r\n\r\n线程限制意味着限制访问共享状态的所有协程，以便它们在单个线程上执行。\r\n也就是说状态不再是线程间共享的了：只有一个线程允许修改状态。\r\n\r\n```kotlin\r\nvar counter = 0\r\nval context = newSingleThreadContext(\"counter\")\r\nfun asyncIncrement(by: Int) = async(context) {\r\n    for (i in 0 until by) {\r\n    counter++\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n#### Actor\r\n\r\nActor这个东西不太明白如何翻译过来。不过通过源码可以看到：\r\n\r\nActor是协程和Channel的组合体：其返回值是SendChannel，block中有个ReceiveChannel。\r\n\r\n其他协程通过返回值的SendChannel发送消息，而后block中的ReceiveChannel接收消息并做处理：\r\n\r\n```kotlin\r\nvar counter = 0\r\n\r\nval sendChannel = GlobalScope.actor<Int> {\r\n    for (i in channel) {\r\n        counter++\r\n    }\r\n}\r\n\r\nfun asyncIncrement(by: Int) = GlobalScope.async {\r\n    for (i in 0 until by) {\r\n        sendChannel.send(1)\r\n    }\r\n}\r\n\r\nfun main() = runBlocking {\r\n    asyncIncrement(2000)\r\n    asyncIncrement(1000)\r\n    delay(3000)\r\n    println(\"counter==${counter}\")\r\n    delay(2000)\r\n}\r\n```\r\n\r\n\r\n\r\n#### Mutexes\r\n\r\n互斥是指一种同步机制，它保证一次只有一个协程可以执行一段代码。\r\n\r\nKotlin互斥最重要的特性是它们没有阻塞：等待执行的协程将暂停，直到它们获得锁并执行代码块为止。 \r\n\r\n`withLock`使用：\r\n\r\n```kotlin\r\nval mutex = Mutex()\r\nvar counter = 0\r\n\r\nfun asyncIncrement(by: Int) = GlobalScope.async {\r\n    for (i in 0 until by) {\r\n       mutex.withLock {\r\n           counter++\r\n       }\r\n    }\r\n}\r\n\r\nfun main() = runBlocking {\r\n    asyncIncrement(2000)\r\n    asyncIncrement(1000)\r\n    delay(3000)\r\n    println(\"counter==${counter}\")\r\n    delay(2000)\r\n}\r\n```\r\n\r\n如果想要更灵活的控制，可以使用`lock() `和`unLock()`。\r\n\r\n\r\n\r\n#### Volatile \r\n\r\n为了强制让更新对其他线程立即可见，我们可以使用注解@Volatile："
  },
  {
    "title": "二叉树的遍历",
    "created_time": "2019-09-25 09:43:09",
    "body": "## 二叉树定义\r\n\r\n有一个根节点；\r\n\r\n除根节点外，其他每个节点都与其唯一的父节点相连；\r\n\r\n从根节点到其他每个节点都有且仅有一条路径；\r\n\r\n如果每个节点最多有两个子节点，我们就称这样的树为二叉树 \r\n\r\n\r\n\r\n## 二叉树遍历\r\n\r\n![图一](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/%E4%BA%8C%E5%8F%89%E6%A0%91.png)\r\n\r\n树的遍历分为先序遍历、中序遍历和后序遍历。\r\n\r\n初次学习树的遍历时比较难理解这几个定义到底是什么意思，是根据什么来定义先后和中的？\r\n\r\n其实是根据**根节点**调用位置定义的。\r\n\r\n所谓**先序遍历**就是先调用根节点，再遍历左子树，最后遍历右子树。简称“根左右”。\r\n\r\n所谓**中序遍历**就是先遍历左子树，再调用根节点，最后遍历右子树。简称“左根右”。\r\n\r\n所谓**后序遍历**就是先遍历左子树，再遍历右子树，最后调用根节点。简称“左右根”。\r\n\r\n**在调用右子树之前要确保左子树已经全部遍历完成**\r\n\r\n一个熟有左子树、右子树和当前节点值，所以创建二叉树类：\r\n\r\n```kotlin\r\nclass BinaryTree(var left: BinaryTree? = null, \r\n                 var right: BinaryTree? = null, \r\n                 var value: Char = 'A')\r\n\r\n\r\n\/**\r\n生成二叉树\r\n**\/\r\nprivate fun generatorTree(): BinaryTree {\r\n    val gTree = BinaryTree(value = 'G')\r\n    val dTree = BinaryTree(value = 'D', right = gTree)\r\n    val eTree = BinaryTree(value = 'E')\r\n    val bTree = BinaryTree(value = 'B', left = dTree, right = eTree)\r\n    val fTree = BinaryTree(value = 'F')\r\n    val cTree = BinaryTree(value = 'C', left = fTree)\r\n    val rootTree = BinaryTree(value = 'A', left = bTree, right = cTree)\r\n    return rootTree\r\n}\r\n```\r\n\r\n\r\n\r\n### 先序遍历\r\n\r\n先序遍历遍历顺序是“根左右”，\r\n\r\n1、A作为根节点时，A有左右节点，所以顺序为ABC，\r\n\r\n2、B作为根节点时，B有左右节点，所以顺序为BDE，\r\n\r\n3、D作为根节点时，只有右节点，把左节点用0补齐，所以顺序为D0G，\r\n\r\n4、E作为根节点时，没有节点，左右节点用0补齐，所以顺序为E00。\r\n\r\n5、C作为根节点时，只有左节点，右节点用0补齐，所以顺序为CF0。\r\n\r\n6、把2中的值代入到1的B，得到ABDEC，\r\n\r\n7、把3中的值代入到6的D，得到ABD0GEC\r\n\r\n8、把4中的值代入到7的E，得到ABD0GE00C\r\n\r\n9、把5中的值代入到8的C，得到ABD0GECF0\r\n\r\n10、最后消零得到ABDGECF。\r\n\r\n代码实现为：\r\n\r\n```kotlin\r\nprivate fun preorder(tree: BinaryTree?) {\r\n    tree?.let {\r\n        println(\"当前节点为${it.value}\")\r\n        preorder(it.left)\r\n        preorder(it.right)\r\n    }\r\n}\r\n```\r\n\r\n 打印结果为：\r\n\r\n```\r\n当前节点为A\r\n当前节点为B\r\n当前节点为D\r\n当前节点为G\r\n当前节点为E\r\n当前节点为C\r\n当前节点为F\r\n```\r\n\r\n\r\n\r\n### 中序遍历\r\n\r\n中序遍历遍历顺序是“左根右”，\r\n\r\n1、A作为根节点时，有BC节点，顺序为BAC\r\n\r\n2、B作为根节点时，有DE节点 ，顺序为DBE，\r\n\r\n3、D作为根节点时，有右节点G，左节点用0补齐，顺序为0DG，\r\n\r\n4、E作为根节点时，没有节点，用0补齐，顺序为0E0，\r\n\r\n5、C作为根节点时，有左节点F，右节点用0补齐，顺序为FC0。\r\n\r\n6、把2的值代入1中B，得到DBEAC，\r\n\r\n7、把3的值代入6中D，得到0DGBEAC，\r\n\r\n8、把4的值代入7中E，得到0DGB0E0AC，\r\n\r\n9、把5的值代入8中C，得到0DGB0E0AFC0，\r\n\r\n10、消零得到DGBEAFC\r\n\r\n代码实现为：\r\n\r\n```kotlin\r\nprivate fun midOrder(tree: BinaryTree?) {\r\n    tree?.let {\r\n        midOrder(it.left)\r\n        println(\"当前节点为${it.value}\")\r\n        midOrder(it.right)\r\n    }\r\n}\r\n```\r\n\r\n 打印结果为：\r\n\r\n```\r\n当前节点为D\r\n当前节点为G\r\n当前节点为B\r\n当前节点为E\r\n当前节点为A\r\n当前节点为F\r\n当前节点为C\r\n```\r\n\r\n\r\n\r\n### 后序遍历\r\n\r\n后序遍历遍历顺序是“左右根”，\r\n1、A作为根节点时，有BC节点，顺序为BCA\r\n\r\n2、B作为根节点时，有DE节点，顺序为DEB\r\n\r\n3、D作为根节点时，只有右节点G，左节点用0补齐，顺序为0GD\r\n\r\n4、E作为根节点时，没有节点，用0补齐，顺序为00E\r\n\r\n5、C作为根节点时，只有左节点F，右节点用0补齐，顺序为F0C\r\n\r\n6、把2的值代入1的B，得到DEBCA\r\n\r\n7、把3的值代入6的D，得到0GDEBCA\r\n\r\n8、把4的值代入7的E，得到0GD00EBCA\r\n\r\n9、把5的值代入8的C，得到0GD00EBF0CA\r\n\r\n10、消零得到GDEBFCA\r\n\r\n代码实现为：\r\n\r\n```kotlin\r\nprivate fun postOrder(tree: BinaryTree?) {\r\n    tree?.let {\r\n        postOrder(it.left)\r\n        postOrder(it.right)\r\n        println(\"当前节点为${it.value}\")\r\n    }\r\n}\r\n```\r\n\r\n打印结果为：\r\n\r\n```\r\n当前节点为G\r\n当前节点为D\r\n当前节点为E\r\n当前节点为B\r\n当前节点为F\r\n当前节点为C\r\n当前节点为A\r\n```"
  },
  {
    "title": "Jar包修改并从新打包",
    "created_time": "2019-10-06 10:32:34",
    "body": "# 前言\r\n\r\n今天遇到一个奇葩的问题：某人的一个爬虫项目用到一个jar包，里面涉及登录功能。但是用户名和密码在jar里面固定了，现在账号权限没有了，需要使用新的帐号，所以就要从新打jar。\r\n\r\n但是当初做这个项目的人已经消失了，并没有源码，所以我的任务是修改这个jar的内容然后从新打包。\r\n\r\n# 步骤\r\n\r\n任务很直观，步骤也很明显：\r\n\r\n首先生成一个和需要替换的class文件一样的新文件，\r\n\r\n然后替换掉旧文件，\r\n\r\n最后打包。\r\n\r\n下面看看详细的操作步骤，\r\n\r\n## 生成新的替换文件\r\n\r\n### 使用jd-jui打开jar，找到要修改的类，ctrl+s保存为java文件\r\n\r\n![保存java文件](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/modifyjar-savetojava.png)\r\n\r\n### Intellij新建一个java项目，注意package要和修改类的包名保持一致\r\n\r\n如果要修改文件包名为`com.aa.bb`那么新建的package包名也要一样。\r\n\r\n### 如果该类文件依赖其他类，添加该jar包的依赖\r\n\r\n![添加依赖](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/modifyjar-dependency.png)\r\n\r\n### 如果没有报红则build project，生成新class文件\r\n\r\n![新文件](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/modifyjar-newclass.png)\r\n\r\n\r\n\r\n## 替换旧文件\r\n\r\n### 解压jar\r\n\r\n### 用新生成的class文件替换旧文件\r\n\r\n## 打包\r\n\r\n### 使用压缩软件压缩为zip，修改后缀名为jar。"
  },
  {
    "title": "CompletableFuture基本使用",
    "created_time": "2019-10-23 09:40:34",
    "body": "# 前言\r\n\r\n工作中会有不少异步编程地方，看到相关知识点往往涉及`Runnable`和`Callable`。\r\n\r\n但是看下源码就会发现这两个都是函数式接口，功能单一，感觉不是那么好用。\r\n\r\n然后`Future`登场了，提供了取消和获取结果等几个方法：\r\n\r\n```java\r\npublic interface Future<V> {\r\n    boolean cancel(boolean mayInterruptIfRunning);\r\n    boolean isCancelled();\r\n    boolean isDone();\r\n    V get() throws InterruptedException, ExecutionException;\r\n    V get(long timeout, TimeUnit unit)\r\n        throws InterruptedException, ExecutionException, TimeoutException;\r\n}\r\n```\r\n\r\n但是这时候`Future`的使用仍然还是比较简单的，\r\n\r\n在线程池提交任务的时候返回`Future`：\r\n\r\n```\r\n ExecutorService executor = Executors.newSingleThreadExecutor();\r\n Future<String> future = executor.submit(new Callable<String>() {\r\n            @Override\r\n            public String call() throws Exception {\r\n            \t\/\/耗时处理\r\n                return \"\";\r\n            }\r\n        });\r\n```\r\n\r\n在我们依赖异步结果的时候通过`future.get()`获取结果，如果任务还没有完成，这会阻塞当前线程。\r\n\r\n感觉`Future`并没有给我们异步编程带来多大便利，对下面任务它仍然很无力：\r\n\r\n- 将两个异步计算合并为一个——这两个异步计算之间相互独立，同时第二个又依赖于第一个的结果。\r\n- 等待`Future`集合中的所有任务都完成。\r\n- 仅等待`Future`集合中最快结束的任务完成（有可能因为它们试图通过不同的方式计算同一个值），并返回它的结果。\r\n- 应对`Future`的完成事件（即当`Future`的完成事件发生时会收到通知，并能使用`Future`计算的结果进行下一步的操作，不只是简单地阻塞等待操作的结果）。\r\n\r\n好在，JDK8之后Java推出了 `CompletableFuture `，支持非阻塞的多功能`Future`，它的功能包括但不限于上面的任务，可见它的功能强大了。\r\n\r\n下面对`CompletableFuture `方法加以分析：\r\n\r\n\r\n\r\n# 方法解析\r\n\r\n\r\n\r\n## 获取 CompletableFuture 实例\r\n\r\n`CompletableFuture` 提供了静态工厂方法获取实例对象，所以我们不用自己new生成。\r\n\r\n如果`CompletableFuture` 运行后有返回值可以通过`supplyAsync`方法，\r\n\r\n如果没有返回值可以通过`runAsync`方法。\r\n\r\n### runAsync\r\n\r\n不需要返回值时，可以使用`runAsync`获取实例,可以看到有2个名称为`runAsync`的方法：\r\n\r\n```java\r\n public static CompletableFuture<Void> runAsync(Runnable runnable) {\r\n        return asyncRunStage(asyncPool, runnable);\r\n    }\r\n    \r\npublic static CompletableFuture<Void> runAsync(Runnable runnable,\r\n                                                   Executor executor) {\r\n        return asyncRunStage(screenExecutor(executor), runnable);\r\n    }\r\n```\r\n\r\n这里方法重载，第二个参数`executor`为自定义的线程池。\r\n\r\n如果没有设置则使用系统默认的` ForkJoinPool.commonPool()`。\r\n\r\n使用方法：\r\n\r\n```java\r\nCompletableFuture.runAsync(() -> {\r\n            System.out.println(\"runAsync\");\r\n        });\r\n```\r\n\r\n\r\n\r\n### supplyAsync\r\n\r\n如果需要返回值，可以使用`supplyAsync`获取实例，可以看到也有2个名称为`supplyAsync`的方法：\r\n\r\n```java\r\n    public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier) {\r\n        return asyncSupplyStage(asyncPool, supplier);\r\n    }\r\n    public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier,\r\n                                                       Executor executor) {\r\n        return asyncSupplyStage(screenExecutor(executor), supplier);\r\n    }\r\n```\r\n\r\n使用方法：\r\n\r\n```java\r\n CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {\r\n            return \"supplyAsync\";\r\n        });\r\n        System.out.println(future.join());\r\n```\r\n\r\n\r\n\r\n## 等待任务完成\r\n\r\n如果我们想阻塞当前线程直到任务完成，可以使用`get`和`join`两种方法。\r\n\r\n`get` 方法抛出的 ExecutionException 是一个受检异常（checked exception）。\r\n`join` 方法与 `get `方法相同，不同之处在于，如果异常出现， `join`方法将抛出\r\n由底层异常所引发的 CompletionException，它是一个非受检异常（unchecked\r\nexception）  \r\n\r\n### get\r\n\r\n`get`有2个方法：\r\n\r\n```java\r\npublic T get() throws InterruptedException, ExecutionException {\r\n        Object r;\r\n        return reportGet((r = result) == null ? waitingGet(true) : r);\r\n}\r\n\r\npublic T get(long timeout, TimeUnit unit)\r\n        throws InterruptedException, ExecutionException, TimeoutException {\r\n        Object r;\r\n        long nanos = unit.toNanos(timeout);\r\n        return reportGet((r = result) == null ? timedGet(nanos) : r);\r\n}\r\n```\r\n\r\n其中`public T get(long timeout, TimeUnit unit)`表示为延迟`timeout`时间后没有返回值则抛出异常。\r\n\r\n使用方法：\r\n\r\n```java\r\n CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {\r\n            return \"supplyAsync\";\r\n        });\r\n        try {\r\n            String result = future.get();\r\n            System.out.println(result);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        } catch (ExecutionException e) {\r\n            e.printStackTrace();\r\n        }\r\n```\r\n\r\n\r\n\r\n### join\r\n\r\n使用方法：\r\n\r\n```java\r\nCompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> {\r\n            return \"supplyAsync-1\";\r\n        });\r\nSystem.out.println(future1.join());\r\n```\r\n\r\n在`join`和`get`之间，我更倾向于使用`join`，不用每次都`try catch`。而且`CompletableFuture`后面有专门的异常处理方法。\r\n\r\n### getNow\r\n\r\n这里还有一个不常用方法，\r\n\r\n看下方法：\r\n\r\n```java\r\npublic T getNow(T valueIfAbsent) {\r\n        Object r;\r\n        return ((r = result) == null) ? valueIfAbsent : reportJoin(r);\r\n}\r\n```\r\n\r\n调用`getNow`时，如果任务没有完成，不进行阻塞等待，而是直接返回值`valueIfAbsent`。\r\n\r\n使用方法：\r\n\r\n```java\r\nCompletableFuture future2 = CompletableFuture.supplyAsync(() -> {\r\n            sleep(2000);\r\n            return \"hello\";\r\n        });\r\nSystem.out.println(future2.getNow(\"world\"));\/\/打印world\r\n```\r\n\r\n\r\n\r\n## 完成任务\r\n\r\n###   complete  \r\n\r\nfuture调用`complete(T t)` 会立即执行。 但是`complete(T t)` 只能调用一次， 后续的重复调用会失效。\r\n\r\n如果future已经执行完毕能够返回结果， 此时再调用`complete(T t)` 则会无效。\r\n\r\n使用方法：\r\n\r\n```java\r\nCompletableFuture future3 = CompletableFuture.supplyAsync(() -> \"hello\");\r\nfuture3.complete(\"world\");\r\nSystem.out.println(future3.join());\/\/打印world\r\n```\r\n\r\n###   completeExceptionally  \r\n\r\n使用`completeExceptionally（Throwable ex)`则抛出一个异常， 而不是一个成功的结果。  \r\n\r\n使用方法：\r\n\r\n```java\r\nCompletableFuture future4 = CompletableFuture.supplyAsync(() -> \"hello\");\r\n        future4.completeExceptionally(new Exception(\"exception..\"));\r\n        try {\r\n            future4.get();\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        } catch (ExecutionException e) {\r\n            e.printStackTrace();\r\n        }\r\n```\r\n\r\n\r\n\r\n## thenApply\r\n\r\n`thenApply`的功能相当于将CompletableFuture＜t＞转换成Completablefuture＜U＞。  \r\n\r\nfuture执行完成后紧接着把结果通过函数参数传递到`thenApply`，然后继续处理future结果并返回一个新的future。\r\n\r\n| 方法名                                                       | 描述                       |\r\n| :----------------------------------------------------------- | :------------------------- |\r\n| public <U> CompletableFuture<U> thenApply(Function<? super T,? extends U> fn) | 使用上一个任务所在线程执行 |\r\n| public <U> CompletableFuture<U> thenApplyAsync(Function<? super T,? extends U> fn) | 使用Fork.joinPool线程池    |\r\n| public <U> CompletableFuture<U> thenApplyAsync(Function<? super T,? extends U> fn, Executor executor) | 指定线程池                 |\r\n\r\n使用方法：\r\n\r\n```java\r\nCompletableFuture<String> future = CompletableFuture.supplyAsync(() -> \"hello\").thenApplyAsync((str) -> str + \" world\");\r\nSystem.out.println(future.join());\r\n```\r\n\r\n\r\n\r\n## thenCompose\r\n\r\n`thenCompose` 可用于组合多个 `CompletableFuture`， 将前一个结果作为下一个计算\r\n的参数， 它们之间存在着先后顺序。  它是连接多个`CompletableFuture `\r\n\r\n\r\n\r\n| 方法名                                                       | 描述                       |\r\n| :----------------------------------------------------------- | :------------------------- |\r\n| public <U> CompletableFuture<U> thenCompose(    Function<? super T, ? extends CompletionStage<U>> fn) | 使用上一个任务所在线程执行 |\r\n| public <U> CompletableFuture<U> thenComposeAsync(    Function<? super T, ? extends CompletionStage<U>> fn) | 使用Fork.joinPool线程池    |\r\n| public <U> CompletableFuture<U> thenComposeAsync(    Function<? super T, ? extends CompletionStage<U>> fn,    Executor executor) | 指定线程池                 |\r\n\r\n使用方法：\r\n\r\n```java\r\n CompletableFuture future1 = CompletableFuture.supplyAsync(() -> {\r\n            System.out.println(Thread.currentThread().getName());\r\n            return \"hello\";\r\n        }).thenCompose(str -> CompletableFuture.supplyAsync(() -> {\r\n            System.out.println(Thread.currentThread().getName());\r\n            return (str + \" world\");\r\n        })).thenApplyAsync(str -> CompletableFuture.supplyAsync(() -> {\r\n            System.out.println(Thread.currentThread().getName());\r\n            return str + \" last\";\r\n        }));\r\n        System.out.println(future1.join());\r\n```\r\n\r\n\r\n\r\n##   thenCombine  \r\n\r\n使用`thenCombine` 之后， future1、 future2之间是并行执行的， 最后再将结果汇总并返回。 \r\n\r\n| 方法名                                                       | 描述                    |\r\n| ------------------------------------------------------------ | ----------------------- |\r\n| public <U,V> CompletableFuture<V> thenCombine(    CompletionStage<? extends U> other,    BiFunction<? super T,? super U,? extends V> fn) |                         |\r\n| public <U,V> CompletableFuture<V> thenCombineAsync(    CompletionStage<? extends U> other,    BiFunction<? super T,? super U,? extends V> fn) | 使用Fork.joinPool线程池 |\r\n| public <U,V> CompletableFuture<V> thenCombineAsync(    CompletionStage<? extends U> other,    BiFunction<? super T,? super U,? extends V> fn, Executor executor) | 指定线程池              |\r\n\r\n使用方法：\r\n\r\n```java\r\n        CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> {\r\n            return \"hello\";\r\n        });\r\n\r\n        CompletableFuture<String> future3 = CompletableFuture.supplyAsync(() -> {\r\n            return \"world\";\r\n        });\r\n        CompletableFuture<String> future5 = future2.thenCombine(future3, (s1, s2) -> {\r\n            return s1 + \"##\" + s2;\r\n        });\r\n        System.out.println(future5.join());\r\n```\r\n\r\n\r\n\r\n## thenAcceptBoth\r\n\r\n上面说了`thenCombine` 是将结果汇总并返回，那如果不需要返回就可以使用`thenAcceptBoth`。\r\n\r\n返回`Void`类型泛型。\r\n\r\n| 方法名                                                       | 描述                    |\r\n| ------------------------------------------------------------ | ----------------------- |\r\n| public <U> CompletableFuture<Void> thenAcceptBoth(    CompletionStage<? extends U> other,    BiConsumer<? super T, ? super U> action) |                         |\r\n| public <U> CompletableFuture<Void> thenAcceptBothAsync(    CompletionStage<? extends U> other,    BiConsumer<? super T, ? super U> action) | 使用Fork.joinPool线程池 |\r\n| public <U> CompletableFuture<Void> thenAcceptBothAsync(    CompletionStage<? extends U> other,    BiConsumer<? super T, ? super U> action, Executor executor) | 指定线程池              |\r\n\r\n使用方法：\r\n\r\n```java\r\nCompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> {\r\n            return \"hello\";\r\n        });\r\n\r\nCompletableFuture<String> future3 = CompletableFuture.supplyAsync(() -> {\r\n            return \"world\";\r\n        });\r\nCompletableFuture<Void> future5 = future2.thenAcceptBothAsync(future3, (s1, s2) -> {\r\n            System.out.println(s1 + \"##\" + s2);\r\n        });\r\nSystem.out.println(future5.join());\r\n```\r\n\r\n\r\n\r\n## whenComplete\r\n\r\n 当`CompletableFuture`的计算结果完成，或者抛出异常的时候，都可以进入`whenComplete`方法对结果进行处理。\r\n\r\n| 方法名                                                       | 描述                    |\r\n| ------------------------------------------------------------ | ----------------------- |\r\n| public CompletableFuture<T> whenComplete(    BiConsumer<? super T, ? super Throwable> action) |                         |\r\n| public CompletableFuture<T> whenCompleteAsync(    BiConsumer<? super T, ? super Throwable> action) | 使用Fork.joinPool线程池 |\r\n| public CompletableFuture<T> whenCompleteAsync(    BiConsumer<? super T, ? super Throwable> action, Executor executor) | 指定线程池              |\r\n\r\n使用方法：\r\n\r\n```java\r\n        CompletableFuture.supplyAsync(() -> \"hello\")\r\n                .thenApply((s1) -> s1 + \"@@\")\r\n                .whenCompleteAsync((result, throwable) -> {\r\n                    System.out.println(result);\r\n                });\r\n```\r\n\r\n\r\n\r\n## handle\r\n\r\n 当`CompletableFuture`的计算结果完成，或者抛出异常的时候，可以通过`handle`方法对结果进行处理 。\r\n\r\n`handle`和`whenComplete`相比，`whenComplete`是没有返回值的，而`handle`是有返回值的。\r\n\r\n| 方法名                                                       | 描述 |\r\n| ------------------------------------------------------------ | ---- |\r\n| public <U> CompletionStage<U> handle    (BiFunction<? super T, Throwable, ? extends U> fn); |      |\r\n| public <U> CompletionStage<U> handleAsync    (BiFunction<? super T, Throwable, ? extends U> fn); |      |\r\n| public <U> CompletionStage<U> handleAsync    (BiFunction<? super T, Throwable, ? extends U> fn,     Executor executor); |      |\r\n\r\n使用方法：\r\n\r\n```java\r\n        CompletableFuture future = CompletableFuture.supplyAsync(() -> \"hello\")\r\n                .thenApply((s1) -> s1 + \"@@\")\r\n                .handleAsync((result, throwable) -> {\r\n                    System.out.println(result);\r\n                    return result;\r\n                });\r\n        System.out.println(future.join());\r\n```\r\n\r\n\r\n\r\n## thenAccept\r\n\r\n  `thenAccept` 是只会对计算结果进行消费而不会返回任何结果的方法。  \r\n\r\n| 方法名                                                       | 描述 |\r\n| ------------------------------------------------------------ | ---- |\r\n| public CompletionStage<Void> thenAccept(Consumer<? super T> action); |      |\r\n| public CompletionStage<Void> thenAcceptAsync(Consumer<? super T> action); |      |\r\n| public CompletionStage<Void> thenAcceptAsync(Consumer<? super T> action,                                             Executor executor); |      |\r\n\r\n使用方法：\r\n\r\n```java\r\n        CompletableFuture future = CompletableFuture.supplyAsync(() -> \"hello\")\r\n                .thenApply((s1) -> s1 + \"@@\")\r\n                .thenAcceptAsync(s -> System.out.println(s));\r\n\r\n        future.join();\r\n```\r\n\r\n\r\n\r\n## acceptEither\r\n\r\n`acceptEither`表示的是两个Future， 当其中任意一个Future计算完成的时候就会执行 。\r\n\r\n| 方法名                                                       | 描述 |\r\n| ------------------------------------------------------------ | ---- |\r\n| public CompletionStage<Void> acceptEither    (CompletionStage<? extends T> other,     Consumer<? super T> action); |      |\r\n| public CompletionStage<Void> acceptEitherAsync    (CompletionStage<? extends T> other,     Consumer<? super T> action); |      |\r\n| public CompletionStage<Void> acceptEitherAsync    (CompletionStage<? extends T> other,     Consumer<? super T> action,     Executor executor); |      |\r\n\r\n使用方法：\r\n\r\n```java\r\n  CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> \"jenson\");\r\n  CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> \"hello\");\r\n  CompletableFuture<Void> future = future1.acceptEither(future2, o -> \t     \tSystem.out.println(o));\r\n  future.join();\r\n\r\n```\r\n\r\n\r\n\r\n##   applyToEither\r\n\r\n`applyToEither` 与 `acceptEither` 类似，\r\n\r\n`applyToEither` 有返回值，`acceptEither` 没有返回值。\r\n\r\n| 方法名                                                       | 描述 |\r\n| ------------------------------------------------------------ | ---- |\r\n| public <U> CompletionStage<U> applyToEither    (CompletionStage<? extends T> other,     Function<? super T, U> fn); |      |\r\n| public <U> CompletionStage<U> applyToEitherAsync    (CompletionStage<? extends T> other,     Function<? super T, U> fn); |      |\r\n| public <U> CompletionStage<U> applyToEitherAsync    (CompletionStage<? extends T> other,     Function<? super T, U> fn,     Executor executor); |      |\r\n\r\n使用方法：\r\n\r\n```java\r\nCompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> \"jenson\");\r\nCompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> \"hello\");\r\nCompletableFuture<String> future = future1.applyToEitherAsync(future2, s -> s);\r\nSystem.out.println(\"result=\" + future.join());\r\n```\r\n\r\n\r\n\r\n## allOf\r\n\r\n| 方法名                                                       | 描述                                                |\r\n| ------------------------------------------------------------ | --------------------------------------------------- |\r\n| public static CompletableFuture<Void> allOf(CompletableFuture<?>... cfs) | 在所有future完成后，返回一个CompletableFuture<Void> |\r\n\r\n\r\n\r\n使用方法：\r\n\r\n```java\r\n val future2 = CompletableFuture.supplyAsync { \"hello\" }\r\n val future3 = CompletableFuture.supplyAsync { \"jenson\" }\r\n val future4 = CompletableFuture.supplyAsync { \"qq\" }\r\n CompletableFuture.allOf(future2, future3, future4).join()\r\n```\r\n\r\n\r\n\r\n## anyOf\r\n\r\n`anyOf`和`acceptEither`、 `applyToEither`的区别在于，\r\n\r\n 后两者只能使用在两个future中， 而`anyOf`可以使用在多个future中。  \r\n\r\n\r\n\r\n## 异常处理\r\n\r\n`CompletableFuture`在运行时如果遇到异常， 则可以使用`get` 并抛出异常进行处理，\r\n\r\n 但这并不是一个最好的方法。 `CompletableFuture`本身也提供了几种方式来处理异常。\r\n\r\n###   Exceptionally  \r\n\r\n| 方法名                                                       | 描述                                                 |\r\n| ------------------------------------------------------------ | ---------------------------------------------------- |\r\n| public CompletionStage<T> exceptionally    (Function<Throwable, ? extends T> fn); | 只有future抛出异常时候才触发这个方法调用fn函数计算。 |\r\n\r\n使用方法：\r\n\r\n```java\r\nCompletableFuture.supplyAsync(() -> \"jenson\").thenApply(s -> {\r\n            s = null;\r\n            return s.length();\r\n        }).exceptionally(t -> {\r\n            System.out.println(t.getMessage());\r\n            return null;\r\n        }).join();\r\n```\r\n\r\n###   whenComplete  \r\n\r\n`whenComplete` 在前面已经介绍过了， 在这里跟`exceptionally`的作用差不多， \r\n\r\n可以捕获任意阶段的异常。 如果没有异常， 就执行action。  \r\n\r\n### handle\r\n\r\n  与`whenComplete`相似的方法是`handle`。"
  },
  {
    "title": "浅谈Java注解(一)",
    "created_time": "2019-11-15 10:47:15",
    "body": "# 0x00 前言\r\n\r\n⼀直以来对于Java注解的理解都停留在`@Override`的使⽤上⾯。\r\n\r\n对于其他则知之较少，但是慢慢发现很多框架都使⽤了注解功能，\r\n\r\n越来越觉得有必要了解下注解的实现了。\r\n\r\n对于注解的学习可以按照图下的四个步骤：  \r\n\r\n![image-20191115143353914](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/qtzj-01-01.png)\r\n\r\n下⾯分别来介绍下每步\r\n\r\n<!-- more -->  \r\n\r\n# 0x01 知道\r\n\r\n## 什么是注解\r\n\r\nJava注解从5.0版本推出，\r\n\r\n注解就是对类、⽅法、参数、变量、构造器及\r\n\r\n包声明中的特殊修饰符，实现对元数据的描述。  \r\n\r\n## 元数据是什么\r\n\r\n简单点说元数据就是⽤来存储数据的数据，\r\n\r\n⽐如⽤来描述学⽣信息需要定义⼀个Student类，\r\n\r\n那么Student类⽤来描述学⽣信息，\r\n\r\n但是谁⼜来描述Student类本身呢？\r\n\r\n就是元类了(meta class)，即Java中Class类。\r\n\r\n其实在注解出现之前，它的功能也有其他⼀些⽅法来实现，\r\n\r\n但是那个时候的实现是⽐较随意的，由开发⼈员⾃⾏实现。\r\n\r\n所以注解的出现相当于统⼀了标准。  \r\n\r\n# 0x02 使用\r\n\r\n## 内置标准注解\r\n\r\nJava注解在推出时便内置了三种标准注解：\r\n\r\n`@Override`，说明当前⽅法覆盖⽗类的⽅法实现。\r\n\r\n`@Deprecated`，说明该代码已经废弃了，不建议使⽤，如果使⽤了编译器会发出警告。\r\n\r\n`@SuppressWarnings`，说明关闭当前修饰代码段内的编译器警告信息。\r\n\r\n使⽤⽅法如下：  \r\n\r\n![image-20191115143733722](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/qtzj-01-02.png)\r\n\r\n可以清楚看到标记了\r\n\r\n`@Deprecated`的⽅法会被划线来表示已经过期废弃。\r\n\r\ntest()和test1()两个⽅法同样的实现， test1()标记了`@SuppressWarnings`⽽没有出现⻩⾊警告信息。\r\n\r\n`@Override`重写⽗⽅法，如果父类没有该⽅法就出现错误提示的。 \r\n\r\n# 0x03 自定义 \r\n\r\n## 元注解\r\n\r\n上⾯简单介绍了Java内置的三种标准注解，但是这三种根本不够看的，我们需要更深⼊的了解。\r\n\r\n在这之前需要了解⼀个知识点：**元注解**。\r\n\r\n上⾯有说到描述类的类叫元类 ，\r\n\r\n所以这⾥描述注解的注解⾃然就是元注解:\r\n\r\n下⾯是描述Override注解的注解 ：\r\n\r\n```java\r\n@Target(ElementType.METHOD)\r\n@Retention(RetentionPolicy.SOURCE)\r\npublic @interface Override {\r\n}\r\n```\r\n\r\n  Java提供了四种元注解⽤来帮助自定义新注解：  \r\n\r\n| 分类       | 描述                   |\r\n| ---------- | ---------------------- |\r\n| @Document  | 是否被包含在Doc文档    |\r\n| @Inherited | 是否允许子类继承该注解 |\r\n| @Retention | 声明周期               |\r\n| @Target    | 作用目标               |\r\n\r\n四种元注解主要了解`@Retention`和`@Target`即可。\r\n\r\n### @Retention\r\n\r\n`@Retention`有三个可选值：  \r\n\r\n| 分类                    | 描述                               |\r\n| ----------------------- | ---------------------------------- |\r\n| RetentionPolicy.SOURCE  | 仅编译期可见                       |\r\n| RetentionPolicy.CLASS   | 仅加载class前可见，存在于class文件 |\r\n| RetentionPolicy.RUNTIME | 一直可见，包括运行时               |\r\n\r\n网上关于`RetentionPolicy.SOURCE`的说法有说“在编译阶段丢弃”,\r\n\r\n⼀时让我很费解，既然在编译阶段就丢弃了，\r\n\r\n那`@override`重写标记也是编译阶段丢弃，\r\n\r\n但是它⼜如何实现⽗类没有该⽅法时出现编译错误提示呢？\r\n\r\n所以我觉得对于`RetentionPolicy.SOURCE`的描述还是⽤\r\n\r\n**仅存在于编译阶段更准确⼀些。**\r\n\r\n### @Target\r\n\r\n关于@Target也有多个属性值可选：  \r\n\r\n| 分类                        | 描述                               |\r\n| --------------------------- | ---------------------------------- |\r\n| ElementType.TYPE            | 类、接口（包括注释类型）或枚举声明 |\r\n| ElementType.FIELD           | 字段声明（包括枚举常量）           |\r\n| ElementType.METHOD          | 方法声明                           |\r\n| ElementType.PARAMETER       | 参数声明                           |\r\n| ElementType.CONSTRUCTOR     | 构造方法声明                       |\r\n| ElementType.LOCAL_VARIABLE  | 局部变量声明                       |\r\n| ElementType.PACKAGE         | 包声明                             |\r\n| ElementType.ANNOTATION_TYPE | 用在注解上                         |\r\n| ElementType.TYPE_PARAMETER  | 1.8添加                            |\r\n| ElementType.TYPE_USE        | 1.8添加                            |\r\n\r\n关于元注解的介绍已经说完了，下⾯开始元注解实战  \r\n\r\n## 实战元注解\r\n\r\n先看下需求：\r\n\r\n现在从服务器返回⼀个json串`{age:29,name:Jenson}`,\r\n\r\n我们要设计⼀个注解，通过注解绑定json和我在本地已有实体类，\r\n\r\n代码如下:\r\n\r\n```java\r\n@Target(ElementType.FIELD)\r\n@Retention(RetentionPolicy.RUNTIME)\r\npublic @interface PAnn {\r\n    String name() default \"\";\r\n}\r\n```\r\n\r\n因为是给People属性设置注解\r\n\r\n所以使⽤`@Target(value =ElementType.FIELD)`，\r\n\r\n因为要⽤到反射，所以设置周期为\r\n\r\n`@Retention(RetentionPolicy.RUNTIME)`。\r\n\r\n实体类：  \r\n\r\n```java\r\npublic class People {\r\n    @PAnn(name = \"name\")\r\n    String name;\r\n    @PAnn(name = \"age\")\r\n    int age;\r\n\r\n    public People() {\r\n    }\r\n\r\n    public People(String name, int age) {\r\n        this.name = name;\r\n        this.age = age;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public int getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(int age) {\r\n        this.age = age;\r\n    }\r\n}\r\n\r\n```\r\n\r\n现在我们要设计⼀个JsonParser类，\r\n\r\n通过⽅法(JsonParser()).parse(text, People.class)；\r\n\r\n可以直接解析成功并返回⼀个People对象。\r\n\r\n下⾯看JsonParser.parse的实现：  \r\n\r\n```java\r\npublic class JsonParser {\r\n    public <T> T parse(String text, Class<T> clz) throws InstantiationException, IllegalAccessException, JSONException {\r\n        T t = clz.newInstance();\r\n        Field[] fields = clz.getDeclaredFields();\r\n        JSONObject object = new JSONObject(text);\r\n        for (int i = 0; i < fields.length; i++) {\r\n            Field f = fields[i];\r\n            PAnn pAnn = f.getAnnotation(PAnn.class);\r\n            if (pAnn != null) {\r\n                f.setAccessible(true);\r\n                f.set(t, object.get(pAnn.name()));\r\n            }\r\n        }\r\n        return t;\r\n    }\r\n}\r\n\r\n```\r\n\r\n因为通过注解绑定了People的属性和json的key值。\r\n\r\n所以通过反射拿到注解信息的value，\r\n\r\n通过这个value作为key拿到json的value。\r\n\r\n最后通过set⽅法把json的value赋值给对应的属性。\r\n\r\n这样完成了解析过程。\r\n\r\n最后看看main⽅法实现：  \r\n\r\n```kotlin\r\n        val text = \"\"\"{name:\"jenson\",age=30}\"\"\"\r\n        try {\r\n            val p = (JsonParser()).parse(text, People::class.java)\r\n            Log.e(this.javaClass.simpleName, \"${p.name},${p.age}\")\r\n        } catch (e: Exception) {\r\n            e.printStackTrace()\r\n        }\r\n\r\n```\r\n\r\n打印结果：\r\n\r\n`MainActivity: jenson,30`\r\n\r\n这样看起来好像⽐直接使⽤JSONObject解析麻烦，\r\n\r\n但是其实这样做更灵活，\r\n\r\n而且⼀般服务器交互过程都是若⼲个实体类，\r\n\r\n⽽我们只要实现这⼀次就可以达到通⽤的⽬的。\r\n\r\n⽐如下次解析消息类时只要给消息实体加上注解 ，\r\n\r\n然后如下使⽤就可以完成解析：\r\n\r\n```java\r\nMessage msg = (Message) JsonParser.parse(json, Message.class);\r\n```\r\n\r\n其实看下jackson和gson等使⽤注解的解析应该都是类似的⽅法。\r\n\r\n另外注解在hibernate和各种测试框架都有⼴泛应⽤。\r\n\r\n所以了解注解原理对理解相关注解框架很有帮助  。\r\n\r\n\r\n\r\n# 0x04 原理\r\n\r\n这⾥的原理只介绍注解在classFile中的实现机制。\r\n\r\n上⾯说了四种元注解主要了解@Retention和@Target。\r\n\r\n下⾯分别说说这两种实现  ：\r\n\r\n##   @Retention\r\n\r\n@Retention有三种可选值： SOURCE、 CLASS和RUNTIME。  \r\n\r\n上⾯说了三种值代表的意义，但是这三种值是如何实现的呢？\r\n\r\n### @RetentionPolicy.SOURCE\r\n\r\n只在源码中存在或者说只在编译成字节码⽂件前存在。\r\n\r\n这时疑问就来了，我们运⾏的都是字节码⽂件，也就是在编译后，\r\n\r\n那`@override`⼜怎么达到重写检查的效果的呢？\r\n\r\n因为`@override`注解修饰的是@Retention.SOURCE。\r\n\r\n这个问题也困惑了我很久。\r\n\r\n因为关于重写检查在IDE中都是即时提示的，⼀度怀疑是IDE搞的⻤。\r\n\r\n有这个想法还是很愚蠢的，同时也说明了⾃⼰基本功的Low。\r\n\r\n我们⼀直在讲编译，其实这是⼀个⽐较⼤范围的概念。\r\n\r\n就是说编译这个步骤不是原⼦性的，还能分成很多⼩步骤：\r\n\r\n词法分析、语法分析、语义分析，\r\n\r\n经过⼀些列分析后才执⾏编译(参⻅编译器原理)\r\n\r\n附⼀张编译器步骤图：  \r\n\r\n![image-20191115145727351](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/qtzj-01-03.png)\r\n\r\n现在清楚了之所以IDE在编译前很智能即时的对\r\n\r\n@Retention.SOURCE注解给出提示，\r\n\r\n是因为IDE对我们输⼊进⾏实时词法、语法、语义的分析。  \r\n\r\n\r\n\r\n\r\n\r\n### @RetentionPolicy.CLASS\r\n\r\n\r\n\r\n只能活到字节码⽂件中，\r\n\r\n再往后⾯的操作是@RetentionPolicy.CLASS所不能及的。\r\n\r\n⽣命周期⽐SOURCE⻓⼀点，却⼜不及RUNTIME。\r\n\r\n如果没有设置，那么注解默认是使⽤RetentionPolicy.CLASS的，\r\n\r\n因为编译后它只存在于字节码⽂件中，\r\n\r\n所以⼀般应⽤开发⼈员⽐较少⽤到，\r\n\r\n更多的可能是给底层研发⼈员来使⽤的吧，我是这样认为的。\r\n\r\n现在⼜产⽣⼀个疑问：\r\n\r\n怎么证明`RetentionPolicy.SOURCE`没有存在字节码⽂件中，\r\n\r\n⽽`RetentionPolicy.CLASS`存在于字节码⽂件中呢？\r\n\r\n这个问题答案只能从`classFile`中找到了。\r\n\r\n编译后的字节码⽂件⼀般称为`classFile`。\r\n\r\n在`classFile`中有⼀个名为字段表的结构，\r\n\r\n字段表⼜包含⼀个属性表，属性表其中⼀项是`RuntimeInvisibleAnnotations`\r\n\r\n(参⻅Java虚拟机规范）。\r\n\r\n如果为`RetentionPolicy.CLASS`，那么字节码⽂件中会出现这属性，\r\n\r\n如果为`RetentionPolicy.SOURCE`，则没有这个属性。\r\n\r\n下⾯对⽐下SOURCE和CLASS字节码⽂件结构：  \r\n\r\n`RetentionPolicy.CLASS`如图：\r\n\r\n![image-20191115175742841](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/qtzj-01-04.png)\r\n\r\n`RetentionPolicy.SOURCE`如图：\r\n\r\n![image-20191115175908599](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/qtzj-01-05.png)\r\n\r\n\r\n\r\n\r\n\r\n### @RetentionPolicy.RUNTIME\r\n\r\n这个是⽣命周期最⻓的，既然存在于虚拟机运⾏时环境中，\r\n\r\n那是不是为应⽤开发⼈员提供了功能？不然的话那和CLASS⼀样了。\r\n\r\n最主要的功能就是通过反射能拿到注解相关信息了。\r\n\r\n注意⼀点：既然`RetentionPolicy.RUNTIME`和`RetentionPolicy.CLASS`都存在于字节码⽂件中，\r\n\r\n那么如何区分它们呢？\r\n\r\n上⾯看到设置`RetentionPolicy.CLASS`后属性表中多了个`RuntimeInvisibleAnnotations`属性。\r\n\r\n⽽设置`RetentionPolicy.RUNTIME`后属性表中其实多了个`RuntimeVisibleAnnotations`属性:\r\n\r\n如图:\r\n\r\n![image-20191115180044571](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/qtzj-01-06.png)\r\n\r\n\r\n\r\n很明显意思是`运行时不可见注解`和`运行时可见注解`。\r\n\r\n这样JVM加载classFile时根据这个属性来判断\r\n\r\n是否将注解信息加载到JVM中，\r\n\r\n如果是`RuntimeVisibleAnnotations`则表明我们可以通过反射拿到相关的注解信息。 \r\n\r\n\r\n\r\n## @Target\r\n\r\n`Target`表示注解设置的目标是谁。\r\n\r\n⼀般是设置给类、字段和⽅法。\r\n\r\n但JVM如何保证我们给类设置的注解不会被⽤在字段或⽅法的身上呢？\r\n\r\n在Java虚拟机规范中讲到： \r\n\r\nclassFile包含字段表、方法表和属性表，\r\n\r\n而字段表和⽅法表中⼜都分别有⾃⼰的属性表。\r\n\r\n字段表和⽅法表中各⾃的属性表同样也都拥有`RuntimeVisibleAnnotations`和\r\n`RuntimeInvisibleAnnotations`属性，\r\n\r\n前提是你设置了相关注解信息。这样根据你设置注解位置不同，\r\n\r\n在classFile中不同区域的属性表也会有不同的注解信息显示。\r\n\r\n现在新创建了⼀个test注解，⽤来修饰⽅法：\r\n\r\n  ```java\r\n@Target(ElementType.METHOD)\r\n@Retention(RetentionPolicy.CLASS)\r\npublic @interface MTest {\r\n}\r\n  ```\r\n\r\n  编译后字节码如下图：\r\n\r\n![image-20191115180439961](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/qtzj-01-07.png)\r\n\r\n可以看到修饰字段和修饰⽅法的注解都还在，\r\n\r\n由此可见， JVM根据不同的区域属性表来显示注解信息是成⽴的。  \r\n\r\n\r\n\r\n# 0x05 关于classFile\r\n\r\n上⾯多次提到了classFile，到底classFile长什么样？\r\n\r\n上⾯图中可视化还是⽐较强的，其实真正的classFile是这个样子：\r\n\r\n![image-20191115153303026](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/qtzj-01-08.png)\r\n\r\n打开之后显示的都是⼗六进制内容，初次看难免让⼈头大。\r\n\r\n但是其实这都是按照JVM规范来定义的。  \r\n\r\n简单看两个了解下JVM对classFile⽂件定义的规则：\r\n\r\nJVM规定⾸个4个字节为魔数，\r\n\r\n紧挨着的2各字节为小版本号，\r\n\r\n小版本后⾯紧挨着的2各字节为主版本号。\r\n\r\n## 魔数\r\n\r\n前4个字节为CAFEBABE，⼀般直接理解为咖啡宝⻉。\r\n\r\n这个魔数是固定不变的，\r\n\r\n它的作⽤就是⽤来判断该⽂本是否为可被JVM接受的class⽂件。\r\n\r\n所以如果你直接从后缀把⼀个⽂件改为*.class是不会被JVM加载的。\r\n\r\n## 版本号\r\n\r\n版本号分为minor_version（副版本号） 、 major_version（主版本号）2个部分。\r\n\r\n如果⼀个class⽂件副版本号为v，主版本号为V，那么该class⽂件版本就为V.v\r\n\r\n⼀个JVM实例只能⽀持特定范围内的主版本号（a～i） 和0⾄特定范围内（0～m） 的副版本号。\r\n\r\n假设⼀个class⽂件的格式版本号为v，\r\n\r\n 仅当a.0≤v≤i.m成⽴时， 这个class⽂件才可以被此Java虚拟机⽀持。\r\n\r\n不同版本的Java虚拟机实现⽀持的版本号也不同， \r\n\r\n⾼版本号的Java虚拟机实现可以⽀持低版本号的class⽂件，反之则不成⽴。\r\n\r\nOracle的JDK在1.0.2版本时， ⽀持的class格式版本号范围为45.0～45.3；\r\n\r\nJDK版本在1.1.x时， ⽀持的class格式版本号范围扩展⾄45.0～45.65535；\r\n\r\nJDK版本为1.k时（k≥2） 时， 对应的class⽂件格式版本号的范围为45.0～44+k.0。\r\n\r\n现在看看截图中classFile，副版本号为0000，主版本号为0034。\r\n\r\n当然这是⼗六进制的，转换成⼗进制是0和52。\r\n\r\n所以该classFile版本号是52.0？  \r\n\r\n这怎么和我们的版本号对应上的呢？\r\n\r\n看这句JDK版本为 版本为1.k时（ 时（k≥2）） 时， \r\n\r\n对应的 对应的class⽂件格式版本号的范围为45.0～～44+k.0。\r\n\r\n求k值： 44+k=52—>k=8，所以JDK版本为： 1.8.0\r\n\r\n下⾯是我通过命令⾏获取的JDK版本信息：\r\n\r\njava version \"1.8.0_101\"\r\n\r\nJava(TM) SE Runtime Environment (build 1.8.0_101-b13)\r\n\r\nJava HotSpot(TM) 64-Bit Server VM (build 25.101-b13, mixed mode)  \r\n\r\n# 0x06 总结\r\n\r\nclassFile后⾯还有很多结构，也还有很多有意思的地⽅，\r\n\r\n感兴趣可以参考《JVM规范》。\r\n\r\n很多时候⽤不到的东西并不是没有用，而是我们使⽤的东西还太浅。"
  },
  {
    "title": "Groovy闭包委托",
    "created_time": "2019-12-22 09:00:27",
    "body": "# 0x00 前言\r\n\r\nGroovy中闭包是一个重要的知识点。\r\n\r\nGradle中也大量使用闭包功能，\r\n\r\n所以了解闭包是一个绕不过去的坎。\r\n\r\n# 0x01 闭包介绍\r\n\r\n什么是闭包？\r\n\r\n**直观的说，闭包就是一个代码块。**\r\n\r\n大括号括起来的代码块，但不是Java中的代码块。\r\n\r\n这是一个闭包：\r\n\r\n```groovy\r\ndef f1 = { println \"this is closure\" }\r\n```\r\n\r\n这也是一个闭包：\r\n\r\n```groovy\r\ndef f2 = { x -> println \"x=$x\" }\r\n```\r\n\r\n这还是一个闭包：\r\n\r\n```groovy\r\nclass ClosureTest {\r\n    def play(closure) {\r\n        closure()\r\n    }\r\n}\r\n\r\nnew ClosureTest().play() {\/\/闭包\r\n    println \"play invoked\"\r\n}\r\n```\r\n\r\n有没有发现这货和Lambda表达式还真像。\r\n\r\n像就对了，因为闭包源于Lambda，但又高于Lambda。\r\n\r\n通过上面例子可以发现，\r\n\r\n**闭包就像一个寄生虫，它须要依附于变量或方法，不能作为代码块单独存在。**\r\n\r\n上面方法依附可以提取出为变量依附：\r\n\r\n```groovy\r\ndef playClosure = { println \"play invoked\" }\r\nnew ClosureTest().play(playClosure)\r\n```\r\n\r\n调用闭包时就像调用方法一样，加上括号和参数就行了。\r\n\r\n刚才说闭包高于Lambda，高在哪里了？\r\n\r\n高在了闭包支持方法分发。\r\n\r\n# 0x02 闭包委托\r\n\r\n上面说的方法分发，也就是本节的委托。\r\n\r\n闭包内有三个属性：`thisObject`，`owner`，`delegate`。\r\n\r\n闭包内我们难免会调用其他方法，\r\n\r\n那么闭包外部不同地方有了相同方法时，闭包怎么知道该调用哪些方法呢？\r\n\r\n这三个属性就用于确定由哪个对象来处理闭包内的方法。\r\n\r\n**`thisObject`：该属性指向的是定义该闭包所在的类或对象**\r\n\r\n**`owner`：该属性和`thisObject`相似，但是如果闭包嵌套闭包时，内部闭包`owner`指向外部闭包**\r\n\r\n**`delegate`该属性默认初始化为`owner`的值。就是说它俩是一样的。**\r\n\r\n**但是我们可以给`delegate`从新赋值来更改委托。**\r\n\r\n下面看下实操：\r\n\r\n```groovy\r\ndef testClouser = {\r\n    println \"testClouser thisObject:\" + thisObject\r\n    println \"testClouser owner:\" + owner\r\n    println \"testClouser delegate:\" + delegate\r\n}\r\ntestClouser.call()\r\n\/\/testClouser thisObject:t12@57cf54e1\r\n\/\/testClouser owner:t12@57cf54e1\r\n\/\/testClouser delegate:t12@57cf54e1\r\n```\r\n\r\n通过打印可以看到这三个属性值都是一个t12的实例对象。\r\n\r\n这里的t12是我创建的t12.groovy文件。\r\n\r\n编译后该文件会对应一个t12.class。\r\n\r\n这个闭包直接定义在文件里，所以三个属性值默认都是定义该闭包类t12的对象。\r\n\r\n再看一个例子：\r\n\r\n```groovy\r\nclass Test1 {\r\n    def static closureTest = {\r\n        println \"closureTest this:\" + thisObject\r\n        println \"closureTest owner:\" + owner\r\n        println \"closureTest delegate:\" + delegate\r\n    }\r\n}\r\n\r\nTest1.closureTest()\r\n\/\/closureTest this:class Test1\r\n\/\/closureTest owner:class Test1\r\n\/\/closureTest delegate:class Test1\r\n```\r\n\r\n这次闭包定义在了类Test1内部，而且声明了static。\r\n\r\n打印出来的时候三个属性值都是指向定义该类Test1的，\r\n\r\n再看一个例子：         \r\n\r\n```groovy\r\nclass Test1 {\r\n    def outerClosure = {\r\n        println \"outerClosure thisObject:\" + thisObject\r\n        println \"outerClosure owner:\" + owner\r\n        println \"outerClosure delegate:\" + delegate\r\n        def innerClosure = {\r\n            println \"innerClosure thisObject:\" + thisObject\r\n            println \"innerClosure owner:\" + owner\r\n            println \"innerClosure delegate:\" + delegate\r\n        }\r\n        innerClosure()\r\n    }\r\n}\r\n\r\nnew Test1().outerClosure()\r\n\/\/outerClosure thisObject:Test1@32502377\r\n\/\/outerClosure owner:Test1@32502377\r\n\/\/outerClosure delegate:Test1@32502377\r\n\/\/innerClosure thisObject:Test1@32502377\r\n\/\/innerClosure owner:Test1$_closure1@36916eb0\r\n\/\/innerClosure delegate:Test1$_closure1@36916eb0\r\n```\r\n\r\n通过打印可以看到外部闭包三个属性值都执行了Test1实例。\r\n\r\n而内部闭包的`thisObject`指向了定义该闭包所在类Test1实例。\r\n\r\n`owner`和`delegate`指向了外部闭包。\r\n\r\n通过三个例子证明了上面三个属性含义的准确性。\r\n\r\n\r\n\r\n# 0x03 闭包委托模式\r\n\r\n上面介绍了闭包委托三个属性含义，\r\n\r\n但是我们仍然不知道闭包内方法调用具体如何分发的。\r\n\r\n**默认情况下闭包委托顺序为`thisObject`->`owner`->`delegate`。**\r\n\r\n就是说闭包内方法调用时，默认先从`thisObject`指向类\/对象中寻找，如果找到了则调用。\r\n\r\n如果没有找到，路由到`owner`，由`owner`指向类\/对象中寻找，如果找到了则调用。\r\n\r\n如果没有找到，路由到`delegate`，由其指向类\/对象寻址，如果找到了则调用，否则抛出异常。\r\n\r\n实操一下：\r\n\r\n```groovy\r\nclass Example {\r\n\r\n    def str1 = \"hello\"\r\n    def outerClosure = {\r\n        def str2 = \"groovy\"\r\n        def innerClosure = {\r\n            println str1\r\n            println str2\r\n        }\r\n        innerClosure()\r\n    }\r\n\r\n    def foo(closure) {\r\n        Closure closur = closure\r\n        closur.delegate = new Handler()\r\n        closur.resolveStrategy = Closure.OWNER_FIRST\r\n        closur()\r\n    }\r\n}\r\n\r\nnew Example().outerClosure()\r\n\/\/hello\r\n\/\/groovy\r\n```\r\n\r\n打印结果不用想就知道是什么了。\r\n\r\n可以看到str1变量定义在了类内部，\r\n\r\nstr2变量定义在了外部闭包中，\r\n\r\n当在内部闭包打印两个变量时，\r\n\r\n先由`thisObject`指向当前类Example的对象处理，找打了str1。\r\n\r\n但是`thisObject`没有找到str2，所以交由`owner`处理。\r\n\r\n`owner`指向外部闭包，而str2刚好定义在外部闭包，找到并打印处理。\r\n\r\n到这里一切都还说得通，但是如何证明`delegate`呢？\r\n\r\n代码改进一下：\r\n\r\n```groovy\r\nclass Handler {\r\n    def str2 = \"Handler\"\r\n}\r\n\r\nclass Example {\r\n    def str1 = \"hello\"\r\n    def outerClosure = {\r\n        def innerClosure = {\r\n            delegate = new Handler()\r\n            println str1\r\n            println str2\r\n        }\r\n        innerClosure()\r\n    }\r\n}\r\nnew Example().outerClosure()\r\n\/\/hello\r\n\/\/Handler\r\n```\r\n\r\n这里我把str2从外部闭包中去掉，\r\n\r\n新建Handler类，里面定义了str2。\r\n\r\n常理来说在一个类闭包中直接使用另一个类的变量是怎么都说不过去的。\r\n\r\n所以我在内部闭包中加了一句`delegate = new Handler()`。\r\n\r\n回想下上面对`delegate`属性解释。\r\n\r\n默认`delegate`和`owner`是一样的值，但是我现在给从新赋值了。\r\n\r\n`delegate`指向了Handler。\r\n\r\n`thisObject`和`owner`处理不了的，由`delegate`指向的Handler来处理。\r\n\r\n所以打印了 hello Handler。\r\n\r\n上面的顺序一直按默认顺序委托的。\r\n\r\n有没有办法改变委托顺序呢？\r\n\r\n**Groovy已经为我们提供了改变委托策略：**\r\n\r\n**`Closure.OWNER_FIRST` 默认策略。**\r\n\r\n**如果属性或方法存在`owner`指向类\/对象中，那么由`owner`处理，如果不在，交由`delegate`处理**\r\n\r\n**`Closure.DELEGATE_FIRST` 颠倒了默认策略：优先交由`delegate` ，然后才是`owner`**\r\n\r\n**`Closure.OWNER_ONLY` 只交给`owner`处理，`delegate` 会被忽略**\r\n\r\n**`Closure.DELEGATE_ONLY` 只交给`delegate`处理，`owner`会被忽略**\r\n\r\n**`Closure.TO_SELF` 只交给当前闭包自己处理，不是`owner`和`delegate`，**\r\n\r\n**可以被用于当开发人员需要使用先进的元数据编程技术和希望实现一个自定义的选择策略时。**\r\n\r\n**当我们实现了自己的 Closure 子类时，他才是有意义的。**\r\n\r\n\r\n\r\n源码中只提供了这几种策略模式。\r\n\r\n而网上很多资源也都是根据这几种模式做了简单介绍。\r\n\r\n但是看完这些介绍我反而更疑惑了。\r\n\r\n1、为什么只有`Closure.OWNER_FIRST`和`Closure.DELEGATE_FIRST`，\r\n\r\n却没有`Closure.THISOBJECT_FIRST`？\r\n\r\n2、`Closure.OWNER_ONLY` 只交给`owner`处理，`delegate` 会被忽略，那么`thisObject`呢？\r\n\r\n\r\n\r\n实践出真知，我们先试试这两个only模式。\r\n\r\n首先看看`Closure.DELEGATE_ONLY`：\r\n\r\n```groovy\r\nclass Handler {\r\n    def str2 = \"Handler\"\r\n}\r\n\r\nclass Example {\r\n    def str1 = \"hello\"\r\n    def outerClosure = {\r\n        def innerClosure = {\r\n            delegate = new Handler()\r\n            resolveStrategy = DELEGATE_ONLY\r\n            println str1\r\n            println str2\r\n        }\r\n        innerClosure()\r\n    }\r\n}\r\n\r\nnew Example().outerClosure()\r\n\/\/Caught: groovy.lang.MissingPropertyException: No such property: str1 for class: Handler\r\n```\r\n\r\n上面代码并不能执行成功，\r\n\r\n异常显示str1在Handler类中找不到。\r\n\r\ninnerClosure中`thisObject`指向的是Example类对象。\r\n\r\n如果`thisObject`执行的话，那么是可以找到str1的。\r\n\r\n所以可以确定\r\n\r\n**`Closure.DELEGATE_ONLY` 将只执行`delegate`，`thisObject`和`owner`将不被执行。**\r\n\r\n再来看看`Closure.OWNER_ONLY`：\r\n\r\n```groovy\r\nclass Handler {\r\n    def str2 = \"Handler\"\r\n}\r\n\r\nclass Example {\r\n    def str1 = \"hello\"\r\n    def outerClosure = {\r\n        def innerClosure = {\r\n            delegate = new Handler()\r\n            resolveStrategy = OWNER_ONLY\r\n            println str1\r\n            println str2\r\n        }\r\n        innerClosure()\r\n    }\r\n}\r\nnew Example().outerClosure()\r\n\/\/hello\r\n\/\/Caught: groovy.lang.MissingPropertyException: No such property: str2 for class: Example\r\n```\r\n\r\n上面代码也不能执行成功。\r\n\r\n异常显示从Example类中找不到str2，但是找到了str1。\r\n\r\n上面我们了解了内部闭包的`owner`指向外部闭包。\r\n\r\n但是外部闭包并没有str1，怎么会成功打印呢？\r\n\r\n最初我也是被这块困扰的，这有点类似`类的双亲委派机制`。\r\n\r\n所以我们别忘了，`owner`指向了外部闭包，所以str1交由外部闭包来处理。\r\n\r\n外部闭包路由属性和方法时，\r\n\r\n默认又按`thisObject`->`owner`->`delegate`顺序来查找的。\r\n\r\n而外部闭包的`thisObject`指向Example类，所以它最终是能找到str1的。\r\n\r\n轮到str2时，内部闭包和外部闭包都找不到，所以抛出异常。\r\n\r\n目前可以确定\r\n\r\n**当嵌套闭包时，内部闭包有机会让`owner`执行时(包含`Closure.OWNER_ONLY`)，**\r\n\r\n**那么它就会路由到它的外部闭包。**\r\n\r\n**如此层层外翻，直到路由到最外层闭包，**\r\n\r\n**如果还是不能找到则抛出异常，任意一处路由到了指定方法\/属性，则终止。**\r\n\r\n我们再修改下代码，来验证下我的猜想：\r\n\r\n```groovy\r\nclass Handler {\r\n    def str2 = \"Handler\"\r\n}\r\n\r\nclass Example {\r\n    def str1 = \"hello\"\r\n    def outerClosure = {\r\n        delegate = new Handler()\r\n        def innerClosure = {\r\n            resolveStrategy = OWNER_ONLY\r\n            println str1\r\n            println str2\r\n        }\r\n        innerClosure()\r\n    }\r\n}\r\nnew Example().outerClosure()\r\n\/\/hello\r\n\/\/Handler\r\n```\r\n\r\n很简单的修改，\r\n\r\n只把内部闭包的`delegate`修改移动到了外部闭包。\r\n\r\n因为内部闭包设置了`OWNER_ONLY`策略，导致设置了`delegate`也无用。\r\n\r\n现在移动到外部闭包。\r\n\r\n按照上面的想法，\r\n\r\n外部闭包会默认执行`thisObject`->`owner`->`delegate`顺序来查找str2。\r\n\r\n当执行到`delegate`时交给了Handler来处理找到了str2。\r\n\r\n所以打印了Handler，而没有抛出异常，这也证实了上面的猜想。\r\n\r\n\r\n\r\n这几次实践解答了上面问题2的疑惑。\r\n\r\n**但是问题1的为什么没有`Closure.THISOBJECT_FIRST`模式呢？**\r\n\r\n**关于这个问题，**\r\n\r\n**我的想法是`Closure.OWNER_FIRST`间接实现了`Closure.THISOBJECT_FIRST`的功能。**\r\n\r\n**当只有一层闭包时，`thisObject`和`owner`指向是一样的。**\r\n\r\n**当有嵌套闭包时，`owner`指向包裹它的外层闭包，**\r\n\r\n**层层外翻，最终也会指向到`thisObject`所指向的类\/对象。**\r\n\r\n**同理`Closure.OWNER_ONLY`也间接实现了`Closure_THISOBJECT_ONLY`的功能。**\r\n\r\n**可能出于这个原因，没有设置`Closure_THISOBJECT_ONLY`和`Closure.THISOBJECT_FIRST`。**"
  }
]