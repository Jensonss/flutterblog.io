## 前言

下面是对《Android移动性能实战》一书的知识点总结：常见App场景的性能优化知识点，


出乎意料的是这本书是由测试部门人员写出来的，书中也有提到一些问题点开发人员无从下手，是由测试人员发现问题所在，不得不感慨有一种测试叫别人家的测试。

## IO性能优化



### 缓存重复读取的系统文件

> 每次打开、 关闭或者读/写文件， 操作系统都需要从用户态到内核态的切
> 换， 这种状态的切换本身是很消耗性能的， 所以为了提高文件的读/写效率， 就需要尽
> 量减少用户态和内核态的切换。 使用缓存可以避免重复读/写， 对于需要多次访问的数
> 据， 在第一次取出数据时， 将数据放到缓存中， 下次再访问这些数据时， 就可以从缓
> 存中取出来 

读取系统文件诸如*/proc/cpuinfo*时，使用变量进行信息缓存，防止每次需要该信息时都进行文件读取，须知每次读取都是一次IO操作

### SharePreference优化

> Android系统中使用SharedPreferences文件来保存数据非常方便， 在需
> 要保存数据的地方调用commit就可以， 但是很多开发同学可能并不知道每调用一次
> commit（） ， 就会对应一次文件的打开和关闭， 从而造成因commit（） 方法的随意调
> 用而导致文件的重复打开和关闭 
>
> 使用apply替代commit，apply是异步操作，commit是同步操作。



### 严禁主线程中进行IO操作

> 随机读/写是相对顺序读/写而言的， 在读取或者写入的时候
> 随机地产生offset。 但为什么随机读/写会如此之慢呢？
> 1． 随机读会失去预读（read-ahead） 的优化效果。
> 2． 随机写相对于顺序写除了产生大量的失效页面之外， 更重要的是增加了触
> 发“写入放大”效应的概率。
> 那么“写入放大”又是什么呢？ 下面我们来介绍第二个概念： “写入放大”效应。
> “写入放大”效应
> 当数据第一次写入时， 由于所有的颗粒都为已擦除状态， 所以数据能够以页为最
> 小单位直接写入进去。 当有新的数据写入需要替换旧的数据时， 主控制器将把新的数
> 据写入到另外的空白闪存空间上（已擦除状态） ， 然后更新逻辑LBA地址来指向到新
> 的物理FTL地址。 此时， 旧的地址内容就变成了无效的数据， 但主控制器并没执行擦
> 除操作而是会标记对应的“页”为无效。 当磁盘需要在上述无效区域进行再次写入的
> 话， 为了得到空闲空间， 闪存必须先复制该“块”中所有的有效“页”到新的“块”里， 并
> 擦除旧“块”后， 才能写入。 （进一步学习， 可参见：
> http： //bbs.pceva.com.cn/forum.php？ mod=viewthread＆action=printable＆tid=8277。 ）
> 比如， 现在写入一个4KB的数据， 最坏的情况就是， 一个块里已经没有干净空间
> 了， 但是恰好有一个“页”的无效数据可以擦除， 所以主控就把所有的数据读出来， 擦
> 除块， 再加上这个4KB新数据写回去。 回顾整个过程， 其实只想写4KB的数据， 结果
> 造成了整个块（512KB） 的写入操作。 同时带来了原本只需要简单地写4KB的操作变
> 成了“闪存读取（512KB） -＞缓存改（4KB） -＞闪存擦除（512KB） -＞闪存写入
> （512KB） ”， 这造成了延迟大大增加， 速度慢是自然的。 这就是所谓的“写入放
> 大”（Write Amplification） 问题。

### 合理使用ByteArrayOutputStream 

> 进行对象缓存时会用到ObjectOutputStream，在序列化磁盘时， 会把内存中的每
> 个对象保存到磁盘， 在保存对象的时候， 每个数据成员会带来一次I/O操作， 意味着多少个对象就带来多少次IO操作，同样也带来严重的性能问题。可以多套一层，在ObjectOutputStream上面再封装一个输出流ByteArrayOutputStream，先将对象序列化后的信息写到缓存区中， 然后再一次性地写到磁盘上 。



### 解压文件优化

> 如果ZIP文件已保存在磁盘中， 且解压ZIP中的所有文件， 建议用ZipFile， 效率较
> ZipInputStream提升15％~27％。
> 仅解压ZIP中间的某些文件， 建议用ZipFile。
> 如果ZIP没有在磁盘上或者顺序解压一小部分文件， 又或ZIP文件目录遭到损坏，
> 建议用ZipInputStream。 

### 表优化

> 首次安装的表为空时， 不要去做无谓的查询操作。
> 对于覆盖安装， 在表已经存在的情况下， 可以使用INSERT OR REPLACE语
> 句来完成插入。 



### 数据库重复打开优化

> 因为打开数据库比较耗时， 如app_plugin_download.db的两次耗时分别为80ms和
> 120ms。 每次打开数据库， 同时会有一些I/O操作。 getWriteableDatabase的注释也明确
> 说明该方法比较耗时， 不能在主线程进行。 
>
> 看一下SQLiteDatabase的源码， getWriteableDatabase（） 方法的注释说明： 一旦
> 打开数据库， 该连接就会被缓存， 以供下次使用， 只有当真正不需要时， 调用close关
> 闭即可 。
>
> 数据库在打开后， 先不要关闭， 在应用程序退出时再关闭。 

### AUTOINCREMENT 不要随便用

- 问题

> 一条插入语句耗时平均在
> 60ms+， SQL语句为： INSERT INTO events（timestamp， content， status，
> send_count） VALUES （1445916309639， test， 1， 100） ，
> 可以看到这条插入语句非常简单， 仅仅是插入3个整形和一个简单的字符串。 而
> 一般的插入操作最多也就十几ms。 

- 解释

> AUTOINCREMENT其实就是“自增长”， 这个关键字只会出现在INTEGER
> PRIMARY KEY后面， 而INTEGER PRIMARY KEY就是“主键”， 下面先来了解一下主
> 键。
> SQLite表的每行都有一个行号， 行号用64位带有符号的整型数据表示。 SQLite支
> 持使用默认的列名ROWID、 _ROWID_和OID来访问行号。 同时， 如果表里某一列指
> 定为INTEGER PRIMARY KEY类型， 那么这一列和ROWID是等价的。 也就是说， 如
> 果你指定某一列为主键， 访问该列其实就是访问行号。

- 行号是如何生成的？

  对于刚创建的表来说， 行号默认是从1开始的， 如果在插入数据时明确指定行
  号， 则会将数据插入对应的行， 如果没有指定行号， 则SQLite会选择比当前已用行号
  大1的行来进行插入。 如果当前已用行号已达到最大值， 数据库引擎会尝试寻找当前
  表里面没有使用的行号， 如果没有找到可用的行号， 就会出现SQLITE_FULL错误。
  小结： 如果你没有删除过数据， 并且没有指定最大值的行号， 行号选择算法可以
  保证行号是递增且唯一的。 但是如果你有删除数据或者使用了最大行号， 之前删除的
  行号可能被复用， 并不能保证插入数据的行号是严格递增的。

- 主键加了AUTOINCREMENT， 会有什么变化？
  上面提到， AUTOINCREMENT只能用来修饰主键， 主键在被“自增长”修饰之
  后， 会略微有些区别。
  （1） 数据库引擎选择的行号会比所有之前用过的行号都大， 即使数据被删除，
  行号也不会被复用， 可以保证行号严格单调递增。
  （2） 如果行号的最大值被用过， 那么在插入新数据时， 会报SQLITE_FULL错
  误。

- 小结：

  AUTOINCREMENT的作用是保证主键是严格单调递增的。
    AUTOINCREMENT实现原理
    SQLite创建一个叫sqlite_sequence的内部表来记录该表使用的最大的行号。 如果指
    定使用AUTOINCREMENT来创建表， 则sqlite_sequence也随之创建。 UPDATE、
    INSERT和DELETE语句可能会修改sqlite_sequence的内容。 因为维护sqlite_sequence表
    带来的额外开销将会导致INSERT的效率降低 。所以除非必要，平时大多情况下不需要使用AUTOINCREMENT。

### Bitmap解码

> 4.4之前的系统，decodeFile源码里面读磁盘用的是
> BufferedInputStream， 并且Buffer大小为DECODE_BUFFER_SIZE = 16×1024， 这也就
> 是为什么在4.3系统decode大小为12KB的图片， 只需要读一次磁盘就可以的原因 。
>
> 4.4之后的系统，decodeFile里面去掉了缓冲区
>
> 解码Bitmap不要使用decodeFile， 因为在Android 4.4以上系统效率不高。
> 解码Bitmap使用decodeStream， 同时传入的文件流为BufferedInputStream。
> decodeResource同样存在性能问题， 请用decodeResourceStream。 



## 内存优化

### 内部类持有外部类Activity引用

> 内部类有个特殊成员`this$0`为外部类的引用。通过它可以访问外部类变量，
>
> 但是如果内部类泄漏，由于其持有外部类引用，同时就导致了外部类Activity泄漏，进而造成view泄漏。
>
> 解决方案为：在Activity关闭时，解除内部类和外部类的引用。
>
> 1.将内部类定义为static
>
> 2.用static的变量引用匿名内部类的实例或将匿名内部类的实例化操作放到外部类的静态方法中

### WifiManager 造成的泄漏

> 把getSystemService（Context.WIFI_SERVICE） ； 修改为以下代码：
> getApplicationContext（） .getSystemService（Context.WIFI_SERVICE） ；
> 同样的情况也发生在AudioManager等服务上， 比如要判断当前是耳机模式或者外
> 放模式， 一样会产生这样的问题， 所以都应该使用
> getApplicationContext（） .getSystemService来获取服务实例。 

### 避免webview泄漏使用独立进程

> 用独立进程来解决内存问题， 独立进程在Android框架下非常简单， 在官网App
> manifest的＜activity＞介绍中， 讲解了有关android： process属性的设置， 一旦设置了
> 这个属性， 这个Activity的启动就会被投射到一个你所命名的进程当中， 最后在
> Activity的onDestory函数中， 退出进程， 这样即可基本上终结此类泄漏。 

- 网络大牛反射解决内存泄漏问题

> “反射”得到WebView的内核， 然后再通
> 过“反射”从内核的xxx变量中得到窗口管理器回调配置， 最后把一个空的窗口管理者赋
> 给它， 来替代原先的那个。 这样就打断了底层的引用联调， 成功地解决了WebView内
> 核造成的上层Activity泄漏。 但重点是作者最后补充了一句： 这并不能适用于所有的
> Android系统， 因为它们的WebView内核字段差异很大。
> 推荐将“反射”作为一种“补丁”来解决系统问题， 并且鼓励使用。 但是将它用在内
> 存问题的解决上， 笔者还是建议大家持谨慎态度， 因为这并不是解决内存问题的正确
> 道路， 正确理解组件本身， 正确调用接口， 给出正确参数， 采用正确调用顺序， 这才
> 是真正解决内存的根本问题所在 
>
>

### Timer及时停止避免泄漏

```kotlin
if(timer !=null){
    timer.cancle();
    timer=null;
}
```



### 延时器postDelay及时remove

> 开发人员在调用postDelayed方法时， 塞入了延时回调内类Runable， 但在Activity销毁的时候， 
>
> 并没有调用removeCallbacks移除掉这个内类， 以至于导致泄漏。
> 注意： 延时器的泄漏特征在于其根部通常是一个以主线程为GC ROOT的
> MessageQueue， 这也是它与定时器泄漏最显著的区别。 



### Bitmap解码配置RGB_565

> 对于没有给定BitmapFactory.Options参数而直接调用图片解码函数的情况，
> Android系统会默认使用ARGB_8888。 通过官方文档， 可以知道RGB_565每个像素占
> 用的内存只有ARGB_8888的一半（RGB_565每个像素使用2字节， ARGB_8888每个像
> 素使用4字节）  。对于非高清(如列表展示)图来说使用RGB_565即可。



>
>
> 缩略图， 用户感官上认为它就不应该是一张高清图片， 如果需要详细查看， 可以
> 通过“点入”操作。 没有透明效果， 因为RGB_565不解码透明通道内容， 因此会造成透
> 明效果丢失（但是同样依赖于透明通道的圆角图片效果， 倒可以使用RBG_565配合
> BitmapShader实现） 。 



### Bitmap大图获取使用inSampleSize 



### 图片资源放到适合的drawable目录

Android在加载这些图片前， 会先一步得到当前设备的显示密度， 然后到相匹配的
drawable目录去寻找图片资源。 但是如果开发人员并没有按照官方推荐的方式， 每个
res/drawable目录下都放置图片的话， Android会按照当前设备显示密度就“近”获取图片
资源， 然后将其所在的目录所代表的密度与当前设备密度相比， 以这个比例来缩放图
片， 以得到一张“合适”的图片（有对应图片就不用缩放， 这也是上面官网说“好”性能
的原因） 。
比如， 一张备显图片只放置在mdpi目录， 而当前的设备显示器为480dpi的超超高
密屏， 这时Android就会按照3倍大小缩放这张图片， 将它加载入内存。
这样是非常危险的， 如果有一张800×480图片放置在ldpi目录， 展示在480dpi的超
超高密屏上时， 会在内存中产生一张3200×1920的巨大图片。 

> 抓不准该放到那个目录的图片， 就尽量问设计人员要高品质图片然后往高密度目
> 录下放， 这样在低密屏上“放大倍数”是小于1的， 在保证画质的前提下， 内存也是可控
> 的。
> 拿不准的图片， 使用Drawable.createFromStream替换getResources（） .getDrawable
> 来加载， 这样就可以绕过Android以上的这套默认适配法则 





### 内存复用











## 网络优化



### webview缓存的坑

android的WebVeiw的缓存策略会在/data/data/应用package下生成database与cache
两个文件夹， database可以存放多个数据库文件， 数据库中保存的是请求的url 。

> HTTP Request的Cache-Control可以
> 是no-cache、 no-store、 max-age、 max-stale、 min-fresh、 no-transform、 only-if-cached以
> 及cache-extension， HTTP Response的Cache-Control为public、 private、 no-cache、 notransform、 must-revalidate、 proxy-revalidate、 max-age、 s-m axage以及cacheextension。 这些Cache策略进行部分说明如下。
> public： 响应可以在任何缓存区缓存。
> private： 对单个用户的整个或部分响应消息， 不能在共享缓存区缓存。
> no-cache： 请求或者响应不使用缓存。
> no-store： 如果在请求中使用， 则该请求和对应的响应都不使用缓存， 如果在响应
> 中使用， 则该响应和其对应的请求都不使用cache。
> max-age： 资源在客户端的最大生命周期。
> max-stale： 客户端可以接收生存期大于当前时间的响应。 

> 在完成了缓存请求资源后， 还需要在客户端程序发送HTTP请求时指定该请求的
> 响应资源可以从缓存中获取， 否则， 即使缓存中有对应的响应资源， 客户端也不会使
> 用， 会重新通过网络下载一遍， 这涉及客户端发送HTTP请求时的缓存模式， 客户端
> 可以指定5种缓存模式， 分别如下。
> LOAD_CACHE_ONLY： 不使用网络， 只读取本地缓存数据。
> LOAD_DEFAULT： 根据Cache-Control决定是否从网络上取数据。
> LOAD_CACHE_NORMAL： API level17中已经废弃， 从API level 11开始作用同
> LOAD_DEFAULT模式。
> LOAD_NO_CACHE： 不使用缓存， 只从网络获取数据。
> LOAD_CACHE_ELSE_NETWORK： 只要本地有， 无论是否过期， 或者NOCACHE， 都使用缓存中的数据。 

### 开启压缩

> 对请求的可压缩数据开启压缩，以减少流量消耗和等待时间



### 传送数据优化

> 这里优化也包括服务端滑动窗口大小。
>
> 服务器的RcvBuffer决定着滑动窗口的大小， 因此可以增大RcvBuffer来增加滑动窗口的大小 



## CPU优化

在经典的性能问题中， 一般我们会说两种问题： 一种是I/O密集型问题， 另外一种
就是CPU密集型的问题。 I/O的问题在前面的磁盘、 网络部分已经介绍过了， 剩下的就
是CPU了。 CPU问题无非分为以下三类。
CPU资源冗余使用
关于这个问题， 可以是算法太糙， 明明可以遍历一次的却遍历两次， 主要出现在
查找、 排序、 删除等环节； 也可以是没有cache， 明明解码过一次的图片还重复解码。
还有， 明明使用int就足够， 偏偏要用long， 导致CPU的运算压力多出4倍。
CPU资源争抢
资源争抢也有几种经典情况。
（1） 抢主线程的CPU资源。 这是最常见的问题， 关键是主线程起码在Android 6.0
版之前， 没有renderthread的时候， 其繁忙程度就决定了是否会引发用户的卡顿问题。
最经典的例子就是主线程的Handler优化。
（2） 抢音视频的CPU资源。 跟主线程的情况不同， 音视频编解码本身就消耗了
大量的CPU资源， 同时音视频编解码对于解码的速度是有硬要求的， 达不到就会有产
生播放流畅度的问题， 试想下， 听歌的时候总卡， 是不是很难受。 所以最常见的一种
情况就是CPU满负载， 除了在耗电上有非常恶劣的影响外， 还会让音视频没有足够的
资源保持流畅播放。 怎么办？ 通过两点挪走压垮骆驼的稻草： 第一、 排除非核心业务
的消耗， 如下面说的QQ音乐的案例， 还有贴耳检测的频率控制； 第二、 优化自身的
性能消耗， 把CPU负载转化为GPU负载， 最经典的就是利用renderscript来处理视频中
的影像信息。
（3） 大家平等， 相互抢。 前面两点都有主次之分， 强弱之别， 但是如果是QQ相
册， 我开了20个线程做图片解码， 那就是相互抢， 我们曾经就遇到过这样的问题， 效
果就是导致图片的显示速度非常慢。 这简直就是三个和尚没水喝的典型案例。 因此按
照核心数、 控制线程数还是很有道理的。
CPU资源利用率低
CPU就是速度与负载的博弈， 用得多会耗电、 会卡顿， 用得少也会有问题， 像启
动、 界面切换、 音视频编解码这些场景， 为了保证其速度， 不好好利用CPU， 真对不
起核心数的不断飙升。 而导致无法充分利用CPU的因素， 除了前面说的磁盘和网络I/O
外， 还有锁操作、 sleep等。 其中锁的优化， 一般在锁的范围上， 主要是尽可能地缩减
范围 

通过查看`“cat/sys/devices/system/cpu/cpu0/cpufreq/scaling_cur_freq” `来判断CPU是否降频





## 电量优化

使用`adb shell dumpsys power`命令， 查看系统中存在的WakeLock信息 

> 每台手机都会有power_profile.xml。 PowerProfile， 在手机厂家出ROM的时候， Android
> 官方建议厂商通过下面介绍的PowerMonitor之类的工具来测试每个硬件模块的耗电情
> 况， 并配置好power_profile.xml文件。 这里必须强调一下， PowerProfile不像某些瞎扯
> 的网文所说， 改变它能改变耗电， 因为它仅仅是一个为了让Android系统能通过硬件调
> 用频率和强度来计算耗电的配置而已。 虽然很多厂商提供的这个文件基本乱配， 但是
> 我们从文件的内容还是可以知道Android官方认为耗电的硬件都有什么？ 如图5-1所
> 示， 我们从文件中可以提取出几个考量耗电的硬件， 包括CPU、 Wi-Fi、 Radio（数据
> 网络） 、 Sensor（感应器） 、 BlueTooth（蓝牙） 、 Screen（屏幕） 、 GPS， 还有其实
> 不属于硬件模块的视频和音频的耗电。 



### 避免无谓的wifiscan

> 获取了几台手机的PowerProfile， 发现WIFISCAN设置在220mA左右， 而
> SCREENFULL的设置也就是160~300mA， 可见Wi-Fi扫描是一个可以比拟屏幕耗电的
> 过程， 因此在理论上用户黑屏状态下， 完全不应该进行Wi-Fi扫描。 

### 避免无谓的RTC_WAKEU 

> （1）使用AlarmManager时一定要考虑到多种情况， 尤其是要充分考虑网络变
> 动、 用户登录状态改变等场景。
> （2） 如果有多个功能需要通过AlarmManager实现时， 最好能够将多个功能合并
> 到一个AlarmManager的广播接收函数中实现（在函数中调用多个功能） 。 尤其是当这
> 几个功能的唤醒周期、 异常处理逻辑比较相近时， 一定要放在一起实现， 后续维护也
> 会更加方便。 

### 避免无谓的动画效果

> 对于动画效果比较炫的界面， 灭屏后CPU占用率仍然很高， 最可能的原因就是动
> 画没有及时释放。
> 监听灭屏以及亮屏的广播， 在灭屏的时候停止动画绘制； 亮屏的时
> 候， 恢复动画的绘制 

### 避免间接调用wakeLock没有及时释放

> 对于使用Media框架音视频功能时，虽然在我们的代码中没有手动调用wakeLock，但是框架会间接调用。
>
> 所以在退入后台时，对于暂未使用的音视频功能需要手动释放资源。



### 避免wakeLock计数的坑

> 有时候调用了wakeLock.release()；方法并没有释放wakeLock。
>
> 这是因为WakeLock有一个函数setReferenceCounted， 用来设置WakeLock的计数机制， 官方默认为计数。 true为计数， false为不计数。 
>
> 所谓计数即每一个acquire必须对应一个release； 不计数则是无论
> 有多少个acquire， 一个release就可以释放。 
>
> 虽然官方说默认是计数的， 但是有的第三方ROM做了修改， 使默认是不计数的（开发人员就是拿到了这种手机） 。  
>
> 所以对于计数的机器最终结局方案为：
>
> 获取wakeLock后设置为不计数：wakeLock.setReferenceCounted(false);
>
>