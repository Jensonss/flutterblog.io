# 0x00 前言

很多人通过Java才听说GC的，甚至刚开始做开发时以为GC是Java独有的。其实不然，GC是一项很古老的技术，与Lisp语言在20世纪60年代一同出现的。

虽然GC不是Java独有的，但是不得不承认，GC很大成分上是因为Java的广泛应用才被广大开发者所熟知的。

说到GC不得不提一个人：John McCarthy，Lisp语言之父和人工智能之父，同时还是GC之父，其论文中提到的算法就是标记-清除算法。

如果是一门语言可以从基础语法学起，但是GC该如何学习呢？

**其实问答形式就是最好的学习方式**

# 0x01 什么是GC

GC(垃圾回收)，通过查找无效对象释放空间达到自动管理内存的目的。

<!-- more -->

# 0x02 如何确定垃圾

要查找垃圾对象，首先要知道什么样对象才算是垃圾对象才好对症下药。

**在内存中，不再被引用的对象就称为垃圾对象**

现在的问题又转到如何确定一个对象是否被引用？

首先想到一种方法是给每个对象都添加一个计数器功能，这个计数器用例记录引用自己的指针数量，每多一个引用数量计数器就增加1，每减少一个引用数量计数器就减少1，如果计数器为0，说明没有其他对象引用当前对象，那么这个对象就是垃圾对象，可以被回收。这种方式叫做**引用计数法**

引用计数法虽然容易理解，但是因为缺点也很明显，所以不得不另寻它法。这时**可达性分析法**就登场了。

**可达性分析法**也可以称为**跟踪收集器法**，找一个对象作为GC的根节点(Root)，通过对对象的连续引用形成一条引用链，如果一个对象能够通过直接或间接的到达Root称为对象可达，否则称为对象不可达。对于不可达对象就可以判定为垃圾对象。



# 0x03 如何回收垃圾

上一节知道了哪些对象是垃圾，现在该讨论有哪些方式能回收垃圾了。

常用的GC算法有**标记-清除算法**、**标记-整理算法**、**复制算法**、**分代GC**、**G1 GC**。

## 标记-清除算法

**标记-清除算法(Mark-Weep)**看名字就知道分为标记和清除两个阶段。

**注意一点这里的标记是指标记活着的对象，而非死对象。**

**标记阶段**从Root开始首先标记Root能直接访问的对象，然后递归通过指针能访问到得对象，同时把这些对象做标记。

**清除阶段**遍历堆内存，把未被标记的对象清除以达到垃圾回收目的。

图片表示如下：

![标记清除](http://othg5ggzi.bkt.clouddn.com/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4.png)

图中问题很明显：回收后会产生大量的内存碎片，不利于对内存连续要求的数据结构的使用，譬如数组。



## 标记-整理算法

**标记-整理算法也叫标记-压缩**，这里的标记阶段和上面的标记-清除的标记阶段完全一样，不同的是整理阶段是对清除阶段的改进。

整理阶段简单来说就是把活着的对象移动到一端，然后从边界处清除另一端所有空间。

图片表示如下：

![标记整理](http://othg5ggzi.bkt.clouddn.com/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86.png)



优点是有效利用堆，但又不会产生内存碎片。

缺点是浪费时间，整理阶段要搜索三次堆内存，而标记-清除算法的清除阶段只搜索一次堆内存。



## 复制算法

**复制算法**是把堆内存分为两块空间标识为from和to。当from空间被占满时，GC把活着的对象复制到to空间，复制完成后把from和to标识互换，GC结束。为了保证from空间对象都能复制到to空间，须要保证from和to空间大小一致。

图片表示如下：

![复制算法](http://othg5ggzi.bkt.clouddn.com/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png)



复制算法吞吐量优秀，分配内存速度快，没有碎片，但是堆内存利用率低下



## 分代GC

根据日常研发总结出一个经验“大部分对象在生成后不久就变成垃圾，很少能活的久”。据此经验，分代GC引入了“年龄”的概念。经历过一次GC后活下来的对象年龄+1。

**分代GC**把内存分为新生代和老年代，针对不同的年代使用不同的GC算法。刚生产的对象称为新生代对象，活到一定年龄的称为老年代对象。

我们把对新对象执行的GC称为**新生代GC(minor GC)**， 把老年代对象执行的GC称为**老年代GC(major GC)**。

**分代GC属于综合性GC，对上面GC算法的综合使用。**

图片表示如下：

![分代GC](http://othg5ggzi.bkt.clouddn.com/%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6.png)

如图所示：**新生代空间包括Eden，S0和S1三个区，老年代空间是Old区**

其中新生代每次回收只有少数对象存活，可以使用复制算法，而老年代对象存活率高也没用额外空间，可以使用标记-整理和标记清除算法。

刚开始时，Eden用来存放刚创建的对象，S0和S1为空，如果发生GC，Eden区幸存对象转移到S0区，如果S0区已有数据前提下再次进行GC时，会把Eden和S0区存活对象转移到S1区，同时清空Eden和S0，然后交换S0和S1标识。经过一定次数的GC仍然存活的对象转移到老年代。



## G1 GC





# 0x04 谁来回收垃圾

知道了哪些对象是垃圾，也知道了用哪些算法来回收垃圾，然后呢？直接满地调用算法回收垃圾吗？

当然不是！GC要分时机且统一来回收垃圾，这里是由垃圾收集器来来根据时机统一回收垃圾对象。

由于各方面需求原因，垃圾收集器也是有多种的。



未完待续.......