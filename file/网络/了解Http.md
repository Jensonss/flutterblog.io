# 0x00 前言

只要是编程，无论学哪种语言，网络就是逃不开的话题，而Http又是网络上层协议应用最广泛的一种。

那么该如何学习Http？下图是个人总结的学习Http比较容易让人记忆的思维导图。下面的介绍也是按照该四维导图来说明。

![了解Http](http://othg5ggzi.bkt.clouddn.com/%E4%BA%86%E8%A7%A3http.png)

<!-- more -->

# 0x01 Http历史

## 一次web请求

当我们在浏览器URL窗口输入www.jensondev.me时，就会看到我们需要的内容。这期间发生了什么？

懂一点的人会说浏览器收到URL请求，发送给服务器，然后接收服务器内容并显示。

更懂一点的人会说浏览器收到URL进行DNS解析，发送给服务器，然后接收服务器内容并显示

那么什么是DNS，什么又是URL，又都有什么用？

## DNS

DNS，全名Domain Name System，域名解析系统。

域名的出现是为了方便记忆，但是通过网络定位到对应服务器需要的是IP，DNS就是提供域名到IP得解析服务。

## URL和URI

URL，Uniform Resource Locator，统一资源定位符，URL就是浏览器访问页面输入的网址。

URI，Uniform Resource Identifier ，统一资源标识符，

URI表示互联网中某一资源，而URL表示资源的地点。URL是URI子集。

URI格式如图：

![URI格式](http://othg5ggzi.bkt.clouddn.com/URI%E6%A0%BC%E5%BC%8F.png)

## Http诞生

1989年CERN的Tim Berners-Lee提出让身处两地的研究者进行交流和知识共享的设想。

当时的理念很简单很纯粹：就是借助多文档相互关联形成一个超文本，形成可以相互参阅的WWW。

这一理念的实现需要三个技术共同支撑：指定文档地址的URL，标记文本的语言HTML，传输文档的协议Http。

1990年CERN研发世界第一台Web服务器和浏览器。同年Http协议诞生，但是没有作为标准被建立，所以这个时候版本是1.0以前，被称为Http0.9。

1995年6月Http标准被公布，正式命名为Http1.0

1997年1月Http1.1公布，也是目前的主流版本。



## TCP/IP

上面介绍了Http的历史信息，但是Http是基于TCPIP的，要了解Http还要了解下TCPIP。

电脑之间如何通信？

要实现电脑之间通信要适用不同的硬件、不同的语言、不同的系统。而这需要一个通用的协议。

TCPIP就是在这基础上诞生的，TCPIP从上至下分为4层：应用层、传输层、网络层和数据链路层。

![TCPIP分层](http://othg5ggzi.bkt.clouddn.com/TCPIP%E5%88%86%E5%B1%82.png)

把 TCP/IP 层次化是有好处的。比如，如果互联网只由一个协议统筹，某个地方需要改变设计时，就必须把所有部分整体替换掉。而分层之后只需把变动的层替换掉即可。把各层之间的接口部分规划好之后，每个层次内部的设计就能够自由改动了。

数据流每经过一层都会添加当前层首部信息：

![tcpip首部](http://othg5ggzi.bkt.clouddn.com/TCPIP%E5%88%86%E5%B1%82%E9%A6%96%E9%83%A8.png)





# 0x02 初涉Http

## 无状态

Http协议设计简洁，仅仅实现数据交互，所以也是无状态协议。HTTP 协议自身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理。

但是随着web的发展，很多网站需要状态保存，所以引入了cookie技术。

## 请求方法

Http协议通过请求和响应进行通信交互，在请求时不同的方法有不同的应用场景。

先看下方法分类：

| 方法      | 说明          | 支持版本    |
| ------- | ----------- | ------- |
| GET     | 获取资源        | 1.0、1.1 |
| POST    | 传输实体主体      | 1.0、1.1 |
| PUT     | 传输文件        | 1.0、1.1 |
| HEAD    | 获得报文首部      | 1.0、1.1 |
| DELETE  | 删除文件        | 1.0、1.1 |
| OPTIONS | 询问支持的方法     | 1.1     |
| TRACE   | 追踪路径        | 1.1     |
| CONNECT | 要求用隧道协议连接代理 | 1.1     |
| LINK    | 建立和资源之间的联系  | 1.0     |
| UNLINK  | 断开连接关系      | 1.0     |

- GET：获取资源
- POST：传输实体主体
- PUT：传输文件
- HEAD：获得报文首部
- DELETE：删除文件
- OPTIONS：询问支持的方法
- TRACE：追踪路径
- CONNECT：要求用隧道协议连接代理

## 持久连接

HTTP 协议的初始版本中，每进行一次 HTTP 通信就要断开一次TCP 连接，这种情况在早期传输的都是小型文本消息时性能上不显优劣。但是随着近年互联网的发展，通信数据愈来愈大，每次通信都要新建和断开连接，耗费时间增加的同时也增加了通信开销。

为了解决TCP这个问题，HTTP/1.1 和一部分的 HTTP/1.0 想出了持久连接（HTTP Persistent Connections，也称为 HTTP keep-alive 或HTTP connection reuse）的方法。

持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。

持久连接的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。另外，减少开销的那部分时间，使HTTP 请求和响应能够更早地结束，这样 Web 页面的显示速度也就相应提高了。
在 HTTP/1.1 中，所有的连接默认都是持久连接，但在 HTTP/1.0 内并未标准化，可以通过首部的**connection = keep-alive**属性实现持久连接。



# 0x03 报文

用于 HTTP 协议交互的信息被称为 HTTP 报文，所以在Http中分为请求报文和响应报文两种。

而 报文又分为报文首部和报文主体两块。

## 首部

**根据请求报文和相应报文，首部也分为请求首部和响应首部。**

**请求首部**包括请求行、请求首部字段、通用首部字段、实体首部字段

**响应首部**包括状态行、响应首部字段、通用首部字段、实体首部字段

请求报文和响应报文结构如图：

![请求报文和响应报文结构](http://othg5ggzi.bkt.clouddn.com/%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E5%92%8C%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E7%9A%84%E7%BB%93%E6%9E%84.png)

请求报文和响应报文结构实例如图：

![请求报文和响应报文结构实例](http://othg5ggzi.bkt.clouddn.com/%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E5%92%8C%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E7%9A%84%E7%BB%93%E6%9E%84%E5%AE%9E%E4%BE%8B.png)





## 状态码

状态码的任务就是对返回结果的描述。

![状态码](http://othg5ggzi.bkt.clouddn.com/%E7%8A%B6%E6%80%81%E7%A0%81.png)

通过状态码我们可以知道服务器是否正确处理了我们的请求，如果出错了，那原因是什么。

状态码以3位数字和短语组成，数字第一位指定响应类别，响应类别主要有5种：

| 状态码  | 名称                     | 原因短语          |
| ---- | ---------------------- | ------------- |
| 1XX  | Informational（信息性状态码）  | 接收的请求正在处理     |
| 2XX  | Success（成功状态码）         | 请求正常处理完毕      |
| 3XX  | Redirection（重定向状态码）    | 需要进行附加操作以完成请求 |
| 4XX  | Client Error（客户端错误状态码） | 服务器无法处理请求     |
| 5XX  | Server Error（服务器错误状态码） | 服务器处理请求出错     |

### 2XX

- 200 OK 

  表示从客户端发来的请求在服务器端被正常处理了

- 204 NoContent

  该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体。比如，当从浏览器发出请求处理后，返回 204 响应，那么浏览器显示的页面不发生更新

- 206 PartialContent

  该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。

### 3XX

- 301 MovedPermanently

  永久性重定向。该状态码表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。也就是说，如果已经把资源对应的 URI保存为书签了，这时应该按 Location 首部字段提示的 URI 重新保存。像下方给出的请求 URI，当指定资源路径的最后忘记添加斜杠“ /”，就会产生 301 状态码

- 302 Found

  临时性重定向。该状态码表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问。

  和 301 Moved Permanently 状态码相似，但 302 状态码代表的资源不是被永久移动，只是临时性质的。换句话说，已移动的资源对应的URI 将来还有可能发生改变。比如，用户把 URI 保存成书签，但不会像301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码的页面对应的 URI。

- 303 SeeOther

  该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET方法定向获取请求的资源。
  303 状态码和 302 Found 状态码有着相同的功能，但 303 状态码明确表示客户端应当采用 GET 方法获取资源，这点与 302 状态码有区别。比如，当使用 POST 方法访问 CGI 程序，其执行后的处理结果是希望客户端能以 GET 方法重定向到另一个 URI 上去时，返回 303 状态码。虽然 302 Found 状态码也可以实现相同的功能，但这里使用 303 状态码是最理想的。 

- 304 NotModified

  该状态码表示客户端发送附带条件的请求 A 时，服务器端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回 304 NotModified（服务器端资源未改变，可直接使用客户端未过期的缓存）。
  304 状态码返回时，不包含任何响应的主体部分。 **304 虽然被划分在3XX 类别中，但是和重定向没有关系**

- 307 TemporaryRedirect

  临时重定向。该状态码与 302 Found 有着相同的含义。尽管 302 标准禁止 POST 变换成 GET，但实际使用时大家并不遵守。307 会遵照浏览器标准，不会从 POST 变成 GET。但是，对于处理
  响应时的行为，每种浏览器有可能出现不同的情况。

### 4XX

- 400 BadRequest

  该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码

- 401 Unauthorized

  该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。另外若之前已进行过 1 次请求，则表示用户认证失败。返回含有 401 的响应必须包含一个适用于被请求资源的WWWAuthenticate 首部用以质询（challenge）用户信息。当浏览器初次接收到 401 响应，会弹出认证用的对话窗口。

- 403 Forbidden

  该状态码表明对请求资源的访问被服务器拒绝了。服务器端没有必要给出拒绝的详细理由，但如果想作说明的话，可以在实体的主体部分对原因进行描述，这样就能让用户看到了。未获得文件系统的访问授权，访问权限出现某些问题（从未授权的发送源 IP 地址试图访问）等列举的情况都可能是发生 403 的原因。

- 404 NotFound

  该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用



### 5XX

- 500 InternalServerError

  该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web应用存在的 bug 或某些临时的故障

- 503 ServiceUnavailable

  该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入 RetryAfter 首部字段再返回给客户端

## 认证

认证有什么用？

用来限制某些页面只想让特定人查看，为此，服务器就要通过某种方式能知晓用户身份是否符合该特定人群来给出适合的响应。

Http1.1中使用的认证方式有：

- BASIC 认证（基本认证）
- DIGEST 认证（摘要认证）
- SSL 客户端认证
- FormBase 认证（基于表单认证）

这里主要讲下基本认证和摘要认证

### BASIC 认证（基本认证）

BASIC认证是从Http1.0就定义的认证方式。

首先看下基本认证流程：

![基本认证流程](http://othg5ggzi.bkt.clouddn.com/%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B.png)

从流程图很容易看出，操作a中直接向服务器请求图片时，由于服务器开启了基本认证，而客户端没有携带认证信息，这时操作b中给客户端返回了401，在上面状态码中我们了解到401Unauthorizeds是由于没有认证信息才出现的情况。

那么如何添加Basic认证信息呢？看操作c，在请求头首部中添加**Authorization: Basic YnJpYW4tdG90dHk6T3ch**首部信息，其中YnJpYW4tdG90dHk6T3ch这个乱码为使用Base64编码后生成的字符串。一般来说参与编码的是用户名和密码，且用户名和密码之间使用冒号：隔开，即base64（username:pwd）==YnJpYW4tdG90dHk6T3ch。

最后操作d接受基本认证信息，返回正确响应报文。

**注意：基本认证简单但不安全，base64只是一直编码而非加密，很容易被有恶意的人通过解码得知用户名密码。所以通过基本认证发送的信息可以说是明文发送。为了保证数据安全最好配合SSL一起使用。**

另外就算密码不被切取，一旦认证信息被拦截，第三者就可以凭借拿到的认证信息进行重放攻击，这时本该该用户看到的文档权限被第三者一览无余。

### DIGEST 认证（摘要认证）

可以认为摘要认证是对基本认证的一个改进：

永远不会以明文方式在网络上发送密码。
可以防止恶意用户捕获并重放认证的握手过程。
可以有选择地防止对报文内容的篡改。
防范其他几种常见的攻击方式。

看下摘要认证流程图：

![摘要认证流程](http://othg5ggzi.bkt.clouddn.com/%E6%91%98%E8%A6%81%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B.png)

摘要认证中传递的信息不是密码本身，而是通过一个算法取得的密码摘要部分内容。这样防止了密码被切取的风险。为了防止重放攻击，服务器会生成一个nonce随机数，客户端使用密码和随机数通过算法计算出摘要，这样每次请求的摘要都是不一样的。



## Https



未完待续。。。。

# 0x04 其他



## web内容



## web攻击



## 其他功能



### Http2.0



### SPDY



### WebSocket