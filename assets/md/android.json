[
  {
    "title": "关于Canvas的一些概念",
    "created_time": "2017-08-03 14:46:20",
    "body": "# 前言\r\n\r\n在Android开发中不管是图片的绘制还是控件的绘制都少不了**Canvas**的参与。\r\n\r\n**Canvas**如此重要，对其多一些了解自然是对开发有益的。\r\n\r\n# 获得对象\r\n\r\n有两种获得Canvas对象的方法：\r\n\r\n- 重写onDraw方法，使用参数中的Canvas\r\n- 直接创建Canvas对象\r\n\r\n<!-- more -->\r\n\r\n# 它有什么用\r\n\r\nCanvas一般译为“画布”。而画布一般只是用来承载画像的，显然在Android中叫Canvas为画布，显然狭隘了。因为Android开发中，Canvas不仅提供了动画特效还提供了常见图形绘制方法，比如圆形、矩形、扇形等。\r\n\r\n在进行绘制过程中，还需要借助Pain辅助，Paint可以理解为画笔。\r\n\r\n\r\n\r\n# 绘制图形方法\r\n\r\n- 绘制文字\r\n\r\n  `drawText(String text, float x, float y, Paint paint)`\r\n\r\n  `drawText(char[] text, int index, int count, float x, float y, Paint paint)`\r\n\r\n  `drawText(CharSequence text, int start, int end, float x, float y, Paint paint)`\r\n\r\n  **float x**：文本开始的x轴位置\r\n\r\n  **float y**：文本开始的y轴位置\r\n\r\n  **text**：要绘制的文本\r\n\r\n  **paint**: 使用的画笔\r\n\r\n  **start**：文本开始的位置\r\n\r\n  **end**：文本结束的位置\r\n\r\n  ​\r\n\r\n- 绘制圆形\r\n\r\n  `drawCircle(float cx, float cy, float radius, Paint paint)`\r\n\r\n  **float cx**：圆心x轴坐标\r\n\r\n  **float cy**：圆心y轴坐标\r\n\r\n  **float radius**：圆半径\r\n\r\n  **paint**：画笔\r\n\r\n  ​\r\n\r\n- 绘制线条\r\n\r\n  `drawLine(float startX, float startY, float stopX, float stopY, Paint paint)`\r\n\r\n  **float startX**：起点x坐标\r\n\r\n  **float startY**：起点y坐标\r\n\r\n  **float stopX**：终点x坐标\r\n\r\n  **float stopY**：终点y坐标\r\n\r\n  ​\r\n\r\n- 绘制椭圆\r\n\r\n  `drawOval(float left, float top, float right, float bottom, Paint paint)`\r\n\r\n  `drawOval(RectF oval, Paint paint)`\r\n\r\n  这里的两个方法可以是一样的，因为绘制一个**RectF**也是需要方法一中的四个点。\r\n\r\n  **float left**：左下\r\n\r\n  **float top**：左上\r\n\r\n  **float right**：右上\r\n\r\n  **float bottom**：右下\r\n\r\n  ​\r\n\r\n- 绘制弧度\r\n\r\n  `drawArc(float left, float top, float right, float bottom, float startAngle, float sweepAngle, boolean useCenter, Paint paint)`\r\n\r\n  ​\r\n\r\n  `drawArc(RectF oval, float startAngle, float sweepAngle, boolean useCenter, Paint paint)`\r\n\r\n  **float startAngle**：开始角度\r\n\r\n  **float sweepAngle**：扫过角度\r\n\r\n  **boolean useCenter**：是否和中心连线 \r\n\r\n  ​\r\n\r\n- 绘制矩形\r\n\r\n  `drawRect(float left, float top, float right, float bottom, Paint paint)`\r\n\r\n  `drawRect(Rect r, Paint paint)`\r\n\r\n  ​\r\n\r\n- 绘制多边形\r\n\r\n  多边形绘制需要用到Path，路径类\r\n\r\n  用到moveTo，lineTo等常用方法\r\n\r\n  `moveTo(float x, float y)`\r\n\r\n  `lineTo(float x, float y)`\r\n\r\n  ​\r\n\r\n- 绘制赛贝尔曲线\r\n\r\n  赛贝尔曲线的绘制也用到了Path。\r\n\r\n  `quadTo(float x1, float y1, float x2, float y2)`\r\n\r\n  ​\r\n\r\n- 绘制点\r\n\r\n  `drawPoint(float x, float y, Paint paint)`\r\n\r\n  `drawPoints(float[] pts, Paint paint)`\r\n\r\n  **float x**：点x轴坐标\r\n\r\n  **float y**：点y轴坐标\r\n\r\n  **float pts**：点数组，每两个值组合一个点，最后如果不够2个点则忽略。\r\n\r\n  ​\r\n\r\n- 绘制图片\r\n\r\n  `drawBitmap(Bitmap bitmap, Matrix matrix, Paint paint)`\r\n\r\n  ​\r\n\r\n  ​\r\n\r\n# 动画方法\r\n\r\n- 位移\r\n\r\n  `translate(float dx, float dy)`\r\n\r\n  **float dx**：x轴移动距离\r\n\r\n  **float dy**：y轴移动距离\r\n\r\n  ​\r\n\r\n- 缩放\r\n\r\n  `scale(float sx, float sy)`\r\n\r\n  `scale(float sx, float sy, float px, float py)`\r\n\r\n  **float sx**：x轴放大倍数\r\n\r\n  **float sy**：y轴放大倍数\r\n\r\n  **float px, float py**：以该点为中心缩放\r\n\r\n- 旋转\r\n\r\n  `rotate(float degrees)`\r\n\r\n  `rotate(float degrees, float px, float py)`\r\n\r\n  **float degrees**：旋转角度\r\n\r\n  **float px, float py**：以px，py组成的点为中心旋转degrees角度\r\n\r\n\r\n\r\n# save和restore\r\n\r\n- save保存画布\r\n\r\n  把save之前的数据保存起来，以便后续的操作在一个新的图层。\r\n\r\n- restore合并图层\r\n\r\n  把save之前和之后的多个图层进行合并"
  },
  {
    "title": "关于Intent那些事",
    "created_time": "2017-07-17 15:51:08",
    "body": "# 0x00 前言\r\n\r\nIntent，译为“意图”。从汉语角度理解，意图是什么意思？意图谋反，就是想要谋反。所以意图可以通俗理解为想要做什么。当然这里的“想要做什么”是告诉Android系统的而不是别人。\r\n\r\n虽然想要做什么就告诉Android系统，但是并不是为所欲为的。通过Intent只能请求三大组件：Activity，Service，Broadcast。\r\n\r\n<!-- more -->\r\n\r\n# 0x01 抽象理解\r\n\r\n因为涉及三个组件，这里不会单独讲每个组件和Intent。startActivity不要叫启动Activity，startService也不要叫启动服务，我们把他们抽象为一个请求。通过Intent向Android发出请求，Android去哪给你匹配呢？你不注册系统当然没地方找，所以我们要在AndroidManifest.xml中进行注册(广播可以动态注册)。注册的作用不光告诉系统可以从这找我，还告诉系统本组件只接收满足要求的请求。说到要求这就要提到IntentFilter了，每个IntentFilter代表一种要求，一个组件可以有多种要求即多个IntentFilter，但只要满足一种就能请求成功。系统所要做的就是把接收到得请求Intent和组件的要求IntentFilter进行匹配，如果匹配上了则牵手成功~\r\n\r\n这个流程抽象为：\r\n\r\n![请求流程](关于Intent那些事\/请求流程.png)\r\n\r\n# 0x02 分类\r\n\r\n通过Intent告诉Android系统“我想要做什么”，可以有两种方式阐述，一种是直白的表述“我想要启动某个页面”，我们称之为显性，另一种是告诉系统“我想要一个满足我某些要求的页面”,至于是哪个或哪几个页面由系统决定，如果是多个可以返回列表给我，这种称之为隐性。\r\n\r\n>Intent从请求性质上分为显性和隐性两种。\r\n\r\n\r\n\r\n由于显性Intent指定了具体的请求，如下：\r\n\r\n```java\r\nintent.setClass(Context packageContext, Class<?> cls)\r\n```\r\n\r\n所以匹配并不会发生在显性Intent,显性组件注册时一般这样的：\r\n\r\n```xml\r\n<activity android:name=\".ThirdActivity\" \/>\r\n```\r\n\r\n没有多余的要求。\r\n\r\n在抽象理解中，IntentFilter匹配只是为隐性准备的。\r\n\r\n下面要了解具体匹配规则如何：\r\n\r\n# 0x03 匹配规则\r\n\r\n要了解匹配规则是怎样的，首先要知道是从哪几方面入手匹配的，由于Android系统也是根据组件注册的要求进行匹配，所以看看注册时的IntentFilter有哪些属性就知道要匹配哪些方面了：\r\n\r\n```xml\r\n <intent-filter>\r\n     <action android:name=\"android.intent.action.CALL\" \/>\r\n     <category android:name=\"android.intent.category.DEFAULT\" \/>\r\n     <data android:mimeType=\"image\/*\"\/>\r\n     <data android:scheme=\"http\"\/>\r\n <\/intent-filter>\r\n```\r\n\r\n显然系统匹配也就是匹配category、action和data。\r\n\r\n下面分别来看看这三种是分别如何匹配的：\r\n\r\n**注意：下面将原理、源码、实例三管齐下** \r\n\r\n- category如何匹配\r\n\r\n  > 匹配原理：\r\n  >\r\n  > ①在请求的Intent中需要在IntentFilter找到匹配项才算匹配成功。\r\n  >\r\n  > ②如果Intent没有添加任何category，那么系统会自动给你添加android.intent.category.DEFAULT，所以如果你的三大组件是为隐性启动准备的，那么你就要在注册时手动添加<category android:name=\"android.intent.category.DEFAULT\" \/>。\r\n  >\r\n  > ③当然如果添加了其他值得category也可以不用添加default了。\r\n\r\n  ​\r\n\r\n\r\n\r\n- action如何匹配\r\n\r\n  > 匹配原理：\r\n  >\r\n  > ①IntentFilter如果没有声明action，则所有Intent都不能匹配成功。\r\n  >\r\n  > ②若IntentFilter声明了action，而Intent没有不带任何action，则匹配通过。\r\n  >\r\n  > ③若IntentFilter声明了action，Intent也声明了action，那么Intent中action必须是IntentFilter中action的子集才能匹配成功。\r\n\r\n\r\n\r\n- data如何匹配\r\n\r\n  data分为两部分，MIME type和URI。\r\n\r\n  - MIME type就是表明数据格式类型，方便系统正确解析处理\r\n\r\n    MIME type又分为两部分：主类型type和子类型subtype，以\"\/\"分割。比如：\r\n\r\n    video\/mp4，image\/jpeg。\r\n\r\n  - URI 唯一资源标识符\r\n\r\n    URI分为scheme、Authory和path三部分。\r\n\r\n    scheme表示采用协议，既可以是http网络协议也可以是本地content和file协议。\r\n\r\n    Authority由host和port组成。\r\n\r\n    path表示文件在host中具体位置。\r\n\r\n  了解了data组成，下面说说data匹配原理\r\n\r\n  > 匹配原理：\r\n  >\r\n  > ①data只匹配IntentFilter中所拥有部分。\r\n  >\r\n  > ②如果Intent中既没有MIME，也没用URI，那么IntentFilter中也都不能有才能通过。\r\n  >\r\n  > ③若Intent没有指定类型，只指定了URI，那么IntentFilter必须没有指定类型。特殊情况下能根据URI推断出类型，这种情况按⑤情况算。\r\n  >\r\n  > ④若Intent只指定了类型，没有URI。那么IntentFilter也必须没有指定URI\r\n  >\r\n  > ⑤若Intent同时指定了类型和URI，那么必须都匹配上才能通过。"
  },
  {
    "title": "浅谈Android事件传递机制",
    "created_time": "2017-07-24 17:34:17",
    "body": "# 0x00 前言\r\n\r\n为什么点下屏幕某个位置时候，系统会找到正确地控件来响应？\r\n\r\n为什么按下按下返回键系统会让当前窗口页面关闭而不是下面的那个页面？\r\n\r\n很多时候多问自己个为什么就发现自己会的其实还很少。\r\n\r\n# 0x01 冯诺依曼模型回顾\r\n\r\n![冯诺依曼模型](http:\/\/othg5ggzi.bkt.clouddn.com\/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E6%A8%A1%E5%9E%8B.png)\r\n\r\n讲事件传递为什么把冯诺依曼模型带进来了？\r\n\r\n事件传递的事件来自哪里？\r\n\r\n基本的事件来自按键、屏幕，属于输入设备，而最终事件的结果要显示在屏幕上(输出设备)，这样才算完成一次交互。其实这里屏幕同时兼顾输入和输出。\r\n\r\n有了输入设备，系统是如何从中采集数据的呢？\r\n\r\n<!-- more -->\r\n\r\n# 0x02 设备节点到ViewRootImpl\r\n\r\n## Android系统是基于Linux的，而输入事件是接收是由Linux内核完成的。\r\n\r\n当发现输入设备可用时，Linux内核会在\/dev\/input\/目录下创建名称为event0~n的设备节点。当设备不可用时则删除对应节点。\r\n\r\n*如果刚才的不好理解，那么可以理解windows这种情况：当我们新买的鼠标插入USB口时，右下角一般弹窗正在安装USB驱动，而最终会在设备管理中多出一个USBHub设备节点，拔掉USB时就会消失*\r\n\r\n输入设备准备就绪，当有事件发生时，Linux内核收到硬件中断，然后把中断加工成原始输入事件存入对应设备节点中。\r\n\r\n输入事件已经有了，用户空间只要读取事件信息就可以了。\r\n\r\n## 在用户空间这块输入事件的负责人是谁呢？\r\n\r\nAndroid系统为我们指定好了负责人：InputManagerService(后面直接称：IMS)。\r\n\r\nIMS和WMS，AMS一样都属于系统服务，在系统启动时由SystemServer统一启动。所以只要看看源码才能知道具体情况如何。\r\n\r\n首先看下`SystemServer`启动情况：\r\n\r\n```java\r\n    \/**\r\n     * The main entry point from zygote.\r\n     *\/\r\n    public static void main(String[] args) {\r\n        new SystemServer().run();\r\n    }\r\n\r\nprivate void run() {\r\n      \/\/ Start services.\r\n        try {\r\n            startBootstrapServices();\r\n            startCoreServices();\r\n            startOtherServices();\r\n        } catch (Throwable ex) {\r\n            Slog.e(\"System\", \t\"******************************************\");\r\n            Slog.e(\"System\", \"************ Failure starting system services\", ex);\r\n            throw ex;\r\n        }\r\n}\r\n```\r\n\r\n通过源码发现`SystemServer`通过main方法直接启动的。当然这里run方法代码只是关键的一部分，如果都粘贴上来会影响分析。\r\n\r\n那么IMS在哪启动的呢？其实IMS通过`startOtherServices`方法启动。\r\n\r\n```java\r\n    private void startOtherServices() {\r\n         WindowManagerService wm = null;\r\n        InputManagerService inputManager = null;\r\n\r\n\t\t wm = WindowManagerService.main(context, inputManager,\r\n                    mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL,\r\n                    !mFirstBoot, mOnlyCore);\r\n            ServiceManager.addService(Context.WINDOW_SERVICE, wm);\r\n            ServiceManager.addService(Context.INPUT_SERVICE, inputManager);\r\n\r\n            inputManager = new InputManagerService(context);\r\n           inputManager.setWindowManagerCallbacks(wm.getInputMonitor());\r\n            inputManager.start();\r\n\t}\r\n```\r\n\r\n这里不仅启动了IMS，还有WMS，还给IMS设置了一个`wm.getInputMonitor()`，这个设置有什么用先不用管。最后调用了start方法。\r\n\r\n目前只只知道IMS是用户空间的输入事件负责人，具体如何负责还要继续看，IMS的start方法调用了`        nativeStart(mPtr);`，看的出来这是要进入C层实现了。\r\n\r\n找到Java层IMS对应的C层实现，打开文件找到`nativeStart`实现：\r\n\r\n```c++\r\nstatic void nativeStart(JNIEnv* env, jclass clazz, jlong ptr) {\r\n    NativeInputManager* im = reinterpret_cast<NativeInputManager*>(ptr);\r\n\r\n    status_t result = im->getInputManager()->start();\r\n    if (result) {\r\n        jniThrowRuntimeException(env, \"Input manager could not be started.\");\r\n    }\r\n}\r\n```\r\n\r\n方法如此简单，又是个躯壳，仅仅调用了其他类的方法。\r\n\r\n下面看看`start()`里面干了什么，\r\n\r\n注意一点：这里显示的是`NativeInputManager`，但其实找到的是`InputManager`,多态特性。\r\n\r\n```C++\r\nstatus_t InputManager::start() {    \r\n    status_t result = mDispatcherThread->run(\"InputDispatcher\", PRIORITY_URGENT_DISPLAY);\r\n    if (result) {\r\n        ALOGE(\"Could not start InputDispatcher thread due to error %d.\", result);\r\n        return result;\r\n    }\r\n\r\n    result = mReaderThread->run(\"InputReader\", PRIORITY_URGENT_DISPLAY);\r\n    if (result) {\r\n        ALOGE(\"Could not start InputReader thread due to error %d.\", result);\r\n\r\n        mDispatcherThread->requestExit();\r\n        return result;\r\n    }\r\n\r\n    return OK;\r\n}\r\n```\r\n\r\n这次真的是全部代码，没有精简，看的出来好像start就启动了两个线程。\r\n\r\nmDispatcherThread对应`InputDispatcherThread`类，负责事件分发\r\n\r\nmReaderThread对应`InputReaderThread`类，负责事件读取\r\n\r\n现在我们基本可以猜到，一个线程读取事件，读取后把事件信息传递给分发线程，由分发线程继续处理。\r\n\r\n当然这还都只是猜测，实践是检验真理的唯一标准。\r\n\r\n## 看看InputReaderThread干了什么\r\n\r\n首先看看`InputReaderThread`源码\r\n\r\n```C++\r\n\/* Reads raw events from the event hub and processes them, endlessly. *\/\r\nclass InputReaderThread : public Thread {\r\npublic:\r\n    InputReaderThread(const sp<InputReaderInterface>& reader);\r\n    virtual ~InputReaderThread();\r\n\r\nprivate:\r\n    sp<InputReaderInterface> mReader;\r\n\r\n    virtual bool threadLoop();\r\n};\r\n```\r\n\r\n`InputReaderThread`继承了Thread，在执行run方法时会回调`threadLoop`。从`virtual`知道这是一个虚函数，来看看具体实现：\r\n\r\n```C++\r\nbool InputReaderThread::threadLoop() {\r\n    mReader->loopOnce();\r\n    return true;\r\n}\r\n```\r\n\r\nmReader对应`InputReader`类，看下`loopOnce`方法实现：\r\n\r\n```C++\r\n\r\nvoid InputReader::loopOnce() {\r\n    int32_t oldGeneration;\r\n    int32_t timeoutMillis;\r\n    bool inputDevicesChanged = false;\r\n    Vector<InputDeviceInfo> inputDevices;\r\n    { \/\/ acquire lock\r\n        AutoMutex _l(mLock);\r\n\r\n        oldGeneration = mGeneration;\r\n        timeoutMillis = -1;\r\n\r\n        uint32_t changes = mConfigurationChangesToRefresh;\r\n        if (changes) {\r\n            mConfigurationChangesToRefresh = 0;\r\n            timeoutMillis = 0;\r\n            refreshConfigurationLocked(changes);\r\n        } else if (mNextTimeout != LLONG_MAX) {\r\n            nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);\r\n            timeoutMillis = toMillisecondTimeoutDelay(now, mNextTimeout);\r\n        }\r\n    } \/\/ release lock\r\n    \/\/这里就是我们开始说的从设备节点读取输入事件的函数了。\r\n    size_t count = mEventHub->getEvents(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE);\r\n\r\n    { \/\/ acquire lock\r\n        AutoMutex _l(mLock);\r\n        mReaderIsAliveCondition.broadcast();\r\n\r\n        if (count) {\r\n          \/\/处理事件\r\n            processEventsLocked(mEventBuffer, count);\r\n        }\r\n\r\n        if (mNextTimeout != LLONG_MAX) {\r\n            nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);\r\n            if (now >= mNextTimeout) {\r\n#if DEBUG_RAW_EVENTS\r\n                ALOGD(\"Timeout expired, latency=%0.3fms\", (now - mNextTimeout) * 0.000001f);\r\n#endif\r\n                mNextTimeout = LLONG_MAX;\r\n                timeoutExpiredLocked(now);\r\n            }\r\n        }\r\n\r\n        if (oldGeneration != mGeneration) {\r\n            inputDevicesChanged = true;\r\n            getInputDevicesLocked(inputDevices);\r\n        }\r\n    } \/\/ release lock\r\n\r\n    \/\/ Send out a message that the describes the changed input devices.\r\n    if (inputDevicesChanged) {\r\n        mPolicy->notifyInputDevicesChanged(inputDevices);\r\n    }\r\n\r\n    \/\/ Flush queued events out to the listener.\r\n    \/\/ This must happen outside of the lock because the listener could potentially call\r\n    \/\/ back into the InputReader's methods, such as getScanCodeState, or become blocked\r\n    \/\/ on another thread similarly waiting to acquire the InputReader lock thereby\r\n    \/\/ resulting in a deadlock.  This situation is actually quite plausible because the\r\n    \/\/ listener is actually the input dispatcher, which calls into the window manager,\r\n    \/\/ which occasionally calls into the input reader.\r\n    mQueuedListener->flush();\r\n}\r\n```\r\n\r\n上面方法主要执行了三个流程：\r\n\r\n①通过`mEventHub->getEvents`读取事件\r\n\r\n​\t这里不再继续深入，重点理解②③\r\n\r\n②通过`processEventsLocked`处理事件\r\n\r\n这方法里面有`processEventsForDeviceLocked`方法，这是处理一般事件的方法。\r\n\r\n```C++\r\nvoid InputReader::processEventsForDeviceLocked(int32_t deviceId,\r\n        const RawEvent* rawEvents, size_t count) {\r\n    ssize_t deviceIndex = mDevices.indexOfKey(deviceId);\r\n    if (deviceIndex < 0) {\r\n        ALOGW(\"Discarding event for unknown deviceId %d.\", deviceId);\r\n        return;\r\n    }\r\n\r\n    InputDevice* device = mDevices.valueAt(deviceIndex);\r\n    if (device->isIgnored()) {\r\n        \/\/ALOGD(\"Discarding event for ignored deviceId %d.\", deviceId);\r\n        return;\r\n    }\r\n\r\n    device->process(rawEvents, count);\r\n}\r\n```\r\n\r\n这里根据`deviceId`生成`InputDevice`。进而调用`device->process`。\r\n\r\n```C++\r\n for (size_t i = 0; i < numMappers; i++) {\r\n                InputMapper* mapper = mMappers[i];\r\n                mapper->process(rawEvent);\r\n            }\r\n```\r\n\r\n最终引出了`InputMapper`，这是一个基类，而对于触摸事件会调用`TouchInputMapper`类的`process`方法：\r\n\r\n```C++\r\nvoid TouchInputMapper::process(const RawEvent* rawEvent) {\r\n    mCursorButtonAccumulator.process(rawEvent);\r\n    mCursorScrollAccumulator.process(rawEvent);\r\n    mTouchButtonAccumulator.process(rawEvent);\r\n\r\n    if (rawEvent->type == EV_SYN && rawEvent->code == SYN_REPORT) {\r\n        sync(rawEvent->when);\r\n    }\r\n}\r\n```\r\n\r\n后面经过一系列方法调用，事件信息封装到`NotifyMotionArgs args`，通过`getListener()->notifyMotion(&args)`方法把事件加入到队列中。然后开始③过程。\r\n\r\n\r\n\r\n③通过`mQueuedListener->flush()`事件转移到`InputDispatcherThread`。\r\n\r\n看看`flush`源码：\r\n\r\n```C++\r\nvoid QueuedInputListener::flush() {\r\n    size_t count = mArgsQueue.size();\r\n    for (size_t i = 0; i < count; i++) {\r\n        NotifyArgs* args = mArgsQueue[i];\r\n        args->notify(mInnerListener);\r\n        delete args;\r\n    }\r\n    mArgsQueue.clear();\r\n}\r\n```\r\n\r\n这个方法遍历事件，同时执行`notify`，然后从队列删除消息，\r\n\r\n`NotifyArgs`也是基类，有多种子类，其中触摸事件为`NotifyMotionArgs`，其`notify`方法如下：\r\n\r\n```C++\r\nvoid NotifyMotionArgs::notify(const sp<InputListenerInterface>& listener) const {\r\n    listener->notifyMotion(this);\r\n}\r\n```\r\n\r\n这里的`listener`指向`InputDispatcher`，而`InputDispatcher`隶属于`InputDispatcherThread` ，下一节继续\r\n\r\n\r\n\r\n## 看看InputDispatcherThread干了什么\r\n\r\n`InputDispatcherThread`执行的时候调用了`threadLoop`然后调用了`mDispatcher->dispatchOnce();`。经过一些列调用会转战到`InputChannel::sendMessage`。\r\n\r\n继续上一节，看看`InputDispatcher`中`notifyMotion`方法：\r\n\r\n```C++\r\n  void InputDispatcher::notifyMotion(const NotifyMotionArgs* args) {\r\n\r\n  \tneedWake = enqueueInboundEventLocked(newEntry);\r\n       if (needWake) {\r\n        mLooper->wake();\r\n    }\r\n  }\r\n```\r\n\r\n方法主要做了这两件事：\r\n\r\n①事件再次加入队列\r\n\r\n​\t其中还执行了`findTouchedWindowAtLocked`查找当前活动窗口并拿到句柄。\r\n\r\n②唤醒looper。\r\n\r\n\r\n\r\n> 这里疑惑的一点是：事件加入队列，唤醒looper，接下来应该是looper循环读取消息队列进行事件分发，但是这里没有找到和dispatchOnce想关联的地方。可能有疏漏地方。以后发现问题会及时更新上。这里直接继续InputChannel::sendMessage来说。\r\n\r\n\r\n\r\n`InputChannel`是负责与app窗口进行通信的，通过WMS找到对应的窗口。那么`InputChannel`到底是怎么找到窗口的？\r\n\r\n在WMS的`addWindow`方法中有这样几行代码：\r\n\r\n```c++\r\npublic int addWindow(Session session, IWindow client, int seq,\r\n            WindowManager.LayoutParams attrs, int viewVisibility, int displayId,\r\n            Rect outContentInsets, Rect outStableInsets, InputChannel outInputChannel) {\r\n            \r\n                \r\n                String name = win.makeInputChannelName();\r\n                InputChannel[] inputChannels = InputChannel.openInputChannelPair(name);\r\n                win.setInputChannel(inputChannels[0]);\r\n                inputChannels[1].transferTo(outInputChannel);\r\n\r\n                mInputManager.registerInputChannel(win.mInputChannel, win.mInputWindowHandle);\r\n            \r\n            }\r\n```\r\n\r\n这里是在Activity初始化时想WMS添加的窗口的调用方法，其中在添加窗口时候就已经给这个窗口设置了通信通道。\r\n\r\n然后看下`InputChannel.openInputChannelPair`里面做了什么：\r\n\r\n```c++\r\nstatus_t InputChannel::openInputChannelPair(const String8& name,\r\n        sp<InputChannel>& outServerChannel, sp<InputChannel>& outClientChannel) {\r\n    int sockets[2];\r\n    if (socketpair(AF_UNIX, SOCK_SEQPACKET, 0, sockets)) {\r\n        status_t result = -errno;\r\n        ALOGE(\"channel '%s' ~ Could not create socket pair.  errno=%d\",\r\n                name.string(), errno);\r\n        outServerChannel.clear();\r\n        outClientChannel.clear();\r\n        return result;\r\n    }\r\n\r\n    int bufferSize = SOCKET_BUFFER_SIZE;\r\n    setsockopt(sockets[0], SOL_SOCKET, SO_SNDBUF, &bufferSize, sizeof(bufferSize));\r\n    setsockopt(sockets[0], SOL_SOCKET, SO_RCVBUF, &bufferSize, sizeof(bufferSize));\r\n    setsockopt(sockets[1], SOL_SOCKET, SO_SNDBUF, &bufferSize, sizeof(bufferSize));\r\n    setsockopt(sockets[1], SOL_SOCKET, SO_RCVBUF, &bufferSize, sizeof(bufferSize));\r\n\r\n    String8 serverChannelName = name;\r\n    serverChannelName.append(\" (server)\");\r\n    outServerChannel = new InputChannel(serverChannelName, sockets[0]);\r\n\r\n    String8 clientChannelName = name;\r\n    clientChannelName.append(\" (client)\");\r\n    outClientChannel = new InputChannel(clientChannelName, sockets[1]);\r\n    return OK;\r\n}\r\n```\r\n\r\n这里主要创建了两个`InputChannel`，一个服务端一个客户端，这里的的`InputChannel`是基于socket的，这个socket不是网络的socket而是Unix特有的关于文件的Unix domain socket。\r\n\r\n## WMS和ViewRootImpl\r\n\r\n经过一些列的调转，最终会回调到`InputEventReceiver`的`dispatchInputEvent`方法。\r\n\r\n这个方法是C++通过JNi回调的：\r\n\r\n```java\r\n    \/\/ Called from native code.\r\n    @SuppressWarnings(\"unused\")\r\n    private void dispatchInputEvent(int seq, InputEvent event) {\r\n        mSeqMap.put(event.getSequenceNumber(), seq);\r\n        onInputEvent(event);\r\n    }\r\n```\r\n\r\n上面的`InputEventReceiver` 对象其实是`WindowInputEventReceiver` 的引用，所以`onInputEvent`其实调用的`WindowInputEventReceiver`方法：\r\n\r\n```java\r\n\t\t@Override\r\n        public void onInputEvent(InputEvent event) {\r\n            enqueueInputEvent(event, this, 0, true);\r\n        }\r\n```\r\n\r\n`enqueueInputEvent`通过连续调用，跳转到`deliverInputEvent`：\r\n\r\n```java\r\n    private void deliverInputEvent(QueuedInputEvent q) {\r\n        Trace.asyncTraceBegin(Trace.TRACE_TAG_VIEW, \"deliverInputEvent\",\r\n                q.mEvent.getSequenceNumber());\r\n        if (mInputEventConsistencyVerifier != null) {\r\n            mInputEventConsistencyVerifier.onInputEvent(q.mEvent, 0);\r\n        }\r\n\r\n        InputStage stage;\r\n        if (q.shouldSendToSynthesizer()) {\r\n            stage = mSyntheticInputStage;\r\n        } else {\r\n            stage = q.shouldSkipIme() ? mFirstPostImeInputStage : mFirstInputStage;\r\n        }\r\n\r\n        if (stage != null) {\r\n            stage.deliver(q);\r\n        } else {\r\n            finishInputEvent(q);\r\n        }\r\n    }\r\n```\r\n\r\n这里的`stage`是多态形式，但是最终会调用`ViewPostImeInputStage`的`onProcess`方法。\r\n\r\n```java\r\n       @Override\r\n        protected int onProcess(QueuedInputEvent q) {\r\n            if (q.mEvent instanceof KeyEvent) {\r\n                return processKeyEvent(q);\r\n            } else {\r\n                \/\/ If delivering a new non-key event, make sure the window is\r\n                \/\/ now allowed to start updating.\r\n                handleDispatchDoneAnimating();\r\n                final int source = q.mEvent.getSource();\r\n                if ((source & InputDevice.SOURCE_CLASS_POINTER) != 0) {\r\n                    return processPointerEvent(q);\r\n                } else if ((source & InputDevice.SOURCE_CLASS_TRACKBALL) != 0) {\r\n                    return processTrackballEvent(q);\r\n                } else {\r\n                    return processGenericMotionEvent(q);\r\n                }\r\n            }\r\n        }\r\n```\r\n\r\n由于是触摸事件，所以会执行`processPointerEvent`方法：\r\n\r\n```java\r\n       private int processPointerEvent(QueuedInputEvent q) {\r\n            final MotionEvent event = (MotionEvent)q.mEvent;\r\n\r\n            mAttachInfo.mUnbufferedDispatchRequested = false;\r\n            boolean handled = mView.dispatchPointerEvent(event);\r\n            if (mAttachInfo.mUnbufferedDispatchRequested && !mUnbufferedInputDispatch) {\r\n                mUnbufferedInputDispatch = true;\r\n                if (mConsumeBatchedInputScheduled) {\r\n                    scheduleConsumeBatchedInputImmediately();\r\n                }\r\n            }\r\n            return handled ? FINISH_HANDLED : FORWARD;\r\n        }\r\n```\r\n\r\n发现有` boolean handled = mView.dispatchPointerEvent(event);`这么一句话，看来现在已经开始向view分发事件了。\r\n\r\n这里的`mView`是指向`DecorView`，剩下的内容下节继续\r\n\r\n\r\n\r\n# 0x03 ViewRootImpl到View \r\n\r\n通过View的`dispatchPointerEvent`调用了`dispatchTouchEvent`，\r\n\r\n因为`DecorView`重写了`dispatchTouchEvent`方法，看下这个内容：\r\n\r\n```java\r\n  @Override\r\n        public boolean dispatchTouchEvent(MotionEvent ev) {\r\n            final Callback cb = getCallback();\r\n            return cb != null && !isDestroyed() && mFeatureId < 0 ? cb.dispatchTouchEvent(ev)\r\n                    : super.dispatchTouchEvent(ev);\r\n        }\r\n```\r\n\r\n这里的`getCallback`返回的是Activity引用，如果Activity没有销毁，则调用Activity的`dispatchTouchEvent`方法。代码如下：\r\n\r\n```java\r\n    public boolean dispatchTouchEvent(MotionEvent ev) {\r\n        if (ev.getAction() == MotionEvent.ACTION_DOWN) {\r\n            onUserInteraction();\r\n        }\r\n        if (getWindow().superDispatchTouchEvent(ev)) {\r\n            return true;\r\n        }\r\n        return onTouchEvent(ev);\r\n    }\r\n```\r\n\r\n这里注意一点，如果`getWindow().superDispatchTouchEvent(ev)`返回true，则不继续执行Activity的`onTouchEvent`。\r\n\r\n这里的getWinddow就是PhoneWindow，而PhoneWindow的`superDispatchTouchEvent`直接引用了DecorView的`superDispatchTouchEvent`，接着调用了`super.dispatchTouchEvent(event)`，这里的super是ViewGroup，这里主要做了两件事：①判断当前ViewGroup是否拦截事件，如果拦截则执行`onInterceptTouchEvent`。②如果不拦截，事件也没取消，则事件向子View分发。在向子View分发前会先判断子View是否接受事件及事件是否在子View范围内。如果都为true了则调用`dispatchTransformedTouchEvent`。这里面调用了子View的`dispatchTouchEvent`。\r\n\r\n子View的`dispatchTouchEvent`里面会判断`touchListener.onTouch`方法和`onTouchEvent`方法。\r\n\r\n\r\n\r\n# 0x04 事件传递须知\r\n\r\n ①如果DecorView的`dispatchPointerEvent`方法返回true表示事件消费成功。\r\n\r\n②如果Activity没有销毁，则回调Activity的`dispatchTouchEvent`,如果phone window的`superDispatchTouchEvent`返回true表示被DecorView或其子View消耗了事件，则不执行Activity的onTouchEvent方法。\r\n\r\n③如果ViewGroup执行dispatchTouchEvent方法，先判断是否需要拦截事件：\r\n\r\n如果需要拦截则执行onInterceptTouchEvent方法。\r\n\r\n如果拦截返回true，则不继续事件传递，如果返回false，则继续，首先判断子View是否接受事件及是否在范围内，如果都符合则传递给子View。\r\n\r\n④如果子View执行dispatchTouchEvent方法，会先判断是否设置onTouchListener，\r\n\r\n如果设置了则执行onTouch方法。如果该方法返回true，则不继续执行子View 的onTouchEvent方法，否则继续执行ouTouchEvent方法。\r\n\r\n⑤如果ouTouchEvent方法执行，actionDown时检查长按事件，actionUp时检查onClick事件。"
  },
  {
    "title": "浅谈Android性能优化系列(0)之为什么需要性能优化",
    "created_time": "2017-09-25 22:40:50",
    "body": "# 0X00 前言\r\n\r\n现在做开发，不管刚入门菜鸟还是资深大牛，总是离不开性能优化\/性能调优的话题。那么到底什么是性能优化呢？\r\n\r\n个人认为通过技术手段，使程序运行达到了比之前版本更好的效果，就是性能优化。\r\n\r\n为什么性能优化是我们绕不开的话题呢？\r\n\r\n<!-- more -->\r\n\r\n# 0x01 为什么需要性能优化\r\n\r\n关于为什么需要性能优化这个问题，我想很多人都会即时作答：“为用户提供更好的体验\"。\r\n\r\n既然说到为用户提供更好体验，设想一下，假如用户并不在意所谓的体验，只要功能完成就行了。那么这时公司还会考虑做性能优化吗？\r\n\r\n我想大多数公司都不会去做”这样一件无意义的事“了。公司是以盈利为目的，怎么会在用户不care的点上花费大量人力物力财力呢？\r\n\r\n然而现实恰恰相反的，随着科技发展，用户对产品体验要求越来越高，加上当前产品同质化严重，特色功能只能吸引用户，而良好的用户体验才是留住用户的关键。\r\n\r\n# 0x02 从哪些方面入手性能优化\r\n\r\n只说性能优化太过笼统，为了提供良好用户体验，应该从哪些方面着手呢？\r\n\r\n换句话说，在产品体验上，用户会通过感知哪些方面来评价产品好坏？这样一说答案就很明显了，就是平常我们自己使用程序都会唠叨的那几个方面：点几下就崩溃、玩一会就没电、没多久流量就超了、打开页面很卡、安装包太大、占了300兆内存~\r\n\r\n> 把上面几个方面归纳下就是：程序稳定性优化、耗电检测优化、网络优化、UI渲染优化、安装包优化和内存优化 6个方面。\r\n\r\n\r\n\r\n# 0x03 结束语\r\n\r\n这是本系列开篇，从为什么要性能优化发散到优化入手的6各方面，为后续章节做铺垫。\r\n\r\n目前预计未来会写6篇关于具体方面优化和6篇相关方面工具使用，共计12篇。希望通过这12篇让自己当然希望也能帮助别人对Android整体性能优化有个了解，最终形成自己的知识脉络。"
  },
  {
    "title": "浅谈Android性能优化系列(1)之安装包大小优化",
    "created_time": "2017-09-25 23:35:04",
    "body": "# 0x00 前言\r\n\r\n可能会有人有疑问，安装包还需要优化吗？现在流量都用不完的！\r\n\r\n这样来说吧，优化有多方面好处的：\r\n\r\n①节省用户流量\r\n\r\n②安装包越小，用户就越快下载完，缩短了联网时间，联网时间短耗电也就越少\r\n\r\n③越快下载完，用户就越能提前使用APP，避免对用户耐心的过多消磨。\r\n\r\n所以，安装包优化还是有必要的。\r\n\r\n<!-- more -->\r\n\r\n# 0x01 安装包构成\r\n\r\n要想优化安装包，首先知道包由哪些部分组成的。这是电视猫app解压后目录：\r\n\r\n![安装包构成](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/%E5%AE%89%E8%A3%85%E5%8C%85%E6%9E%84%E6%88%90.png)\r\n\r\n\r\n\r\n目录中com和org两个文件夹是第三方包信息，不用管着两个。\r\n\r\n- assets可以存放资源和配置等各种文件，但是这里的资源文件不会像res中那样生成ID，而是通过AssetManager获取\r\n- dex是Java文件编程成class文件后又经过虚拟机优化压缩形成的\r\n- lib中存放native类库，根据不同CPU架构有四种类型：armeabi，armeabi-v7a，x86，mips。\r\n- META-INF保存了app签名信息\r\n- res中存放了资源文件\r\n- resources.arsc 记录资源文件和资源ID映射。可以根据ID查找资源\r\n- AndroidManifest.xml是app配置文件注册四大组件，声明权限等。\r\n\r\n知道了各个部分作用就大概知道了该从哪方面入手了：代码和资源，因为包中这两个部分占了很大一部分。\r\n\r\n# 0x02 代码优化\r\n\r\n代码优化其实包含了Java代码和Native代码，但是因为Native代码涉及了C和C++，这里不做阐述，但是说下lib库还是有必要的\r\n\r\n## lib库\r\n\r\n根据cpu架构lib中分为四种类型，但是目前大部分移动设备都是基于arm和arm-v7a的。x86和mips较少。而且据说x86兼容arm指令集，所以适配库优先考虑arm和arm-v7a两种即可。\r\n\r\n## 删除无用代码\r\n\r\n无用代码是指工程中那些未被引用的代码和文件， 比如未被引用的变量、 方法和类等。 \r\n\r\n这种情况的出现主要是一些在旧版本的开发中使用的变量、 方法或类在新版本中不用了或者被替换成了新的变\r\n\r\n量、 方法或类，而旧的又没有及时删除， 遗留在工程代码中  。\r\n\r\n**PMD 可以检查  未使用的局部变量、参数和private方法 **\r\n\r\n## 整理冗余代码\r\n\r\n冗余代码是指重复的代码或经过优化后可以用一段代码量更小的代码替换的代码， \r\n\r\n比如完全一样的代码、 重命名标识符后完全一样的代码、 插入或删除语句后完全一样的代码、 重新排列语句后完\r\n\r\n全一样的代码， 以及结构一样或类似的代码。 \r\n\r\n好的代码应该降低冗余度， 提高复用率， 这除了能使代码量减少， 还能提高代码可读性。  \r\n\r\n**定期codereview和使用  simian  工具都可以减少冗余代码的产生**\r\n\r\n## 减少方法数\r\n\r\n\r\n\r\n## ProGuard代码混淆\r\n\r\nProGuard具有压缩(移除无效类、方法、属性)、优化、混淆功能。\r\n\r\n- 开启混淆\r\n\r\n  ```groovy\r\n      buildTypes {\r\n          release {\r\n              minifyEnabled true\/\/开启混淆\r\n              proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' \/\/混淆文件\r\n          }\r\n      }\r\n  ```\r\n\r\n- 压缩\r\n\r\n  压缩功能是默认开启的，如果对某个或某些文件不想压缩可以使用：\r\n\r\n  `-dontshrink class * extends android.app.Activity`。\r\n\r\n- 优化\r\n\r\n  优化optimization默认开启，如果不开启可以使用：\r\n\r\n  `-dontoptimize`。一些相对复杂的方法时，压缩后可能会抛出errors，这时可以不压缩。\r\n\r\n- 混淆\r\n\r\n  混淆也是默认开启,如果对某些文件不想混淆可以使用：\r\n\r\n  `-dontobfuscate`。\r\n\r\n- 保留\r\n\r\n  如果想保留某些类、成员等不被混淆可以使用：\r\n\r\n  `-kepp`。\r\n\r\n  关于proguard更多使用方法可参考：\r\n\r\n  [Android进阶之ProGuard代码混淆](http:\/\/hanhailong.com\/2015\/12\/28\/Android%E8%BF%9B%E9%98%B6%E4%B9%8BProGuard%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86\/)\r\n\r\n  [Jean同学的Proguard私房物语](https:\/\/my.oschina.net\/u\/659658\/blog\/71976)\r\n\r\n# 0x03 资源优化\r\n\r\n这里的资源优化主要是Res资源。\r\n\r\n## 删除无用资源\r\n\r\n因为需求变更，版本更新等因素，很多研发只是一味的把新的资源文件让res下面扔，却没哟及时的把不用的文件给清理掉，长此以往导致res越来越臃肿。\r\n\r\nres资源的定时清理是很有必要的，但是资源那么多如何快速清理呢？\r\n\r\nAndroid提供了非常好用的工具Lint快速检测res中未使用的资源并给出提示。\r\n\r\n运行Analyze—>Run Inspection By Name ，弹窗输入：\r\n\r\n![lint](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/lint.png)\r\n\r\n执行结果如下：\r\n\r\n![lint_result](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/lint_result.png)\r\n\r\n其中lint.png图片没有使用，可以删除。Lint不只检测图片，而是res中所有资源包括未使用的string。\r\n\r\n\r\n\r\n## 资源混淆\r\n\r\n资源混淆简单来说就是将res\/drawable-xhdpi\/icon_pic， png变成res\/drawablexhdpi\/f.png， \r\n\r\n或我们甚至可以将文件路径也同时混淆， 改成R\/s\/f.png。 同时， 还需要修改resources.arsc中的映射关系。\r\n\r\n资源混淆能减小安装包的原因如下：\r\n\r\n- resources.arsc变小。\r\n\r\n- 文件信息变小。 由于采用了超短路径， 例如res\/drawable\/first_page.png被改为R\/o\/f.png。\r\n\r\n- 签名信息会变小。 由于采用了超短路径， 签名过程需要对每个文件使用SHA1算法生成摘要信息。\r\n\r\n\r\n\r\n  需要注意的是， 如果代码是通过getIdentifier方式获得资源， 那么这些资源需要放\r\n  置在白名单中。  \r\n\r\n\r\n\r\n## 图片处理\r\n\r\n### 图片压缩\r\n\r\n在app打包时，aapt会对图片进行压缩处理，但是这种压缩比较有限。\r\n\r\n因此我们可以再拿到设计给的图片后，使用一些工具进行二次压缩，\r\n\r\n比如Zopfli，这时谷歌开源项目。再比如PNGoo。\r\n\r\n###   JPG与PNG的转换  \r\n\r\nPNG是一种无损格式， JPG是有损格式。 \r\n\r\nJPG在处理颜色很多的图片时， 根据压缩率的不同， 有时会去掉一些肉眼识别差距较小的中间颜色。 \r\n\r\n但是PNG对于无损这个基本要求， 会严格保留所有的色彩数。 \r\n\r\n所以， 在图片尺寸大， 或者色彩数量多（特别是渐变色多） 的时候， PNG的体积会明显大于JPG。\r\n\r\n在这种情况下，我们可以有所取舍：\r\n\r\n小尺寸、 色彩数少、 或者有alpha通道透明度的时候， 使用PNG；大尺寸、 色彩渐变色多的用JPG。\r\n\r\n对于这一点的处理， 建议跟设计师进行协商， 寻求图片质量和大小的一个折中方案。\r\n\r\n> 对于可以使用JPG格式的图片， 最好不要从PNG转JPG，而是让设计师出图时直接出JPG格式的图片，\r\n>\r\n> 相对来说， 后者的效果要更好。  \r\n\r\n### 使用点9图\r\n\r\nAndroid系统程序对点9图有优化的算法。\r\n\r\n 使用点9图技术后， 只需采用一套界面切图去适配不同的分辨率， 减少了图片量， 也就减少了安装包的大小。 \r\n\r\n而且我们不需要专门做处理就可以实现其拉伸， 也减少了代码量和开发工作量。  \r\n\r\n### 图片网络化\r\n\r\n对于有些图片， 它们所在的界面本身不是特别重要或者使用比较少， 这时可以考虑把这些图片通过网络来下载。 \r\n\r\n当用户第一次进入图片所在的界面时就去下载， 下载失败影响也不是很大。\r\n\r\n适当把图片网络化处理， 也是一个比较有效的瘦身方法 。\r\n\r\n### webp图片\r\n\r\nwebp压缩⽐⽐JPG更⾼，从4.0开始支持，但是这时不支持透明度。较好地支持从4.2.2开始。\r\n\r\n### 资源图片最少化\r\n\r\n这里最少化有2个参考原则：\r\n\r\n①简单的图片shape画\r\n\r\n②多状态的图片filter画\r\n\r\n下面分别说说这两个原则都是什么意思\r\n\r\n- 简单的图片shape画\r\n\r\n  这里的简单是图形简单，颜色简单，比如矩形、圆角等纯色能用shape方便绘制出来的。\r\n\r\n- 多状态的图片filter画\r\n\r\n  这里的filter是colorFilter。\r\n\r\n  比如一些按钮都有默认背景色和选中背景色。这时设计一般会提供两套图片，如果使用colorFilter，我们只要一套就可以了。\r\n\r\n# 0x04精简第三方库\r\n\r\n很多时候可能只需要第三方库的一部分功能，这时可以根据公司业务需求进行精简，这样会有个问题就是后期的库版本更新会是个问题。\r\n\r\n# 0x05插件化\r\n\r\n把一些使用率不高的业务模块再需要的时候从服务器下载，动态加载。\r\n\r\n# 0x06zip压缩\r\n\r\n分析打包过程，对dex和res进行深度压缩。"
  },
  {
    "title": "浅谈Android性能优化系列(2)之稳定性优化",
    "created_time": "2017-09-26 17:47:22",
    "body": "# 0x00 前言\r\n\r\n上一节讲了安装包优化，本节说下稳定性优化方面入手点。\r\n\r\n相比于电量和网络，稳定性可视性更高，什么是可视性？就是用户的感知程度！\r\n\r\n电量多耗了百分之几和网络流量多跑了几兆，可能用户并不会注意到，但是一旦发生ANR或者Crash，用户基本是\r\n\r\n必感知的，而且每一次的感知都会降低对你的APP的忍耐度，一旦忍耐度耗光，你的APP也就要该卸载了。\r\n\r\n因为稳定性是个很宽泛的话题，影响因素也很多，譬如内存的不合理利用造成频繁GC，导致OOm等都可以算是稳定性范围，但是这里我们只讨论2个场景：ANR和Crash。\r\n\r\n# 0x01 ANR\r\n\r\n## ANR介绍\r\n\r\n什么是ANR？Application Not Response，应用无响应。\r\n\r\n要解决ANR，首先要知道什么原因引起的ANR才好入手，主要有一下几种类型：\r\n\r\n-  KeyDispatchTimeout ：输入事件5s未完成\r\n-  BroadcastTimeout ：广播10s未完成\r\n-  BroadcastTimeout ：服务20s未完成\r\n\r\n**其实这几个方面的根本原因就是在主线程做了耗时操作，在处理ANR时可以使用traceview查看方法耗时以便修复。**\r\n\r\n<!--more-->\r\n\r\n## ANR分析\r\n\r\n 在Android系统上，如果发生ANR，Logcat会产生对应的日志和一个trace文件，\r\n\r\n分析ANR原因主要是分析这两个信息。 \r\n\r\n### Logcat\r\n\r\n从网上找了段anr的Logcat信息看下：\r\n\r\n```\r\n07-20 15:36:58.711  1000  1520  1597 E ActivityManager: ANR in com.xxxx.moblie (com.xxxx.moblie\/.ui.MainActivity) (进程名)\r\n07-20 15:36:58.711  1000  1520  1597 E ActivityManager: PID: 1480 (进程pid)\r\n07-20 15:36:58.711  1000  1520  1597 E ActivityManager: Reason: Input dispatching timed out (AppWindowToken{da8f666 token=Token{5501f51 ActivityRecord{15c5c78 u0 com.xxxx.moblie\/.ui.MainActivity t3862}}}, Waiting because no window has focus but there is a focused application that may eventually add a window when it finishes starting up.)\r\n07-20 15:36:58.711  1000  1520  1597 E ActivityManager: Load: 0.0 \/ 0.0 \/ 0.0 (Load表明是1分钟,5分钟,15分钟CPU的负载)\r\n07-20 15:36:58.711  1000  1520  1597 E ActivityManager: CPU usage from 20ms to 20286ms later (2018-07-20 15:36:36.170 to 2018-07-20 15:36:56.436):\r\n07-20 15:36:58.711  1000  1520  1597 E ActivityManager:   42% 6774\/pressure: 41% user + 1.4% kernel \/ faults: 168 minor\r\n07-20 15:36:58.711  1000  1520  1597 E ActivityManager:   34% 142\/kswapd0: 0% user + 34% kernel\r\n07-20 15:36:58.711  1000  1520  1597 E ActivityManager:   31% 1520\/system_server: 13% user + 18% kernel \/ faults: 58724 minor 1585 major\r\n07-20 15:36:58.711  1000  1520  1597 E ActivityManager:   13% 29901\/com.ss.android.article.news: 7.7% user + 6% kernel \/ faults: 56007 minor 2446 major\r\n07-20 15:36:58.711  1000  1520  1597 E ActivityManager:   13% 32638\/com.android.quicksearchbox: 9.4% user + 3.8% kernel \/ faults: 48999 minor 1540 major\r\n07-20 15:36:58.711  1000  1520  1597 E ActivityManager:   11% (CPU的使用率)1480\/com.xxxx.moblie: 5.2%(用户态的使用率) user + (内核态的使用率) 6.3% kernel \/ faults: 76401 minor 2422 major\r\n07-20 15:36:58.711  1000  1520  1597 E ActivityManager:   8.2% 21000\/kworker\/u16:12: 0% user + 8.2% kernel\r\n07-20 15:36:58.711  1000  1520  1597 E ActivityManager:   0.8% 724\/mtd: 0% user + 0.8% kernel \/ faults: 1561 minor 9 major\r\n07-20 15:36:58.711  1000  1520  1597 E ActivityManager:   8% 29704\/kworker\/u16:8: 0% user + 8% kernel\r\n07-20 15:36:58.711  1000  1520  1597 E ActivityManager:   7.9% 24391\/kworker\/u16:18: 0% user + 7.9% kernel\r\n07-20 15:36:58.711  1000  1520  1597 E ActivityManager:   7.1% 30656\/kworker\/u16:14: 0% user + 7.1% kernel\r\n07-20 15:36:58.711  1000  1520  1597 E ActivityManager:   7.1% 9998\/kworker\/u16:4: 0% user + 7.1% kernel\r\n```\r\n\r\n从上面Logcat信息中，可以提取到几个关键信息，：\r\n\r\n·ANR IN：发生ANR的具体类。\r\n\r\n·PID：发生ANR的进程，系统在此时会生成trace文件，当前的时间点也是发生ANR的具体时间，以及生成trace文件的时间。\r\n\r\n·Reason：当前ARN的类型以及导致ANR的原因。\r\n\r\n·CPU usage：CPU的使用情况，在日志中CPU usage有两个时间点，第一个是发生ANR前的CPU使用情况，第二个是发生ANR后的CPU使用情况。\r\n\r\n从Logcat中除了能看出在哪个类发生ANR以及ANR的类型，具体的原因主要还是看CPU的使用情况\r\n\r\n如果CPU使用少，说明主线程可能阻塞，如果IOwait很高，说明可能是由于主线程进行耗时的I\/O操作造成的。\r\n\r\n但是Logcat不一定保证在发生ANR时可以拿到，并且ANR的原因复杂。这时候我们可以分析traces.txt，\r\n\r\n这个文件保存在\/data\/anr\/traces.txt。\r\n\r\n### trace.txt\r\n\r\n在Android Studio上提供了一个分析trace文件的工具：Analyze Stacktrace。\r\n\r\nAnalyze Stacktrace可以更直观地分析导致ANR的原因。\r\n\r\nAnalyze Stacktrace使用方法如下：\r\n\r\n1）在Android Studio的工具栏中，选择Analyze→Analyze Stacktrace，打开Analyze Stacktrace工具窗口。\r\n\r\n2）将traces.txt中的内容复制到窗口，单击Normalize按钮，生成Thread Dump列表，左边为所有线程列表，\r\n\r\n右边为选中线程的具体信息。\r\n\r\n3）如果某个线程被标红，说明此线程被堵塞了，然后在右边的详细信息中查看堵塞的具体原因。\r\n\r\n## 找出ANR\r\n\r\n上面的分析是在ANR出现后我们需要做的，\r\n\r\n那么在开发过程中我们如何尽量避免ANR？\r\n\r\n通过Android系统提供的工具可以帮助我们及时发现这些问题：\r\n\r\n### StrictMode\r\n\r\n```kotlin\r\nStrictMode.setThreadPolicy(StrictMode.ThreadPolicy.Builder()\r\n                                       .detectDiskReads()\r\n                                       .detectDiskWrites()\r\n                                       .detectNetwork()\r\n                                       .build())\r\n```\r\n\r\n### Traceview\r\n\r\n\r\n\r\n# 0x02 Crash\r\n\r\n## Java Crash监控\r\n\r\n人无完人，同样我们也不可能一次写出完美的程序。如果异常不能避免，那我们除了做好必要的减少异常措施，还要实现一套良好的异常捕获机制，以便研发人员及时收集异常信息进行修复。\r\n\r\n关于未知异常捕获，Android系统为我们提供了一个类：`UncaughtExceptionHandler`。\r\n\r\n```java\r\npackage com.example.jenson.myapplication;\r\n\r\nimport android.content.Context;\r\nimport android.os.Build;\r\n\/**\r\n * Created by jenson on 2017\/9\/26.\r\n *\/\r\n\r\npublic class CrashHandler implements Thread.UncaughtExceptionHandler {\r\n    private Thread.UncaughtExceptionHandler mDefaultHandler;\r\n    private static CrashHandler mInstance;\r\n    private Context mContext;\r\n\r\n    private CrashHandler() {\r\n    }\r\n\r\n    \/**\r\n     * 获取CrashHandler实例\r\n     *\/\r\n    public static synchronized CrashHandler getInstance() {\r\n        if (null == mInstance) {\r\n            mInstance = new CrashHandler();\r\n        }\r\n        return mInstance;\r\n    }\r\n\r\n    public void init(Context context) {\r\n        mContext = context;\r\n        mDefaultHandler = Thread.getDefaultUncaughtExceptionHandler();\r\n        \/\/设置该CrashHandler为系统默认的\r\n        Thread.setDefaultUncaughtExceptionHandler(this);\r\n    }\r\n\r\n\r\n    @Override\r\n    public void uncaughtException(Thread t, Throwable e) {\r\n        if (!handleException(e) && mDefaultHandler != null) {\r\n            \/\/如果自己没处理交给系统处理\r\n            mDefaultHandler.uncaughtException(t, e);\r\n        } else {\r\n            \/\/自己处理\r\n        }\r\n\r\n    }\r\n\r\n    \/**\r\n     * 收集错误信息.发送到服务器\r\n     *\r\n     * @return 处理了该异常返回true, 否则false\r\n     *\/\r\n    private boolean handleException(Throwable ex) {\r\n        if (ex == null) {\r\n            return false;\r\n        }\r\n        \/\/收集设备参数信息\r\n        \/\/发送到服务器\r\n        return true;\r\n    }\r\n}\r\n\r\n```\r\n\r\n在Application中调用`CrashHandler.getInstance().init(this)`。\r\n\r\n## Native Crash监控\r\n\r\nLinux发生Crash时也会生成dump文件，在Linux中，信号量不光是一种常见IPC机制，也负责系统异常和中断。\r\n\r\nAndroid系统基于Linux内核，所以如果我们可以捕捉异常信号并处理相应函数就可以了。\r\n\r\n关于Native Crash监控可以参考：\r\n\r\n[Android 平台 Native 代码的崩溃捕获机制及实现]( https:\/\/cloud.tencent.com\/developer\/article\/1071749 )\r\n\r\n\r\n\r\n# 0x03 提高代码质量\r\n\r\n代码质量和稳定性一样，都是很宽泛的话题，市面介绍如何编写高质量代码的书籍也很多。\r\n\r\n但是由于程序员之间水平不同、人员变动、项目时间紧凑等原因，导致代码质量下降是难免的。\r\n\r\n为了解决这个问题引入**代码审查**和**重构**是十分必要的。\r\n\r\n## 代码审查\r\n\r\n到了这一步，有一个www问题：when（什么时候审查）、who(谁来审查) 、what(审查什么)\r\n\r\n### 何时审查\r\n\r\n如果是开发进度中进行审查，可以只审查基础模块、新手代码和修改过的模块。\r\n\r\n基础模块譬如公共的网络模块、图片模块等。\r\n\r\n关于核心业务模块也是一个审查点。\r\n\r\n### 谁来审查\r\n\r\n一般来说可以不用固定审查模式，譬如结对审查、模块负责人审查、团队审查可以定期交替执行。\r\n\r\n### 审查什么\r\n\r\n团队内部在审查之前确定好目标要审查哪些东西？譬如设计思想、代码风格、业务逻辑等。\r\n\r\n不要流于形式、漫无目的，这样只会浪费时间，没有实际意义。\r\n\r\n关于代码风格，可以使用阿里的java规范插件。\r\n\r\n参考http:\/\/www.techug.com\/post\/code-review-2.html\r\n\r\n## 代码扫描\r\n\r\n静态代码分析是指通过分析或检查源代码的语法、结构、过程、接口等来检查程序的正确性，找出代码隐藏的错误\r\n\r\n和缺陷，比如参数类型不匹配、错误的递归、线程安全、非法计算，以及可能出现的空指针引用等。 \r\n\r\nJava项目常用静态扫描工具有：Lint、FindBugs、CheckStyle和PMD。\r\n\r\n![静态扫描工具对比](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/%E9%9D%99%E6%80%81%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7%E5%AF%B9%E6%AF%94.png)"
  },
  {
    "title": "浅谈Android性能优化系列(4)之耗电优化",
    "created_time": "2017-09-26 18:26:54",
    "body": "# 0x00 前言\r\n\r\n作为移动设备，电池重要性不言而喻，设备没有电那就真的只能拿来砸核桃了。所以作为开发者的我们，为了给用户带来更好的体验，耗电优化一直是我们撇不开的话题。\r\n\r\n# 0x01 为什么耗电\r\n\r\n![屏幕快照 2017-03-23 下午2.51.24.png](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/%E7%94%A8%E6%88%B7app%E8%80%97%E7%94%B5.png)\r\n\r\n通过上图先把用户-电量这一流程抽象出来，\r\n\r\n设备的耗电和硬件本身无关，根本原因在于对硬件的使用，耗电越严重说明对硬件使用的越频繁。\r\n\r\n<!-- more -->\r\n\r\n先看下移动设备元件耗电大户有哪些：\r\n![fullsizerender.jpg](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/%E8%80%97%E7%94%B5%E6%A8%A1%E5%9D%97%E6%AF%94%E4%BE%8B%E5%9B%BE.png)\r\n\r\n# 0x02 屏幕\r\n\r\n屏幕是耗电最大元件之一，但是用户要和app交互就要点亮屏幕，有人可能会觉得屏幕的明暗是用户自己根据喜好设定的，我们无可奈何。其实不然，在有些时候是可以通过UI的设计来减少屏幕电能消耗的。\r\n\r\n在这之前我们先来看下目前常用手机屏幕材质：LCD和LED(OLED)。\r\n\r\n- LCD概述\r\n  LCD又名液晶显示屏，屏幕由成千上万液晶分子负责像素显示，并通过背光来将其照亮。所以说每个像素点都使用了同一个光源，每个像素消耗的电量是相同的。\r\n\r\n- LED概述\r\n  LED每个屏幕像素都可以看成是一个LED灯，由RGB三种颜色共同呈现，不同颜色能量消耗也各不相同。黑色不使用任何颜色，不消耗能量，白色相反使用了所有颜色且亮度高，所以能量消耗也更多。\r\n\r\n  \r\n\r\n  \r\n\r\n  **优化方案：较暗的颜色比明亮的颜色更节能，所以在很多留白的地方可以考虑使用偏暗的色调，当然这要在不影响用户体验的前提下。**\r\n\r\n# 0x03 网络\r\n\r\n参考[浅谈Android性能优化系列(3)之网络优化](http:\/\/www.jensondev.me\/2017\/09\/26\/%E6%B5%85%E8%B0%88Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%B3%BB%E5%88%97-4-%E4%B9%8B%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96\/)\r\n\r\n# 0x04 CPU\r\n\r\n当应用退到后台运行时， 尽量减少应用的主动运行。\r\n\r\n锁屏、 灭屏、 程序 放置后台时，释放或停止Android涉 及耗电的服务。\r\n\r\n当检测到CPU时间片消耗异常时， 深入线程分析： \r\n\r\n通过获取运行过程中线程的CPU时间片消耗， 去抓取消耗时间片异常的线程， 通过线程去定位相应代码逻辑。\r\n\r\n使用**traceview**，定位CPU占用率异常的方法。\r\n\r\n## 位移替代除法\r\n\r\n浮点运算比整数运算相对更消耗cpu时间片，相应耗电也就增加，因而在编码过程尽量减少浮点运算，\r\n\r\n例如使用位移代替除法。\r\n\r\n## 动画释放\r\n\r\n对于动画效果比较炫的界面， 灭屏后CPU占用率仍然很高，\r\n\r\n最可能的原因就是动画没有及时释放。   \r\n\r\n## 避免wakelock不正确使用\r\n\r\nwakelock可以唤醒设备也可以阻止设备休眠。\r\n\r\n在PowerManager类中谷歌已经声明了：\r\n\r\n这个类会影响设备电量，除非必须，否则尽量不要使用该类，同时使用完毕要尽快释放。\r\n\r\nwankelock有几种类型，在使用时注意选择正确地类型。\r\n\r\n降低对系统的唤醒频率， 使用partial wake lock代替full wake lock， \r\n\r\n因为屏幕的亮起， 也会消耗手机电量。\r\n\r\n在注册后，也要注意及时释放，否则锁的持有时间会被一直计算到电量消耗中。  \r\n\r\n无论是间接还是直接 的，否则会让CPU 无法休眠， 导致严重的耗电问题。\r\n\r\n### 注意兼容wakeLock\r\n\r\nWakeLock有一个接口setReferenceCounted， 用来设置WakeLock的计数机制， \r\n\r\n官方默认为计数：true为计数， false为不计数。 \r\n\r\n所谓计数即每一个acquire必须对应一个release； \r\n\r\n不计数则是无论有多少个acquire， 一个release就可以释放。\r\n\r\n虽然官方说默认是计数的， 但是有的第三方ROM做了修改， 使默认是不计数的。\r\n\r\n所以在使用时注意查看并设置好兼容性问题。\r\n\r\n### 间接引用wakeLock\r\n\r\n在调用音视频API时，看似我们只是简单调用了Media某些功能，\r\n\r\n但是深入API分析会发现其源码内部一些地方间接使用了wakeLock。\r\n\r\n所以如果在退入后台后音视频资源没有及时释放，也就间接导致wakeLock一直注册中。\r\n\r\n## JobScheduler\r\n\r\n很多时候为了满足我们的需求而没有考虑cpu的感受，\r\n\r\n为了执行1s中的数据去唤醒cpu，但实际却消耗了约两分钟的电量。\r\n\r\n为此谷歌在5.0系统下提供了JobScheduler组件，使用场景：\r\n\r\n必要不紧急，可延迟执行的任务，比如数据块更新，bug日志上报。\r\n\r\n耗电大的任务，如备份在充电时执行。\r\n\r\n## Doze模式\r\n\r\nDoze模式通过限制应用访问网络及其他一些操作频率，从而减少cpu开销达到省电目的。\r\n\r\n在6.0系统上未连接电源、屏幕关闭就会进入Doze模式。\r\n\r\n但是为了不影响应用正常工作，系统还会周期性退出Doze，\r\n\r\n在退出期间去执行那些被挂起的任务，这个时间窗口称作维护窗口。\r\n\r\n# 0x05 其他优化\r\n\r\n## 传感器\r\n\r\n每个传感器都有最大信号频率，开发者在使用传感器时要设置合适的采样频率。\r\n\r\n最后在使用完成后一定要进行注销，否则激活的传感器会一直进行检测，造成cpu负载和电量消耗。\r\n\r\n为了耗电优化干的这些活用户感知不到，但是如果不去优化，肆意使用，那用户就很容易感知到了。"
  },
  {
    "title": "浅谈Android性能优化系列(3)之网络优化",
    "created_time": "2017-09-26 18:00:31",
    "body": "# 0x00 前言\r\n\r\n无线网络主要是WIFI和移动运营商网络，通常情况下使用移动网络要比WIFI耗电要多一些。\r\n\r\n# 0x01 无线状态机\r\n\r\n### 移动网络\r\n\r\n移动网络数据传输有3种状态：\r\n\r\n<!-- more -->\r\n\r\n**Full power**：高功率状态，网络激活，允许设备以最大传输速率进行传输。\r\n\r\n**Low power**：低功率状态，传输速率低于15kbps，耗电是Full Power状态的一半，一般不能直接从程序中进入该\r\n\r\n状态，而是由Full Power状态降级进入。\r\n\r\n**Standby**：空闲状态，没有数据连接需要传输，耗电最少。\r\n\r\n这三种状态有一个转换流程：\r\n\r\n![mobile_radio_state_machine.png](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/mobile_radio_state_machine.png)\r\n\r\n\r\n\r\n> 可以看出，三种状态耗电不同，要使耗电最低应该尽量保持状态在空闲或低功率下。\r\n>\r\n> 从空闲状态转换到高功率状态需要2s，从低功率状态转换到高功率状态需要1.5s。\r\n>\r\n> 应用中每创建一个网络连接，网络射频都会转到高功率状态，数据传输完毕降回低功率状态，\r\n>\r\n> 降回过程需要5s，这5s耗电量保持在高功率状态，低功率降回到空闲状态需要12s，\r\n>\r\n> 期间一直保持低功率状态。所以每次的数据传输都将导致将近20s电量的消耗。\r\n\r\n### WIFI网络\r\n\r\nWIFI在active状态下有4种模式：低功率、高功率、低传输、高传输。\r\n\r\n当从低(高)功率状态传输数据时，WIFI会暂时进入相应地低(高)传输状态，一旦数据传输完毕就回到初始状态。\r\n\r\n> WIFI耗电是受包率(每秒接收和发送的数据包)和网速因素影响的。\r\n>\r\n> 如果因素良好，即网络良好时，数据传输的很快，所以WIFI的高功率状态维持时间很短。\r\n>\r\n> 这也就是说移动网络耗电高于WIFI耗电，因为同样的数据大小传输时，\r\n>\r\n> 移动网络固定状态转换就需要近20s的电量消耗。\r\n\r\n\r\n\r\n通过上面了解网络连接过程，应该心里有了大概的优化建议。\r\n\r\n# 0x02 网络优化方案：\r\n\r\n优化从**减少请求大小**和**减少请求次数**两方面着手。\r\n\r\n### 压缩文本文件\r\n\r\n不管发送还是请求数据，在数据传输过程中使用gzip将数据进行压缩。经过压缩的数据需要更短的时间传输即可完成，这样是无线所处的高功率状态时间更短，从而减少了耗电。\r\n\r\n### 精简文本文件\r\n\r\n精简是另外一个缩小文本文件的方式。精简过程就是去掉文本文件中所有只具有方便阅读\r\n\r\n作用的格式（比如空格、制表符和注释），进而使文件变小。   \r\n\r\n```html\r\n<html>  \r\n  <title> A Sample Page<\/title> \r\n  <body> \r\n \t with some sample text \r\n\t\t<--do more here--> \r\n\t<\/body> \r\n<\/html>\r\n```\r\n\r\n精简后\r\n\r\n```html\r\n<html><title> A Sample Page<\/title><body> with some sample text \t\t\t<--do more here--><\/body><\/html>\r\n```\r\n\r\n### 图片\r\n\r\n#### 根据显示大小从服务器获取图片\r\n\r\n请求一个图片时，客户端提供一个分辨率大小，服务器根据分辨率把裁剪缩放后的图片给客户端返回。\r\n\r\n也可以使用Android端使用Bitmap.Option自行获取缩放的图片。\r\n\r\n#### 压缩图片\r\n\r\n图片适用的有损压缩率取决于图片的用途。 对缩略图而言，压缩率可以更高，\r\n\r\n因为它们本身就很小，很难发现有粒子或像素变化。  可以采用webp格式\r\n\r\n#### 去掉图片元数据\r\n\r\n当用数码相机拍照片时， 文件里很可能有与照片相关的元数据（包括设备名称、设备设置\r\n\r\n以及拍摄地点等信息）。\r\n\r\n照片编辑软件也会给图片增加一些元数据。\r\n\r\n 除非 App 是讨论照片拍摄方法和编辑技巧的摄影 App， \r\n\r\n否则你可以去掉照片上所有相关的元数据，将这些几字节到几十千字节不等的元数据保存在其他地方，\r\n\r\n这样不会损坏发送给用户的图片的质量。  \r\n\r\n### 文件缓存。\r\n\r\n把经常使用的文件缓存到本地，如头像icon、好友信息等。以后可以直接从本地读取缓存减少网络请求次数。\r\n\r\n### 分组连接\r\n\r\n移动网络下最好批量执行网络请求，利用一次高功率状态执行尽可能多的事情，\r\n\r\n从而减少频繁间隔请求导致状态转换消耗更多电量。\r\n\r\n例如版本检查和日志上传这些可以分配在同一时间段请求。\r\n\r\n再比如获取数据时，一次获取多页数据。\r\n\r\n### 网络判断\r\n\r\n根据不同的网络状态执行不同的逻辑。\r\n\r\n如果在移动网络状态下推迟非紧急请求，在连接到wifi时执行请求。\r\n\r\n在WiFi和移动网络不同状态时执行同一套逻辑的不同数据量请求。"
  },
  {
    "title": "浅谈Android性能优化系列(5)之UI优化",
    "created_time": "2017-09-26 18:30:30",
    "body": "# 0x00 前言\r\n\r\n研究显示，0-100ms的延迟会让用户感知到瞬时的卡顿，100-300ms的延迟会让用户感觉迟缓，\r\n\r\n300-1000ms的延迟让用户感觉“手机卡死了”，1000ms以上的延迟会让用户想要去干别的事情，\r\n\r\n由此可见保持UI流畅的重要性。\r\n\r\n造成卡顿的原因是什么呢？\r\n\r\n大概了解Android系统显示原理后可以知道，\r\n\r\n造成卡顿根本原因有3个方面：\r\n\r\n- UI太复杂\r\n\r\n  UI过于复杂，导致即使其他条件完备，但是CPU和GPU加班加点也干不完\r\n\r\n- 主线程太忙\r\n\r\n  看看主线程是否有执行耗时操作(网络\/IO\/密集计算)。StrictMode是个不错的工具类。\r\n\r\n- CPU太忙\r\n\r\n  在做UI绘制任务同时，后台还在一直抢占CPU时间片。\r\n\r\n# 0x01 优化到什么程度\r\n\r\n如今屏幕刷新频率大都是60FPS，就是说每帧绘制只要16ms，\r\n\r\n即保证你的UI页面在16ms内绘制渲染完成，就会让用户感觉到体验是流畅的，\r\n\r\n所以我们需要做的就是确保我们的APP页面渲染小于16ms。\r\n\r\n\r\n\r\n<!-- more -->\r\n\r\n\r\n\r\n# 0x02 如何优化\r\n\r\n## 布局优化\r\n\r\n### 减少xml布局层级\r\n\r\nxml布局最终会被解析成view tree。\r\n\r\n解析过程就是树的遍历过程，其复杂度和层级成正相关性。\r\n\r\n>通过Lint扫描配置 TooDeepLayout和TooManyViews两个地方，最终扫描出布局太深、控件太多有问题的布局文件。\r\n>\r\n>通过Hierarchy  View检测布局测量、布局、绘制耗时，优化黄色和红色控件。\r\n\r\n### Merge的使用\r\n\r\nMerge是合并的意思，使用Merge合并子元素和父View，而Merge本身可以被忽略。使用Merge的场合：\r\n\r\nxml布局中，根元素是FrameLayout时；\r\n\r\n自定义View中，父元素尽量是FrameLayout或者LinearLayout；\r\n\r\n>Merge不能乱用：\r\n>\r\n>Merge只能用在xml布局根元素；\r\n>\r\n>使用Merge加载一个布局时，必须制定一个ViewGroup作为其父元素，并且设置attachToRoot参数为True（inflate(int,ViewGroup,boolean)）；\r\n>\r\n>不能在ViewStub中使用Merge标签，原因就是ViewStub的inflate方法中没有attachToRoot的设置\r\n\r\n### 合理使用RelativeLayout和LinearLayout\r\n\r\nRelativeLayout一定程度上可以减少布局层级，但是其对子View测量次数多于LinearLayout。\r\n\r\n所以综合考虑：\r\n\r\n> 如果层级较多情况下，使用RelativeLayout能减少层级的话，\r\n>\r\n> 优先使用RelativeLayout以便保持界面扁平化；\r\n>\r\n> 如果层级相同的情况下优先使用LinearLayout，这样能减少子View多次测量。\r\n\r\n### ViewStub提高加载速度\r\n\r\nViewStub默认不可见不占位置，\r\n\r\n如果在特定情况下才显示某些布局，可以使用ViewStub。\r\n\r\n显示ViewStub有两种方法：ViewStub.inflate()和ViewStub.setVisibility(View.Visible)；\r\n\r\n> 使用ViewStub注意：\r\n>\r\n> Viewstub只能加载一次，之后该对象引用会被置空；\r\n>\r\n> Viewstub只能用来加载一个布局文件，而不是某个View\r\n>\r\n> Viewstub中不能嵌套Merge\r\n\r\n### include实现view复用\r\n\r\n对于在多个页面都会使用的公共布局诸如Title栏或导航栏，提取出来通过使用inlucde引入，\r\n\r\n这样只需要维护一份代码即可。\r\n\r\n## 避免过度绘制\r\n\r\n### 什么是过度绘制\r\n\r\n过度绘制是说屏幕上某一像素在同一帧时间内被绘制多次。\r\n\r\n在UI布局中如果不可见的部分UI也在进行绘制，这会导致浪费多余的CPU和GPU资源。\r\n\r\n### 引起过度绘制原因\r\n\r\nxml布局中控件重叠且都设置了背景或图片\r\n\r\n自定义View，onDraw方法中同一区域绘制了多次\r\n\r\n### 如何避免过度绘制\r\n\r\n#### 布局优化\r\n\r\n移除xml中非必须背景，或根据条件设置\r\n\r\n移除window默认背景\r\n\r\n按需设置占位背景图\r\n\r\n#### 自定义View优化\r\n\r\n在自定义 View中可以通过 `canvas.clipRect()`来帮助系统识别那些可见的区域 。\r\n\r\n这个方法可以指定一块矩形区域 ，只有在这个区域内才会被绘制 ，其他的区域会被忽视 。\r\n\r\n `canvas.clipRect()`可以很好地帮助那些有多组重叠组件的自定义View来控制显示的区域 。\r\n\r\n `canvas.clipRect()`方法还可以帮助节约CPU与GPU资源 ，\r\n\r\n在 `canvas.clipRect()`区域之外的绘制指令都不会被执行 ，\r\n\r\n那些部分内容在矩形区域内的组件 ，仍然会得到绘制 ，\r\n\r\n并且可以使用`canvas.clipRect()`来判断是否没和某个矩形相交 ，\r\n\r\n从而跳过那些非矩形区域内的绘制操作 。\r\n\r\n## 合理使用动画\r\n\r\n动画对于提高视觉感官舒适度很有帮助，\r\n\r\n对于IO等耗时操作给予适当的动画提示在一定程度上提高用户体验。\r\n\r\n> Android系统3.0开始提供了属性动画，在使用动画时优先考虑属性动画，\r\n>\r\n> 因为属性动画不但效果更多，性能也大大提高，减少了很多重绘。\r\n>\r\n> 虽然属性动画减少重绘，但是重绘仍然存在，\r\n>\r\n> 如果要再次提升性能，可以使用硬件加速。\r\n>\r\n> 如果怕硬件加速引发一些其他问题，\r\n>\r\n> 可以在动画执行前设置 ：View的LayerType为LAYER_TYPE_HARDWARE。\r\n>\r\n> 然后在动画结束后设置：View的LayerType为NONE。  \r\n\r\n## UI线程避免耗时操作\r\n\r\nAndroid4.0以后在UI线程执行网络操作会出现` NetworkOnMainThreadException `。\r\n\r\n所以这里主要检测I\/O和计算密集型任务。\r\n\r\n通过`StrictMode`和`TraceView`可以方便的检测耗时方法。\r\n\r\n## UI频繁绘制时减少后台其他操作\r\n\r\n这里主要指在列表滑动过程中暂停数据的下载。\r\n\r\n待停止滑动后再去请求网络。"
  },
  {
    "title": "浅谈Android性能优化系列(6)之内存优化",
    "created_time": "2017-09-26 18:35:54",
    "body": "# 0x00 前言\r\n\r\n内存从状态上来说只有已使用和未使用两种。\r\n\r\n所以内存优化也从这两方面下手：\r\n\r\n保证已使用内存的顺利回收，\r\n\r\n保证未使用内存的合理申请。\r\n\r\n\r\n\r\n<!-- more -->\r\n\r\n\r\n\r\n# 0x01 顺利回收已使用内存\r\n\r\n## Java对象生命周期\r\n\r\n- 创建阶段\r\n\r\n  申请内存空间，构造对象并初始化相关属性值\r\n\r\n- 使用阶段\r\n\r\n  根据对象应用调用相关方法完成业务逻辑。\r\n\r\n  对象至少被一个强引用持有，除非对象创建时显示声明使用软引用、弱引用和虚引用。\r\n\r\n- 不可见阶段\r\n\r\n  当一个对象处于不可见阶段时，说明程序本身不再持有该对象的任何强引用，当然对象还是存在着的。\r\n\r\n- 不可达阶段\r\n\r\n  对象处于不可达阶段是指该对象不再被任何强引用所持有。GC会发现对象已不可达\r\n\r\n- 收集阶段\r\n\r\n  当垃圾回收器发现该对象已经处于“不可达阶段”\r\n\r\n  并且垃圾回收器已经对该对象的内存空间重新分配做好准备时，则对象进入了“收集阶段”。\r\n\r\n- 终结阶段\r\n\r\n  当对象执行完finalize()方法后仍然处于不可达状态时，则该对象进入终结阶段。\r\n\r\n  在该阶段，等待垃圾回收器对该对象空间进行回收。\r\n\r\n- 对象空间重新分配阶段\r\n\r\n  若垃圾回收器对该对象的所占用的内存空间进行回收或者再分配，则该对象彻底消失，\r\n\r\n  这个阶段称之为“对象空间重新分配阶段”。\r\n\r\n以上是Java对象生命周期的简要介绍，要保证内存顺利回收，\r\n\r\n正确使用Java对象生命周期很重要，如果不能及时回收，我们就称之为“发生了内存泄露”。\r\n\r\n>在不可见阶段，程序本身不再持有对象强引用，\r\n>\r\n>但对象仍可能被JVM等系统下的某些已装载的静态变量或线程或JNI等强引用持有着，\r\n>\r\n>这些特殊的强引用被称为”GC root”。\r\n>\r\n>存在着这些GC root会导致对象的内存泄露情况，无法被回收。\r\n\r\n\r\n![垃圾回收.jpeg](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/gc%20root.png)\r\n\r\n图中灰色的孤立无援的对象对于GC Roots来说不可达，会被回收。\r\n\r\n知道了内存泄露会影响回收，下面说下哪些方面会导致内存泄露\r\n\r\n## 引起内存泄露的情况\r\n\r\n### 资源没有适时关闭\r\n\r\nsqlite的cursor、读写文件使用的File文件流等在使用完后没有及时关闭。\r\n\r\n虽然cursor会在系统回收时自动关闭，但是这样效率较低。\r\n\r\n对于资源对象使用还是应该养成良好习惯，使用完毕close并置空。\r\n\r\n### 注册对象未注销\r\n\r\n在Android中主要是指注册的广播在Activity销毁时反注销。\r\n\r\n在Activity中如果有使用的观察者模式在生命周期发生变化时根据需求注销。\r\n\r\n在Activity中使用的各类传感器(光线、重力等)在页面销毁时及时注销，\r\n\r\n否则不光导致内存泄露还会因为传感器频繁的采样导致耗电及cpu的占用。\r\n\r\n### 使用static修饰变量\r\n\r\n这里只说一点，被static修饰的变量可以认为是直接被GC Roots引用了，那你就知道其生命周期有多长了。\r\n\r\n这时候你如果用static 修饰Bitmap、View、Context和Activity等后果有多严重了吧。\r\n\r\n### 非静态内部类的静态实例\r\n\r\n先看几行代码：\r\n\r\n```java\r\npublic class MainActivity extends AppCompatActivity {\r\npublic static People people;\r\n\t @Override\r\n \tprotected void onCreate(Bundle savedInstanceState) {\r\n  \t\t super.onCreate(savedInstanceState);\r\n  \t\t setContentView(R.layout.activity_main);\r\n  \t\t people = new People();\r\n \t}\r\n\t class  People{\r\n  \t\t int age ;\r\n  \t\t String name ;\r\n \t}\r\n}\r\n```\r\n\r\n非静态内部类People持有外部类即当前Activity的引用，\r\n\r\n而该非静态内部类实例又是static修饰的，导致Activity一直被持有而不得释放，\r\n\r\n最终导致Activity所包含的view不能释放，如果viewtree中包含多图片，那泄露的内存是很大的。\r\n\r\n### Handler\r\n\r\n众所周知handler用来发送和处理消息回调的。\r\n\r\nhandler导致泄露主要是handler实例是作为非静态匿名内部类方式创建，\r\n\r\n并且MessageQueue队列中有未处理消息，这时如果退出Activity，\r\n\r\nMessageQueue中还有Message，而Message持有handler实例，\r\n\r\nhandler实例作为非静态内部类持有Activity引用，最终的连锁反应导致Activity泄露。\r\n\r\n>handler引起的内存泄露一般是临时性的，\r\n>\r\n>因为消息队列里的Message在延时到时间或者某一情况激活后还是会执行的，\r\n>\r\n>除非你是故意搞事情。\r\n>\r\n>创建handler时最好使用静态内部类，\r\n>\r\n>同时在Activity退出时执行 `handler.removeCallbacksAndMessages(null);`清空队列消息\r\n\r\n### Webview\r\n\r\nwebview的使用总是会莫名的出现各种问题或泄露。\r\n\r\n#### 反射解决\r\n\r\n高手在民间，有网友用反射解决掉了引用造成的内存泄漏。\r\n\r\n```java\r\npublic void setConfigCallback(WindowManager windowManager) {\r\n    try {\r\n        Field field = WebView.class.getDeclaredField(\"mWebViewCore\");\r\n        field = field.getType().getDeclaredField(\"mBrowserFrame\");\r\n        field = field.getType().getDeclaredField(\"sConfigCallback\");\r\n        field.setAccessible(true);\r\n        Object configCallback = field.get(null);\r\n\r\n        if (null == configCallback) {\r\n            return;\r\n        }\r\n\r\n        field = field.getType().getDeclaredField(\"mWindowManager\");\r\n        field.setAccessible(true);\r\n        field.set(configCallback, windowManager);\r\n    } catch(Exception e) {\r\n    }\r\n}\r\n```\r\n\r\n在Activity生命周期中调用：\r\n\r\n```java\r\npublic void onCreate(Bundle savedInstanceState) {\r\n    super.onCreate(savedInstanceState);\r\n\t\t setConfigCallback((WindowManager)getApplicationContext().getSystemService(Context.WINDOW_SERVICE));\r\n}\r\n\r\npublic void onDestroy() {\r\n    setConfigCallback(null);\r\n    super.onDestroy();\r\n}\r\n```\r\n\r\n这种操作并不适用所有Android系统，有些版本更新较大可能不适用了。\r\n\r\n#### web进程\r\n\r\n用独立进程来解决内存问题， 独立进程在Android框架下非常简单， \r\n\r\n在官网Androidmanifest的＜activity＞介绍中， 讲解了有关android： process属性的设置，\r\n\r\n 一旦设置了这个属性， 这个Activity的启动就会被投射到一个你所命名的进程当中， \r\n\r\n最后在Activity的onDestory函数中退出进程，这样即可基本上终结此类泄漏。  \r\n\r\n如果需要交互使用aidl。\r\n\r\n### 容器中的对象未清理对象\r\n\r\nAndroid中使用的容器最多的就是List和Map。\r\n\r\n用来存储对象集合，如果对象集合和页面相关，那么在退出页面时注意清空集合。\r\n\r\n同时不要使用static修饰集合。\r\n\r\n# 0x02 合理申请未使用内存\r\n\r\n上面说完了如何保证GC顺利回收，现在来讲讲要最小使用内存应该怎么做：\r\n\r\n## 慎用自动封装\r\n\r\n来几行代码尝尝：\r\n\r\n```\r\n      Integer num=0;\r\n      for (int i=0;i<100;i++) {\r\n          num+=i;\r\n      }\r\n```\r\n\r\nJava基本数据类型是有自动装箱机制的。\r\n\r\n每次执行循环都会发生一次装箱操作创建一个Integer对象，造成内存消耗。\r\n\r\n包括其他基本数据类型都有可能造成这种情况。\r\n\r\n为了减少自动装箱，对于一些类已经有了相关的优化类，\r\n\r\n譬如Java8中的Stream，有对应的IntStream、LongStream等。\r\n\r\n## 内存复用\r\n\r\n### 视图复用\r\n\r\n在ListView中使用ViewHolder复用item组件，一方面节省内存，一方面提高滑动流畅性。都用过不多介绍。\r\n\r\n### 使用对象池\r\n\r\n看过Handler、Looper、Message、MessageQueue这一套消息循环源码的同志应该知道里面的Message使用了对象池模式。\r\n\r\n> 对象池类似线程池， 首先初始化一个固定大小池子，每次创建对象时候先去池子中找有没有，\r\n>\r\n> 如果有直接取出，如果没有new出来使用后还到池子里。这样便可达到对象复用的目的。\r\n>\r\n> 对象池模式适用于那些频繁使用创建的对象，\r\n>\r\n> 比如一个聊天app，里面对象最多的恐怕就是聊天信息(每条聊天信息对应一个信息对象)。\r\n>\r\n> 都知道对象的创建是很耗费时间和内存的，没事不要new着玩。\r\n>\r\n> 如果每条消息都创建一个对象，那可想而知该APP的性能。\r\n\r\n对象池的使用也很简单，少量代码即可完成：\r\n\r\n\r\n```Java\r\npublic class People {\r\nprivate static final Pools.SynchronizedPool<People> sPool = new Pools.SynchronizedPool<People>(20);\/\/需要维持对象的数量\r\nint age;\r\nString name;\r\n  \r\n  public static People obtain() {\r\n    People instance = sPool.acquire();\r\n    return (instance != null) ? instance : new People();\r\n  }\r\n  public void recycle() {\r\n     sPool.release(this);\r\n  }\r\n}\r\n```\r\n\r\n> 注意：对象申请(obtain)和释放(recycle)成对出现，使用一个对象后一定要释放还给对象池。\r\n\r\n### Bitmap复用\r\n\r\n如果设置了options.inBitmap属性，以后再使用带有该options参数的decode方法加载图片资源时，\r\n\r\ndecode会尝试重用已存在的位图内存，这样节省了加载和分配的时间，同时也节省了内存空间。\r\n\r\n> 该属性从3.0开始引进，低版本不支持inBitmap，\r\n>\r\n> 4.4系统之前只能重用大小相同的内存区域，\r\n>\r\n> 4.4以后可以重用任何比所需内存小的区域。\r\n>\r\n> 具体使用可参考[官网](https:\/\/developer.android.com\/topic\/performance\/graphics\/manage-memory.html)。\r\n\r\n## 纯色规则形状背景用Color Res代替图片\r\n\r\n经常遇到一些按钮背景是纯色显示，比如选中状态背景变为纯灰，\r\n\r\n但是设计已经发来了切图用还是不用？大声say NO！\r\n\r\n如果背景使用图片来显示，那背景每个像素都要绘制。\r\n\r\n假设一个分辨率为100x100的图片，占用4通道。\r\n\r\n那该图片内存占用就是100x100x4 =4万Byte≈40KB；\r\n\r\n但是如果使用`android:background=\"@color\/colorAccent\"`引用color值的方式，\r\n\r\n由于是纯色，只需渲染一个像素而其他像素复用这个像素值即可。\r\n\r\n这样只需要4Byte即完成了背景设置。\r\n\r\n## 选择合适数据类型\r\n\r\n### 使用ArrayMap替换HashMap\r\n\r\nHashMap是一个散列链表，稀疏阵列导致内存稍大，\r\n\r\n而ArrayMap提供了和HashMap一样的功能，但是避免了内存过度开销。\r\n\r\n在以下两个场景考虑优先使⽤ArrayMap：\r\n\r\n- 当对象的数⽬⾮常⼩(1000以内)，但是访问特别多，或者删除和插⼊频率不⾼时。\r\n\r\n- 当有映射容器，有映射发⽣，并且所有映射的容器也是ArrayMap时。  \r\n\r\n### 枚举替身来了\r\n\r\nJDK1.5就支持了枚举类型，使用Enum关键字定义。\r\n\r\n使用枚举类型很多时候出于参数类型安全迫不得已作出的选择。\r\n\r\n   ```java\r\n  public String  getValue(int type){\r\n            switch (type) {\r\n                case 1:\r\n                    break;\r\n                case 2:\r\n                    break;\r\n                case 3:\r\n                    break;\r\n                default:\r\n                    throw new IllegalArgumentException(\"不合法参数\");\r\n            }\r\n    return \"\";\r\n    }\r\n   ```\r\n\r\n试想一下如果一个函数的参数为int type，函数处理时只用到了1，2，3三种值，\r\n\r\n如果是其他值就抛出异常，这无疑增加了程序的不稳定性，\r\n\r\n按以前此时最好的解决办法就是参数改为枚举类型，增加了限定也就提高了稳定性。\r\n\r\n但是枚举类型就是一把双刃剑，增加安全同时也大大增加了内存占用,尤其是在移动设备上，\r\n\r\n资源有限更应该注意内存节省。\r\n\r\n谷歌或许考虑到了这些问题，在提供的注解包里添加了注解方式检查类型安全，\r\n\r\n目前支持int和String两种，看下使用方式：\r\n\r\n\r\n```Java\r\n\/\/1、先声明需要的类型常量值\r\npublic static final int TYPE_1 = 1;\r\npublic static final int TYPE_2 = 2;\r\n\/\/2、创建注解接口同时把上一步声明的常量囊括到这里\r\n@IntDef({TYPE_1,TYPE_2})\r\n@Retention(RetentionPolicy.SOURCE)\r\npublic @interface _TYPE{\r\n    \r\n}\r\n\/\/3、在函数参数中增加 注解接口名称\r\npublic String getValue(@_TYPE int type){\r\n    switch (type) {\r\n        case 1:\r\n            break;\r\n        case 2:\r\n            break;\r\n    }\r\n    return \"\";\r\n}\r\n```\r\n\r\n经过上面的步骤，再调用getValue()函数时如果传入其他int则报错编译不通过，这样通过注解就增加了安全性：\r\n\r\n![屏幕快照 2017-03-29 下午7.13.32.png](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/intdef.png)\r\n\r\n## 图片内存\r\n\r\n⼀张图片（BitMap） 占⽤的内存=图片长度×图片宽度×单位像素占⽤的字节数\r\n\r\n  单位像素占用内存数由图片质量决定，\r\n\r\n一个普通图片有红绿蓝和透明4个通道，每个通道8bit(1字节)，所以一个像素4个字节。\r\n\r\n一个600x600的图片，占用内存：600x600x4=1406KB=1.37m\r\n\r\n可见未经优化的图片占用内存非常大的。\r\n\r\n### 设置位图规格\r\n\r\nAndroid位图格式有ARGB_8888、ARGB_565、ARGB_4444、\r\n\r\n最⾼的是RGB_8888， 也就是系统默认的位图格式， \r\n\r\n其他⼏种都减⼩了位图通道位， 可以减少内存开销并提升图⽚显⽰的性能  \r\n\r\n在一些场景下可以适当降低图片质量，采用ARGB_565：\r\n\r\n- 显⽰局部图⽚， ⽐如列表中的⼩图⽚。\r\n\r\n- ⼩屏幕⼿机或者对图⽚质量要求不⾼的场景， 可以使⽤RGB_565， \r\n\r\n  但实际上是， 根据应⽤开发经验， 不需要Alpha通道。\r\n\r\n  如果需要更⼩的格式， 但又需要透明通道， 可以尝试ARGB_4444图像格式。 \r\n\r\n  它减少了⼀半的数据， 但保留了透明通道， 视觉差异变化较⼤，\r\n\r\n   ⼀般⽤于⽤户头像， 特别是圆⾓的头像， 可以尝试使⽤ARGB_4444看看。 \r\n\r\n### inSampleSize\r\n\r\n\r\n\r\n###   inScaled， inDensity和inTargetDensity"
  },
  {
    "title": "如何知道下载好的aosp版本？",
    "created_time": "2017-04-21 20:55:54",
    "body": "下载源码时执行的是\r\n\r\n```\r\nrepo init -u git:\/\/mirrors.ustc.edu.cn\/aosp\/platform\/manifest\r\n\r\n```\r\n\r\n没有写上分支然后就直接同步了，下载完了不知道版本是多少。\r\n在\r\n\r\n```\r\n找到 build\/make\/core\/version_defaults.mk文件打开\r\n搜索 PLATFORM_SDK_VERSION\r\n找到了   PLATFORM_SDK_VERSION := 25\r\nsdk版本知道了晓得原来是最新的7.1\r\n```"
  },
  {
    "title": "Android studio Git提示Push rejected: Push to origin\/master was rejected",
    "created_time": "2017-08-25 13:27:03",
    "body": "# 0x00 前言\r\n\r\n最近做一个IPTV项目，由于经常和历史记录做对比或者实现新思路不行而还原，所以要把项目添加到Git。\r\n\r\n但是当用Android studio push的时候出现异常信息：\r\n\r\n```\r\nPush rejected: Push to origin\/master was rejected\r\nGit Pull Failed: fatal: refusing to merge unrelated histories\r\n\r\n```\r\n\r\n因为刚创建的Git remote仓库初始化时顺带创建了一个read.me文件，\r\n\r\n而本地已经add过了。\r\n\r\n<!-- more -->\r\n\r\n# 0x01 解决\r\n\r\n因为Android studio可以执行的命令有限（或者还未发现新天地），所以cd到项目目录执行\r\n\r\n```\r\ngit pull origin master --allow-unrelated-histories\r\n```\r\n\r\n即可。"
  },
  {
    "title": "Android本地广播",
    "created_time": "2017-09-14 17:50:05",
    "body": "# 0x00 前言\r\n\r\n在android开发中广播作为四大组件之一，其重要性不言而喻。虽然重要但使用却是极其简单，\r\n\r\n通常我们的使用无非就是`sendBroadCast`和继承BroadCastReceiver重写`onReceive`方法。\r\n\r\n如果多想想其实这种做法是存在安全隐患的，比如我们发送的广播是全局性的，那么有被其他程序截获泄露的风险，同样的我们广播接收器也是全局性的，垃圾应用也有可能不停发送垃圾广播。\r\n\r\n对于这种安全隐患如何避免呢？\r\n\r\n**Google为我们提供了本地广播服务：`LocalBroadcastManager`对广播进行管理。让我们发出的广播只在应用内传递，且广播接收器也只接收来自本应用的广播。**\r\n\r\n<!-- more -->\r\n\r\n# 0x01 使用\r\n\r\n`LocalBroadcastManager`在SDK22版本添加在v4包中。\r\n\r\n\r\n\r\n## 实例化\r\n\r\n```java\r\nprivate LocalBroadcastManager manager;\r\n\r\nmanager.getInstance(Context context)\r\n```\r\n\r\n\r\n\r\n## 本地发送广播\r\n\r\n```java\r\nprivate LocalBroadcastManager manager;\r\n\r\nmanager.sendBroadcast(intent);\r\n```\r\n\r\n\r\n\r\n## 本地注册广播\r\n\r\n```java\r\nprivate LocalBroadcastManager manager;\r\n\r\nmanager.registerReceiver(receiver,filter)\r\n```\r\n\r\n\r\n\r\n## 本地取消广播\r\n\r\n```java\r\nprivate LocalBroadcastManager manager;\r\n\r\nmanager.unregisterReceiver(receiver)\r\n```"
  },
  {
    "title": "Android各版本新功能及区别",
    "created_time": "2017-07-26 13:17:15",
    "body": "#  0x00 前言\r\n\r\nAndroid版本更新快，版本越来越越多，兼容性也就要越来越注意，注意各个版本新加了哪些功能，哪些功能和API对开发有帮助，都要心里有个数\r\n\r\n\r\n\r\n# 0x01 Android8.0 \r\n\r\nwaiting...\r\n\r\n\r\n\r\n# 0x02 Android 7.0 Nougat\r\n\r\n- 引入了一个新的而且非常需要的多任务处理功能 — 多窗口支持。\r\n\r\n- **通知增强** 通知界面直接回复等\r\n\r\n- 进一步的低耗电模式Doze 增强版\r\n\r\n- 删除了三个常用隐式广播 — `CONNECTIVITY_ACTION`、`ACTION_NEW_PICTURE` 和`ACTION_NEW_VIDEO` \r\n\r\n  ​<!-- more -->\r\n\r\n# 0x03 Android 6.0 Marshmallow\r\n\r\n- **引入了一种新的权限模式 运行时权限检查**\r\n\r\n  对于以 Android 6.0（API 级别 23）或更高版本为目标平台的应用，请务必在运行时检查和请求权限。要确定您的应用是否已被授予权限，请调用新增的 `checkSelfPermission()` 方法。要请求权限，请调用新增的 `requestPermissions()` 方法。即使您的应用并不以 Android 6.0（API 级别 23）为目标平台，您也应该在新权限模式下测试您的应用。\r\n\r\n- 取消支持 Apache HTTP 客户端\r\n\r\n  Android 6.0 版移除了对 Apache HTTP 客户端的支持。如果您的应用使用该客户端，并以 Android 2.3（API 级别 9）或更高版本为目标平台，请改用 `HttpURLConnection` 类。此 API 效率更高，因为它可以通过透明压缩和响应缓存减少网络使用，并可最大限度降低耗电量。要继续使用 Apache HTTP API，您必须先在 `build.gradle`文件中声明以下编译时依赖项：\r\n\r\n  ```\r\n  android {\r\n      useLibrary 'org.apache.http.legacy'\r\n  }\r\n  ```\r\n\r\n- **低电耗模式和应用待机模式：Doze模式**\r\n\r\n- **新的通知构建方法**\r\n\r\n  移除了 `Notification.setLatestEventInfo()` 方法。请改用 `Notification.Builder` 类来构建通知。要重复更新通知，请重复使用 `Notification.Builder` 实例。调用 `build()` 方法可获取更新后的 `Notification` 实例。\r\n\r\n  `adb shell dumpsys notification` 命令不再打印输出您的通知文本。请改用 `adb shell dumpsys notification --noredact` 命令打印输出 notification 对象中的文本。\r\n\r\n- **Android 密钥库变更**\r\n\r\n  从此版本开始，[Android 密钥库提供程序](https:\/\/developer.android.com\/training\/articles\/keystore.html)不再支持 DSA。但仍支持 ECDSA。\r\n\r\n  停用或重置安全锁定屏幕时（例如，由用户或设备管理员执行此类操作时），系统将不再删除需要闲时加密的密钥，但在上述事件期间会删除需要闲时加密的密钥。\r\n\r\n  ​\r\n\r\n# 0x04 Android 5.0 Lollipop\r\n\r\n- **引入了Material Design并提供了UI工具包**\r\n\r\n- **把ART模式作为默认的运行模式**\r\n\r\n- Android 5.0 中的通知更醒目、更便于访问并且可配置程度更高。\r\n\r\n- Android 5.0 还引入了 Android 扩展包 (AEP)，支持 OpenGL ES 3.1\r\n\r\n- Android 5.0 引入了全新的 Camera API\r\n\r\n- 在 Android 5.0 中，新增的倾斜检测器传感器有助于改善受支持设备上的 Activity 识别\r\n\r\n- 新增的 **Job Scheduling** API 允许通过将作业推迟到稍后或指定条件下（如设备充电或连入 WLAN 时）运行来优化电池寿命。\r\n\r\n  新增的 `dumpsys batterystats` 命令可生成**电池使用情况统计信息**，可通过它了解整个系统的耗电情况，以及了解应用对设备电池的影响。\r\n\r\n\r\n\r\n# 0x05 Android 4.4 Jelly Bean\r\n\r\n- Android 4.4 针对硬件传感器批处理引入平台支持\r\n\r\n- **全屏沉浸模式**\r\n\r\n  Android 4.4 添加了新的全屏沉浸模式，让您可以在手机和平板电脑上创建从一个边缘延伸到另一个边缘的全出血 UI，**隐藏所有系统 UI**，例如状态栏和导航栏。它适用于鲜艳的视觉内容，例如照片、视频、地图、书本和游戏。\r\n\r\n  在新模式中，系统 UI 保持隐藏状态，即使在用户与您的应用或游戏交互时 - 您可以从屏幕上的任何位置（甚至在系统栏占据的其他位置）捕获触摸事件。这是您在应用或游戏中创建更大、更加丰富和更加沉浸式的 UI 并减少视觉分散的绝佳方式。\r\n\r\n  为确保用户在全屏沉浸模式中始终能轻松、一致地访问系统 UI， Android 4.4 支持新的手势。现在，在沉浸模式中，从屏幕顶部或底部边缘滑动手指可以显示系统 UI。\r\n\r\n  要返回沉浸模式，用户可以触摸栏界限之外的屏幕或等待一小段时间，让栏自动隐藏。为提供一致的用户体验，新的手势还与之前隐藏状态栏的方法配合使用。\r\n\r\n- 安全增强功能\r\n\r\n  SELinux（强制模式）\r\n  Android 4.4 将其 SELinux 配置从“permissive”更新为“enforcing”。这意味着，在具有强制政策的 SELinux 域中，将阻止潜在的政策违规行为。\r\n\r\n  改进加密算法\r\n  Android 添加了对另外两种加密算法的支持，进一步提升了其安全性。已向密钥库提供程序添加椭圆曲线数字签名算法 (ECDSA) 支持，从而提升了数字签名的安全性，适用于应用签名或数据连接等场景。实现 Scrypt 密钥派生函数，以保护用于全磁盘加密的加密密钥。\r\n\r\n- 内存使用率分析工具procstats\r\n\r\n- Android 4.4 包含新的开发者选项：设备内存状态和分析\r\n\r\n  Settings > Developer options > Process stats\r\n\r\n- **可重复使用的位图，参考[inBitmap](https:\/\/developer.android.com\/reference\/android\/graphics\/BitmapFactory.Options.html#inBitmap)**"
  },
  {
    "title": "Android关于Activity生命周期误解",
    "created_time": "2017-05-05 11:03:36",
    "body": "两个Activity  A和B，先启动A，通过A打开B，在关闭B，这时候两个Activity的生命周期分别是如何执行的？\r\n\r\n我的答案是：\r\n\r\nA启动时\r\n\r\n`A onCreate onStart onResume`\r\n\r\n点击启动B之后\r\n\r\n`\tA onPause onStop, B onCreate onStart onResume`\r\n\r\nB关闭之后\r\n\r\n` B onPause onStop onDestory ,A onRestart onStart onResume`\r\n\r\n<!-- more -->\r\n\r\n但是想的太简单了，我以为的并不是我以为的。下面是打印的生命周期执行：\r\n\r\n```\r\n05-05 11:01:33.801 5494-5494\/com.example.jenson.myapplication I\/MainActivity: onCreate\r\n05-05 11:01:33.801 5494-5494\/com.example.jenson.myapplication I\/MainActivity: onStart\r\n05-05 11:01:33.801 5494-5494\/com.example.jenson.myapplication I\/MainActivity: onResume\r\n05-05 11:01:33.861 5494-5542\/com.example.jenson.myapplication I\/OpenGLRenderer: Initialized EGL, version 1.4\r\n05-05 11:01:46.391 5494-5494\/com.example.jenson.myapplication I\/MainActivity: onPause\r\n05-05 11:01:46.411 5494-5494\/com.example.jenson.myapplication I\/FirstActivity: onCreate\r\n05-05 11:01:46.411 5494-5494\/com.example.jenson.myapplication I\/FirstActivity: onStart\r\n05-05 11:01:46.411 5494-5494\/com.example.jenson.myapplication I\/FirstActivity: onResume\r\n05-05 11:01:46.691 5494-5494\/com.example.jenson.myapplication I\/MainActivity: onStop\r\n05-05 11:02:20.641 5494-5494\/com.example.jenson.myapplication I\/ViewRootImpl: WindowInputEventReceiver onInputEvent!! KeyCode is 4, action is 0\r\n05-05 11:02:20.641 5494-5494\/com.example.jenson.myapplication I\/ViewRootImpl: WindowInputEventReceiver onInputEvent!! KeyCode is 4, action is 1\r\n05-05 11:02:20.651 5494-5494\/com.example.jenson.myapplication I\/FirstActivity: onPause\r\n05-05 11:02:20.651 5494-5494\/com.example.jenson.myapplication I\/MainActivity: onRestart\r\n05-05 11:02:20.651 5494-5494\/com.example.jenson.myapplication I\/MainActivity: onStart\r\n05-05 11:02:20.651 5494-5494\/com.example.jenson.myapplication I\/MainActivity: onResume\r\n05-05 11:02:20.871 5494-5494\/com.example.jenson.myapplication I\/FirstActivity: onStop\r\n05-05 11:02:20.871 5494-5494\/com.example.jenson.myapplication I\/FirstActivity: onDestroy\r\n```\r\n\r\n> 记住一点：启动一个新Activity，先把自己onPause，然后等新Activity启动成功即onResume后再onStop，关闭当前Activity时，还是先把自己onPause，下一帧的Activity(相对于Activity栈来说)执行恢复onResume，然后自己再执行onStop、onDestory\r\n\r\n虽然知道了真相，但是现在还不清楚为什么要这样设计，，有时间还要看看这里的源码，mark下。"
  },
  {
    "title": "Android获取IP",
    "created_time": "2017-09-25 20:11:03",
    "body": "# 0x00 前言\r\n\r\n学过计算机网络的都知道，计算机IP地址分为内网IP和外网IP。\r\n\r\n在Android中API只提供了获取内网IP的方法，那如何获取外网IP呢？要解决这个问题要借助于服务器或者提供该服务的网站了。\r\n\r\n# 0x01 内网IP\r\n\r\nAndroid系统提供了获取内网IP的API，下面看如何使用API实现：\r\n\r\n```java\r\n    \/**\r\n     * 获取本地ip地址\r\n     *\r\n     * @return\r\n     *\/\r\n    public static String getHostIP() {\r\n        String hostIp = null;\r\n        try {\r\n            Enumeration nis = NetworkInterface.getNetworkInterfaces();\r\n            InetAddress ia = null;\r\n            while (nis.hasMoreElements()) {\r\n                NetworkInterface ni = (NetworkInterface) nis.nextElement();\r\n                Enumeration<InetAddress> ias = ni.getInetAddresses();\r\n                while (ias.hasMoreElements()) {\r\n                    ia = ias.nextElement();\r\n                    if (ia instanceof Inet6Address) {\r\n                        continue;\/\/ skip ipv6\r\n                    }\r\n                    String ip = ia.getHostAddress();\r\n                    if (!\"127.0.0.1\".equals(ip)) {\r\n                        hostIp = ia.getHostAddress();\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        } catch (SocketException e) {\r\n            e.printStackTrace();\r\n        }\r\n        return hostIp;\r\n\r\n    }\r\n```\r\n\r\n<!--more-->\r\n\r\n\r\n\r\n# 0x02 外网IP\r\n\r\n由于Android系统没有提供获取外网IP的API，所以只能通过间接的方法获取。了解Http原理的都知道，客户端向服务器发送请求时会携带MAC和IP地址，而这里的IP地址就是客户端的外网IP。所以服务器接收到请求后可以得知客户端外网IP，如果服务器把客户端外网IP给我们返回，这样就达到了间接获取外网IP的方法。\r\n\r\n所以目前的问题是我们只要找到一些提供返回IP地址服务的网站就可以了。\r\n\r\n介绍2个返回IP地址的网站：\r\n\r\n淘宝`http:\/\/ip.taobao.com\/service\/getIpInfo2.php?ip=myip`\r\n\r\n和\r\n\r\n搜狐`http:\/\/pv.sohu.com\/cityjson?ie=utf-8`\r\n\r\n淘宝返回的结果值为：\r\n\r\n```json\r\n{\"code\":0,\"data\":{\"country\":\"\\u4e2d\\u56fd\",\"country_id\":\"CN\",\"area\":\"\\u534e\\u5317\",\"area_id\":\"100000\",\"region\":\"\\u5317\\u4eac\\u5e02\",\"region_id\":\"110000\",\"city\":\"\\u5317\\u4eac\\u5e02\",\"city_id\":\"110100\",\"county\":\"\",\"county_id\":\"-1\",\"isp\":\"\\u9e4f\\u535a\\u58eb\",\"isp_id\":\"1000143\",\"ip\":\"113.47.141.3\"}}\r\n```\r\n\r\n搜狐返回的结果值为：\r\n\r\n```json\r\nvar returnCitySN = {\"cip\": \"113.47.141.3\", \"cid\": \"110000\", \"cname\": \"北京市\"};\r\n```\r\n\r\n代码实现：\r\n\r\n```java\r\n    \/**\r\n     * 获取外网IP地址\r\n     *\r\n     * @return\r\n     *\/\r\n    public static String getNetIp() {\r\n        URL infoUrl = null;\r\n        InputStream inStream = null;\r\n        String line = \"\";\r\n        try {\r\n            infoUrl = new URL(\"http:\/\/pv.sohu.com\/cityjson?ie=utf-8\");\r\n            URLConnection connection = infoUrl.openConnection();\r\n            HttpURLConnection httpConnection = (HttpURLConnection) connection;\r\n            int responseCode = httpConnection.getResponseCode();\r\n            if (responseCode == HttpURLConnection.HTTP_OK) {\r\n                inStream = httpConnection.getInputStream();\r\n                BufferedReader reader = new BufferedReader(new InputStreamReader(inStream, \"utf-8\"));\r\n                StringBuilder strber = new StringBuilder();\r\n                while ((line = reader.readLine()) != null)\r\n                    strber.append(line + \"\\n\");\r\n                inStream.close();\r\n                \/\/ 从反馈的结果中提取出IP地址\r\n                int start = strber.indexOf(\"{\");\r\n                int end = strber.indexOf(\"}\");\r\n                String json = strber.substring(start, end + 1);\r\n                if (json != null) {\r\n                    try {\r\n                        JSONObject jsonObject = new JSONObject(json);\r\n                        line = jsonObject.optString(\"cip\");\r\n                    } catch (JSONException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                }\r\n                return line;\r\n            }\r\n        } catch (MalformedURLException e) {\r\n            e.printStackTrace();\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n        return line;\r\n    }\r\n```"
  },
  {
    "title": "浅谈Android性能优化系列工具篇之MAT使用",
    "created_time": "2017-11-09 07:41:54",
    "body": "# 说在前面的话\r\n\r\n关于Android内存优化可参见我的另一篇文章[[Android性能优化之内存优化](http:\/\/www.jenson.top\/post\/32\/)]。Android性能优化中内存优化可谓重中之重，而内存泄露又是Android内存优化的重灾区。重灾区就要重拳出击，整治内存泄露，Mat是必备的利器。\r\n\r\n<!-- more -->\r\n\r\n# 关于Mat\r\n\r\nMat，全面Memory Analyzer Tool，Java内存分析工具。注意一点，Mat是由eclipse社区维护，所以如果使用Android studio开发的话，需要单独下载，[官方通道](http:\/\/www.eclipse.org\/mat\/downloads.php)。我用的是mac版，后面也会使用mac版来分析。\r\n\r\n# Mat使用\r\n\r\n注意：我的测试app包名为：com.example.jenson.myapplication\r\n\r\n在eclipse中集成了Mat，可以直接拿来使用，而使用Android studio时。这两个是分开的，所以我们要先导出dump文件。\r\n\r\n## Android studio导出dump文件\r\n\r\n打开Android Monitor窗口，![dump生成按钮](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/dump%E7%94%9F%E6%88%90%E6%8C%89%E9%92%AE.png)\r\n\r\n点击圆圈中的按钮，过几秒中会自动生成一个dump文件，然后自动打开如下图的窗口：![自动生成的dump文件](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84dump%E6%96%87%E4%BB%B6.png\r\n\r\n\r\n\r\n## 导出标准dump文件\r\n\r\n在Heap Snapshot下的几个文件就是自动生成的dump文件，但是这不是标准的dump文件，所以需要选择文件右键导出标准dump文件，保存到一个目录下：\r\n\r\n![导出标准dump文件](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/%E5%AF%BC%E5%87%BA%E6%A0%87%E5%87%86dump%E6%96%87%E4%BB%B6.png)\r\n\r\n\r\n\r\n\r\n\r\n## Mat打开标准dump文件\r\n\r\n使用Mat，菜单open File选择刚才导出的dump文件，经过分析后回显示如下所示的项目：\r\n\r\n![打开标准文件](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/%E6%89%93%E5%BC%80%E6%A0%87%E5%87%86%E6%96%87%E4%BB%B6.png)\r\n\r\n\r\n\r\n![图2](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-27%20%E4%B8%8B%E5%8D%882.21.48.png)\r\n\r\n\r\n\r\nMat从多角度提供了内存分析，其中包括Histogram、Dominator Tree、Leak Suspects和Top consumers等。\r\n\r\noverview是一个概况图，把内存的消耗以饼状图形式显示出来，鼠标在每个饼块区域划过或者点击，就会在Inspector栏目显示这块区域的相关信息。\r\n\r\nLeak Suspectss是一个关于内存泄露猜想的饼图，Problem Suspect 1是泄露猜想的描述。看我这里说的像是字节数组，这么大的数组难不成是图片，要知道图片在内存中就是以字节数组形式存在的。\r\n\r\n平常内存分析比较常用的还是Histogram、Dominator Tree。\r\n\r\n## 开始分析内存\r\n\r\n这里我们使用Histogram进行分析，切换到Histogram页面。这个页面主要有4个列，Class Name、Objects、Shallow Heap和Retained Heap。其中Class Name是全类名，Objects是这个类的对象实例个数。Shallow Heap是对象本身占用内存大小，非数组的常规对象，本身内存占用很小，所以这个对泄露分析作用不大。Retained Heap指当前对象大小和当前对象能直接或间接引用的对象大小的总和。这个栏目是分析重点。\r\n\r\n内存分析是分析的整个系统的内存泄露，而我们只要查找我们APP的内存泄露情况。这无疑增加了很多工作，不过幸亏Histogram支持正则表达式查找，在Regex中输入我们的包名进行过滤，直奔和我们APP有关的内存泄露：\r\n\r\n![包名过滤](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/%E5%8C%85%E5%90%8D%E8%BF%87%E6%BB%A4.png)\r\n\r\n过滤后就显示了我们APP相关内存信息，按Retained Heap大小排列下，发现Student和MainActivity这两个类问题比较大。但是MainActivity的Objects数量为1，而Student的为130，看起来Student问题更严重，所以先从Student入手：\r\n\r\n首先看下是哪里的引用导致了Student不能被GC回收。![GC Root](http:\/\/othg5ggzi.bkt.clouddn.com\/GC%20Root.png)\r\n\r\n右键使用Merge Shortest Paths to GC Roots显示距GC Root最短路径，当然选择过程中要排除软引用和弱引用，因为这些标记的一般都是可以被回收的。进入结果页查看：\r\n\r\n![结果页面](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/%E7%BB%93%E6%9E%9C%E9%A1%B5%E9%9D%A2.png)\r\n\r\n啧啧，原来Student不能被回收竟然就是这个MainActivity搞的鬼，可以看到这个类里面有个students集合里面存放的正式不能回收的Student对象。\r\n\r\n看代码：\r\n\r\n```\r\n    static List<Student> students=new ArrayList<>();\r\n    static final String tag=\"MainActivity\";\r\n    @Override\r\n    protected void onCreate(Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n        setContentView(R.layout.activity_main);\r\n        sample_text = (TextView) findViewById(R.id.sample_text);\r\n        TestNative testNative = new TestNative();\r\n        sample_text.setText(testNative.stringFromJNI());\r\n        for (int i = 0; i < 10; i++) {\r\n\r\n            Student student = new Student(\"jenson\" + i, i);\r\n            students.add(student);\r\n        }\r\n    }\r\n```\r\n\r\n原来不能被回收是因为用static修饰了students集合。这导致其生命周期边长，在Activity销毁时，仍然存在。问题找到了，去掉static完成内存泄露修复。\r\n\r\n# 结束语\r\n\r\nMAT功能不止于此，还有很多实用有趣的功能等着我们自己去探索。"
  },
  {
    "title": "Android网络框架okhttp执行流程分析",
    "created_time": "2017-05-10 00:58:46",
    "body": "# 说在前面的话\r\n\r\nAndroid开发中，网络框架okhttp可以说是越来越风光，Android4.4的源码中可以看到HttpURLConnection已经替换成OkHttp，能够被谷歌认可，足见okhttp的强大之处了。既如此还有什么理由不去深入理解下它呢？很惭愧，这么好的东西以前一直处于简单调用，今天有时间把流程看了一下，简单总结了下执行请求时的大概流程作为备忘。\r\n\r\n<!-- more -->\r\n\r\n# 执行流程\r\n\r\n![流程](Android网络框架执行流程分析\/流程.png)"
  },
  {
    "title": "Android源码下载",
    "created_time": "2017-04-21 20:55:54",
    "body": "# 说在前面的话\r\nwin系统的笔记本过年回来就没有带回北京。最近打算看看Android源码，所以需要在mac中从新下载。\r\n# 从官网下载\r\n下载Android源码首先想到的就是[官网](https:\/\/source.android.com\/source\/downloading.html)\r\n按照指示要先安装repo。但是在执行\r\n```\r\ncurl https:\/\/storage.googleapis.com\/git-repo-downloads\/repo > ~\/bin\/repo\r\n```\r\n\r\n时候就出现异常\r\n\r\n```\r\ncurl https:\/\/storage.googleapis.com\/git-repo-downloads\/repo > ~\/bin\/repo\r\n  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\r\n                                 Dload  Upload   Total   Spent    Left  Speed\r\n  0     0    0     0    0     0      0      0 --:--:--  0:01:14 --:--:--    0\r\ncurl: (7) Failed to connect to storage.googleapis.com port 443: Operation timed out\r\n```\r\n\r\n<!-- more -->\r\n\r\n搜索了下异常发现很早就有这个问题，比如[这里](https:\/\/github.com\/npm\/npm\/issues\/10037)\r\n但是好像没什么好的解决方法。网传有其他地址可以使用，但是没有继续浪费时间了，不能一条路走到黑。\r\n\r\n# 使用国内资源\r\n国外太麻烦，毕竟只是想看源码，不想在下载方面浪费太多精力。所以把想法转战到国内的源上。\r\n分享2个源，[科大源](https:\/\/lug.ustc.edu.cn\/wiki\/mirrors\/help\/aosp#已有仓库如何改用科大源)和[清大源](https:\/\/mirrors.tuna.tsinghua.edu.cn\/help\/AOSP\/)\r\n其中我选择使用的是科大源，打开页面看到初始同步有两个方法，方法1毕竟简单，下载一个打好的包，自己repo sync。方法2还是要下载repo，而且如果中途断掉还要从头下载，所以果断选了方法1，直接使用迅雷下载tar包还是很快的。\r\n不到一个小时下载完成，解压后打开aosp文件夹发现没有文件，因为是.开头的，都是隐藏文件，显示后如图：\r\n![屏幕快照 2017-03-16 下午1.55.14.png](http:\/\/upload-images.jianshu.io\/upload_images\/1796052-a48a38e120b53440.png?imageMogr2\/auto-orient\/strip%7CimageView2\/2\/w\/1240)\r\n执行\r\n```\r\n\/Users\/jenson\/Downloads\/aosp\/.repo\/repo\/repo sync\r\n```\r\n\r\n同步\r\n\r\n![屏幕快照 2017-03-16 下午2.08.54.png](http:\/\/upload-images.jianshu.io\/upload_images\/1796052-185f5625074cf187.png?imageMogr2\/auto-orient\/strip%7CimageView2\/2\/w\/1240)\r\n\r\n\r\n# 如何修改已经init的repo\r\n如果想下载其他版本的源码，但是repo已经初始化过，\r\n如果再次执行repo init xxx会提示 :\r\n```\r\nYour identity is: jenson <xxx@foxmail.com>\r\nIf you want to change this, please re-run 'repo init' with --config-name\r\nrepo has been initialized in \/Users\/jenson\/Downloads\/aosp\r\n```\r\n\r\n上面意思是如果要修改init，需要重新运行repo init +新的url +config\r\n这时会自动修改配置并初始化:\r\n\r\n```\r\n\/Users\/jenson\/Downloads\/aosp\/.repo\/repo\/repo init -u https:\/\/aosp.tuna.tsinghua.edu.cn\/platform\/manifest -b android-6.0.1_r58  --config\r\n```"
  },
  {
    "title": "No resource identifier found for attribute 'roundIcon' in package 'and",
    "created_time": "2017-08-04 11:37:39",
    "body": "# 前言\r\n\r\nAndroid studio更新到2.3后创建项目时就出现了这个问题，我只要降低版本就出现编译异常信息：\r\n\r\n`No resource identifier found for attribute 'roundIcon' in package 'android'Ask Question`。\r\n\r\n这个**roundIcon**真是害人匪浅。\r\n\r\n而且也是感受到了天下文章一大抄的说法所言非虚。。\r\n\r\n只要搜出来的说法都是删掉`roundIcon`那个属性即可。\r\n\r\n可是我和其他网友都遇到了另一个问题：删除后再编译又会自动给添加上，而编译版本已经改为了5.0。\r\n\r\n<!-- more -->\r\n\r\n# 解决\r\n\r\n- 简单做法\r\n\r\n如果只是因为没有为最新系统功能做好适配工作。那么可以把**targetSdkVersion**降回到所需版本，但保留**compileSdkVersion 26**编译版本最新。这是最简单做法，但是可能有一些过时API需要进行版本判断。\r\n\r\n- 我还想降低compileSdkVersion为20\r\n\r\n  当把**compileSdkVersion**降为20的时候，再次编译项目就出现了`Error:(11) No resource identifier found for attribute 'roundIcon' in package 'android'`。\r\n\r\n  这时想到还有构建版本还是26.0.0，然后也改为20.0.0了。再次编译\r\n\r\n  这时候仍然有异常，但是信息变了：`Error:The SDK Build Tools revision (20.0.0) is too low for project ':app'. Minimum required is 25.0.0\r\n  <a href=\"fix.build.tools.version\">Update Build Tools version and sync project<\/a><br><a href=\"openFile:\/Users\/jenson\/AndroidStudioProjects\/CanvasTest\/app\/build.gradle\">Open File<\/a>`。\r\n\r\n  这是一个好兆头，说明我们的对手变了。我现在要做的就是让项目认可低版本的bt(build tool)。\r\n\r\n  这条异常是由：Gradle sync发出的。所以异常和Gradle有关，那现在问题矛头指向Gradle，而Gradle又有Gradle版本和插件版本，\r\n\r\n  **会不会是版本太新缘故，毕竟谷歌老喜欢搞新花样，所以现在的想法是回退到一个合适的版本。**\r\n  目前版本是**gradle-3.3-all**和**com.android.tools.build:gradle:2.3.3**\r\n\r\n  现在使用**gradle-3.0-all**和**com.android.tools.build:gradle:2.2.0**\r\n\r\n  从新编译时出现了如下弹窗：\r\n\r\n  ![gradle版本升级弹窗](http:\/\/othg5ggzi.bkt.clouddn.com\/gradle%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7%E6%8F%90%E7%A4%BA%E5%BC%B9%E7%AA%97.png)\r\n\r\n\r\n\r\n​\t说明两个版本在匹配范围内，获得初步成功，但是编译完成时再次提示了**roundIcon**，然后这次把**属性删掉**，同时**clean project**。\r\n\r\n然后又出现了如下异常信息：\r\n\r\nError:In <declare-styleable> ConstraintSet, unable to find attribute android:elevation\r\n\r\n这可能是由于把compileSdkVersion设置20，有点太低了得缘故。\r\n\r\n既然如此，干脆一不做二不休，进入布局文件把**android.support.constraint.ConstraintLayout**布局替换为其他布局。同时删除该类用到的一些属性，譬如：\r\n\r\n```\r\napp:layout_constraintBottom_toBottomOf=\"parent\"\r\napp:layout_constraintLeft_toLeftOf=\"parent\"\r\napp:layout_constraintRight_toRightOf=\"parent\"\r\napp:layout_constraintTop_toTopOf=\"parent\"\r\n```\r\n\r\n斩草要除根，把依赖包也干脆去掉：\r\n\r\n删除**compile 'com.android.support.constraint:constraint-layout:1.0.2'**\r\n\r\n\r\n\r\n最最最后clean project，各种build后没有终于恢复正常了。。。。\r\n\r\n\r\n\r\n> 提示：每次升级前注意下当前Gradle版本是多少，对应的Plugin版本又是多少，如果升级后有问题，可以方便的回退。\r\n\r\n\r\n\r\ngradle本地：\r\n\r\n```\r\ndistributionUrl=file:\/Users\/jenson\/.gradle\/wrapper\/dists\/gradle-3.0-all.zip\r\n```"
  },
  {
    "title": "浅谈Android性能优化系列工具篇之BatteryHistorian电量检测工具使用",
    "created_time": "2017-11-08 16:28:31",
    "body": "# 前言\r\n\r\nBattery Historian是谷歌开放的电量检测工具，目前发布2个版本：首个版本是由python编写，但是在2015年谷歌IO大会发布的Battery Historian2.0版本使用Go重写，新版本提供的信息更全面。\r\n\r\n去[Google的github项目](https:\/\/github.com\/google\/battery-historian)下载Battery Historian。\r\n\r\n# 准备\r\n\r\n## 电池重置\r\n\r\n使用命令`adb shell dumpsys batterystats --reset`重置电池\r\n\r\n**电池重置的目的是为了让下次电量统计时从当前时间开始，而不是从最初开机或上次充满电(具体何时开始不清楚)。**\r\n\r\n## 开启全部wakelock\r\n\r\n使用命令`adb shell dumpsys batterystats --enable full-wake-history`开启全部wakelock\r\n\r\n# 导出统计数据\r\n\r\n接下来应该断开设备的充电连接，对我们的app进行各种操作，等操作完成重新连接设备，然后进行电量统计。\r\n\r\n其实电量统计系统已经为我们做了，我们要做的就是把电量统计信息以文件形式导出到我们的电脑。\r\n\r\n老版本的导出命令为：`adb shell dumpsys batterystats > out.txt `。\r\n\r\n`adb shell dumpsys batterystats > 包名 > out.txt `得到给定的app相关的电量消耗信息\r\n\r\n新版本的导出命令为：` adb bugreport out.zip`，也可以使用`adb bugreport > out.txt`。\r\n\r\n新版本同样也可以统计指定APP\r\n\r\n导出的out.txt文件在你命令行执行时的所属目录。\r\n\r\n### 异常1\r\n\r\n这里我出现一个异常：当前SDK最新版本为7.0(25)，而我的手机系统版本为5.0，\r\n\r\n所以使用命令行：**adb bugreport > report.txt**时出现了如下异常：\r\n\r\n**Failed to get bugreportz version, which is only available on devices running Android 7.0 or later.**\r\n\r\n这是由于SDK版本太新了，既然手机系统不能升级，那就只好把SDK降级，\r\n\r\n其实这里只是使用了plantform下的adb命令，所以从新下载**platform-tools**即可。\r\n\r\n我下载和手机系统版本一致的platform-tools，然后解压。\r\n\r\n使用新下载的platform-tools的adb命令执行`adb bugreport > out.txt`时提示没有设备。\r\n\r\n### 异常2\r\n\r\n又使用**adb devices**查看列表仍然没有。重启adb也没用效果。\r\n\r\n因为我的是Mac设备，所以命令行执行`system_profiler SPUSBDataType`时会显示一系列外接设备信息，找到你的Android设备，复制Vendor ID。\r\n\r\n进入你下载的低版本**platform-tools**文件夹下，修改或创建**adb_usb.ini**文件，把刚才复制的Vendor ID粘贴到这里。\r\n\r\n再次执行**adb devices**就可以查看到设备列表了。\r\n\r\n然后再次执行`adb bugreport > out.txt`就会产生一个设备耗能统计信息文件。\r\n\r\n### 注意\r\n\r\n导出电量统计数据是一个持续输出的过程，就是说如果你不手动停止，那会一直统计。\r\n\r\n所以看到文件中已经写入内容后就可以CTRL+C了。\r\n\r\n# 数据可视化\r\n\r\n我们得到的是一个可读性很差的txt文件，接下来就是把out.txt文件转为方便我们可视化的图表信息html\r\n\r\n**老版本**使用命令`python historian.py out.txt > out.html`，其中**historian.py**在我们前言中下载的项目中scripts目录下。\r\n\r\n转换后的页面如图：\r\n\r\n![historian01](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/historian-01.png)\r\n\r\n![historian02](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/historian-02.png)\r\n\r\n![historian03](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/historian-03.png)\r\n\r\n\r\n\r\n**注意：刚打开html时可能页面只显示Battery Historian analysis for bugreport.txt，看不到其他内容，是因为页面正在分析txt，耐心等待下，不要关闭页面。**\r\n\r\n图中垂直白线每个间隔在我这里表示半分钟，\r\n\r\nbattery_level（ 剩余电量）\r\n鼠标悬停在 battery_level 变化处，显示剩余电量，以及距上次 battery_level 变化的间隔\r\n\r\nplugged（连接）\r\n电量来源（类似于上面的电量信息）。\r\n\r\nscreen（屏幕）\r\n屏幕开启的时长。\r\n\r\ntop（上栏）\r\n列举了当前屏幕上显示的进程\r\n\r\nsync（同步）\r\n处理与服务器的同步。\r\n\r\nwake_lock\r\n\r\nrunning（运行）\r\n游戏时，电话一直在后台运行。\r\n\r\n wake_lock_in（唤醒锁）\r\n可以看到哪些进程正在运行，以及所引起的 WakeLock 或 Alarm。在这张截图中，游\r\n戏音频控制进程多次调用 WakeLock（ 播放不同的示例音乐引发了将近 2000 次音频\r\nWakeLock）。同时也可以看到屏幕 WakeLock。\r\n\r\nJob\t后台的工作，比如服务service的运行\r\n\r\nwifi\r\n\r\nwifi_full_lock\r\n\r\nwifi_scan（WIFI扫描）\r\n\r\nwifi_running（WIFI运行状态）\r\n\r\n我这里一条全是绿，说明一直在连接WIFI使用中\r\n\r\n\r\n\r\nwifi_suppl（ Wi-Fi状态）\r\n\r\n\r\nwifi_signal_strength（ Wi-Fi信号强度）\r\n图 3-8 中，有 Wi-Fi 信号被检测到——尽管 Wi-Fi 已经被关闭，但由于高级 Wi-Fi 设置，\r\n也会一直搜索 Wi-Fi 信号。\r\n\r\nphone_signal_strength（无线网络信息 ）\r\n显示信号变化（有差、中、好 三种）。\r\n\r\naudio\r\n\r\nfg\r\n这里指的是前台应用。前台程序很少被销毁来释放内存。即使关闭屏幕，我们也可以看\r\n到 Facebook 客户端在前台处理收到的信息。\r\n\r\nstatus（状态）\r\n正在放电（与充电状态相对应）。\r\n\r\nhealth（健康）\r\n电池健康状态，来自电池管理器 API。\r\n\r\nplug（连接状态）\r\n设备是否接通电源。\r\n\r\n\r\n\r\n**通过上面的数据展示可以看出各个硬件耗电信息，根据相关信息和自己APP的相关设置，看哪些是不该出现的硬件使用而执行了，那这就是该优化的地方。比如在wake_lock_in横条中，左半部分红色竖条还是比较均匀的，但是到了右半部分，红条多了很多而且同一时间有多个wakelock发生了，这些都是需要的吗？不是的话就要想办法优化了。**\r\n\r\n# 结尾\r\n\r\n这里使用的一直是Battery Historian1.0，新版本的由于是GO语言重新的，所以需要安装Go的环境，有时间在尝试下。\r\n\r\n新版本内容也更丰富，页面有四个标签：SystemStats（系统统计）、 Historian 2.0、 Historian（ legacy） 和 App Stats（应用程序统计）。"
  },
  {
    "title": "Log工具封装Tag显示类方法和行数",
    "created_time": "2017-11-28 15:29:25",
    "body": "```java\r\n​​​import android.text.TextUtils;\r\nimport android.util.Log;\r\n\r\n\/**\r\n * 二次封装的log打印工具\r\n *\/\r\npublic class LogUtils {\r\n\r\n\tpublic static String customTagPrefix = \"\";\r\n\r\n\tprivate LogUtils() {\r\n\t}\r\n\r\n\tpublic static boolean allowD = true;\r\n\tpublic static boolean allowE = true;\r\n\tpublic static boolean allowI = true;\r\n\tpublic static boolean allowV = true;\r\n\tpublic static boolean allowW = true;\r\n\tpublic static boolean allowWtf = true;\r\n\r\n\tpublic static LogListener logListener;\/\/如果要处理Log信息，实现listener即可\r\n\r\n\t\/**\r\n\t * @Description log输出监听（简易观察者）\r\n\t *\/\r\n\tpublic interface LogListener {\r\n\r\n\t\tvoid handleLog( String level, String tag, String content );\r\n\t}\r\n  \r\n    public static StackTraceElement getCurrentStackTraceElement() {\r\n        return Thread.currentThread().getStackTrace()[4];\r\n    }\r\n  \r\n\tprivate static String generateTag( StackTraceElement caller ) {\r\n\t\tString tag = \"%s[%s, %d]\";\r\n\t\tString callerClazzName = caller.getClassName();\r\n\t\tcallerClazzName = callerClazzName.substring(\r\n\t\t\t\tcallerClazzName.lastIndexOf( \".\" ) + 1 );\r\n\t\ttag = String.format( tag, callerClazzName, caller.getMethodName(), caller.getLineNumber() );\r\n\t\ttag = TextUtils.isEmpty( customTagPrefix ) ?\r\n\t\t\t\ttag :\r\n\t\t\t\tcustomTagPrefix + \":\" + tag;\r\n\t\treturn tag;\r\n\t}\r\n\r\n\tpublic static void d( String content ) {\r\n\t\tif (!allowD)\r\n\t\t\treturn;\r\n\t\tStackTraceElement caller = getCurrentStackTraceElement();\r\n\t\tString tag = generateTag( caller );\r\n\t\tLog.d( tag, content );\r\n\t\thandleLog( \"d\", tag, content );\r\n\t}\r\n\r\n\tpublic static void d( String content, Throwable tr ) {\r\n\t\tif (!allowD)\r\n\t\t\treturn;\r\n\t\tStackTraceElement caller = getCurrentStackTraceElement();\r\n\t\tString tag = generateTag( caller );\r\n\t\tLog.d( tag, content, tr );\r\n\t}\r\n\r\n\tpublic static void e( String content ) {\r\n\t\tif (!allowE)\r\n\t\t\treturn;\r\n\t\tStackTraceElement caller = getCurrentStackTraceElement();\r\n\t\tString tag = generateTag( caller );\r\n\t\tLog.e( tag, content );\r\n\t\thandleLog( \"e\", tag, content );\r\n\t}\r\n\r\n\tpublic static void e( String content, Throwable tr ) {\r\n\t\tif (!allowE)\r\n\t\t\treturn;\r\n\t\tStackTraceElement caller = getCurrentStackTraceElement();\r\n\t\tString tag = generateTag( caller );\r\n\t\tLog.e( tag, content, tr );\r\n\t}\r\n\r\n\tpublic static void i( String content ) {\r\n\t\tif (!allowI)\r\n\t\t\treturn;\r\n\t\tStackTraceElement caller = getCurrentStackTraceElement();\r\n\t\tString tag = generateTag( caller );\r\n\t\tLog.i( tag, content );\r\n\t\thandleLog( \"i\", tag, content );\r\n\t}\r\n\r\n\tpublic static void i( String content, Throwable tr ) {\r\n\t\tif (!allowI)\r\n\t\t\treturn;\r\n\t\tStackTraceElement caller = getCurrentStackTraceElement();\r\n\t\tString tag = generateTag( caller );\r\n\t\tLog.i( tag, content, tr );\r\n\t}\r\n\r\n\tpublic static void v( String content ) {\r\n\t\tif (!allowV)\r\n\t\t\treturn;\r\n\t\tStackTraceElement caller = getCurrentStackTraceElement();\r\n\t\tString tag = generateTag( caller );\r\n\t\tLog.v( tag, content );\r\n\t\thandleLog( \"v\", tag, content );\r\n\t}\r\n\r\n\tpublic static void v( String content, Throwable tr ) {\r\n\t\tif (!allowV)\r\n\t\t\treturn;\r\n\t\tStackTraceElement caller = getCurrentStackTraceElement();\r\n\t\tString tag = generateTag( caller );\r\n\t\tLog.v( tag, content, tr );\r\n\t}\r\n\r\n\tpublic static void w( String content ) {\r\n\t\tif (!allowW)\r\n\t\t\treturn;\r\n\t\tStackTraceElement caller = getCurrentStackTraceElement();\r\n\t\tString tag = generateTag( caller );\r\n\t\tLog.w( tag, content );\r\n\t\thandleLog( \"w\", tag, content );\r\n\t}\r\n\r\n\tpublic static void w( String content, Throwable tr ) {\r\n\t\tif (!allowW)\r\n\t\t\treturn;\r\n\t\tStackTraceElement caller = getCurrentStackTraceElement();\r\n\t\tString tag = generateTag( caller );\r\n\t\tLog.w( tag, content, tr );\r\n\t}\r\n\r\n\tpublic static void w( Throwable tr ) {\r\n\t\tif (!allowW)\r\n\t\t\treturn;\r\n\t\tStackTraceElement caller = getCurrentStackTraceElement();\r\n\t\tString tag = generateTag( caller );\r\n\t\tLog.w( tag, tr );\r\n\t}\r\n\r\n\tpublic static void wtf( String content ) {\r\n\t\tif (!allowWtf)\r\n\t\t\treturn;\r\n\t\tStackTraceElement caller = getCurrentStackTraceElement();\r\n\t\tString tag = generateTag( caller );\r\n\t\tLog.wtf( tag, content );\r\n\t\thandleLog( \"wtf\", tag, content );\r\n\t}\r\n\r\n\tpublic static void wtf( String content, Throwable tr ) {\r\n\t\tif (!allowWtf)\r\n\t\t\treturn;\r\n\t\tStackTraceElement caller = getCurrentStackTraceElement();\r\n\t\tString tag = generateTag( caller );\r\n\t\tLog.wtf( tag, content, tr );\r\n\t}\r\n\r\n\tpublic static void wtf( Throwable tr ) {\r\n\t\tif (!allowWtf)\r\n\t\t\treturn;\r\n\t\tStackTraceElement caller = getCurrentStackTraceElement();\r\n\t\tString tag = generateTag( caller );\r\n\t\tLog.wtf( tag, tr );\r\n\t}\r\n\r\n\t\/**\r\n\t * 处理Log信息\r\n\t *\r\n\t * @param level\r\n\t * @param tag\r\n\t * @param content\r\n\t *\/\r\n\tprivate static void handleLog( String level, String tag, String content ) {\r\n\t\tif (null != logListener) {\r\n\t\t\tlogListener.handleLog( level, tag, content );\r\n\t\t}\r\n\t}\r\n}\r\n```"
  },
  {
    "title": "《Android移动性能实战》优化点总结",
    "created_time": "2018-11-16 08:14:19",
    "body": "## 前言\r\n\r\n下面是对《Android移动性能实战》一书的知识点总结：常见App场景的性能优化知识点，\r\n\r\n\r\n出乎意料的是这本书是由测试部门人员写出来的，书中也有提到一些问题点开发人员无从下手，是由测试人员发现问题所在，不得不感慨有一种测试叫别人家的测试。\r\n\r\n## IO性能优化\r\n\r\n\r\n\r\n### 缓存重复读取的系统文件\r\n\r\n> 每次打开、 关闭或者读\/写文件， 操作系统都需要从用户态到内核态的切\r\n> 换， 这种状态的切换本身是很消耗性能的， 所以为了提高文件的读\/写效率， 就需要尽\r\n> 量减少用户态和内核态的切换。 使用缓存可以避免重复读\/写， 对于需要多次访问的数\r\n> 据， 在第一次取出数据时， 将数据放到缓存中， 下次再访问这些数据时， 就可以从缓\r\n> 存中取出来 \r\n\r\n读取系统文件诸如*\/proc\/cpuinfo*时，使用变量进行信息缓存，防止每次需要该信息时都进行文件读取，须知每次读取都是一次IO操作\r\n\r\n### SharePreference优化\r\n\r\n> Android系统中使用SharedPreferences文件来保存数据非常方便， 在需\r\n> 要保存数据的地方调用commit就可以， 但是很多开发同学可能并不知道每调用一次\r\n> commit（） ， 就会对应一次文件的打开和关闭， 从而造成因commit（） 方法的随意调\r\n> 用而导致文件的重复打开和关闭 \r\n>\r\n> 使用apply替代commit，apply是异步操作，commit是同步操作。\r\n\r\n\r\n\r\n### 严禁主线程中进行IO操作\r\n\r\n> 随机读\/写是相对顺序读\/写而言的， 在读取或者写入的时候\r\n> 随机地产生offset。 但为什么随机读\/写会如此之慢呢？\r\n> 1． 随机读会失去预读（read-ahead） 的优化效果。\r\n> 2． 随机写相对于顺序写除了产生大量的失效页面之外， 更重要的是增加了触\r\n> 发“写入放大”效应的概率。\r\n> 那么“写入放大”又是什么呢？ 下面我们来介绍第二个概念： “写入放大”效应。\r\n> “写入放大”效应\r\n> 当数据第一次写入时， 由于所有的颗粒都为已擦除状态， 所以数据能够以页为最\r\n> 小单位直接写入进去。 当有新的数据写入需要替换旧的数据时， 主控制器将把新的数\r\n> 据写入到另外的空白闪存空间上（已擦除状态） ， 然后更新逻辑LBA地址来指向到新\r\n> 的物理FTL地址。 此时， 旧的地址内容就变成了无效的数据， 但主控制器并没执行擦\r\n> 除操作而是会标记对应的“页”为无效。 当磁盘需要在上述无效区域进行再次写入的\r\n> 话， 为了得到空闲空间， 闪存必须先复制该“块”中所有的有效“页”到新的“块”里， 并\r\n> 擦除旧“块”后， 才能写入。 （进一步学习， 可参见：\r\n> http： \/\/bbs.pceva.com.cn\/forum.php？ mod=viewthread＆action=printable＆tid=8277。 ）\r\n> 比如， 现在写入一个4KB的数据， 最坏的情况就是， 一个块里已经没有干净空间\r\n> 了， 但是恰好有一个“页”的无效数据可以擦除， 所以主控就把所有的数据读出来， 擦\r\n> 除块， 再加上这个4KB新数据写回去。 回顾整个过程， 其实只想写4KB的数据， 结果\r\n> 造成了整个块（512KB） 的写入操作。 同时带来了原本只需要简单地写4KB的操作变\r\n> 成了“闪存读取（512KB） -＞缓存改（4KB） -＞闪存擦除（512KB） -＞闪存写入\r\n> （512KB） ”， 这造成了延迟大大增加， 速度慢是自然的。 这就是所谓的“写入放\r\n> 大”（Write Amplification） 问题。\r\n\r\n### 合理使用ByteArrayOutputStream \r\n\r\n> 进行对象缓存时会用到ObjectOutputStream，在序列化磁盘时， 会把内存中的每\r\n> 个对象保存到磁盘， 在保存对象的时候， 每个数据成员会带来一次I\/O操作， 意味着多少个对象就带来多少次IO操作，同样也带来严重的性能问题。可以多套一层，在ObjectOutputStream上面再封装一个输出流ByteArrayOutputStream，先将对象序列化后的信息写到缓存区中， 然后再一次性地写到磁盘上 。\r\n\r\n\r\n\r\n### 解压文件优化\r\n\r\n> 如果ZIP文件已保存在磁盘中， 且解压ZIP中的所有文件， 建议用ZipFile， 效率较\r\n> ZipInputStream提升15％~27％。\r\n> 仅解压ZIP中间的某些文件， 建议用ZipFile。\r\n> 如果ZIP没有在磁盘上或者顺序解压一小部分文件， 又或ZIP文件目录遭到损坏，\r\n> 建议用ZipInputStream。 \r\n\r\n### 表优化\r\n\r\n> 首次安装的表为空时， 不要去做无谓的查询操作。\r\n> 对于覆盖安装， 在表已经存在的情况下， 可以使用INSERT OR REPLACE语\r\n> 句来完成插入。 \r\n\r\n\r\n\r\n### 数据库重复打开优化\r\n\r\n> 因为打开数据库比较耗时， 如app_plugin_download.db的两次耗时分别为80ms和\r\n> 120ms。 每次打开数据库， 同时会有一些I\/O操作。 getWriteableDatabase的注释也明确\r\n> 说明该方法比较耗时， 不能在主线程进行。 \r\n>\r\n> 看一下SQLiteDatabase的源码， getWriteableDatabase（） 方法的注释说明： 一旦\r\n> 打开数据库， 该连接就会被缓存， 以供下次使用， 只有当真正不需要时， 调用close关\r\n> 闭即可 。\r\n>\r\n> 数据库在打开后， 先不要关闭， 在应用程序退出时再关闭。 \r\n\r\n### AUTOINCREMENT 不要随便用\r\n\r\n- 问题\r\n\r\n> 一条插入语句耗时平均在\r\n> 60ms+， SQL语句为： INSERT INTO events（timestamp， content， status，\r\n> send_count） VALUES （1445916309639， test， 1， 100） ，\r\n> 可以看到这条插入语句非常简单， 仅仅是插入3个整形和一个简单的字符串。 而\r\n> 一般的插入操作最多也就十几ms。 \r\n\r\n- 解释\r\n\r\n> AUTOINCREMENT其实就是“自增长”， 这个关键字只会出现在INTEGER\r\n> PRIMARY KEY后面， 而INTEGER PRIMARY KEY就是“主键”， 下面先来了解一下主\r\n> 键。\r\n> SQLite表的每行都有一个行号， 行号用64位带有符号的整型数据表示。 SQLite支\r\n> 持使用默认的列名ROWID、 _ROWID_和OID来访问行号。 同时， 如果表里某一列指\r\n> 定为INTEGER PRIMARY KEY类型， 那么这一列和ROWID是等价的。 也就是说， 如\r\n> 果你指定某一列为主键， 访问该列其实就是访问行号。\r\n\r\n- 行号是如何生成的？\r\n\r\n  对于刚创建的表来说， 行号默认是从1开始的， 如果在插入数据时明确指定行\r\n  号， 则会将数据插入对应的行， 如果没有指定行号， 则SQLite会选择比当前已用行号\r\n  大1的行来进行插入。 如果当前已用行号已达到最大值， 数据库引擎会尝试寻找当前\r\n  表里面没有使用的行号， 如果没有找到可用的行号， 就会出现SQLITE_FULL错误。\r\n  小结： 如果你没有删除过数据， 并且没有指定最大值的行号， 行号选择算法可以\r\n  保证行号是递增且唯一的。 但是如果你有删除数据或者使用了最大行号， 之前删除的\r\n  行号可能被复用， 并不能保证插入数据的行号是严格递增的。\r\n\r\n- 主键加了AUTOINCREMENT， 会有什么变化？\r\n  上面提到， AUTOINCREMENT只能用来修饰主键， 主键在被“自增长”修饰之\r\n  后， 会略微有些区别。\r\n  （1） 数据库引擎选择的行号会比所有之前用过的行号都大， 即使数据被删除，\r\n  行号也不会被复用， 可以保证行号严格单调递增。\r\n  （2） 如果行号的最大值被用过， 那么在插入新数据时， 会报SQLITE_FULL错\r\n  误。\r\n\r\n- 小结：\r\n\r\n  AUTOINCREMENT的作用是保证主键是严格单调递增的。\r\n    AUTOINCREMENT实现原理\r\n    SQLite创建一个叫sqlite_sequence的内部表来记录该表使用的最大的行号。 如果指\r\n    定使用AUTOINCREMENT来创建表， 则sqlite_sequence也随之创建。 UPDATE、\r\n    INSERT和DELETE语句可能会修改sqlite_sequence的内容。 因为维护sqlite_sequence表\r\n    带来的额外开销将会导致INSERT的效率降低 。所以除非必要，平时大多情况下不需要使用AUTOINCREMENT。\r\n\r\n### Bitmap解码\r\n\r\n> 4.4之前的系统，decodeFile源码里面读磁盘用的是\r\n> BufferedInputStream， 并且Buffer大小为DECODE_BUFFER_SIZE = 16×1024， 这也就\r\n> 是为什么在4.3系统decode大小为12KB的图片， 只需要读一次磁盘就可以的原因 。\r\n>\r\n> 4.4之后的系统，decodeFile里面去掉了缓冲区\r\n>\r\n> 解码Bitmap不要使用decodeFile， 因为在Android 4.4以上系统效率不高。\r\n> 解码Bitmap使用decodeStream， 同时传入的文件流为BufferedInputStream。\r\n> decodeResource同样存在性能问题， 请用decodeResourceStream。 \r\n\r\n\r\n\r\n## 内存优化\r\n\r\n### 内部类持有外部类Activity引用\r\n\r\n> 内部类有个特殊成员`this$0`为外部类的引用。通过它可以访问外部类变量，\r\n>\r\n> 但是如果内部类泄漏，由于其持有外部类引用，同时就导致了外部类Activity泄漏，进而造成view泄漏。\r\n>\r\n> 解决方案为：在Activity关闭时，解除内部类和外部类的引用。\r\n>\r\n> 1.将内部类定义为static\r\n>\r\n> 2.用static的变量引用匿名内部类的实例或将匿名内部类的实例化操作放到外部类的静态方法中\r\n\r\n### WifiManager 造成的泄漏\r\n\r\n> 把getSystemService（Context.WIFI_SERVICE） ； 修改为以下代码：\r\n> getApplicationContext（） .getSystemService（Context.WIFI_SERVICE） ；\r\n> 同样的情况也发生在AudioManager等服务上， 比如要判断当前是耳机模式或者外\r\n> 放模式， 一样会产生这样的问题， 所以都应该使用\r\n> getApplicationContext（） .getSystemService来获取服务实例。 \r\n\r\n### 避免webview泄漏使用独立进程\r\n\r\n> 用独立进程来解决内存问题， 独立进程在Android框架下非常简单， 在官网App\r\n> manifest的＜activity＞介绍中， 讲解了有关android： process属性的设置， 一旦设置了\r\n> 这个属性， 这个Activity的启动就会被投射到一个你所命名的进程当中， 最后在\r\n> Activity的onDestory函数中， 退出进程， 这样即可基本上终结此类泄漏。 \r\n\r\n- 网络大牛反射解决内存泄漏问题\r\n\r\n> “反射”得到WebView的内核， 然后再通\r\n> 过“反射”从内核的xxx变量中得到窗口管理器回调配置， 最后把一个空的窗口管理者赋\r\n> 给它， 来替代原先的那个。 这样就打断了底层的引用联调， 成功地解决了WebView内\r\n> 核造成的上层Activity泄漏。 但重点是作者最后补充了一句： 这并不能适用于所有的\r\n> Android系统， 因为它们的WebView内核字段差异很大。\r\n> 推荐将“反射”作为一种“补丁”来解决系统问题， 并且鼓励使用。 但是将它用在内\r\n> 存问题的解决上， 笔者还是建议大家持谨慎态度， 因为这并不是解决内存问题的正确\r\n> 道路， 正确理解组件本身， 正确调用接口， 给出正确参数， 采用正确调用顺序， 这才\r\n> 是真正解决内存的根本问题所在 \r\n>\r\n>\r\n\r\n### Timer及时停止避免泄漏\r\n\r\n```kotlin\r\nif(timer !=null){\r\n    timer.cancle();\r\n    timer=null;\r\n}\r\n```\r\n\r\n\r\n\r\n### 延时器postDelay及时remove\r\n\r\n> 开发人员在调用postDelayed方法时， 塞入了延时回调内类Runable， 但在Activity销毁的时候， \r\n>\r\n> 并没有调用removeCallbacks移除掉这个内类， 以至于导致泄漏。\r\n> 注意： 延时器的泄漏特征在于其根部通常是一个以主线程为GC ROOT的\r\n> MessageQueue， 这也是它与定时器泄漏最显著的区别。 \r\n\r\n\r\n\r\n### Bitmap解码配置RGB_565\r\n\r\n> 对于没有给定BitmapFactory.Options参数而直接调用图片解码函数的情况，\r\n> Android系统会默认使用ARGB_8888。 通过官方文档， 可以知道RGB_565每个像素占\r\n> 用的内存只有ARGB_8888的一半（RGB_565每个像素使用2字节， ARGB_8888每个像\r\n> 素使用4字节）  。对于非高清(如列表展示)图来说使用RGB_565即可。\r\n\r\n\r\n\r\n>\r\n>\r\n> 缩略图， 用户感官上认为它就不应该是一张高清图片， 如果需要详细查看， 可以\r\n> 通过“点入”操作。 没有透明效果， 因为RGB_565不解码透明通道内容， 因此会造成透\r\n> 明效果丢失（但是同样依赖于透明通道的圆角图片效果， 倒可以使用RBG_565配合\r\n> BitmapShader实现） 。 \r\n\r\n\r\n\r\n### Bitmap大图获取使用inSampleSize \r\n\r\n\r\n\r\n### 图片资源放到适合的drawable目录\r\n\r\nAndroid在加载这些图片前， 会先一步得到当前设备的显示密度， 然后到相匹配的\r\ndrawable目录去寻找图片资源。 但是如果开发人员并没有按照官方推荐的方式， 每个\r\nres\/drawable目录下都放置图片的话， Android会按照当前设备显示密度就“近”获取图片\r\n资源， 然后将其所在的目录所代表的密度与当前设备密度相比， 以这个比例来缩放图\r\n片， 以得到一张“合适”的图片（有对应图片就不用缩放， 这也是上面官网说“好”性能\r\n的原因） 。\r\n比如， 一张备显图片只放置在mdpi目录， 而当前的设备显示器为480dpi的超超高\r\n密屏， 这时Android就会按照3倍大小缩放这张图片， 将它加载入内存。\r\n这样是非常危险的， 如果有一张800×480图片放置在ldpi目录， 展示在480dpi的超\r\n超高密屏上时， 会在内存中产生一张3200×1920的巨大图片。 \r\n\r\n> 抓不准该放到那个目录的图片， 就尽量问设计人员要高品质图片然后往高密度目\r\n> 录下放， 这样在低密屏上“放大倍数”是小于1的， 在保证画质的前提下， 内存也是可控\r\n> 的。\r\n> 拿不准的图片， 使用Drawable.createFromStream替换getResources（） .getDrawable\r\n> 来加载， 这样就可以绕过Android以上的这套默认适配法则 \r\n\r\n\r\n\r\n\r\n\r\n### 内存复用\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 网络优化\r\n\r\n\r\n\r\n### webview缓存的坑\r\n\r\nandroid的WebVeiw的缓存策略会在\/data\/data\/应用package下生成database与cache\r\n两个文件夹， database可以存放多个数据库文件， 数据库中保存的是请求的url 。\r\n\r\n> HTTP Request的Cache-Control可以\r\n> 是no-cache、 no-store、 max-age、 max-stale、 min-fresh、 no-transform、 only-if-cached以\r\n> 及cache-extension， HTTP Response的Cache-Control为public、 private、 no-cache、 no\u0002transform、 must-revalidate、 proxy-revalidate、 max-age、 s-m axage以及cache\u0002extension。 这些Cache策略进行部分说明如下。\r\n> public： 响应可以在任何缓存区缓存。\r\n> private： 对单个用户的整个或部分响应消息， 不能在共享缓存区缓存。\r\n> no-cache： 请求或者响应不使用缓存。\r\n> no-store： 如果在请求中使用， 则该请求和对应的响应都不使用缓存， 如果在响应\r\n> 中使用， 则该响应和其对应的请求都不使用cache。\r\n> max-age： 资源在客户端的最大生命周期。\r\n> max-stale： 客户端可以接收生存期大于当前时间的响应。 \r\n\r\n> 在完成了缓存请求资源后， 还需要在客户端程序发送HTTP请求时指定该请求的\r\n> 响应资源可以从缓存中获取， 否则， 即使缓存中有对应的响应资源， 客户端也不会使\r\n> 用， 会重新通过网络下载一遍， 这涉及客户端发送HTTP请求时的缓存模式， 客户端\r\n> 可以指定5种缓存模式， 分别如下。\r\n> LOAD_CACHE_ONLY： 不使用网络， 只读取本地缓存数据。\r\n> LOAD_DEFAULT： 根据Cache-Control决定是否从网络上取数据。\r\n> LOAD_CACHE_NORMAL： API level17中已经废弃， 从API level 11开始作用同\r\n> LOAD_DEFAULT模式。\r\n> LOAD_NO_CACHE： 不使用缓存， 只从网络获取数据。\r\n> LOAD_CACHE_ELSE_NETWORK： 只要本地有， 无论是否过期， 或者NO\u0002CACHE， 都使用缓存中的数据。 \r\n\r\n### 开启压缩\r\n\r\n> 对请求的可压缩数据开启压缩，以减少流量消耗和等待时间\r\n\r\n\r\n\r\n### 传送数据优化\r\n\r\n> 这里优化也包括服务端滑动窗口大小。\r\n>\r\n> 服务器的RcvBuffer决定着滑动窗口的大小， 因此可以增大RcvBuffer来增加滑动窗口的大小 \r\n\r\n\r\n\r\n## CPU优化\r\n\r\n在经典的性能问题中， 一般我们会说两种问题： 一种是I\/O密集型问题， 另外一种\r\n就是CPU密集型的问题。 I\/O的问题在前面的磁盘、 网络部分已经介绍过了， 剩下的就\r\n是CPU了。 CPU问题无非分为以下三类。\r\nCPU资源冗余使用\r\n关于这个问题， 可以是算法太糙， 明明可以遍历一次的却遍历两次， 主要出现在\r\n查找、 排序、 删除等环节； 也可以是没有cache， 明明解码过一次的图片还重复解码。\r\n还有， 明明使用int就足够， 偏偏要用long， 导致CPU的运算压力多出4倍。\r\nCPU资源争抢\r\n资源争抢也有几种经典情况。\r\n（1） 抢主线程的CPU资源。 这是最常见的问题， 关键是主线程起码在Android 6.0\r\n版之前， 没有renderthread的时候， 其繁忙程度就决定了是否会引发用户的卡顿问题。\r\n最经典的例子就是主线程的Handler优化。\r\n（2） 抢音视频的CPU资源。 跟主线程的情况不同， 音视频编解码本身就消耗了\r\n大量的CPU资源， 同时音视频编解码对于解码的速度是有硬要求的， 达不到就会有产\r\n生播放流畅度的问题， 试想下， 听歌的时候总卡， 是不是很难受。 所以最常见的一种\r\n情况就是CPU满负载， 除了在耗电上有非常恶劣的影响外， 还会让音视频没有足够的\r\n资源保持流畅播放。 怎么办？ 通过两点挪走压垮骆驼的稻草： 第一、 排除非核心业务\r\n的消耗， 如下面说的QQ音乐的案例， 还有贴耳检测的频率控制； 第二、 优化自身的\r\n性能消耗， 把CPU负载转化为GPU负载， 最经典的就是利用renderscript来处理视频中\r\n的影像信息。\r\n（3） 大家平等， 相互抢。 前面两点都有主次之分， 强弱之别， 但是如果是QQ相\r\n册， 我开了20个线程做图片解码， 那就是相互抢， 我们曾经就遇到过这样的问题， 效\r\n果就是导致图片的显示速度非常慢。 这简直就是三个和尚没水喝的典型案例。 因此按\r\n照核心数、 控制线程数还是很有道理的。\r\nCPU资源利用率低\r\nCPU就是速度与负载的博弈， 用得多会耗电、 会卡顿， 用得少也会有问题， 像启\r\n动、 界面切换、 音视频编解码这些场景， 为了保证其速度， 不好好利用CPU， 真对不\r\n起核心数的不断飙升。 而导致无法充分利用CPU的因素， 除了前面说的磁盘和网络I\/O\r\n外， 还有锁操作、 sleep等。 其中锁的优化， 一般在锁的范围上， 主要是尽可能地缩减\r\n范围 \r\n\r\n通过查看`“cat\/sys\/devices\/system\/cpu\/cpu0\/cpufreq\/scaling_cur_freq” `来判断CPU是否降频\r\n\r\n\r\n\r\n\r\n\r\n## 电量优化\r\n\r\n使用`adb shell dumpsys power`命令， 查看系统中存在的WakeLock信息 \r\n\r\n> 每台手机都会有power_profile.xml。 PowerProfile， 在手机厂家出ROM的时候， Android\r\n> 官方建议厂商通过下面介绍的PowerMonitor之类的工具来测试每个硬件模块的耗电情\r\n> 况， 并配置好power_profile.xml文件。 这里必须强调一下， PowerProfile不像某些瞎扯\r\n> 的网文所说， 改变它能改变耗电， 因为它仅仅是一个为了让Android系统能通过硬件调\r\n> 用频率和强度来计算耗电的配置而已。 虽然很多厂商提供的这个文件基本乱配， 但是\r\n> 我们从文件的内容还是可以知道Android官方认为耗电的硬件都有什么？ 如图5-1所\r\n> 示， 我们从文件中可以提取出几个考量耗电的硬件， 包括CPU、 Wi-Fi、 Radio（数据\r\n> 网络） 、 Sensor（感应器） 、 BlueTooth（蓝牙） 、 Screen（屏幕） 、 GPS， 还有其实\r\n> 不属于硬件模块的视频和音频的耗电。 \r\n\r\n\r\n\r\n### 避免无谓的wifiscan\r\n\r\n> 获取了几台手机的PowerProfile， 发现WIFISCAN设置在220mA左右， 而\r\n> SCREENFULL的设置也就是160~300mA， 可见Wi-Fi扫描是一个可以比拟屏幕耗电的\r\n> 过程， 因此在理论上用户黑屏状态下， 完全不应该进行Wi-Fi扫描。 \r\n\r\n### 避免无谓的RTC_WAKEU \r\n\r\n> （1）使用AlarmManager时一定要考虑到多种情况， 尤其是要充分考虑网络变\r\n> 动、 用户登录状态改变等场景。\r\n> （2） 如果有多个功能需要通过AlarmManager实现时， 最好能够将多个功能合并\r\n> 到一个AlarmManager的广播接收函数中实现（在函数中调用多个功能） 。 尤其是当这\r\n> 几个功能的唤醒周期、 异常处理逻辑比较相近时， 一定要放在一起实现， 后续维护也\r\n> 会更加方便。 \r\n\r\n### 避免无谓的动画效果\r\n\r\n> 对于动画效果比较炫的界面， 灭屏后CPU占用率仍然很高， 最可能的原因就是动\r\n> 画没有及时释放。\r\n> 监听灭屏以及亮屏的广播， 在灭屏的时候停止动画绘制； 亮屏的时\r\n> 候， 恢复动画的绘制 \r\n\r\n### 避免间接调用wakeLock没有及时释放\r\n\r\n> 对于使用Media框架音视频功能时，虽然在我们的代码中没有手动调用wakeLock，但是框架会间接调用。\r\n>\r\n> 所以在退入后台时，对于暂未使用的音视频功能需要手动释放资源。\r\n\r\n\r\n\r\n### 避免wakeLock计数的坑\r\n\r\n> 有时候调用了wakeLock.release()；方法并没有释放wakeLock。\r\n>\r\n> 这是因为WakeLock有一个函数setReferenceCounted， 用来设置WakeLock的计数机制， 官方默认为计数。 true为计数， false为不计数。 \r\n>\r\n> 所谓计数即每一个acquire必须对应一个release； 不计数则是无论\r\n> 有多少个acquire， 一个release就可以释放。 \r\n>\r\n> 虽然官方说默认是计数的， 但是有的第三方ROM做了修改， 使默认是不计数的（开发人员就是拿到了这种手机） 。  \r\n>\r\n> 所以对于计数的机器最终结局方案为：\r\n>\r\n> 获取wakeLock后设置为不计数：wakeLock.setReferenceCounted(false);\r\n>\r\n>"
  },
  {
    "title": "Android JNI知识点",
    "created_time": "2019-03-22 10:10:17",
    "body": "### JNI介绍\r\n\r\nJNI 是 Java Native Interface 的缩写，译为 Java 本地接口，是 Java 与其他语言通信的桥\r\n梁。 所以说白了，有了JNI可以通过Java调用C\/C++，当然也可以通过C\/C++回调Java，这是JNI两个主要功能。那下面分别从这两方面说下JNI如何实现调用的。\r\n\r\n### Java调用C\/C++\r\n\r\n既然Java要调用C\/C++，那么Java如何根据native方法找到对应的so库函数呢？\r\n\r\n常规想法就是需要定义一套规则，根据这套规则使能根据native方法找到唯一与之对应的so库函数。\r\n\r\n规则如下：根据native方法及相关信息生成固定模式的本地实现函数名称\r\n\r\n```\r\nJNIEXPORT 返回值类型 JNICALL Java_类全名_方法名(JNIEnv *env, jobject instance,参数列表){\r\n    \r\n}\r\n```\r\n\r\n这套规则我们称为静态注册。\r\n\r\n#### 静态注册\r\n\r\n静态注册方法有固定的实现步骤：\r\n\r\n##### 声明native方法并编译\r\n\r\n声明native方法：\r\n\r\n```java\r\npublic class Tes {\r\n    public native int add(int a, int b);\r\n    public native void getStr_FromJNI();\r\n}\r\n```\r\n\r\nKotlin中使用`external`声明jni方法：\r\n\r\n```kotlin\r\nclass Tes {\r\n    external fun getStr_FromJNI(): String\r\n    external fun add(a: Int, b: Int): Int\r\n}\r\n```\r\n\r\n\r\n\r\n编译类文件：\r\n\r\n`javac Tes.java`\r\n\r\n编译完成后生成了Tes.class文件\r\n\r\n##### 生成头文件\r\n\r\n命令行定位到class文件，执行`javah Tes`生成头文件：\r\n\r\n> Android Studio 3.x版本中声明native方法后会飘红，这时候直接fix即可自动创建头文件，免去命令行生成这一步\r\n\r\n```c\r\n#include <jni.h>\r\n\r\nJNIEXPORT jstring JNICALL\r\nJava_pet_home_main_Tes_getStr_1FromJNI(JNIEnv *env, jobject instance) {\r\n    \/\/ TODO\r\n    return (*env)->NewStringUTF(env, returnValue);\r\n}\r\n\r\nJNIEXPORT jint JNICALL\r\nJava_pet_home_main_Tes_add(JNIEnv *env, jobject instance, jint a, jint b) {\r\n    \/\/ TODO\r\n}\r\n```\r\n\r\n注意头文件中方法名，以“Java”开头说明是在 Java 平台中调用 JNI 方法的，后面的 pet_home_main_Tes_getStr_1FromJNI指的是包名＋类名＋方法名的格式，原本在 Java 中应该是以\".\"\r\n来进行分割，这里却用了\"_\"，这是因为在 Native 语言中\".\"有特殊的含义。\r\n\r\n还有getStr_1FromJNI中下划线后面多了个1，这是因为 Java 的getStr_FromJNI方法中包含了\"_\"，\r\n\r\n转换成JNI方法后就变成了   \"_1\"。\r\n\r\n##### 编写C代码\r\n\r\nC代码直接进行简单的内容返回即可：\r\n\r\n```C \r\n#include <jni.h>\r\n\r\nJNIEXPORT jint JNICALL\r\nJava_pet_home_main_Tes_add(JNIEnv *env, jobject instance, jint a, jint b) {\r\n    return a + b;\r\n}\r\n\r\nJNIEXPORT jstring JNICALL\r\nJava_pet_home_main_Tes_getStr_1FromJNI(JNIEnv *env, jobject instance) {\r\n    return (*env)->NewStringUTF(env, \"this is from jni\");\r\n}\r\n```\r\n\r\n##### 编译so库并运行\r\n\r\n编译so库在运行App时由Studio自动编译完成，不过可以在moudle的gradle文件中配置编译平台：\r\n\r\n```groovy\r\n    defaultConfig {\r\n       \r\n\t\t\/\/配置编译平台\r\n        ndk{\r\n            abiFilters \"armeabi\", \"armeabi-v7a\",\"x86\"\r\n        }\r\n    }\r\n```\r\n\r\nKotlin加载so库：\r\n\r\n```kotlin\r\n    companion object {\r\n        \/\/ Used to load the 'native-lib' library on application startup.\r\n        init {\r\n            System.loadLibrary(\"native-lib\")\r\n        }\r\n    }\r\n```\r\n\r\nJava加载so库：\r\n\r\n```java\r\nstatic{\r\n    System.loadLibrary(\"native-lib\")\r\n}\r\n```\r\n\r\n上面既然说明了有静态注册，那不难想象应该还有动态注册，动态注册又是如何实现的呢？\r\n\r\n#### 动态注册\r\n\r\n##### Log动态注册\r\n\r\n动态注册通过使用JNINativeMethod， 保存了声明函数和实现函数的一一对应关系。  它是一个结构体类型，\r\n\r\n该结构体的数组变量`gMethods[]`被注册到VM，这样VM就知道了当调用native方法时该调用哪个实现函数。\r\n\r\n以日志类Log为例：\r\n\r\nJava层Log类有三个native方法：\r\n\r\n```java\r\n    public static native boolean isLoggable(String tag, int level);\r\n \tpublic static native int println_native(int bufID,int priority, String tag, String msg);\r\n    private static native int logger_entry_max_payload_native();\r\n```\r\n\r\n对应的cpp实现`android_util_Log.cpp`：\r\n\r\n```c++\r\n\/* \/\/device\/libs\/android_runtime\/android_util_Log.cpp\r\n**\r\n** Copyright 2006, The Android Open Source Project\r\n**\r\n** Licensed under the Apache License, Version 2.0 (the \"License\");\r\n** you may not use this file except in compliance with the License.\r\n** You may obtain a copy of the License at\r\n**\r\n**     http:\/\/www.apache.org\/licenses\/LICENSE-2.0\r\n**\r\n** Unless required by applicable law or agreed to in writing, software\r\n** distributed under the License is distributed on an \"AS IS\" BASIS,\r\n** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n** See the License for the specific language governing permissions and\r\n** limitations under the License.\r\n*\/\r\n\r\n#define LOG_NAMESPACE \"log.tag.\"\r\n#define LOG_TAG \"Log_println\"\r\n\r\n#include <android-base\/macros.h>\r\n#include <assert.h>\r\n#include <cutils\/properties.h>\r\n#include <log\/log.h>               \/\/ For LOGGER_ENTRY_MAX_PAYLOAD.\r\n#include <utils\/Log.h>\r\n#include <utils\/String8.h>\r\n\r\n#include \"jni.h\"\r\n#include \"JNIHelp.h\"\r\n#include \"utils\/misc.h\"\r\n#include \"core_jni_helpers.h\"\r\n#include \"android_util_Log.h\"\r\n\r\nnamespace android {\r\n\r\nstruct levels_t {\r\n    jint verbose;\r\n    jint debug;\r\n    jint info;\r\n    jint warn;\r\n    jint error;\r\n    jint assert;\r\n};\r\nstatic levels_t levels;\r\n\r\nstatic jboolean isLoggable(const char* tag, jint level) {\r\n    return __android_log_is_loggable(level, tag, ANDROID_LOG_INFO);\r\n}\r\n\r\nstatic jboolean android_util_Log_isLoggable(JNIEnv* env, jobject clazz, jstring tag, jint level)\r\n{\r\n    if (tag == NULL) {\r\n        return false;\r\n    }\r\n\r\n    const char* chars = env->GetStringUTFChars(tag, NULL);\r\n    if (!chars) {\r\n        return false;\r\n    }\r\n\r\n    jboolean result = isLoggable(chars, level);\r\n\r\n    env->ReleaseStringUTFChars(tag, chars);\r\n    return result;\r\n}\r\n\r\nbool android_util_Log_isVerboseLogEnabled(const char* tag) {\r\n    return isLoggable(tag, levels.verbose);\r\n}\r\n\r\n\/*\r\n * In class android.util.Log:\r\n *  public static native int println_native(int buffer, int priority, String tag, String msg)\r\n *\/\r\nstatic jint android_util_Log_println_native(JNIEnv* env, jobject clazz,\r\n        jint bufID, jint priority, jstring tagObj, jstring msgObj)\r\n{\r\n    const char* tag = NULL;\r\n    const char* msg = NULL;\r\n\r\n    if (msgObj == NULL) {\r\n        jniThrowNullPointerException(env, \"println needs a message\");\r\n        return -1;\r\n    }\r\n\r\n    if (bufID < 0 || bufID >= LOG_ID_MAX) {\r\n        jniThrowNullPointerException(env, \"bad bufID\");\r\n        return -1;\r\n    }\r\n\r\n    if (tagObj != NULL)\r\n        tag = env->GetStringUTFChars(tagObj, NULL);\r\n    msg = env->GetStringUTFChars(msgObj, NULL);\r\n\r\n    int res = __android_log_buf_write(bufID, (android_LogPriority)priority, tag, msg);\r\n\r\n    if (tag != NULL)\r\n        env->ReleaseStringUTFChars(tagObj, tag);\r\n    env->ReleaseStringUTFChars(msgObj, msg);\r\n\r\n    return res;\r\n}\r\n\r\n\/*\r\n * In class android.util.Log:\r\n *  private static native int logger_entry_max_payload_native()\r\n *\/\r\nstatic jint android_util_Log_logger_entry_max_payload_native(JNIEnv* env ATTRIBUTE_UNUSED,\r\n                                                             jobject clazz ATTRIBUTE_UNUSED)\r\n{\r\n    return static_cast<jint>(LOGGER_ENTRY_MAX_PAYLOAD);\r\n}\r\n\r\n\/*\r\n * JNI registration.\r\n *\/\r\nstatic const JNINativeMethod gMethods[] = {\r\n    \/* name, signature, funcPtr *\/\r\n    { \"isLoggable\",      \"(Ljava\/lang\/String;I)Z\", (void*) android_util_Log_isLoggable },\r\n    { \"println_native\",  \"(IILjava\/lang\/String;Ljava\/lang\/String;)I\", (void*) android_util_Log_println_native },\r\n    { \"logger_entry_max_payload_native\",  \"()I\", (void*) android_util_Log_logger_entry_max_payload_native },\r\n};\r\n\r\nint register_android_util_Log(JNIEnv* env)\r\n{\r\n    jclass clazz = FindClassOrDie(env, \"android\/util\/Log\");\r\n\r\n    levels.verbose = env->GetStaticIntField(clazz, GetStaticFieldIDOrDie(env, clazz, \"VERBOSE\", \"I\"));\r\n    levels.debug = env->GetStaticIntField(clazz, GetStaticFieldIDOrDie(env, clazz, \"DEBUG\", \"I\"));\r\n    levels.info = env->GetStaticIntField(clazz, GetStaticFieldIDOrDie(env, clazz, \"INFO\", \"I\"));\r\n    levels.warn = env->GetStaticIntField(clazz, GetStaticFieldIDOrDie(env, clazz, \"WARN\", \"I\"));\r\n    levels.error = env->GetStaticIntField(clazz, GetStaticFieldIDOrDie(env, clazz, \"ERROR\", \"I\"));\r\n    levels.assert = env->GetStaticIntField(clazz, GetStaticFieldIDOrDie(env, clazz, \"ASSERT\", \"I\"));\r\n\r\n    return RegisterMethodsOrDie(env, \"android\/util\/Log\", gMethods, NELEM(gMethods));\r\n}\r\n\r\n}; \/\/ namespace android\r\n\r\n```\r\n\r\n可以看到Java层打印方法`println_native`对应的cpp方法`android_util_Log_println_native`并没有包含如上面静态注册所提到的`JNIEXPORT`等关键字样，这是因为native方法和实现方法通过`gMethods[]`进行了绑定。\r\n\r\n看下JNINativeMethod结构体内容：\r\n\r\n```c++\r\ntypedef struct {\r\n    const char* name;\r\n    const char* signature;\r\n    void*       fnPtr;\r\n} JNINativeMethod;\r\n```\r\n\r\n其中：\r\n\r\n`name`为java方法名；\r\n\r\n`signature`为java方法签名；\r\n\r\n`fnPtr`为本地实现函数指针；\r\n\r\n由于Java有函数重载的问题，所以使用方法签名避免方法名相同问题，这里方法签名涉及参数个数、参数类型、返回值。\r\n\r\n要知道方法签名，先看下java中类型在jni中对应的别名：\r\n\r\n| java      | native        | signature             |\r\n| --------- | ------------- | --------------------- |\r\n| byte      | jbyte         | B                     |\r\n| char      | jchar         | C                     |\r\n| double    | jdouble       | D                     |\r\n| float     | jfloat        | F                     |\r\n| int       | jint          | I                     |\r\n| short     | jshort        | S                     |\r\n| long      | jlong         | J                     |\r\n| boolean   | jboolean      | Z                     |\r\n| void      | void          | V                     |\r\n| 所有对象  | jobject       | L+classname+;         |\r\n| Class     | jclass        | Ljava\/lang\/Class;     |\r\n| String    | jstring       | Ljava\/lang\/String;    |\r\n| Throwable | jthrowable    | Ljava\/lang\/Throwable; |\r\n| Object[]  | jobjectArray  | [L+classname+;        |\r\n| byte[]    | jbyteArray    | [B                    |\r\n| char[]    | jcharArray    | [C                    |\r\n| doubel[]  | jdoubleArray  | [D                    |\r\n| float[]   | jfloatArray   | [F                    |\r\n| int[]     | jintArray     | [I                    |\r\n| short[]   | jshortArray   | [S                    |\r\n| long[]    | jlongArray    | [J                    |\r\n| boolean[] | jbooleanArray | [Z                    |\r\n\r\n已经知道`gMethods`保存了函数对应关系，然后在`register_android_util_Log`方法中进行了注册，\r\n\r\n追踪源码最终调用了`AndroidRuntime::registerNativeMethods`，将对应函数关系传递给了VM。\r\n\r\n那么`register_android_util_Log`是什么时候调用的呢？\r\n\r\n其实是在`AndroidRuntime.cpp`的`startReg`方法中调用的，源码如下：\r\n\r\n```c++\r\n\/*\r\n * Register android native functions with the VM.\r\n *\/\r\n\/*static*\/ int AndroidRuntime::startReg(JNIEnv* env)\r\n{\r\n    ATRACE_NAME(\"RegisterAndroidNatives\");\r\n    \/*\r\n     * This hook causes all future threads created in this process to be\r\n     * attached to the JavaVM.  (This needs to go away in favor of JNI\r\n     * Attach calls.)\r\n     *\/\r\n    androidSetCreateThreadFunc((android_create_thread_fn) javaCreateThreadEtc);\r\n\r\n    ALOGV(\"--- registering native functions ---\\n\");\r\n\r\n    \/*\r\n     * Every \"register\" function calls one or more things that return\r\n     * a local reference (e.g. FindClass).  Because we haven't really\r\n     * started the VM yet, they're all getting stored in the base frame\r\n     * and never released.  Use Push\/Pop to manage the storage.\r\n     *\/\r\n    env->PushLocalFrame(200);\r\n\r\n    if (register_jni_procs(gRegJNI, NELEM(gRegJNI), env) < 0) {\r\n        env->PopLocalFrame(NULL);\r\n        return -1;\r\n    }\r\n    env->PopLocalFrame(NULL);\r\n\r\n    \/\/createJavaThread(\"fubar\", quickTest, (void*) \"hello\");\r\n\r\n    return 0;\r\n}\r\n```\r\n\r\n上面方法中调用了`register_jni_procs`：\r\n\r\n```c++\r\nstatic int register_jni_procs(const RegJNIRec array[], size_t count, JNIEnv* env)\r\n{\r\n    for (size_t i = 0; i < count; i++) {\r\n        if (array[i].mProc(env) < 0) {\r\n#ifndef NDEBUG\r\n            ALOGD(\"----------!!! %s failed to load\\n\", array[i].mName);\r\n#endif\r\n            return -1;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n\r\n```\r\n\r\n在`register_jni_procs`方法的`if`语句执行了`register_android_util_Log`函数。\r\n\r\n这里简单的一个`if`语句其实还是有挺多逻辑的。\r\n\r\n首先看下`register_jni_procs`函数接收的第一个参数`gRegJNI`：\r\n\r\n```C++\r\nstatic const RegJNIRec gRegJNI[] = {\r\n    REG_JNI(register_com_android_internal_os_RuntimeInit),\r\n    REG_JNI(register_com_android_internal_os_ZygoteInit),\r\n    REG_JNI(register_android_os_SystemClock),\r\n    REG_JNI(register_android_util_EventLog),\r\n    REG_JNI(register_android_util_Log),\r\n    REG_JNI(register_android_util_MemoryIntArray),\r\n    REG_JNI(register_android_util_PathParser),\r\n    REG_JNI(register_android_app_admin_SecurityLog),\r\n    REG_JNI(register_android_content_AssetManager),\r\n \t\/\/后面省略很多\r\n};\r\n\r\n```\r\n\r\n上面可以看到这是一个`RegJNIRec`类型的静态数组，`RegJNIRec`又是什么呢？：\r\n\r\n```c++\r\n#ifdef NDEBUG\r\n    #define REG_JNI(name)      { name }\r\n    struct RegJNIRec {\r\n        int (*mProc)(JNIEnv*);\r\n    };\r\n#else\r\n    #define REG_JNI(name)      { name, #name }\r\n    struct RegJNIRec {\r\n        int (*mProc)(JNIEnv*);\r\n        const char* mName;\r\n    };\r\n#endif\r\n```\r\n\r\n可以看到`RegJNIRec`只是一个结构体，\r\n\r\n结合这两段源码可以看出`REG_JNI(xxx)`，其实就是{xxx}，\r\n\r\n所以 REG_JNI(register_android_util_Log),就是{register_android_util_Log},\r\n\r\n那么上面源码中的那些xxx是从哪里来的呢？其实在`AndroidRuntime.cpp`有很多类似这样的代码：\r\n\r\n```c++\r\nextern int register_android_app_admin_SecurityLog(JNIEnv* env);\r\nextern int register_android_content_AssetManager(JNIEnv* env);\r\nextern int register_android_util_EventLog(JNIEnv* env);\r\nextern int register_android_util_Log(JNIEnv* env);\r\n\r\n```\r\n\r\n`extern`告诉我们，它这里引用的这些函数诸如：register_android_util_Log等可能定义在另一个源文件中，\r\n\r\n这里的`register_android_util_Log`函数就定义在`android_util_Log.cpp`文件中。\r\n\r\n结构体RegJNIRec中有这样一个东西`int (*mProc)(JNIEnv*);`\r\n\r\n这是一个函数指针：函数变量名为mProc，返回int值，接收一个JNIEnv指针参数。\r\n\r\n`gRegJNI[]`其实就是把各个函数指针(诸如register_android_util_Log)赋值给结构体`RegJNIRec`中函数指针变量mProc。\r\n\r\n所以在`if`语句中执行`array[i].mProc(env)`其实就是调用了`extern`所引入的各个外部函数。从而达到注册jni函数目的。\r\n\r\n##### 自定义JNI动态注册\r\n\r\n动态注册相比静态注册灵活性提高了很多，没有那么多条条框框。\r\n\r\n但是上面只是讲了系统如何动态注册，那么我们实际开发JNi过程中又该在哪注册呢？毕竟系统启动过程就注册了系统所需JNI，这个过程对我们来说是不可控的。\r\n\r\n还记得我们在加载so库时是怎么做的吗？\r\n\r\n使用`System.loadLibrary`，这个方法调用完成后系统会回调我们的cpp\/c文件中的`JNI_OnLoad`函数：\r\n\r\n```c++\r\njint JNI_OnLoad(JavaVM *vm, void *reserved) {\r\n}\r\n\r\n```\r\n\r\n所以我们可以在这个方法中进行函数绑定。\r\n\r\n首先实现native函数：\r\n\r\n```c++\r\njstring getStr(JNIEnv *env, jobject instance) {\r\n    return (*env)->NewStringUTF(env, \"this is from jni\");\r\n}\r\n\/\/注意:实现的函数最少要包含JNIEnv *env, jobject instance 这2个参数\r\njint addResult(JNIEnv *env, jobject instance, jint a, jint b) {\r\n    return a + b;\r\n}\r\n\r\n```\r\n\r\n然后进行函数绑定：\r\n\r\n```c++\r\nstatic JNINativeMethod gMethods[] = {\r\n        {\"getStr_FromJNI\", \"()Ljava\/lang\/String;\", (void *) getStr},\r\n        {\"add\",            \"(II)I\",                (void *) addResult},\r\n};\r\n\r\n```\r\n\r\n最后在`JNI_OnLoad`中进行函数注册：\r\n\r\n```C++\r\njint JNI_OnLoad(JavaVM *vm, void *reserved) {\r\n    jint result = -1;\r\n    char className[20] = {\"pet\/home\/main\/Tes\"};\r\n    JNIEnv *env = NULL;\r\n    \/\/通过vm获取env\r\n    if ((*vm)->GetEnv(vm, (void **) &env, JNI_VERSION_1_4) != JNI_OK) {\r\n        return -1;\r\n    }\r\n    \/\/获取class\r\n    jclass clazz = (*env)->FindClass(env, (const char *) className);\r\n    \/\/函数注册\r\n    if ((*env)->RegisterNatives(env, clazz, gMethods, 2) < 0) {\r\n        return -1;\r\n    }\r\n    \/\/一定要返回版本号，否则会出错。\r\n    result = JNI_VERSION_1_4;\r\n    return result;\r\n}\r\n```\r\n\r\nActivity进行结果展示：\r\n\r\n```kotlin\r\n        val tes = Tes()\r\n        sample_text.text = \"${tes.getStr_FromJNI()}#####${tes.add(3, 5)}\"\r\n```\r\n\r\n##### JNI添加Log打印\r\n\r\n在so调试过程中免不了要进行日志打印，但如何在LogCat中显示JNI日志呢？\r\n\r\n首先引入`#include<android\/log.h>`头文件，\r\n\r\n然后进行宏定义：\r\n\r\n```c++\r\n#define TAG    \"tes.c\" \/\/ 自定义的LOG的Tag\r\n#define LOGD(...)  __android_log_print(ANDROID_LOG_DEBUG,TAG,__VA_ARGS__)\r\n#define LOGI(...)  __android_log_print(ANDROID_LOG_INFO,TAG,__VA_ARGS__)\r\n#define LOGW(...)  __android_log_print(ANDROID_LOG_WARN,TAG,__VA_ARGS__)\r\n#define LOGE(...)  __android_log_print(ANDROID_LOG_ERROR,TAG,__VA_ARGS__)\r\n```\r\n\r\n最后应用Log：\r\n\r\n```c++\r\njint addResult(JNIEnv *env, jobject instance, jint a, jint b) {\r\n    LOGD(\"a value is %d\", a);\r\n    LOGD(\"b value is %d\", b);\r\n    return a + b;\r\n}\r\n```\r\n\r\n\r\n\r\n### C\/C++调用Java\r\n\r\n代码沿用上面的，可以看到C\/C++层的native方法实现中，JNI方法接受的第二个参数是Java对象： jobject， 可以在\r\nJNI中操作这个jobject进而操作Java对象提供的变量和方法 。\r\n\r\n#### 获取class\r\n\r\n要操作jobject， 就是要访问这个对象并操作它的变量和方法。 JNI提供的类和对象操作函数有很多， 常用的有两个：\r\nFindClass和GetObjectClass， 在C和C++中分别有不同的函数原型。\r\n\r\n C++中的函数原型如下：\r\n\r\n```C++\r\njclass FindClass（const charname） ； \/\/查找类信息\r\njclass GetObjectClass（jobject obj） ； \/\/返回对象的类\r\n\r\n```\r\n\r\nC中的函数原型如下：\r\n\r\n```C\r\njclass（FindClass） （JNIEnv， const char） ；\r\njclass（GetObjectClass） （JNIEnv*， jobject） ； \r\n\r\n```\r\n\r\n给Tes类添加一个`calc`函数：\r\n\r\n```kotlin\r\nclass Tes {\r\n    val NAME = \"TES\"\r\n\r\n    external fun getStr_FromJNI(): String\r\n    external fun add(a: Int, b: Int): Int\r\n    fun calc(a: Int, b: Int): Int {\r\n        return a * b\r\n    }\r\n}\r\n\r\n```\r\n\r\n根据object实例获取jclass：\r\n\r\n```C++\r\n    jclass clzz = (*env)->GetObjectClass(env, instance);\r\n\r\n```\r\n\r\n\r\n\r\n#### 获取Java变量\r\n\r\n上面已经获取到了jclass，有了class可以通过`GetStaticFieldID`和`GetFieldID`获取静态变量ID和实例变量ID，\r\n\r\n获取到FieldID后，再通过`GetStaticxxxField`和`GetxxxField`获取静态变量或实例变量的值：\r\n\r\n```C++\r\n    jclass clzz = (*env)->GetObjectClass(env, instance);\r\n\t\/\/获取fieldid\r\n  \tjfieldID fieldID = (*env)->GetStaticFieldID(env, clzz, \"NAME\", \"Ljava\/lang\/String;\");\r\n\t\/\/根据id获取变量值\r\n    jstring nameStr = (jstring) (*env)->GetStaticObjectField(env, clzz, fieldID);\r\n    const char *name = (*env)->GetStringUTFChars(env, nameStr, JNI_FALSE);\r\n    LOGD(\"Tes name is %s\", name);\r\n\r\n```\r\n\r\n\r\n\r\n#### 调用Java方法\r\n\r\n上面了解到获取变量值前要先获取变量ID，同样调用方法前要先获取方法ID。\r\n\r\n通过`GetMethodID`和`GetStaticMethodID`获取实例方法和静态方法ID，\r\n\r\n通过`CallxxxMethod`和`CallStaticxxxMethod`调用实例方法和静态方法：\r\n\r\n```c++\r\n \tjclass clzz = (*env)->GetObjectClass(env, instance);\r\n\t\/\/获取方法id\r\n    jmethodID methID = (*env)->GetMethodID(env, clzz, \"calc\", \"(II)I\");\r\n\t\/\/调用方法\r\n    jint result = (*env)->CallIntMethod(env, instance, methID, 3, 2);\r\n    LOGD(\"result value is %d\", result);\r\n```\r\n\r\n\r\n\r\n### 关于JNIENV\r\n\r\nC++中： JNIEnv就是struct _JNIEnv。 JNIEnv *env等价于 struct  _JNIEnv *env， \r\n\r\n在调用JNI函数的时候， 只需要env-＞FindClass（ JNIEnv*， const char *） ， 就会间接调用JNINativeInterface结构体里定义的函数指针， 而无需首先对env解引用。\r\n\r\nC中： JNIEnv就是const struct JNINativeInterface*。JNIEnv *env实际等价于const struct JNINativeInterface **env，\r\n因此要得到JNINativeInterface结构体内的函数指针就必须先对env解引用得到（ *env） ，\r\n\r\n 即const struct JNINativeInterface *，这个指针才是真正指向JNINativeInterface结构体的指针，\r\n\r\n 然后再通过它调用具体的JNI函数。 因此需要这样调用：（ *env） -＞FindClass（ JNIEnv *， const char *） 。\r\n\r\n注意 JNIEnv只在当前线程中有效。 本地方法不能将JNIEnv从一个线程传递到另一个线程中。 \r\n\r\n相同的Java线程中对本地方法多次调用时， 传递给该本地方法的JNIEnv是相同的。 但是， 一个本地方法可被不同的Java线程所调用， 因此可以接受不同的JNIEnv。 \r\n\r\n\r\n\r\n### 关于CMakeLists.txt添加目录\r\n\r\nAndroid Studio添加jni支持后会创建CMakeLists.txt文件，\r\n\r\n其中会包含你创建的C文件：\r\n\r\n```txt\r\nadd_library( # Sets the name of the library.\r\n        native-lib\r\n        # Sets the library as a shared library.\r\n        SHARED\r\n        # Provides a relative path to your source file(s).\r\n       src\/main\/jni\/tes.c )\r\n```\r\n\r\n但是这里只包含一个文件，如果文件是多文件多目录该怎么办？\r\n\r\n可以添加：\r\n\r\n```\r\naux_source_directory( .\/src\/main\/cpp NATIVE_SRC) #参数1为源，参数2为目标\r\n\r\n```\r\n\r\n如果cpp目录下还要子目录，则继续添加：\r\n\r\n```\r\naux_source_directory( .\/src\/main\/cpp\/rtc_base RTC_BASE )\r\n\r\n```\r\n\r\n将 RTC_BASE 增加到 NATIVE_SRC 中，这样子目录的源文件也加入了编译行列中：\r\n\r\n```\r\nlist(APPEND NATIVE_SRC ${RTC_BASE})\r\n\r\n```\r\n\r\n最后修改add_library地方：\r\n\r\n```\r\nadd_library( # Sets the name of the library.\r\n        native-lib\r\n\r\n        # Sets the library as a shared library.\r\n        SHARED\r\n\r\n        # Provides a relative path to your source file(s).\r\n        ${NATIVE_SRC}\r\n        )\r\n\r\n```"
  },
  {
    "title": "我是如何破解一个小视频app的",
    "created_time": "2019-09-17 17:28:49",
    "body": "### 前言\r\n\r\n最近想找一个看美剧的app，想看《黑袍纠察队》，一连下了几个app看看哪个效果好。\r\n\r\n结果无意中发现一个小(你)视(懂)频(得)app，随便点了几下发现都只能试看几十秒。\r\n\r\n看完整视频需要付费且价格不便宜(年费300)，爱优腾的年费赶上半价活动也才99\/年，\r\n\r\n所以付费观看我是拒绝的，就想着能不能破解下。\r\n\r\n### 工具\r\n\r\nandroid studio：安装java2smali插件，作为编辑器修改smali\r\n\r\napktool_2.4.0.jar：解压apk\r\n\r\nVirtualBox安装Ubuntu，openjdk：作为解压和重打包环境，在win下会有莫名的错误。\r\n\r\ndebug.keystore：android默认签名文件，用于apk重签名\r\n\r\njarsigner：jdk自带的签名工具\r\n\r\n以下app操作都在模拟器中运行，创建一个pad大屏模拟器，没有为啥就是看着爽\r\n\r\n### 目标\r\n\r\n工具和环境都准备好了，接下来要确认好目标，因为有了目标可以精准查找相应页面进行逻辑修改。\r\n\r\n现在视频是需要VIP才能完整播放的，我想不登录注册、没有vip直接播放完整视频：\r\n\r\n![不能完整播放](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/ll-play-no-vip-old.png)\r\n\r\n同一个视频播放后下次再次播放时会提示“你已经观看过，再次观看需要购买VIP”，我想随便点进来时直接播放就好，不要给我提示：\r\n\r\n![播放一次后再次播放提示](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/ll-after-play-no-vip-old.png)\r\n\r\n每次播放前都有个7s的视频，这个虽然可以忍受，但是我不想看：\r\n\r\n![7s广告](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/ll-play-ad-old%2Cpng.png)\r\n\r\nAPP现在要申请电话和存储权限，因为缓存关系，存储权限可以给它，但是我都不打算登录注册，电话权限我要去掉：\r\n\r\n![电话权限](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/ll-permission-old.png)\r\n\r\n所以现在4个目标基本明确了：\r\n\r\n- 无需登录和VIP进行全视频播放\r\n- 同一视频可以多次播放\r\n- 去广告\r\n- 去掉电话权限申请\r\n\r\n### 实操\r\n\r\n4个目标有3个都和播放页面相关，那就先搞前3个目标。\r\n\r\n#### 解压apk\r\n\r\n进入虚拟机的Ubuntu命令行，执行命令`java -jar apktool_2.4.0.jar d  llsp.apk`\r\n\r\n解压后文件如图：\r\n\r\n![解压目录](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/ll-unzip.png)\r\n\r\n#### 解压的项目导入到android studio\r\n\r\n#### 定位播放activity\r\n\r\n首先模拟器打开播放页面，adb查看当前播放页面Activity\r\n\r\n执行`dumpsys activity`\r\n\r\n定位到`ResumedActivity: ActivityRecord activity.PlayVideoActivity`即当前栈顶activity。\r\n\r\n#### 阅读smali\r\n\r\n在刚刚导入的项目中进入smali文件夹找到`PlayVideoActivity`。\r\n\r\n搜索发现除了`PlayVideoActivity`还有很多**PlayVideoActivity$1**类似的文件，其实这些都是`PlayVideoActivity`的内部类。\r\n\r\n##### 目标1：播放完整视频\r\n\r\n通过之前app播放，当发现你不是VIP时，几十秒后会弹出“此片试看已结束，您可以继续试看其他影片”的字样。\r\n\r\n所以第一想法就是这个几十秒的倒计时是app端实现的，我只要把倒计时去掉是不是就可以继续播放了。\r\n\r\n> 有时在学会走之前，先要跑起来.\r\n>\r\n> ​\t\t\t\t\t\t\t\t\t\t《钢铁侠》Tony Stark\r\n\r\n所以有了想法就赶紧去尝试，那么如何快速定位到倒计时及周围的逻辑呢？\r\n\r\n这里通过关键字快速定位法，既然有提示“此片试看已结束”了，那就去Activity中看看哪个方法调用了这个地方。\r\n\r\n但是smali中字符串是以Unicode方式存储的，所以在搜索前要把字符串转为Unicode码，\r\n\r\n“此片试看已结束”转码后的Unicode为\"\\u6b64\\u7247\\u8bd5\\u770b\\u5df2\\u7ed3\\u675f\"。\r\n\r\n用这个Unicode码去项目中搜索，发现只有`PlayVideoActivity$1`、`PlayVideoActivity$6`和`PlayVideoActivity$16`三个类中有该字符串的使用。\r\n\r\n\r\n\r\n`PlayVideoActivity$6`代码如下：\r\n\r\n```smali\r\n.class Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$6;\r\n.super Landroid\/os\/Handler;\r\n.source \"\"\r\n\r\n\r\n# annotations\r\n.annotation system Ldalvik\/annotation\/EnclosingClass;\r\n    value = Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n.end annotation\r\n\r\n.annotation system Ldalvik\/annotation\/InnerClass;\r\n    accessFlags = 0x0\r\n    name = null\r\n.end annotation\r\n\r\n\r\n# instance fields\r\n.field final synthetic ˏ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n\r\n# direct methods\r\n.method constructor <init>(Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;)V\r\n    .locals 0\r\n\r\n    .line 689\r\n    iput-object p1, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$6;->ˏ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    invoke-direct {p0}, Landroid\/os\/Handler;-><init>()V\r\n\r\n    return-void\r\n.end method\r\n\r\n\r\n# virtual methods\r\n.method public handleMessage(Landroid\/os\/Message;)V\r\n    .locals 2\r\n\r\n    .line 692\r\n    invoke-super {p0, p1}, Landroid\/os\/Handler;->handleMessage(Landroid\/os\/Message;)V\r\n\r\n    .line 693\r\n    iget v0, p1, Landroid\/os\/Message;->what:I\r\n\r\n    const\/4 v1, 0x1\r\n\r\n    if-ne v0, v1, :cond_0\r\n\r\n    .line 694\r\n    iget-object v0, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$6;->ˏ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    const-string v1, \"\\u6b64\\u7247\\u8bd5\\u770b\\u5df2\\u7ed3\\u675f\\uff0c\\u60a8\\u53ef\\u4ee5\\u7ee7\\u7eed\\u8bd5\\u770b\\u5176\\u4ed6\\u5f71\\u7247\\uff0c\\u6216\\u8005\\u6210\\u4e3a\\u4f1a\\u5458\\u65e0\\u9650\\u89c2\\u770b\\u6240\\u6709\\u5f71\\u7247\"\r\n\r\n    invoke-static {v0, v1}, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ˎ(Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;Ljava\/lang\/String;)V\r\n\r\n    .line 696\r\n    :cond_0\r\n    return-void\r\n.end method\r\n\r\n```\r\n\r\n\r\n\r\n`PlayVideoActivity$16`代码如下：\r\n\r\n```smali\r\n.class Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$16;\r\n.super Landroid\/os\/CountDownTimer;\r\n.source \"\"\r\n\r\n\r\n# annotations\r\n.annotation system Ldalvik\/annotation\/EnclosingClass;\r\n    value = Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n.end annotation\r\n\r\n.annotation system Ldalvik\/annotation\/InnerClass;\r\n    accessFlags = 0x0\r\n    name = null\r\n.end annotation\r\n\r\n\r\n# instance fields\r\n.field final synthetic ˋ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n\r\n# direct methods\r\n.method constructor <init>(Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;JJ)V\r\n    .locals 0\r\n\r\n    .line 337\r\n    iput-object p1, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$16;->ˋ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    invoke-direct {p0, p2, p3, p4, p5}, Landroid\/os\/CountDownTimer;-><init>(JJ)V\r\n\r\n    return-void\r\n.end method\r\n\r\n\r\n# virtual methods\r\n.method public onFinish()V\r\n    .locals 2\r\n\r\n    .line 346\r\n    iget-object v0, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$16;->ˋ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    invoke-virtual {v0}, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->getResources()Landroid\/content\/res\/Resources;\r\n\r\n    move-result-object v0\r\n\r\n    invoke-virtual {v0}, Landroid\/content\/res\/Resources;->getConfiguration()Landroid\/content\/res\/Configuration;\r\n\r\n    move-result-object v0\r\n\r\n    iget v0, v0, Landroid\/content\/res\/Configuration;->orientation:I\r\n\r\n    const\/4 v1, 0x2\r\n\r\n    if-ne v0, v1, :cond_0\r\n\r\n    .line 347\r\n    iget-object v0, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$16;->ˋ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    iget-object v0, v0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ॱˎ:Lchuangyuan\/ycj\/videolibrary\/video\/ExoUserPlayer;\r\n\r\n    invoke-virtual {v0}, Lchuangyuan\/ycj\/videolibrary\/video\/ExoUserPlayer;->onBackPressed()Z\r\n\r\n    .line 349\r\n    :cond_0\r\n    iget-object v0, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$16;->ˋ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    iget-object v0, v0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ˋॱ:Landroid\/widget\/TextView;\r\n\r\n    const\/16 v1, 0x8\r\n\r\n    invoke-virtual {v0, v1}, Landroid\/widget\/TextView;->setVisibility(I)V\r\n\r\n    .line 350\r\n    iget-object v0, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$16;->ˋ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    iget-object v0, v0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ॱˎ:Lchuangyuan\/ycj\/videolibrary\/video\/ExoUserPlayer;\r\n\r\n    invoke-virtual {v0}, Lchuangyuan\/ycj\/videolibrary\/video\/ExoUserPlayer;->onPause()V\r\n\r\n    .line 351\r\n    iget-object v0, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$16;->ˋ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    iget-object v0, v0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ॱˎ:Lchuangyuan\/ycj\/videolibrary\/video\/ExoUserPlayer;\r\n\r\n    invoke-virtual {v0}, Lchuangyuan\/ycj\/videolibrary\/video\/ExoUserPlayer;->onDestroy()V\r\n\r\n    .line 352\r\n    iget-object v0, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$16;->ˋ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    iget-object v0, v0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ˎ:Landroid\/view\/View;\r\n\r\n    const\/4 v1, 0x0\r\n\r\n    invoke-virtual {v0, v1}, Landroid\/view\/View;->setVisibility(I)V\r\n\r\n    .line 353\r\n    iget-object v0, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$16;->ˋ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    const-string v1, \"\\u6b64\\u7247\\u8bd5\\u770b\\u5df2\\u7ed3\\u675f\\uff0c\\u60a8\\u53ef\\u4ee5\\u7ee7\\u7eed\\u8bd5\\u770b\\u5176\\u4ed6\\u5f71\\u7247\\uff0c\\u6216\\u8005\\u6210\\u4e3a\\u4f1a\\u5458\\u65e0\\u9650\\u89c2\\u770b\\u6240\\u6709\\u5f71\\u7247\"\r\n\r\n    invoke-static {v0, v1}, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ˎ(Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;Ljava\/lang\/String;)V\r\n\r\n    .line 354\r\n    return-void\r\n.end method\r\n\r\n.method public onTick(J)V\r\n    .locals 3\r\n\r\n    .line 340\r\n    const-wide\/16 v0, 0x3e8\r\n\r\n    div-long v0, p1, v0\r\n\r\n    long-to-int v0, v0\r\n\r\n    invoke-static {v0}, Ljava\/lang\/String;->valueOf(I)Ljava\/lang\/String;\r\n\r\n    move-result-object v2\r\n\r\n    .line 341\r\n    iget-object v0, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$16;->ˋ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    iget-object v0, v0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ˋॱ:Landroid\/widget\/TextView;\r\n\r\n    invoke-virtual {v0, v2}, Landroid\/widget\/TextView;->setText(Ljava\/lang\/CharSequence;)V\r\n\r\n    .line 342\r\n    return-void\r\n.end method\r\n\r\n\r\n```\r\n\r\n\r\n\r\n`PlayVideoActivity$1`代码如下：\r\n\r\n```smali\r\n.class Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$1;\r\n.super Ljava\/lang\/Object;\r\n.source \"\"\r\n\r\n# interfaces\r\n.implements Lchuangyuan\/ycj\/videolibrary\/listener\/VideoInfoListener;\r\n\r\n\r\n# annotations\r\n.annotation system Ldalvik\/annotation\/EnclosingMethod;\r\n    value = Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ʼ()V\r\n.end annotation\r\n\r\n.annotation system Ldalvik\/annotation\/InnerClass;\r\n    accessFlags = 0x0\r\n    name = null\r\n.end annotation\r\n\r\n\r\n# instance fields\r\n.field final synthetic ॱ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n\r\n# direct methods\r\n.method constructor <init>(Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;)V\r\n    .locals 0\r\n\r\n    .line 576\r\n    iput-object p1, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$1;->ॱ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    invoke-direct {p0}, Ljava\/lang\/Object;-><init>()V\r\n\r\n    return-void\r\n.end method\r\n\r\n\r\n# virtual methods\r\n.method public isPlaying(Z)V\r\n    .locals 0\r\n\r\n    .line 638\r\n    return-void\r\n.end method\r\n\r\n.method public onLoadingChanged()V\r\n    .locals 0\r\n\r\n    .line 593\r\n    return-void\r\n.end method\r\n\r\n.method public onPlayEnd()V\r\n    .locals 3\r\n\r\n    .line 612\r\n    iget-object v0, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$1;->ॱ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    iget-object v0, v0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ॱˎ:Lchuangyuan\/ycj\/videolibrary\/video\/ExoUserPlayer;\r\n\r\n    if-eqz v0, :cond_0\r\n\r\n    .line 613\r\n    iget-object v0, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$1;->ॱ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    iget-object v0, v0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ॱˎ:Lchuangyuan\/ycj\/videolibrary\/video\/ExoUserPlayer;\r\n\r\n    invoke-virtual {v0}, Lchuangyuan\/ycj\/videolibrary\/video\/ExoUserPlayer;->onBackPressed()Z\r\n\r\n    .line 618\r\n    :cond_0\r\n    invoke-static {}, Lcom\/okappplay\/playproject\/AppContext;->ˊ()Lcom\/okappplay\/playproject\/AppContext;\r\n\r\n    move-result-object v0\r\n\r\n    invoke-virtual {v0}, Lcom\/okappplay\/playproject\/AppContext;->ˎ()Ljava\/lang\/String;\r\n\r\n    move-result-object v0\r\n\r\n    const-string v1, \"Y\"\r\n\r\n    invoke-virtual {v0, v1}, Ljava\/lang\/String;->equals(Ljava\/lang\/Object;)Z\r\n\r\n    move-result v0\r\n\r\n    if-eqz v0, :cond_2\r\n\r\n    .line 619\r\n    iget-object v0, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$1;->ॱ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    invoke-static {v0}, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ʼ(Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;)Landroid\/os\/CountDownTimer;\r\n\r\n    move-result-object v0\r\n\r\n    if-eqz v0, :cond_1\r\n\r\n    .line 620\r\n    iget-object v0, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$1;->ॱ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    invoke-static {v0}, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ʼ(Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;)Landroid\/os\/CountDownTimer;\r\n\r\n    move-result-object v0\r\n\r\n    invoke-virtual {v0}, Landroid\/os\/CountDownTimer;->cancel()V\r\n\r\n    .line 622\r\n    :cond_1\r\n    iget-object v0, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$1;->ॱ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    invoke-virtual {v0}, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->getApplicationContext()Landroid\/content\/Context;\r\n\r\n    move-result-object v0\r\n\r\n    invoke-static {v0}, Lo\/ก;->ˎ(Landroid\/content\/Context;)Lcom\/okappplay\/playproject\/bean\/UserBean;\r\n\r\n    move-result-object v0\r\n\r\n    invoke-virtual {v0}, Lcom\/okappplay\/playproject\/bean\/UserBean;->getUserType()Ljava\/lang\/String;\r\n\r\n    move-result-object v0\r\n\r\n    invoke-static {v0}, Ljava\/lang\/Integer;->parseInt(Ljava\/lang\/String;)I\r\n\r\n    move-result v2\r\n\r\n    .line 623\r\n    if-gtz v2, :cond_2\r\n\r\n    .line 624\r\n    iget-object v0, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$1;->ॱ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    iget-object v0, v0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ˎ:Landroid\/view\/View;\r\n\r\n    const\/4 v1, 0x0\r\n\r\n    invoke-virtual {v0, v1}, Landroid\/view\/View;->setVisibility(I)V\r\n\r\n    .line 626\r\n    iget-object v0, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$1;->ॱ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    const-string v1, \"\\u6b64\\u7247\\u8bd5\\u770b\\u5df2\\u7ed3\\u675f\\uff0c\\u60a8\\u53ef\\u4ee5\\u7ee7\\u7eed\\u8bd5\\u770b\\u5176\\u4ed6\\u5f71\\u7247\\uff0c\\u6216\\u8005\\u6210\\u4e3a\\u4f1a\\u5458\\u65e0\\u9650\\u89c2\\u770b\\u6240\\u6709\\u5f71\\u7247\"\r\n\r\n    invoke-static {v0, v1}, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ˎ(Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;Ljava\/lang\/String;)V\r\n\r\n    .line 631\r\n    :cond_2\r\n    return-void\r\n.end method\r\n\r\n.method public onPlayStart(J)V\r\n    .locals 2\r\n\r\n    .line 580\r\n    invoke-static {}, Lcom\/okappplay\/playproject\/AppContext;->ˊ()Lcom\/okappplay\/playproject\/AppContext;\r\n\r\n    move-result-object v0\r\n\r\n    invoke-virtual {v0}, Lcom\/okappplay\/playproject\/AppContext;->ˎ()Ljava\/lang\/String;\r\n\r\n    move-result-object v0\r\n\r\n    const-string v1, \"Y\"\r\n\r\n    invoke-virtual {v0, v1}, Ljava\/lang\/String;->equals(Ljava\/lang\/Object;)Z\r\n\r\n    move-result v0\r\n\r\n    if-eqz v0, :cond_0\r\n\r\n    .line 581\r\n    iget-object v0, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$1;->ॱ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    iget-boolean v0, v0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ॱˊ:Z\r\n\r\n    if-eqz v0, :cond_0\r\n\r\n    .line 582\r\n    iget-object v0, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$1;->ॱ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    const\/4 v1, 0x0\r\n\r\n    iput-boolean v1, v0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ॱˊ:Z\r\n\r\n    .line 583\r\n    iget-object v0, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$1;->ॱ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    invoke-static {v0}, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ʼ(Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;)Landroid\/os\/CountDownTimer;\r\n\r\n    move-result-object v0\r\n\r\n    invoke-virtual {v0}, Landroid\/os\/CountDownTimer;->start()Landroid\/os\/CountDownTimer;\r\n\r\n    .line 584\r\n    iget-object v0, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$1;->ॱ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    iget-object v0, v0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ˋॱ:Landroid\/widget\/TextView;\r\n\r\n    const\/4 v1, 0x0\r\n\r\n    invoke-virtual {v0, v1}, Landroid\/widget\/TextView;->setVisibility(I)V\r\n\r\n    .line 588\r\n    :cond_0\r\n    return-void\r\n.end method\r\n\r\n.method public onPlayerError(Lcom\/google\/android\/exoplayer2\/ExoPlaybackException;)V\r\n    .locals 2\r\n    .param p1    # Lcom\/google\/android\/exoplayer2\/ExoPlaybackException;\r\n        .annotation build Landroid\/support\/annotation\/Nullable;\r\n        .end annotation\r\n    .end param\r\n\r\n    .line 597\r\n    iget-object v0, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$1;->ॱ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    iget-boolean v0, v0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ᐝॱ:Z\r\n\r\n    if-nez v0, :cond_0\r\n\r\n    .line 598\r\n    iget-object v0, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$1;->ॱ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    iget-object v0, v0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ʽ:Landroid\/widget\/TextView;\r\n\r\n    const-string v1, \"\\u91cd\\u65b0\\u64ad\\u653e\"\r\n\r\n    invoke-virtual {v0, v1}, Landroid\/widget\/TextView;->setText(Ljava\/lang\/CharSequence;)V\r\n\r\n    .line 599\r\n    iget-object v0, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$1;->ॱ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    const\/4 v1, 0x1\r\n\r\n    iput-boolean v1, v0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ᐝॱ:Z\r\n\r\n    goto :goto_0\r\n\r\n    .line 601\r\n    :cond_0\r\n    iget-object v0, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$1;->ॱ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    invoke-virtual {v0}, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->getApplicationContext()Landroid\/content\/Context;\r\n\r\n    move-result-object v0\r\n\r\n    iget-object v1, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$1;->ॱ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    invoke-static {v1}, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ˏ(Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;)Lcom\/okappplay\/playproject\/bean\/VideoBean;\r\n\r\n    move-result-object v1\r\n\r\n    invoke-static {v0, v1}, Lo\/ก;->ʼ(Landroid\/content\/Context;Lcom\/okappplay\/playproject\/bean\/VideoBean;)Z\r\n\r\n    move-result v0\r\n\r\n    if-eqz v0, :cond_1\r\n\r\n    .line 602\r\n    iget-object v0, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$1;->ॱ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    iget-object v0, v0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ʽ:Landroid\/widget\/TextView;\r\n\r\n    const-string v1, \"\\u611f\\u8c22\\u60a8\\u7684\\u53cd\\u9988\"\r\n\r\n    invoke-virtual {v0, v1}, Landroid\/widget\/TextView;->setText(Ljava\/lang\/CharSequence;)V\r\n\r\n    goto :goto_0\r\n\r\n    .line 604\r\n    :cond_1\r\n    iget-object v0, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$1;->ॱ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    iget-object v0, v0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ʽ:Landroid\/widget\/TextView;\r\n\r\n    const-string v1, \"\\u70b9\\u51fb\\u53cd\\u9988\"\r\n\r\n    invoke-virtual {v0, v1}, Landroid\/widget\/TextView;->setText(Ljava\/lang\/CharSequence;)V\r\n\r\n    .line 608\r\n    :goto_0\r\n    return-void\r\n.end method\r\n\r\n```\r\n\r\n\r\n\r\n可以看出：\r\n\r\n`PlayVideoActivity$6`继承自`handler`,该类没有什么内容，只是重写了`handleMessage`方法。\r\n\r\n`PlayVideoActivity$16`继承自`CountDownTimer`，这是一个倒计时类，而我们的视频就是倒计时几十秒的，可以关注下\r\n\r\n`PlayVideoActivity$1`继承自`Object`，以为没什么用，但是它还实现了`VideoInfoListener`接口，其中有`onPlayStart`、`onPlayEnd`和`onPlayerError`等播放状态回调方法。\r\n\r\n视频倒计时是从点击试看按钮后开始计时的，所以会不会点击试看后调用播放功能当视频播放后回调`onPlayStart`时执行了计时功能？进去该方法看看就知道了\r\n\r\n在`onPlayStart`方法中有这样一段代码：\r\n\r\n```smali\r\n    .line 583\r\n    iget-object v0, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$1;->ॱ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    invoke-static {v0}, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ʼ(Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;)Landroid\/os\/CountDownTimer;\r\n\r\n    move-result-object v0\r\n\r\n    invoke-virtual {v0}, Landroid\/os\/CountDownTimer;->start()Landroid\/os\/CountDownTimer;\r\n```\r\n\r\n翻译过来的意思就是：\r\n\r\n把`PlayVideoActivity$1;->ॱ`这个变量放到`v0`寄存器，这个变量类型是`PlayVideoActivity`\r\n\r\n调用`PlayVideoActivity;->ʼ(Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;)`静态方法返回一个`CountDownTimer`\r\n\r\n把上面方法调用后的返回值放到`v0`寄存器  这个时候`v0`寄存器是一个`CountDownTimer`实例。\r\n\r\n最后调用`CountDownTimer`实例的`start`方法。这里应该就是倒计时开始的地方了。\r\n\r\n> 关于上面做一些说明：\r\n>\r\n> Android是基于寄存器的，Java是基于栈的，所以smali中的v0，p0都是寄存器。\r\n>\r\n> 一些不明所以的符号其实是混淆造成的。\r\n>\r\n> p0是非静态方法的隐形参数，表示调用当前方法的实例 this，所以可知显示传递的参数在smali中从p1开始。\r\n>\r\n> \r\n\r\n既然基本确定了这个倒计时是负责完整视频的，那么就注释掉最后这个虚方法的调用，重新打包签名(见下面)。\r\n\r\n最后运行时发现确实能直接观看完整视频了。\r\n\r\n视频都露点，所以不截图了。\r\n\r\n##### 目标2：同一视频可以多次播放\r\n\r\n现在播放过的视频再次播放提示“此片您已试看过”，不让我再看了。\r\n\r\n初步怀疑是在退出播放\/页面时对当前视频id进行了保存，而且只保存在了本地。。因为我清除数据或者从新安装后能从新观看。\r\n\r\n当再次点击视频进入播放页面时取出该视频id在本地存储里找，如果找到了就弹出提示不给播放。\r\n\r\n所以把“此片您已试看过”转为Unicode码去项目中搜索，发现在`VideoPlayActivity`的`ˏॱ()V`方法里有该字符串使用，相关代码如下：\r\n\r\n```smali\r\n    .line 391\r\n    :cond_2\r\n    const-string v0, \"\\u6b64\\u7247\\u60a8\\u5df2\\u7ecf\\u8bd5\\u770b\\u8fc7\\uff0c\\u60a8\\u53ef\\u4ee5\\u7ee7\\u7eed\\u8bd5\\u770b\\u5176\\u4ed6\\u5f71\\u7247\\uff0c\\u6216\\u8005\\u6210\\u4e3a\\u4f1a\\u5458\\u65e0\\u9650\\u89c2\\u770b\\u6240\\u6709\\u5f71\\u7247\"\r\n\r\n    invoke-direct {p0, v0}, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ˋ(Ljava\/lang\/String;)V\r\n```\r\n\r\n`const-string`表示取出常量字符串放到`v0`寄存器，\r\n\r\n`invoke-direct {p0, v0}`表示调用方法传入参数`p0`，`v0`  这里基本确定里面某个地方会调用弹窗了。\r\n\r\n为什么这里直接调用弹窗呢？直接就执行这个逻辑了吗？\r\n\r\n其实并没有，看上面还有个`:cond_2`，这表示一个跳转地址，\r\n\r\n也就是说在该方法上面地方执行了前面说的视频id比较，经过一些条件判断跳转到了`:cond_2`。\r\n\r\n顺腾摸瓜，果然又发现了`:cond_2 `代码如下：\r\n\r\n```\r\ninvoke-virtual {v1}, Lcom\/okappplay\/playproject\/bean\/VideoBean;->getVideoId()Ljava\/lang\/String;\r\n\r\n    move-result-object v1\r\n\r\n    invoke-static {v0, v1}, Lo\/ก;->ˋॱ(Landroid\/content\/Context;Ljava\/lang\/String;)Z\r\n\r\n    move-result v0\r\n\r\n    if-nez v0, :cond_2\r\n```\r\n\r\n这几句大概意思是：\r\n\r\n调用`getVideoId`返回视频id字符串\r\n\r\n通过`move-result-object`把id存到`v1`寄存器\r\n\r\n调用静态方法`Lo\/ก;->ˋॱ(Landroid\/content\/Context;Ljava\/lang\/String;)Z`返回布尔值\r\n\r\n通过`move-result`把布尔值存到`v0`寄存器\r\n\r\n`if-nez v0` 表示如果` v0`不为0就跳转到刚才的弹窗逻辑。\r\n\r\n感觉看到了希望的曙光，\r\n\r\n既然`v0`不为0就弹窗 ,不让看了，那我让`v0`为0不就好了吗。\r\n\r\n`v0`的值来自于静态方法的执行，进去看看，找到第一个return地方：\r\n\r\n```smali\r\n    invoke-interface {v2, v0, v1}, Landroid\/content\/SharedPreferences;->getString(Ljava\/lang\/String;Ljava\/lang\/String;)Ljava\/lang\/String;\r\n\r\n    move-result-object v3\r\n\r\n    .line 1207\r\n    invoke-static {v3}, Landroid\/text\/TextUtils;->isEmpty(Ljava\/lang\/CharSequence;)Z\r\n\r\n    move-result v0\r\n\r\n    if-eqz v0, :cond_0\r\n\r\n    .line 1208\r\n    const\/4 v0, 0x0\r\n\r\n    return v0\r\n    \r\n    .line 1211\r\n    :cond_0\r\n    new-instance v0, Lcom\/google\/gson\/Gson;\r\n```\r\n\r\n可以看得出来这里确实和我上面猜测的一样，把视频id存在本地了，而且就用sp存的。\r\n\r\n这里逻辑不用管，我们进这个方法目的就是让它返回0的\r\n\r\n第一个`return `返回`v0`寄存器值，而上面一行`const\/4 v0, 0x0 ` 直接把0存到了`v0`寄存器。\r\n\r\n这样就是可以直接观看的了，当然如果能执行到这里的话。\r\n\r\n不过既然弹窗了，那说明`if-eqz v0, :cond_0`这里，地址跳转到了`cond_0`。\r\n\r\n注释掉不给它机会判断就好了。\r\n\r\n按照上面打包签名验证下，果然多次播放也不会给提示了。\r\n\r\n到这里已经完成了非VIP观看完整视频且允许多次观看，如果处于看小视频目的，那已经完成了。\r\n\r\n不过我是为了提升技术的，所以继续目标3、4。\r\n\r\n##### 目标3：去广告\r\n\r\n广告这里不打算去掉页面的显示，只把倒计时7s改为1s，达到进入即播放效果。\r\n\r\n广告是在播放前，点击试看按钮后出现的倒计时。\r\n\r\n倒计时会出现\"广告xs\"的字样，所以去搜索“广告”的Unicode码，发现在内部类`PlayVideoActivity$19`中有使用，这个类是`CountDownTimer`子类，所以在``PlayVideoActivity`某个地方调用了该实例的start方法。\r\n\r\n查找发现只有下面方法中使用了`PlayVideoActivity$19`：\r\n\r\n```smali\r\n.method public ʽ()V\r\n    .locals 6\r\n\r\n    .line 289\r\n\r\n    new-instance v0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$19;\r\n\r\n    iget-object v1, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ˋ:Lcom\/okappplay\/playproject\/bean\/AdResult$AaData;\r\n\r\n    invoke-virtual {v1}, Lcom\/okappplay\/playproject\/bean\/AdResult$AaData;->getShowTime()Ljava\/lang\/String;\r\n\r\n    move-result-object v1\r\n\r\n    invoke-static {v1}, Ljava\/lang\/Integer;->parseInt(Ljava\/lang\/String;)I\r\n\r\n    move-result v1\r\n\r\n    mul-int\/lit16 v1, v1, 0x3e8\r\n\r\n    int-to-long v2, v1\r\n\r\n    move-object v1, p0\r\n\r\n    const-wide\/16 v4, 0x3e8\r\n\r\n    invoke-direct\/range {v0 .. v5}, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$19;-><init>(Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;JJ)V\r\n\r\n    iput-object v0, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;->ˉ:Landroid\/os\/CountDownTimer;\r\n\r\n    .line 307\r\n    return-void\r\n.end method\r\n```\r\n\r\n`new-instance v0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$19;`表示把`PlayVideoActivity$19`实例存入`v0`寄存器\r\n\r\n`invoke-direct\/range {v0 .. v5}, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$19;-><init>(Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;JJ)V `表示调用`PlayVideoActivity$19`的构造方法，这里把`v0`到`v5`几个寄存器的值都传递过去了。\r\n\r\n查看`PlayVideoActivity$19`构造方法：\r\n\r\n```\r\n# direct methods\r\n.method constructor <init>(Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;JJ)V\r\n    .locals 0\r\n\r\n    .line 289\r\n    iput-object p1, p0, Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity$19;->ˎ:Lcom\/okappplay\/playproject\/activity\/PlayVideoActivity;\r\n\r\n    invoke-direct {p0, p2, p3, p4, p5}, Landroid\/os\/CountDownTimer;-><init>(JJ)V\r\n\r\n    return-void\r\n.end method\r\n```\r\n\r\n可以看到实参和形参对应关系为：\r\n\r\n`v0`对应`p1`，`v1`对应`p2`，\r\n\r\n`invoke-direct {p0, p2, p3, p4, p5}, Landroid\/os\/CountDownTimer;-><init>(JJ)V`\r\n\r\n看到`p2`(也就是`v1`)表示倒计时总时长，\r\n\r\n所以我们修改`v1`值为1即可。\r\n\r\n只要找到把广告时间存到`v1`的地方，在其后面我们从新给`v1`存个`0x1`应该就可以了。\r\n\r\n可以看到下面这里获取到了广告时间，并且转为int类型存入`v1`：\r\n\r\n```\r\n    invoke-virtual {v1}, Lcom\/okappplay\/playproject\/bean\/AdResult$AaData;->getShowTime()Ljava\/lang\/String;\r\n\r\n    move-result-object v1\r\n   invoke-static {v1}, Ljava\/lang\/Integer;->parseInt(Ljava\/lang\/String;)I\r\n\r\n    move-result v1\r\n```\r\n\r\n所以我们在其后面添加：\r\n\r\n```smali\r\nconst v1,0x1\r\n```\r\n\r\n这时不管从AaData取到的广告值是多少，最后都是1s了。\r\n\r\n从新打包签名后验证即可。\r\n\r\n##### 目标4：去掉电话权限申请\r\n\r\n启动时的权限申请是在欢迎页申请的。\r\n\r\n通过命令行可以知道欢迎页是`WelComeActivity`，它也继承了`BaseActivity`\r\n\r\n去`WelComeActivity`中找实现的那几个抽象方法，看看哪个里面有关于权限申请的代码。\r\n\r\n最终找到如下代码：\r\n\r\n```smali\r\n    const-string v3, \"android.permission.READ_PHONE_STATE\"\r\n\r\n    const\/4 v4, 0x0\r\n\r\n    aput-object v3, v2, v4\r\n\r\n    const-string v3, \"android.permission.WRITE_EXTERNAL_STORAGE\"\r\n\r\n    const\/4 v4, 0x1\r\n\r\n    aput-object v3, v2, v4\r\n\r\n    invoke-static {v0, v1, v2}, Lcom\/okappplay\/playproject\/perssion\/PermissionsUtil;->ˎ(Landroid\/content\/Context;Lo\/م;[Ljava\/lang\/String;)V\r\n```\r\n\r\n第一行就用到了电话权限，\r\n\r\n我们知道权限的申请是按组来的，既然下面申请了\"写存储\"，那我干脆把电话权限改为\"读存储\"。\r\n\r\n让它多余但又不会抱错：\r\n\r\n```\r\n# const-string v3, \"android.permission.READ_PHONE_STATE\"\r\n  const-string v3, \"android.permission.READ_EXTERNAL_STORAGE\"\r\n```\r\n\r\n打包验证发现电话申请权限已经没有了。\r\n\r\n#### 重打包\r\n\r\n`java -jar apktool_2.4.0.jar b llsp -o aa.apk`\r\n\r\n#### 重签名\r\n\r\n`jarsigner -keystore debug.keystore aa.apk androiddebugkey`\r\n\r\n### 最后\r\n\r\n放一个破解后可以观看完整视频的截图：\r\n\r\n![完整视频截图](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/ll-play.png)\r\n\r\n能播放到29分钟，说明几十秒的倒计时已经无效了。\r\n\r\n参考：\r\n\r\napktool下载：https:\/\/ibotpeaches.github.io\/Apktool\/install\/\r\n\r\n关于CountDownTimer使用方法：https:\/\/www.jianshu.com\/p\/949cd818becc\r\n\r\n中文和Unicode互转：https:\/\/www.bejson.com\/convert\/unicode_chinese\/ \r\n\r\n《Android软件安全与逆向分析》\r\n\r\n《Android安全技术揭秘与防范》"
  },
  {
    "title": "Android性能优化整理",
    "created_time": "2019-10-30 07:22:43",
    "body": "# 图\r\n\r\n\r\n\r\n![Android性能优化图](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%9B%BE.png)\r\n\r\n\r\n\r\n# 文章\r\n\r\n[浅谈Android性能优化系列(0)之为什么需要性能优化](\/flutterblog.io/#\/markdown_page?type=android&name=浅谈Android性能优化系列(0)之为什么需要性能优化)\r\n\r\n[浅谈Android性能优化系列(1)之安装包大小优化](\/flutterblog.io\/#\/markdown_page?type=android&name=浅谈Android性能优化系列(1)之安装包大小优化 )\r\n\r\n[浅谈Android性能优化系列(2)之稳定性优化](\/flutterblog.io\/#\/markdown_page?type=android&name=浅谈Android性能优化系列(2)之稳定性优化 )\r\n\r\n[浅谈Android性能优化系列(3)之网络优化](\/flutterblog.io\/#\/markdown_page?type=android&name=浅谈Android性能优化系列(3)之网络优化)\r\n\r\n[浅谈Android性能优化系列(4)之耗电优化](\/flutterblog.io\/#\/markdown_page?type=android&name=浅谈Android性能优化系列(4)之耗电优化)\r\n\r\n[浅谈Android性能优化系列(5)之UI优化](\/flutterblog.io\/#\/markdown_page?type=android&name=浅谈Android性能优化系列(5)之UI优化)\r\n\r\n[浅谈Android性能优化系列(6)之内存优化](\/flutterblog.io\/#\/markdown_page?type=android&name=浅谈Android性能优化系列(6)之内存优化)\r\n\r\n[浅谈Android性能优化系列工具篇之BatteryHistorian电量检测工具使用](\/flutterblog.io\/#\/markdown_page?type=android&name=浅谈Android性能优化系列工具篇之BatteryHistorian电量检测工具使用 )\r\n\r\n[浅谈Android性能优化系列工具篇之MAT使用](\/flutterblog.io\/#\/markdown_page?type=android&name=浅谈Android性能优化系列工具篇之MAT使用)\r\n\r\n[关于FileMonitor的想法和实现](\/flutterblog.io\/#\/markdown_page?type=android&name=关于FileMonitor的想法和实现)"
  },
  {
    "title": "关于FileMonitor的想法和实现",
    "created_time": "2019-11-02 12:17:29",
    "body": "# 0x00 前言\r\n\r\nAndroid为我们提供了很多好用的工具，以便我们能从各个角度来分析查找出App中的缺陷。\r\n\r\n比如UI优化的Hierarchy Viewer、方法检测的TraceView、内存泄漏的Mat。\r\n\r\n但是发现Android常用的工具里面对IO操作分析监控工具比较少，或者说没有？\r\n\r\n已知的检测IO的StrictMode也只能检测主线程的磁盘操作，对于IO的分析及优化是不能达到的。\r\n\r\n所以就萌生了自己实现一个IO监控工具的想法。\r\n<!-- more -->\r\n\r\n# 0x01 目标\r\n\r\n有了想法，但也不要着急去做，首先要去细化要实现什么样的功能？\r\n\r\n这里IO监控暂时只想监控文件IO，不包括sqlite。\r\n\r\n想实现：\r\n\r\n- 监控文件的打开、读写、关闭状态、次数及耗时。\r\n- 当前操作文件的线程、进程及堆栈信息\r\n- 当前文件路径\r\n\r\n# 0x02 尝试\r\n\r\n## 文件IO流程简单分析\r\n\r\n很多多黑科技的实现不过是**动态代理**的具体应用。\r\n\r\n要做文件IO监控，首先查看文件从Java到Native的流程。\r\n\r\n看看能不能从中找到hook点。\r\n\r\n我们知道文件的操作都是通过流来完成，\r\n\r\n所以我随便点开了个`FileOutputStream`源码，看看里面`write`方法如何实现的：\r\n\r\n![image-20191102175146704](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/%E6%96%87%E4%BB%B6%E7%9B%91%E6%8E%A7-write%E6%96%B9%E6%B3%95.png)\r\n\r\n让人蛋疼的情况出现了，这刚走一步，就出现了框架类`IoBridge`，通过应用层不能继续深入源码了。\r\n\r\n所以只能通过Android源码里去分析，源码位置为：\r\n\r\n`E:\\AndroidSource\\Android-8.0.0_r9\\libcore\\luni\\src\\main\\java\\libcore\\io\\IoBridge.java`\r\n\r\n其`write`方法为：\r\n\r\n```java\r\n    public static void write(FileDescriptor fd, byte[] bytes, int byteOffset, int byteCount) throws IOException {\r\n        Arrays.checkOffsetAndCount(bytes.length, byteOffset, byteCount);\r\n        if (byteCount == 0) {\r\n            return;\r\n        }\r\n        try {\r\n            while (byteCount > 0) {\r\n                int bytesWritten = Libcore.os.write(fd, bytes, byteOffset, byteCount);\r\n                byteCount -= bytesWritten;\r\n                byteOffset += bytesWritten;\r\n            }\r\n        } catch (ErrnoException errnoException) {\r\n            throw errnoException.rethrowAsIOException();\r\n        }\r\n    }\r\n```\r\n\r\n这里的核心部分就是`Libcore.os.write(fd, bytes, byteOffset, byteCount);`\r\n\r\n进去看看这个`Libcore`的实现：\r\n\r\n```java\r\npublic final class Libcore {\r\n    private Libcore() { }\r\n\r\n    \/**\r\n     * Direct access to syscalls. Code should strongly prefer using {@link #os}\r\n     * unless it has a strong reason to bypass the helpful checks\/guards that it\r\n     * provides.\r\n     *\/\r\n    public static Os rawOs = new Linux();\r\n\r\n    \/**\r\n     * Access to syscalls with helpful checks\/guards.\r\n     *\/\r\n    public static Os os = new BlockGuardOs(rawOs);\r\n}\r\n```\r\n\r\n可以看到`LibCore`的实现非常简单，所以可以确定干货都在`OS`里面。\r\n\r\n这个`OS`其实是个接口，里面定义了所有对于文件操作，方法比较多，这里随便找几个方法看看：\r\n\r\n```java\r\npublic interface Os {\r\n    public FileDescriptor accept(FileDescriptor fd, SocketAddress peerAddress) throws ErrnoException, SocketException;\r\n    public void chmod(String path, int mode) throws ErrnoException;\r\n    public int pread(FileDescriptor fd, ByteBuffer buffer, long offset) throws ErrnoException, InterruptedIOException;\r\n    public int pread(FileDescriptor fd, byte[] bytes, int byteOffset, int byteCount, long offset) throws ErrnoException, InterruptedIOException;\r\n    public int pwrite(FileDescriptor fd, ByteBuffer buffer, long offset) throws ErrnoException, InterruptedIOException;\r\n    public int pwrite(FileDescriptor fd, byte[] bytes, int byteOffset, int byteCount, long offset) throws ErrnoException, InterruptedIOException;\r\n    public int read(FileDescriptor fd, ByteBuffer buffer) throws ErrnoException, InterruptedIOException;\r\n    public int read(FileDescriptor fd, byte[] bytes, int byteOffset, int byteCount) throws ErrnoException, InterruptedIOException;\r\n    public void rename(String oldPath, String newPath) throws ErrnoException;\r\n    public int write(FileDescriptor fd, ByteBuffer buffer) throws ErrnoException, InterruptedIOException;\r\n    public int write(FileDescriptor fd, byte[] bytes, int byteOffset, int byteCount) throws ErrnoException, InterruptedIOException;\r\n    public int writev(FileDescriptor fd, Object[] buffers, int[] offsets, int[] byteCounts) throws ErrnoException, InterruptedIOException;\r\n}\r\n\r\n```\r\n\r\n既然`OS`是接口，那自然就有实现类，看下它的继承关系图：\r\n\r\n![image-20191102181510086](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/%E6%96%87%E4%BB%B6%E7%9B%91%E6%8E%A7-OS%E7%BB%A7%E6%89%BF%E5%9B%BE.png)\r\n\r\n其中`Linux`里面是`native`方法，调用JNI层。\r\n\r\n刚才看到`Libcore`的`os`是这样的：\r\n\r\n`public static Os os = new BlockGuardOs(rawOs);`\r\n\r\n所以`Libcore.os.write`方法其实调用的是`BlockGuardOs`中的方法，进去看看内容：\r\n\r\n```java\r\n    @Override public int write(FileDescriptor fd, ByteBuffer buffer) throws ErrnoException, InterruptedIOException {\r\n        BlockGuard.getThreadPolicy().onWriteToDisk();\r\n        return os.write(fd, buffer);\r\n    }\r\n```\r\n\r\n这里又调用了`os.write`方法。\r\n\r\n这个`os`变量就是`public static Os os = new BlockGuardOs(rawOs);`中的`rawOs`。\r\n\r\n也就是说从这开始进入`native`方法了，看下实现：\r\n\r\n```java\r\npublic int write(FileDescriptor fd, ByteBuffer buffer) throws ErrnoException, InterruptedIOException {\r\n        final int bytesWritten;\r\n        final int position = buffer.position();\r\n        if (buffer.isDirect()) {\r\n            bytesWritten = writeBytes(fd, buffer, position, buffer.remaining());\r\n        } else {\r\n            bytesWritten = writeBytes(fd, NioUtils.unsafeArray(buffer), NioUtils.unsafeArrayOffset(buffer) + position, buffer.remaining());\r\n        }\r\n\r\n        maybeUpdateBufferPosition(buffer, position, bytesWritten);\r\n        return bytesWritten;\r\n    }\r\n    public int write(FileDescriptor fd, byte[] bytes, int byteOffset, int byteCount) throws ErrnoException, InterruptedIOException {\r\n        \/\/ This indirection isn't strictly necessary, but ensures that our public interface is type safe.\r\n        return writeBytes(fd, bytes, byteOffset, byteCount);\r\n    }\r\n    private native int writeBytes(FileDescriptor fd, Object buffer, int offset, int byteCount) throws ErrnoException, InterruptedIOException;\r\n    public native int writev(FileDescriptor fd, Object[] buffers, int[] offsets, int[] byteCounts) throws ErrnoException, InterruptedIOException;\r\n\r\n```\r\n\r\n通过`write`调用了`native`方法的`writeBytes`。\r\n\r\n至此，流程就简单分析完了。\r\n\r\n## 寻找hook点\r\n\r\nJava层流程分析完了，接下来就是在Java层寻找hook点。\r\n\r\n如果没有合适点，再去寻找Native层。\r\n\r\n因为我们要统计open、close、read、write四个地方。\r\n\r\n所以一个不错的方案是自定义一个类`BlockGuardOSProxy`继承`ForwardingOs`,实现我们需要的方法，\r\n\r\n然后找个合适的点，用我们的类替换掉系统的类，当对文件IO操作时，会回调到我们类重写的方法。\r\n\r\n在我们的方法中添加相关分析，然后继续调用系统层，让流程继续，这是代理思想。\r\n\r\n可以看下时序图：\r\n\r\n![image-20191102185450269](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/%E6%96%87%E4%BB%B6%E7%9B%91%E6%8E%A7-%E5%8E%9F%E6%97%B6%E5%BA%8F%E5%9B%BE.png)\r\n\r\n\r\n\r\n刚才我们看到`Libcore`中`os`变量是`public`的。\r\n\r\n所以我们可以把这个`os`变量变成我们的`BlockGuardOSProxy`。然后在我们方法里面调用`BlockGuardOs`。\r\n\r\n这样既拦截了我们想要的方法，又不会影响流程。这样最新流程就是这样的：\r\n\r\n![image-20191102185845650](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/%E6%96%87%E4%BB%B6%E7%9B%91%E6%8E%A7-%E6%96%B0%E6%97%B6%E5%BA%8F%E5%9B%BE.png)\r\n\r\n\r\n\r\n## 如何修改\r\n\r\n经过上面的分析，已经基本找到了hook点。接下来如何修改呢？\r\n\r\n```java\r\nLibcore.os = BlockGuardOSProxy(Libcore.os)\r\n```\r\n\r\n在`Application`方法里加上这样一句应该就可以完成替换了。\r\n\r\n其余的工作只要在`BlockGuardOSProxy`处理就好了。\r\n\r\n但是现在又要面临一个问题，就是`Libcore`和`ForwardingOs`这些类在应用层不存在不能编译通过。\r\n\r\n看看源码结构图：\r\n\r\n![image-20191102190806076](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/%E6%96%87%E4%BB%B6%E7%9B%91%E6%8E%A7-libcore%E4%BB%A3%E7%A0%81%E6%88%AA%E5%9B%BE.png)\r\n\r\n通过源码结构图发现里面有`src`目录，这分明也是一个小项目类型。\r\n\r\n所以这里面的代码应该是独立能编译的。\r\n\r\n既然都是java代码那我们也就可以打成一个jar包。\r\n\r\njar包有了，放到我们的项目libs下就可以了。\r\n\r\n不过其实不用我们自己动手打包，网上有现成的，也可以从自己ROM中提取，位置是：\r\n\r\n`\/system\/framework\/core-libart.jar`\r\n\r\n至此，文件IO监控已经完成，我们只使用了简单的静态代理。\r\n\r\n# 0x03 测试\r\n\r\n很多时候很多数据是需要缓存的，\r\n\r\n一般的缓存不是存sqlite就是File缓存。\r\n\r\n而对于不涉及隐私安全的，使用File缓存可以得到更好的性能。\r\n\r\n比如微博每条动态，谁都可以看，所以缓存时使用File缓存也可以。\r\n\r\n我们自定义一个数据类：\r\n\r\n```kotlin\r\ndata class WBItem(var textContent: String? = null,\r\n                  var imgUrl: String? = null,\r\n                  var good: Int = 0) : Serializable\r\n```\r\n\r\n对象序列化使用`ObjectOutputStream`，现在我们把200条信息缓存到本地File：\r\n\r\n```kotlin\r\n    private fun writeWBItemWithoutBuffer() {\r\n        thread {\r\n            val dir = Environment.getExternalStorageDirectory()\r\n            val mdir = File(\"${dir.path}${File.separator}monitor\")\r\n            val file1 = File(\"${mdir.path}${File.separator}wb.cache\")\r\n            if (checkFile()) {\r\n                LogUtils.e(file1.path)\r\n                val fos: OutputStream = FileOutputStream(file1)\r\n                val data = arrayListOf<WBItem>()\r\n                val oos = ObjectOutputStream(fos)\r\n                for (i in 0..200) {\r\n                    val wbItem = WBItem().apply {\r\n                        textContent = \"这是文本内容--$i\"\r\n                        imgUrl = \"这是图片url--$i\"\r\n                        good = i\/\/点赞数\r\n                    }\r\n                    data.add(wbItem)\r\n                }\r\n                oos.writeObject(data)\r\n                oos.flush()\r\n                oos.close()\r\n                fos.close()\r\n            }\r\n        }\r\n    }\r\n```\r\n\r\n打印Log如下：\r\n\r\n```\r\nFileWrap(fdInt=59, fd=java.io.FileDescriptor@b5e92d3, \r\npid=12323, tid=12371, mode=1, \r\npath=\/storage\/emulated\/0\/monitor\/wb.cache, \r\nopenTime=1572695396436, closeTime=1572695396532, \r\nprocess=null, thread=Thread-2, \r\nreadCount=0, readBytes=0, readTime=0, \r\nwriteCount=611, writeBytes=11793, writeTime=96, stacktrace=java.io.FileOutputStream.write(FileOutputStream.java:381)\r\n    java.io.ObjectOutputStream$BlockDataOutputStream.drain(ObjectOutputStream.java:1973)\r\n    java.io.ObjectOutputStream$BlockDataOutputStream.setBlockDataMode(ObjectOutputStream.java:1855)\r\n    java.io.ObjectOutputStream.<init>(ObjectOutputStream.java:253)\r\n    top.jenson.filemonitor.MainActivity$writeWBItemWithoutBuffer$1.invoke(MainActivity.kt:116)\r\n    top.jenson.filemonitor.MainActivity$writeWBItemWithoutBuffer$1.invoke(MainActivity.kt:12)\r\n    kotlin.concurrent.ThreadsKt$thread$thread$1.run(Thread.kt:30)\r\n    )\r\n```\r\n\r\n其中：\r\n\r\n`path`表示操作的文件路径\r\n\r\n通过`closeTime`-`openTime`可以计算出文件耗时。\r\n\r\n`stacktrace`表示调用堆栈，可以快速定位到问题位置。\r\n\r\n`readCount`表示读取次数，我们这里是写对象，自然为0了。\r\n\r\n`writeCount`表示写入次数，这里显示611次，200个对象写入这么多次？？？，\r\n\r\n后来查证，好像每个对象的每个属性都要被写入一次，再加上系统一些附加的。那就差不多了。\r\n\r\n不过这也就说明了200个对象，10多kb文件，写入如此高的次数是需要优化的。\r\n\r\n下面看看使用了buffer后的代码实现：\r\n\r\n```kotlin\r\nprivate fun writeWBItemWithBuffer() {\r\n        thread {\r\n            val dir = Environment.getExternalStorageDirectory()\r\n            val mdir = File(\"${dir.path}${File.separator}monitor\")\r\n            val file1 = File(\"${mdir.path}${File.separator}wb.cache\")\r\n            if (checkFile()) {\r\n                LogUtils.e(file1.path)\r\n                val fos: OutputStream = FileOutputStream(file1)\r\n                val data = arrayListOf<WBItem>()\r\n                val bos = ByteArrayOutputStream()\r\n                val oos = ObjectOutputStream(bos)\r\n                for (i in 0..200) {\r\n                    val wbItem = WBItem().apply {\r\n                        textContent = \"这是文本内容--$i\"\r\n                        imgUrl = \"这是图片url--$i\"\r\n                        good = i\r\n                    }\r\n                    data.add(wbItem)\r\n                }\r\n                oos.writeObject(data)\r\n                oos.flush()\r\n                bos.writeTo(fos)\r\n                bos.flush()\r\n                bos.close()\r\n                oos.close()\r\n                fos.close()\r\n            }\r\n        }\r\n    }\r\n```\r\n\r\n优化后的Log打印如下：\r\n\r\n```\r\nFileWrap(fdInt=59, fd=java.io.FileDescriptor@17f3d09, \r\npid=12653, tid=12696, mode=1, \r\npath=\/storage\/emulated\/0\/monitor\/wb.cache, \r\nopenTime=1572695907143, closeTime=1572695907144, \r\nprocess=null, thread=Thread-2, \r\nreadCount=0, readBytes=0, readTime=0, \r\nwriteCount=1, writeBytes=11793, writeTime=1, stacktrace=java.io.FileOutputStream.write(FileOutputStream.java:381)\r\n    java.io.ByteArrayOutputStream.writeTo(ByteArrayOutputStream.java:167)\r\n    top.jenson.filemonitor.MainActivity$writeWBItemWithBuffer$1.invoke(MainActivity.kt:154)\r\n    top.jenson.filemonitor.MainActivity$writeWBItemWithBuffer$1.invoke(MainActivity.kt:12)\r\n    kotlin.concurrent.ThreadsKt$thread$thread$1.run(Thread.kt:30)\r\n```\r\n\r\n可以看到优化后的`writeCount=1`。\r\n\r\n未优化的耗时计算为：1572695396532-1572695396436=‭96‬\r\n\r\n优化后的耗时计算为：1572695907144-1572695907143=1\r\n\r\n\r\n\r\n其实不仅对象序列化，其他的文件缓存也都可以监控并发现问题点。\r\n\r\n感谢：\r\n\r\n[【个人笔记一】ART系统类的编译解析加载探究]( https:\/\/www.twblogs.net\/a\/5b8aaa392b71775d1ce866c1\/zh-cn )\r\n\r\n[android 从java到C层文件读取流程]( https:\/\/blog.csdn.net\/zhu929033262\/article\/details\/51496809 )\r\n\r\n[剖析 Android ART Runtime (2) – dex2oat]( https:\/\/mssun.me\/blog\/android-art-runtime-2-dex2oat.html )"
  },
  {
    "title": "关于Android旧项目模块化组件化实现",
    "created_time": "2019-11-25 09:56:05",
    "body": "# 0x00 前言\r\n\r\n很多公司都喊起了模块化、组件化、插件化、热更新的口号。\r\n\r\n没用过，有点心慌；想用一下，但是上来就是四个名词更TM心慌，都是咋个意思？\r\n\r\n个人想法，为了理解方便，把它们分门别类一下：\r\n\r\n**模块化、组件化主要是提升开发体验**\r\n\r\n**插件化、热更新主要是提升用户体验**\r\n\r\n这两类可以分开学习，\r\n\r\n这里我们就先学习下模块化、组件化。\r\n\r\n# 0x01 为什么学\r\n\r\n学习新东西是有成本的，这是个功利的时代，\r\n\r\n我们很在意它能不能保本，如果能捞点就更好了。\r\n\r\n很多时候项目你以为是这样的：\r\n\r\n![image-20191126112252677](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/moudle-1.png)\r\n\r\n\r\n\r\n但实际是这样的：\r\n\r\n![image-20191126112410109](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/moudle-2.png)\r\n\r\n\r\n\r\n随着项目功能越来越丰富，代码越来越臃肿，\r\n\r\n带来的一个显著问题是编译时间变长。\r\n\r\n因为一点的改动都会造成一次全局的编译。\r\n\r\n如果实现模块化，每次只编译自己负责的模块岂不是很好？\r\n\r\n虽然说是各自负责模块，但是模块界限并不清晰，难免越界。\r\n\r\n所以我们渴望项目架构做出调整。\r\n\r\n经常我们实现初步模块化架构可能如图：\r\n\r\n\r\n\r\n![image-20191126114419704](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/moudle-3.png)\r\n\r\n这只是最基本的模块化结构图。\r\n\r\n对了，我们开头说了模块化\/组件化，但是现在一直提的只是模块化。\r\n\r\n**怎么才算组件化？**\r\n\r\n**我觉得组件化是更细粒度的模块化。**\r\n\r\n**模块是一组功能相关业务模块，比如动态模块有动态列表，动态详情，发表动态等一组功能**\r\n\r\n**组件是功能单一模块，比如动态和聊天都可以发送视频类型，取出视频播放这一功能作为组件**\r\n\r\n**组件可以单独抽取出来作为SDK，将来为公司其他项目直接引入可用**\r\n\r\n所以现在我们心中的模块化组件化结构图可能是这样的：\r\n\r\n![image-20191127101901377](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/moudle-4.png)\r\n\r\n\r\n\r\n# 0x02 结构调整\r\n\r\n在我看来模块化\/组件化第一步就是先结构调整。\r\n\r\n而结构调整的第一步是创建相关moudle。\r\n\r\n## 创建moudle\r\n\r\n我这里创建的moudle都是选择`android library`。\r\n\r\n创建好所需的moudle，按结构图添加好依赖关系。\r\n\r\n每个moudle都有一个`build.gradle`文件。\r\n\r\n我们要保证每个`build.gradle`中的\r\n\r\n`compileSdkVersion`、`minSdkVersion`、`targetSdkVersion`、`buildToolsVersion`值都相同，\r\n\r\n不然可能会有冲突。\r\n\r\n可以在项目根目录新建文件`common_config.gradle`，添加内容：\r\n\r\n```groovy\r\nproject.ext {\r\n    compileSdkVersion = 28\r\n    minSdkVersion = 21\r\n    targetSdkVersion = 21\r\n    buildToolsVersion = \"29.0.2\"\r\n}\r\n```\r\n\r\n然后在每个`build.gradle`文件中添加引用：\r\n\r\n```groovy\r\napply from: \"${rootProject.rootDir}\/common_config.gradle\"\r\n```\r\n\r\n接下来为各个属性使用统一的值：\r\n\r\n```groovy\r\nbuildToolsVersion project.ext.buildToolsVersion\r\ncompileSdkVersion project.ext.compileSdkVersion\r\nminSdkVersion project.ext.minSdkVersion\r\ntargetSdkVersion project.ext.targetSdkVersion\r\n```\r\n\r\n这样以后修改相关属性值只需要修改一次即可。\r\n\r\n到这一步，从新编译尝试运行项目。\r\n\r\n修复遇到的问题，确保现在在空壳moudle情况下可以正常运行。\r\n\r\n开始为后面操作做准备。\r\n\r\n## 代码拆分\r\n\r\n上面创建了moudle，但是里面还是空的。这一步来填内容。\r\n\r\n按照结构图开始像择菜一样择代码，把择出来的代码放到相应moudle中。\r\n\r\n但凡项目稍微大点，这都是一个痛苦且漫长的过程。\r\n\r\n择完代码后，业务moudle之间没有依赖关系，导致无法相互调用。\r\n\r\n**如果遇到组件之间的跳转代码飘红的地方暂时先注释掉。**\r\n\r\n**如果遇到组件之间的数据通信飘红地方也先注释掉。**\r\n\r\n**如果出现moudle无法使用它所依赖moudle已经添加依赖库中类的情况下，**\r\n\r\n**可能是你的依赖库使用的是`implementation`，改为`api`即可。**\r\n\r\n这俩的区别是：\r\n\r\n你在A moudle中用`implementation`添加的依赖，依赖的类库只能在A 本moudle中使用。\r\n\r\n如果其他moudle引用了A moudle，其他moudle要使用A中依赖的类库，需要使用`API`声明。\r\n\r\n譬如：\r\n\r\n```groovy\r\n    api 'com.squareup.retrofit2:retrofit:2.5.0'\r\n    api 'com.squareup.retrofit2:converter-gson:2.0.2'\r\n    \/\/rxjava\r\n    api 'io.reactivex.rxjava2:rxandroid:2.0.1'\r\n    \/\/二维码\r\n    api 'com.google.zxing:core:3.3.0'\r\n```\r\n\r\n## 适时下沉\r\n\r\n不要为了图方便一口气把所有文件都下沉到common。\r\n\r\n不要抱着反正下沉到common，我的moudle也能正常使用的心态。\r\n\r\n做人要有节操。\r\n\r\n## anko问题\r\n\r\n对于多个moudle公用的布局，我把它们下沉到common模块中。\r\n\r\n但是业务moudle通过anko直接使用id进行操作时是没有问题的。\r\n\r\n但是一旦编译运行就出现unresolve。\r\n\r\n所以只能通过手动方式获取：\r\n\r\n```kotlin\r\nprivate val titleView by lazy { find<TextView>(R.id.titleView) }\r\n```\r\n\r\n\r\n\r\n经过这一阶段的处理，你的App应该可以运行起来。\r\n\r\n同一个moudle之间可以跳转、数据传递。\r\n\r\n剩下的慢慢处理。\r\n\r\n# 0x03 模块间跳转\r\n\r\n上面说了模块之间的跳转飘红注释掉。\r\n\r\n这里我们来处理模块间跳转。\r\n\r\n上面模块间跳转所以会出错是因为使用了`显示跳转`，\r\n\r\n强依赖关系，而模块之前是没有关系的，导致飘红。\r\n\r\n那么如何实现模块之间正确跳转呢？\r\n\r\n## 隐式跳转\r\n\r\n隐式跳转，\r\n\r\n一种方式通过`action`跳转，\r\n\r\n首先要在`AndroidManifest`中对应actvity设置`IntentFilter`：\r\n\r\n```xml\r\n<intent-filter>\r\n     <action android:name=\"top.jenson.setting.activity.about\"\/>\r\n     <category android:name=\"android.intent.category.DEFAULT\"\/>\r\n<\/intent-filter>\r\n```\r\n\r\n然后在其他moudle使用如下跳转：\r\n\r\n```kotlin\r\nstartActivity(Intent(\"top.jenson.setting.activity.setting\"))\r\n```\r\n\r\n\r\n\r\n还可以通过另一种方式隐式跳转：包名+Activity全路径形式：\r\n\r\n```kotlin\r\nval intent = Intent()\r\nintent.setClassName(\"模块包名\", \"activity类全名称\")\r\nintent.component = ComponentName(\"模块包名\", \"activity类全名称\")\r\nstartActivity(intent)\r\n```\r\n\r\n\r\n\r\n隐式跳转并不理想，因为如果其他模块负责人把相关信息修改了。\r\n\r\n有可能会导致你的跳转异常崩溃。\r\n\r\n尽管你可以通过`intent.resolveActivity(activity!!.packageManager)`来判断。\r\n\r\n但是显然这是比较麻烦且不友好的。况且获取Fragment你要怎么办？\r\n\r\n## 路由跳转\r\n\r\n隐式跳转用着不舒服？还可以使用路由跳转。\r\n\r\nAndroid路由框架还是蛮多的，`activityRouter`、`deepLink`、`ARouter`等等。\r\n\r\n根据情况选择自己熟悉的框架即可。这里我使用`ARouter`。\r\n\r\n### 添加依赖\r\n\r\n在`build.gradle`中添加：\r\n\r\n下面是Kotlin方式\r\n\r\n```groovy\r\napply plugin: 'kotlin-kapt'\r\n\r\nkapt {\r\n    arguments {\r\n        arg(\"AROUTER_MODULE_NAME\", project.getName())\r\n    }\r\n}\r\n\r\ndependencies {\r\n    api 'com.alibaba:arouter-api:1.4.1'\r\n    kapt 'com.alibaba:arouter-compiler:1.2.2'\r\n   \r\n}\r\n```\r\n\r\n如果使用Java方式，及进阶使用参考[Github]( https:\/\/github.com\/alibaba\/ARouter\/blob\/master\/README_CN.md )\r\n\r\n### 统一声明path\r\n\r\n在Common moudle新建常量类，其中封装各个moudle中使用的path：\r\n\r\n```kotlin\r\nclass Constant {\r\n    companion object {\r\n        \/\/chat模块\r\n        \/\/common模块\r\n        const val COMMON_BDMapActivity = \"\/COMMON\/BDMapActivity\"\r\n        const val COMMON_AddLocationActivity = \"\/COMMON\/AddLocationActivity\"\r\n        \/\/dynamic模块\r\n        const val DYNAMIC_AddDynamicActivity = \"\/DYNAMIC\/AddDynamicActivity\"\r\n        \/\/feed模块\r\n        const val FEED_NearFeedActivity = \"\/FEED\/NearFeedActivity\"\r\n        \/\/lost模块\r\n        const val LOST_FindPetActivity = \"\/LOST\/FindPetActivity\"\r\n        \/\/setting模块\r\n        const val SETTING_FeedBackActivity = \"\/SETTING\/FeedBackActivity\"\r\n        const val SETTING_AboutActivity = \"\/SETTING\/AboutActivity\"\r\n        const val SETTING_SettingActivity = \"\/SETTING\/SettingActivity\"\r\n        \/\/user模块\r\n        const val USER_RegistActivity = \"\/USER\/RegistActivity\"\r\n        const val USER_LoginActivity = \"\/USER\/LoginActivity\"\r\n        const val USER_FindPwdActivity = \"\/USER\/FindPwdActivity\"\r\n    }\r\n}\r\n```\r\n\r\n### 调用\r\n\r\n无参调用使用：\r\n\r\n```kotlin\r\nARouter.getInstance().build(Constant.SETTING_AboutActivity).navigation()\r\n```\r\n\r\n如果要携带数据，在`navigation`前通过`with`函数传递：\r\n\r\n```java\r\nARouter.getInstance().build(\"\/test\/1\")\r\n            .withLong(\"key1\", 666L)\r\n            .withString(\"key3\", \"888\")\r\n            .withObject(\"key4\", new Test(\"Jack\", \"Rose\"))\r\n            .navigation();\r\n```\r\n\r\n期间遇到两个问题已解决，参考：\r\n\r\n[ ARouter::Compiler >>> No module name ]( https:\/\/blog.csdn.net\/a34927341\/article\/details\/87690451 )\r\n\r\n[ arouter there's  no route matched ]( https:\/\/blog.csdn.net\/weixin_37292229\/article\/details\/93375669 )\r\n\r\n## 项目调整\r\n\r\n模块间跳转大部分操作就是`actvity启动`和`获取fragment` ，以`activity启动`为例。\r\n\r\n跳转可以分为`调用点`和`被调用方`。\r\n\r\n`调用点`是指调用跳转的地方，譬如：\r\n\r\n```kotlin\r\nval intent = Intent(activity, AboutActivity::class.java)\r\nstartActivity(Intent(intent))\r\n```\r\n\r\n把调用点直接替换为上面介绍的跳转方法。\r\n\r\n`被调用方`是负责响应调用的类，如果涉及数据传递，就需要修改，\r\n\r\n为接收数据的变量添加@Autowired注解，譬如：\r\n\r\n```kotlin\r\n  @Autowired\r\n  var name;\r\n  @Autowired\r\n  var age;\r\n```\r\n\r\n **ARouter会自动对字段进行赋值，无需主动获取。**\r\n\r\n按照上面方式完成所有模块跳转修改，\r\n\r\n目前你的项目应该确保模块间页面互相打开是没问题的。\r\n\r\n# 0x04 模块间通信\r\n\r\n通过上面操作，目前已经完成了模块间跳转功能。\r\n\r\n本节开始处理模块间通信问题。\r\n\r\n通过结构图可以看到模块之间是没有依赖的。\r\n\r\n所以直接通信不现实，那么只能走间接通信。\r\n\r\n业务模块都依赖了common moudle。\r\n\r\n**我们可以把通信内容(数据类)下沉到common模块，通过事件总线实现通信**\r\n\r\n事件总线有一个不好的地方就是每个不同的消息事件都对应成一个数据类。\r\n\r\n如果事件很多，我们需要维护的事件类是庞大的。\r\n\r\n每次的事件修改，都是对common moudle的修改。\r\n\r\n所以**可以单独创建EventMoudle，用来存放事件类，common moudle 依赖它。**\r\n\r\n\r\n\r\n经过上面的一通修改，目前你的App功能应该和调整前一样，各功能正常运行。\r\n\r\n但是我们结构调整的最初目标：单独编译还没实现。\r\n\r\n# 0x05 独立编译\r\n\r\n上面已经通过`common_config.gradle`抽取了四个通用属性。\r\n\r\n下面我们要继续抽取。\r\n\r\n## 继续抽取build.gradle\r\n\r\n我们看到每个moudle都有一个`build.gradle`。\r\n\r\n每个文件里面开头都引用了几个插件，除了lib和Application，大体都是一样的：\r\n\r\n```groovy\r\n\/\/主moudle\r\napply plugin: 'com.android.application'\r\n\/\/lib moudle\r\nextension.apply plugin: 'com.android.library'\r\n\r\napply plugin: 'kotlin-android'\r\napply plugin: 'kotlin-android-extensions'\r\napply plugin: 'kotlin-kapt'\r\n```\r\n\r\n所以在`common_config.gradle`的`ext`域中添加：\r\n\r\n```\r\n    \/\/主moudle使用\r\n    setAppDefaultConfig = {\r\n        extension ->\r\n            extension.apply plugin: 'com.android.application'\r\n            extension.apply plugin: 'kotlin-android'\r\n            extension.apply plugin: 'kotlin-android-extensions'\r\n            extension.apply plugin: 'kotlin-kapt'\r\n    }\r\n\t\/\/lib moudle使用\r\n    setLibDefaultConfig = {\r\n        extension ->\r\n            extension.apply plugin: 'com.android.library'\r\n            extension.apply plugin: 'kotlin-android'\r\n            extension.apply plugin: 'kotlin-android-extensions'\r\n            extension.apply plugin: 'kotlin-kapt'\r\n    }\r\n    \r\n```\r\n\r\n由于在`android{}`和`dependencies{}`中也有很多相同内容，所以把这两个地方也提取出来。\r\n\r\n在`common_config.gradle`的`ext`域添加为：\r\n\r\n```\r\n    setAndroidConfig = {\r\n        extension ->\r\n            extension.compileSdkVersion = 28\r\n            extension.buildToolsVersion = \"29.0.2\"\r\n            extension.defaultConfig {\r\n                kapt {\r\n                    arguments {\r\n                        arg(\"AROUTER_MODULE_NAME\", extension.project.getName())\r\n                    }\r\n                }\r\n                minSdkVersion = 21\r\n                targetSdkVersion = 21\r\n                testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\r\n            }\r\n\/\/            extension.dataBinding {\r\n\/\/                enable = true\r\n\/\/            }\r\n    }\r\n\r\n    setDependencies = {\r\n\r\n    }\r\n```\r\n\r\n不管是主moudle还是lib moudle，它们都包含`setAndroidConfig`和`setDependencies`。\r\n\r\n所以要把这两个放入前面moudle内容中。\r\n\r\n修改后内容为：\r\n\r\n```groovy\r\nproject.ext {\r\n    setAppDefaultConfig = {\r\n        extension ->\r\n            extension.apply plugin: 'com.android.application'\r\n            extension.apply plugin: 'kotlin-android'\r\n            extension.apply plugin: 'kotlin-android-extensions'\r\n            extension.apply plugin: 'kotlin-kapt'\r\n            setAndroidConfig extension.android\r\n            setDependencies extension.dependencies\r\n    }\r\n    setLibDefaultConfig = {\r\n        extension ->\r\n            extension.apply plugin: 'com.android.library'\r\n            extension.apply plugin: 'kotlin-android'\r\n            extension.apply plugin: 'kotlin-android-extensions'\r\n            extension.apply plugin: 'kotlin-kapt'\r\n            setAndroidConfig extension.android\r\n            setDependencies extension.dependencies\r\n    }\r\n\r\n    setAndroidConfig = {\r\n        extension ->\r\n            extension.compileSdkVersion = 28\r\n            extension.buildToolsVersion = \"29.0.2\"\r\n            extension.defaultConfig {\r\n                kapt {\r\n                    arguments {\r\n                        arg(\"AROUTER_MODULE_NAME\", extension.project.getName())\r\n                    }\r\n                }\r\n                minSdkVersion = 21\r\n                targetSdkVersion = 21\r\n                testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\r\n            }\r\n\/\/            extension.dataBinding {\r\n\/\/                enable = true\r\n\/\/            }\r\n    }\r\n\r\n    setDependencies = {\r\n        extension ->\r\n            extension.implementation fileTree(dir: 'libs', include: ['*.jar'])\r\n            extension.implementation \"org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version\"\r\n            extension.implementation 'androidx.appcompat:appcompat:1.0.2'\r\n            extension.implementation 'androidx.core:core-ktx:1.0.2'\r\n            extension.kapt 'com.alibaba:arouter-compiler:1.2.2'\r\n    }\r\n}\r\n```\r\n\r\n内容抽取差不之后，需要把每个`build.gradle`中重复的内容移除掉。\r\n\r\n同时添加`common_config.gradle`使用：\r\n\r\n```groovy\r\napply from: \"${rootProject.rootDir}\/common_config.gradle\"\r\nproject.ext.setAppDefaultConfig project\r\n```\r\n\r\n同步项目并运行，为后面做准备。\r\n\r\n## 独立编译\r\n\r\n现在我的项目动态模块`dynamic`只有Fragment提供给app moudle的MainActivity。\r\n\r\n![image-20191127162514819](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/moudle-5.png)\r\n\r\n我现在打算独立运行`dynamic`。\r\n\r\n首先要添加个标志`isDebug`。如果为true表示我要独立运行，否则作为lib运行。\r\n\r\n标志加在`common_config.gradle`中`isDebug = true`。\r\n\r\n### 判断是否作为lib\r\n\r\n在`dynamic`的`build.gradle`中，根据`isDebug`来判断该moudle是否作为lib:\r\n\r\n```groovy\r\nif (project.ext.isDebug) {\r\n    project.ext.setAppDefaultConfig project\r\n} else {\r\n    project.ext.setLibDefaultConfig project\r\n}\r\n```\r\n\r\n### 设置applicationId\r\n\r\n作为app moudle，需要设置`applicationId`。\r\n\r\n在`dynamic`的`build.gradle`中，根据`isDebug`来判断该moudle是否添加`applicationId`:\r\n\r\n```groovy\r\nif (project.ext.isDebug) {\r\n            applicationId \"top.jenson.pet\"\r\n}\r\n```\r\n\r\n### 取消被依赖\r\n\r\n一个app中，你要当主moudle，就不能作为lib被其他moudle依赖。\r\n\r\n所以要根据`isDebug`来判断是否可以被添加依赖。\r\n\r\n在app moudle的`build.gradle`中修改：\r\n\r\n```\r\n    if (!project.ext.isDebug) {\r\n        implementation project(path: ':dynamic')\r\n    }\r\n```\r\n\r\n同步项目，发现已经多出了可以运行的`dynamic`：\r\n\r\n![image-20191127164425098](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/moudle-6.png)\r\n\r\n运行时提示错误`More than one file was found with OS independent path 'META-INF\/rxjava.properties'`。\r\n\r\n这是rxjava引起的问题。\r\n\r\n在`dynamic`的`build.gradle`中`defaultConfig`添加：\r\n\r\n```groovy\r\n        packagingOptions {\r\n            exclude 'META-INF\/rxjava.properties'\r\n        }\r\n```\r\n\r\n再次运行，发现还是运行不起来。因为没有可运行的activity。\r\n\r\n### 添加debug内容\r\n\r\n在`dynamic`的`src`下创建`debug`目录。\r\n\r\n和`main`目录一样，新建`AndroidManifest.xml`，`java`，`res`。\r\n\r\n新建`DynamicListActivity`，包裹Fragment。\r\n\r\n在`debug`目录的`AndroidManifest`注册Activity  :\r\n\r\n```xml\r\n        <activity android:name=\"activity.DynamicListActivity\">\r\n            <intent-filter>\r\n                <action android:name=\"android.intent.action.MAIN\"\/>\r\n                <category android:name=\"android.intent.category.LAUNCHER\" \/>\r\n            <\/intent-filter>\r\n        <\/activity>\r\n```\r\n\r\n结构图为：\r\n\r\n![image-20191127172530979](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/moudle-7.png)\r\n\r\n\r\n\r\n一般项目都有自定义Application，里面有很多初始化的逻辑。\r\n\r\n在`debug`下的`AndroidManifest`，为了避免各种问题，这里也使用以前定义的Application：\r\n\r\n```xml\r\n<application\r\n            android:name=\"top.jenson.common.acitivty.PetApplication\"\r\n            android:allowBackup=\"true\"\r\n            android:icon=\"@mipmap\/ic_launcher\"\r\n            android:label=\"@string\/app_name\"\r\n            android:roundIcon=\"@mipmap\/ic_launcher_round\"\r\n            android:supportsRtl=\"true\"\r\n            android:theme=\"@style\/AppTheme\"\r\n            android:usesCleartextTraffic=\"true\">\r\n        <activity android:name=\".activity.AddDynamicActivity\" \/>\r\n        <activity android:name=\"activity.DynamicListActivity\">\r\n            <intent-filter>\r\n                <action android:name=\"android.intent.action.MAIN\" \/>\r\n                <category android:name=\"android.intent.category.LAUNCHER\" \/>\r\n            <\/intent-filter>\r\n        <\/activity>\r\n    <\/application>\r\n```\r\n\r\n\r\n\r\n我们在`debug`目录下新建了很多内容，用于为本moudle提供一个入库Activity。\r\n\r\n这些内容只在独立编译时才会用到，作为lib时无需使用。\r\n\r\n所以在`build.gradle`中配置：\r\n\r\n```groovy\r\n    sourceSets {\r\n        main() {\r\n            jniLibs.srcDirs = ['libs']\r\n            if (project.ext.isDebug) {\r\n                manifest.srcFile 'src\/debug\/AndroidManifest.xml'\r\n                res.srcDirs = ['src\/debug\/res', 'src\/main\/res']\r\n            } else {\r\n                manifest.srcFile 'src\/main\/AndroidManifest.xml'\r\n                resources {\r\n                    exclude 'src\/debug\/*'\r\n                }\r\n            }\r\n        }\r\n    }\r\n```\r\n\r\n\r\n\r\n运行后如图：\r\n\r\n![image-20191127172857836](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/moudle-8.png)\r\n\r\n可以看到现在已经没有了app moudle作为主moudle时的底部导航。\r\n\r\n因为我这里的Activity只是单纯的包含了Fragment，没有其他逻辑。\r\n\r\n\r\n\r\n目前为止，项目模块化已经基本完成。\r\n\r\n以后其他的改动都是在此基础上进行。"
  },
  {
    "title": "关于Android旧项目模块化组件化实现--续篇",
    "created_time": "2019-11-29 10:14:51",
    "body": "# 0x00 前言\r\n\r\n经过[关于Android旧项目模块化组件化实现]( \/flutterblog.io\/#\/markdown_page?type=android&name=关于Android旧项目模块化组件化实现 )\r\n\r\n实现模块化后。\r\n\r\n在执行sync时，发现`dynamic moudle`其他兄弟模块也都执行了从新编译，\r\n\r\n可以看到其他moudle也都执行了相应task：\r\n\r\n```txt\r\nExecuting tasks: [clean, :user:generateDebugSources, :feed:generateDebugSources, :setting:generateDebugSources, :lost:generateDebugSources, :app:generateDebugSources, :chat:generateDebugSources, :dynamic:generateDebugSources, :common:generateDebugSources] in project D:\\AndroidStudioProjects\\PetsHome\r\n\r\n> Task :clean UP-TO-DATE\r\n> Task :app:clean\r\n> Task :chat:clean\r\n> Task :common:clean\r\n> Task :dynamic:clean\r\n> Task :feed:clean\r\n> Task :lost:clean\r\n> Task :setting:clean\r\n> Task :user:clean\r\n> Task :common:preBuild UP-TO-DATE\r\n> Task :common:preDebugBuild UP-TO-DATE\r\n> Task :user:preBuild UP-TO-DATE\r\n> Task :user:preDebugBuild UP-TO-DATE\r\n> Task :common:packageDebugRenderscript NO-SOURCE\r\n> Task :user:checkDebugManifest\r\n> Task :user:generateDebugBuildConfig\r\n> Task :user:prepareLintJar UP-TO-DATE\r\n> Task :user:prepareLintJarForPublish UP-TO-DATE\r\n> Task :common:compileDebugAidl NO-SOURCE\r\n> Task :user:compileDebugAidl NO-SOURCE\r\n> Task :user:compileDebugRenderscript NO-SOURCE\r\n> Task :user:generateDebugSources\r\n> Task :feed:preBuild UP-TO-DATE\r\n> Task :feed:preDebugBuild UP-TO-DATE\r\n> Task :feed:compileDebugAidl NO-SOURCE\r\n> Task :feed:checkDebugManifest\r\n> Task :feed:compileDebugRenderscript NO-SOURCE\r\n> Task :feed:generateDebugBuildConfig\r\n> Task :feed:prepareLintJar UP-TO-DATE\r\n> Task :feed:prepareLintJarForPublish UP-TO-DATE\r\n> Task :feed:generateDebugSources\r\n> Task :setting:preBuild UP-TO-DATE\r\n> Task :setting:preDebugBuild UP-TO-DATE\r\n> Task :setting:compileDebugAidl NO-SOURCE\r\n> Task :setting:checkDebugManifest\r\n> Task :setting:compileDebugRenderscript NO-SOURCE\r\n> Task :setting:generateDebugBuildConfig\r\n> Task :setting:prepareLintJar UP-TO-DATE\r\n> Task :setting:prepareLintJarForPublish UP-TO-DATE\r\n> Task :setting:generateDebugSources\r\n> Task :lost:preBuild UP-TO-DATE\r\n> Task :lost:preDebugBuild UP-TO-DATE\r\n> Task :lost:compileDebugAidl NO-SOURCE\r\n> Task :lost:checkDebugManifest\r\n> Task :lost:compileDebugRenderscript NO-SOURCE\r\n> Task :lost:generateDebugBuildConfig\r\n> Task :lost:prepareLintJar UP-TO-DATE\r\n> Task :lost:prepareLintJarForPublish UP-TO-DATE\r\n> Task :lost:generateDebugSources\r\n> Task :app:preBuild UP-TO-DATE\r\n> Task :app:preDebugBuild UP-TO-DATE\r\n> Task :app:compileDebugAidl NO-SOURCE\r\n> Task :app:checkDebugManifest\r\n> Task :app:compileDebugRenderscript NO-SOURCE\r\n> Task :app:generateDebugBuildConfig\r\n> Task :app:prepareLintJar UP-TO-DATE\r\n> Task :app:prepareLintJarForPublish UP-TO-DATE\r\n> Task :app:generateDebugSources\r\n> Task :chat:preBuild UP-TO-DATE\r\n> Task :chat:preDebugBuild UP-TO-DATE\r\n> Task :chat:compileDebugAidl NO-SOURCE\r\n> Task :chat:checkDebugManifest\r\n> Task :chat:compileDebugRenderscript NO-SOURCE\r\n> Task :chat:generateDebugBuildConfig\r\n> Task :chat:prepareLintJar UP-TO-DATE\r\n> Task :chat:prepareLintJarForPublish UP-TO-DATE\r\n> Task :chat:generateDebugSources\r\n> Task :dynamic:preBuild UP-TO-DATE\r\n> Task :dynamic:preDebugBuild UP-TO-DATE\r\n> Task :dynamic:compileDebugAidl NO-SOURCE\r\n> Task :dynamic:checkDebugManifest\r\n> Task :dynamic:compileDebugRenderscript NO-SOURCE\r\n> Task :dynamic:generateDebugBuildConfig\r\n> Task :dynamic:prepareLintJar UP-TO-DATE\r\n> Task :dynamic:prepareLintJarForPublish UP-TO-DATE\r\n> Task :dynamic:generateDebugSources\r\n> Task :common:checkDebugManifest\r\n> Task :common:compileDebugRenderscript NO-SOURCE\r\n> Task :common:generateDebugBuildConfig\r\n> Task :common:prepareLintJar UP-TO-DATE\r\n> Task :common:prepareLintJarForPublish UP-TO-DATE\r\n> Task :common:generateDebugSources\r\n\r\nBUILD SUCCESSFUL in 0s\r\n41 actionable tasks: 24 executed, 17 up-to-date\r\n\r\n```\r\n\r\n\r\n\r\n也就是说目前只成功独立运行了`dynamic moudle`。并没有实现独立编译功能。\r\n\r\n所以对于指望独立编译以达到节省时间来说，还要继续研究。\r\n\r\n\r\n\r\n# 0x01 分析\r\n\r\n在独立运行`dynamic moudle`时，并没有使用到其他兄弟模块，它们依旧参与了编译过程。\r\n\r\n问题出在了哪里？\r\n\r\n每个Android  studio创建的项目，\r\n\r\n根目录下有个`setting.gradle`，每个moudle又有各自的`build.gradle`。\r\n\r\n在`setting.gradle`囊括了所有的moudle。\r\n\r\n如果独立运行时，不导入无关兄弟moudle，又会怎样？\r\n\r\n修改内容如下：\r\n\r\n```groovy\r\n\/\/ include ':app', ':dynamic', ':chat', ':user', ':setting', ':feed', ':lost', ':common'\r\n\/\/修改为\r\ninclude  ':dynamic', ':common'\r\n```\r\n\r\n执行sync，打印内容为：\r\n\r\n```txt\r\nExecuting tasks: [:dynamic:generateDebugSources, :common:generateDebugSources] in project D:\\AndroidStudioProjects\\PetsHome\r\n\r\n:dynamic\r\n> Task :common:preBuild UP-TO-DATE\r\n> Task :common:preDebugBuild UP-TO-DATE\r\n> Task :dynamic:preBuild UP-TO-DATE\r\n> Task :dynamic:preDebugBuild UP-TO-DATE\r\n> Task :common:packageDebugRenderscript NO-SOURCE\r\n> Task :dynamic:checkDebugManifest UP-TO-DATE\r\n> Task :dynamic:generateDebugBuildConfig UP-TO-DATE\r\n> Task :dynamic:prepareLintJar UP-TO-DATE\r\n> Task :dynamic:prepareLintJarForPublish UP-TO-DATE\r\n> Task :common:checkDebugManifest UP-TO-DATE\r\n> Task :common:compileDebugAidl NO-SOURCE\r\n> Task :dynamic:compileDebugAidl NO-SOURCE\r\n> Task :dynamic:compileDebugRenderscript NO-SOURCE\r\n> Task :dynamic:generateDebugSources UP-TO-DATE\r\n> Task :common:compileDebugRenderscript NO-SOURCE\r\n> Task :common:generateDebugBuildConfig UP-TO-DATE\r\n> Task :common:prepareLintJar UP-TO-DATE\r\n> Task :common:prepareLintJarForPublish UP-TO-DATE\r\n> Task :common:generateDebugSources UP-TO-DATE\r\n\r\nBUILD SUCCESSFUL in 0s\r\n8 actionable tasks: 8 up-to-date\r\n```\r\n\r\n可以看到要减少编译，我们需要**动态包含\/取消无关moudle**。\r\n\r\n# 0x02 修改\r\n\r\n声明一个`aloneMoudle`表示要独立编译的模块\r\n\r\n声明一个`commonMoudle`表示公共模块，\r\n\r\n声明一个`logicMoudles`表示业务模块数组列表\r\n\r\n如果`aloneMoudle`不为空，那么从`logicMoudles`取出模块和`commonMoudle`一起include。\r\n\r\n内容修改为：\r\n\r\n```groovy\r\ndef aloneMoudle = ':dynamic'\r\ndef commonMoudle = ':common'\r\ndef logicMoudles = [':app', ':dynamic', ':chat', ':user', ':setting', ':feed', ':lost']\r\n\r\nif (aloneMoudle != null) {\r\n    def index = logicMoudles.indexOf(aloneMoudle)\r\n    include logicMoudles[index], commonMoudle\r\n} else {\r\n    include ':app', ':dynamic', ':chat', ':user', ':setting', ':feed', ':lost', ':common'\r\n}\r\n```\r\n\r\n修改完成后，执行sync。没有报错，且只执行了dynamic和common相关task。\r\n\r\n但是现在要独立编译运行某个模块，\r\n\r\n除了要修改`setting.gradle`中`aloneMoudle`为相应模块名称。\r\n\r\n还要修改`common_config.gradle`中`isDebug=true`。\r\n\r\n最后修改对应模块的`build.gradle`，添加ApplicationId:\r\n\r\n```groovy\r\n        if (project.ext.isDebug) {\r\n            applicationId \"top.jenson.pet\"\r\n        }\r\n```\r\n\r\n这显然比较麻烦的。步骤多了就容易出错。\r\n\r\n# 0x03 改进\r\n\r\n三步嫌麻烦，一步到位最好。\r\n\r\n每个`build.gradle`对应一个project。\r\n\r\n`setting.gradle`对应setting\r\n\r\n目前的情况是，\r\n\r\n`common_config.gradle`可以获取到project作用域，却获取不到setting作用域。\r\n\r\n而project和setting互相无法作用。\r\n\r\n如果要一步到位，需要`common_config.gradle`、`build.gradle`和`setting.gradle`都能获取的一个作用域。\r\n\r\n而`gradle.properties`就是这三个地方都能访问的域。\r\n\r\n## 修改gradle.properties\r\n\r\n在该文件中添加内容：\r\n\r\n```\r\naloneMoudle=:app\r\n```\r\n\r\n## 修改settings.gradle\r\n\r\n该文件内容修改为：\r\n\r\n```groovy\r\ndef commonMoudle = ':common'\r\ndef mainMoudle = ':app'\r\ndef logicMoudles = [':dynamic', ':chat', ':user', ':setting', ':feed', ':lost']\r\n\r\nif (aloneMoudle == mainMoudle) {\r\n    println \"编译主模\"\r\n    include ':app', ':dynamic', ':chat', ':user', ':setting', ':feed', ':lost', ':common'\r\n} else {\r\n    println \"单独编译模块：$aloneMoudle\"\r\n    def index = logicMoudles.indexOf(aloneMoudle)\r\n    include logicMoudles[index], commonMoudle\r\n}\r\n```\r\n\r\n这里目前分为业务逻辑模块、基础模块和主模块。\r\n\r\n获取`aloneMoudle`，\r\n\r\n如果和主模块名称一致，那么说明这里不是独立编译，常规编译所有模块。\r\n\r\n如果和主模块名称不一致，说明要独立编译，那么只编译该模块和其依赖模块，兄弟模块不引入。\r\n\r\n\r\n\r\n## 修改common_config\r\n\r\n添加属性`isAloneMoudle`：\r\n\r\n```\r\nisAloneMoudle = (aloneMoudle == ':app' ? false : true)\r\n```\r\n\r\n如果`gradle.properties`中设置的`aloneMoudle`名称和主模块一致，\r\n\r\n表示不能作为独立编译`isAloneMoudle=false`，\r\n\r\n否则表示将要独立编译`isAloneMoudle=true`。\r\n\r\n\r\n\r\n修改原`setAndroidConfig extension.android`\r\n\r\n为`setAndroidConfig extension, extension.android`。\r\n\r\n改为接收2个参数。\r\n\r\n\r\n\r\n在`setAndroidConfig`闭包中，\r\n\r\n添加是否把当前模块作为主模块的判断：\r\n\r\n```groovy\r\ndef isAsMainMoudle = isAloneMoudle && aloneMoudle.contains(pro.name)\r\n```\r\n\r\n意思是上面确定了将要作为独立编译，\r\n\r\n并且独立编译模块名称和当前project名称一致，本模块才作为主模块。\r\n\r\n添加`sourceSets`设置：\r\n\r\n```groovy\r\n            if (isAsMainMoudle) {\r\n                extension.sourceSets {\r\n                    main() {\r\n                        jniLibs.srcDirs = ['libs']\r\n                        if (project.ext.isAloneMoudle) {\r\n                            manifest.srcFile 'src\/debug\/AndroidManifest.xml'\r\n                            res.srcDirs = ['src\/debug\/res', 'src\/main\/res']\r\n                        } else {\r\n                            manifest.srcFile 'src\/main\/AndroidManifest.xml'\r\n                            resources {\r\n                                exclude 'src\/debug\/*'\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n```\r\n\r\n在闭包`defaultConfig`中添加：\r\n\r\n```groovy\r\nif (isAsMainMoudle) {\r\n      applicationId \"top.jenson.pet\"\r\n}\r\n```\r\n\r\n\r\n\r\n之前的`isDebug`变量去掉，修改后的全部内容为：\r\n\r\n```groovy\r\nproject.ext {\r\n\r\n    isAloneMoudle = (aloneMoudle == ':app' ? false : true)\r\n    println \"isAloneMoudle:$isAloneMoudle\"\r\n\r\n    setAppDefaultConfig = {\r\n        extension ->\r\n            println \"@@${extension}\"\r\n            extension.apply plugin: 'com.android.application'\r\n            extension.apply plugin: 'kotlin-android'\r\n            extension.apply plugin: 'kotlin-android-extensions'\r\n            extension.apply plugin: 'kotlin-kapt'\r\n\/\/            extension.description \"app\"\r\n            setAndroidConfig extension, extension.android\r\n            setDependencies extension.dependencies\r\n    }\r\n\r\n    setLibDefaultConfig = {\r\n        extension ->\r\n            extension.apply plugin: 'com.android.library'\r\n            extension.apply plugin: 'kotlin-android'\r\n            extension.apply plugin: 'kotlin-android-extensions'\r\n            extension.apply plugin: 'kotlin-kapt'\r\n\/\/            extension.description \"library\"\r\n            setAndroidConfig extension, extension.android\r\n            setDependencies extension.dependencies\r\n    }\r\n\r\n\r\n    setAndroidConfig = {\r\n        pro, extension ->\r\n            extension.compileSdkVersion = 28\r\n            extension.buildToolsVersion = \"29.0.2\"\r\n            println \"aloneMoudle=$aloneMoudle\"\r\n            println \"pro.name=$pro.name\"\r\n            def isAsMainMoudle = isAloneMoudle && aloneMoudle.contains(pro.name)\r\n            println \"isAsMainMoudle:$isAsMainMoudle\"\r\n            extension.defaultConfig {\r\n                if (isAsMainMoudle) {\r\n                    applicationId \"top.jenson.pet\"\r\n                }\r\n                kapt {\r\n                    arguments {\r\n                        arg(\"AROUTER_MODULE_NAME\", extension.project.getName())\r\n                    }\r\n                }\r\n                minSdkVersion = 21\r\n                targetSdkVersion = 21\r\n                testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\r\n            }\r\n            if (isAsMainMoudle) {\r\n                extension.sourceSets {\r\n                    main() {\r\n                        jniLibs.srcDirs = ['libs']\r\n                        if (project.ext.isAloneMoudle) {\r\n                            manifest.srcFile 'src\/debug\/AndroidManifest.xml'\r\n                            res.srcDirs = ['src\/debug\/res', 'src\/main\/res']\r\n                        } else {\r\n                            manifest.srcFile 'src\/main\/AndroidManifest.xml'\r\n                            resources {\r\n                                exclude 'src\/debug\/*'\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n\/\/            extension.dataBinding {\r\n\/\/                enable = true\r\n\/\/            }\r\n    }\r\n\r\n    setDependencies = {\r\n        extension ->\r\n            extension.implementation fileTree(dir: 'libs', include: ['*.jar'])\r\n            extension.implementation \"org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version\"\r\n            extension.implementation 'androidx.appcompat:appcompat:1.0.2'\r\n            extension.implementation 'androidx.core:core-ktx:1.0.2'\r\n            extension.kapt 'com.alibaba:arouter-compiler:1.2.2'\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## 修改build.gradle\r\n\r\n修改所有业务模块下的`build.gradle`：\r\n\r\n```groovy\r\n\/\/project.ext.setLibDefaultConfig project\r\n\/\/改为动态设置\r\nif (project.ext.isAloneMoudle) {\r\n    project.ext.setAppDefaultConfig project\r\n} else {\r\n    project.ext.setLibDefaultConfig project\r\n}\r\n```\r\n\r\n\r\n\r\n基础模块的`build.gradle`固定位`project.ext.setLibDefaultConfig project`就好。\r\n\r\n\r\n\r\n\r\n\r\n# 0x04 结尾\r\n\r\n经过上面的修改。\r\n\r\n在给业务模块添加好独立入口代码后。\r\n\r\n\r\n\r\n**只要在`gradle.properties`改为想要独立运行的模块。**\r\n\r\n**后面流程自动执行：**\r\n\r\n然后`settings.gradle`会根据你设置的名称，找到该模块和基础模块引入，其他不引入。\r\n\r\n这样只会编译指定模块和其依赖模块(这里只有common)。\r\n\r\n每个模块编译时都会用到`common_config`。\r\n\r\n编译dynamic模块时，\r\n\r\n执行到\r\n\r\n`isAloneMoudle = (aloneMoudle == ':app' ? false : true)`\r\n\r\n返回true。\r\n\r\n执行到闭包\r\n\r\n`setAndroidConfig`时\r\n\r\n`def isAsMainMoudle = isAloneMoudle && aloneMoudle.contains(pro.name)`\r\n\r\n返回true。\r\n\r\n然后就会给该模块添加`applicationId`。\r\n\r\n同时设置编译源码位置`sourceSets`。"
  },
  {
    "title": "关于Android旧项目模块化组件化实现(三)",
    "created_time": "2020-01-13 06:53:47",
    "body": "# 0x00 前言\r\n\r\n在前面两篇组件化文章中，\r\n\r\n通过[关于Android旧项目模块化组件化实现](\/flutterblog.io\/#\/markdown_page?type=android&name=关于Android旧项目模块化组件化实现)实现了模块独立运行，\r\n\r\n通过[关于Android旧项目模块化组件化实现--续篇](\/flutterblog.io\/#\/markdown_page?type=android&name=关于Android旧项目模块化组件化实现--续篇)实现了模块独立编译。\r\n\r\n但是细细考量下会发现还有很多可以改进的地方。\r\n\r\n比如公司项目有多个apk。\r\n\r\n各个apk又都涉及了相同组件的使用该怎么办？\r\n\r\n这里我提出个概念“组件司有化”。\r\n\r\n**所谓“组件司有化”，是指提取组件，使其不局限于app内使用，**\r\n\r\n**而是上升到公司高度，使公司内部其他项目都能使用它。**\r\n\r\n那么如何实现\"组件司有化\"？\r\n\r\n首先组件\/模块打包aar，\r\n\r\n其次公司搭建内部maven库，\r\n\r\n然后aar上传maven库，\r\n\r\n最后依赖maven库添加。\r\n\r\n下面看每一步具体如何实现。\r\n\r\n# 0x01 组件打包aar\r\n\r\n在侧边栏打开`Gradle任务栏`，找到`xx模块\/Tasks\/build\/build`：\r\n\r\n![image-20200113114029599](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200113114029599.png)\r\n\r\n双击执行后在模块的`build\/outputs\/aar\/`目录生成了打包好的aar。\r\n\r\n这里生成的了`debug`和`release`两种包：\r\n\r\n![image-20200113114052907](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200113114052907.png)\r\n\r\n如果要生成某一种包，可以在`xx模块\/Tasks\/other\/`下，\r\n\r\n找到`assembleDebug`和`assembleRelease`：\r\n\r\n![image-20200113114118337](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200113114118337.png)\r\n\r\n点击即可生成对应类型的aar。\r\n\r\n\r\n\r\n# 0x02 搭建私有maven\r\n\r\n## 下载仓库\r\n\r\n下载[nexus-repository-oss](https:\/\/www.sonatype.com\/nexus-repository-oss)。\r\n\r\n如果不想直接使用最新类型，\r\n\r\n从这里下载[版本列表](https:\/\/help.sonatype.com\/repomanager3\/download\/download-archives---repository-manager-3)\r\n\r\n## 运行\r\n\r\n下载后解压，\r\n\r\n通过`cmd`进入目录`C:\\Users\\Jenson\\Downloads\\nexus-3.20.0-04-win64\\nexus-3.20.0-04\\bin`。\r\n\r\n执行`nexus.exe \/run`启动服务。\r\n\r\n出现如下字样表示启动成功：\r\n\r\n![image-20200113114404384](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200113114404384.png)\r\n\r\n执行`http:\/\/localhost:8081\/`打开服务页面。\r\n\r\n## 登录\r\n\r\n旧版登录账号密码为admin;admin123。\r\n\r\n新版密码改了，账号仍然是`admin`\r\n\r\n在解压目录搜索`admin`，出现`admin.password`字样的文件。\r\n\r\n或者在目录`C:\\Users\\Jenson\\Downloads\\nexus-3.20.0-04-win64\\sonatype-work\\nexus3`查找。\r\n\r\n打开密码文件，复制该文件中字符串登录即可。\r\n\r\n参考：[Nexus3 初始密码不再是admin123](https:\/\/www.jianshu.com\/p\/fcb128e34c87)\r\n\r\n\r\n\r\n# 0x03 创建repository\r\n\r\n## 介绍\r\n\r\n登录后的nexus页面很简单，顶部只有2个tab。\r\n\r\n第一个tab页面只有创建好的列表和手动上传两块功能。\r\n\r\n![image-20200113115257718](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200113115257718.png)\r\n\r\n第二个tab页面虽然功能稍多，但是平常也只用到repository：\r\n\r\n可以创建新的repository并配置存储目录。\r\n\r\n![image-20200113115555754](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200113115555754.png)\r\n\r\n## 创建\r\n\r\n点击创建一个新的存储位置，默认在C盘不太好。\r\n\r\n![image-20200113115758053](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200113115758053.png)\r\n\r\n位置路径分配到D盘：\r\n\r\n![image-20200113115915543](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200113115915543.png)\r\n\r\n点击创建。\r\n\r\n创建新的repository：\r\n\r\n![image-20200113115950018](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200113115950018.png)\r\n\r\n这里因为用的maven，所以选择maven2类型：\r\n\r\n![image-20200113120027853](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200113120027853.png)\r\n\r\n![image-20200113120302940](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200113120302940.png)\r\n\r\n创建好之后列表多了个新的repository：\r\n\r\n![image-20200113120345972](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200113120345972.png)\r\n\r\n\r\n\r\n# 0x04 aar上传\r\n\r\n前面创建好了repository，\r\n\r\n创建仓库就是要存储东西的，\r\n\r\n上传有手动和自动两种。\r\n\r\n## 手动上传\r\n\r\n进入upload页面，选择新建的user repository：\r\n\r\n![image-20200113120538582](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200113120538582.png)\r\n\r\n\r\n\r\n创建之前我们先分析下添加依赖时各个部件名称：\r\n\r\n```groovy\r\nimplementation 'top.jenson.user:libuser:1.1.4'\r\n\/\/使用冒号分隔，各个部分名称为：\r\n\/\/'groupId:artifactId:version'\r\n```\r\n\r\n了解了这三部分可以继续上传了：\r\n\r\n![image-20200113121053127](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200113121053127.png)\r\n\r\n填完后内容：\r\n\r\n![image-20200113121132568](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200113121132568.png)\r\n\r\n上传后有提示信息：\r\n\r\n![image-20200113121212906](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200113121212906.png)\r\n\r\n点击查看页面如下：\r\n\r\n![image-20200113121238903](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200113121238903.png)\r\n\r\n\r\n\r\n通过browse查看如图：\r\n\r\n![image-20200113121359053](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200113121359053.png)\r\n\r\n至此已经完成了user库的1.0.0版本的手动上传。\r\n\r\n\r\n\r\n## 自动上传\r\n\r\n上面手工上传，在库较少情况下还可以，但是随着项目发展，\r\n\r\n库越来越多时，每个手动上传就比较蛋疼了。\r\n\r\n所以实现自动上传是有必要的。\r\n\r\n在项目根目录(以便其他moudle引用)创建`upload_to_maven.gradle`。\r\n\r\n首先添加`maven`插件\r\n\r\n```groovy\r\napply plugin: 'maven'\r\n```\r\n\r\n然后设置仓库url和账号、密码信息：\r\n\r\n```groovy\r\n\/\/定义变量\r\n\/\/设置仓库位置\r\ndef RELEASE_REPOSITORY_URL = 'http:\/\/127.0.0.1:8081\/repository\/user\/'\r\n\/\/登录账号\r\ndef NEXUS_USERNAME = 'admin'\r\n\/\/登录密码\r\ndef NEXUS_PASSWORD = 'qqqq'\r\n```\r\n\r\n然后就是上传逻辑了，\r\n\r\n我们既然依赖了maven插件，它就给我们提供了相应的上传闭包：\r\n\r\n```groovy\r\nafterEvaluate { project ->\r\n    println \"project=$project.name\"\r\n    uploadArchives {\r\n        repositories {\r\n            mavenDeployer {\r\n\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n我们要做的就是在`mavenDeployer`完成功能。\r\n\r\n由于我这里只打算用user模块测试，所以内容填写的是user模块相关：\r\n\r\n```groovy\r\nafterEvaluate { project ->\r\n    println \"project=$project.name\"\r\n    uploadArchives {\r\n        repositories {\r\n            mavenDeployer {\r\n                pom.groupId = 'top.jenson.user'\r\n                pom.artifactId = 'libuser'\r\n                pom.version = '1.1.1'\r\n                pom.packaging = 'aar'\r\n                pom.name = project.name\r\n                repository(url: RELEASE_REPOSITORY_URL) {\r\n                    authentication(userName: NEXUS_USERNAME, password: NEXUS_PASSWORD)\r\n                }\r\n\/\/                snapshotRepository(url: SNAPSHOT_REPOSITORY_URL) {\r\n\/\/                    authentication(userName: NEXUS_USERNAME, password: NEXUS_PASSWORD)\r\n\/\/                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n全部内容为：\r\n\r\n```groovy\r\napply plugin: 'maven'\r\n\r\ndef RELEASE_REPOSITORY_URL = 'http:\/\/127.0.0.1:8081\/repository\/user\/'\r\ndef NEXUS_USERNAME = 'admin'\r\ndef NEXUS_PASSWORD = 'qqqq'\r\n\r\nafterEvaluate { project ->\r\n    println \"project=$project.name\"\r\n    uploadArchives {\r\n        repositories {\r\n            mavenDeployer {\r\n                pom.groupId = 'top.jenson.user'\r\n                pom.artifactId = 'libuser'\r\n                pom.version = '1.1.1'\r\n                pom.packaging = 'aar'\r\n                pom.name = project.name\r\n\r\n                repository(url: RELEASE_REPOSITORY_URL) {\r\n                    authentication(userName: NEXUS_USERNAME, password: NEXUS_PASSWORD)\r\n                }\r\n\/\/                snapshotRepository(url: SNAPSHOT_REPOSITORY_URL) {\r\n\/\/                    authentication(userName: NEXUS_USERNAME, password: NEXUS_PASSWORD)\r\n\/\/                }\r\n\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\nuser模块的build.gradle添加该文件依赖：\r\n\r\n```groovy\r\napply from:\"${rootProject.rootDir}\/upload_to_maven.gradle\"\r\n```\r\n\r\n然后在`gradle任务栏`，user模块下找到uploadArchives任务双击执行\r\n\r\n![image-20200113124231648](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200113124231648.png)\r\n\r\n\r\n\r\n出现如下字样表示上传成功：\r\n\r\n![image-20200113124421013](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200113124421013.png)\r\n\r\n\r\n\r\n接下里还要去maven库中看看是不是真得存在了：\r\n\r\n![image-20200113124554173](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200113124554173.png)\r\n\r\n可以看到aar文件已经存在已经上传成功了。\r\n\r\n\r\n\r\n## 自动上传优化\r\n\r\n上面只是针对user模块使用，所以groupId、artifactId和version都直接写代码里面了。\r\n\r\n这里我们进行抽取，以保证各个模块通用：\r\n\r\n在需要的模块下创建`gradle.properties`文件，比如user添加内容：\r\n\r\n```properties\r\nGROUPID=top.jenson.user\r\nARTIFACT_ID=libuser\r\nVERSION=1.1.1\r\n```\r\n\r\n原本的pom信息直接调用这些变量即可：\r\n\r\n```properties\r\n pom.groupId = GROUPID\r\n pom.artifactId = ARTIFACT_ID\r\n pom.version = VERSION\r\n pom.packaging = 'aar'\r\n pom.name = project.name\r\n```\r\n\r\ngradle文件最终修改为：\r\n\r\n```groovy\r\napply plugin: 'maven'\r\n\r\ndef RELEASE_REPOSITORY_URL = 'http:\/\/127.0.0.1:8081\/repository\/user\/'\r\ndef NEXUS_USERNAME = 'admin'\r\ndef NEXUS_PASSWORD = 'qqqq'\r\n\r\nafterEvaluate { project ->\r\n    println \"project=$project.name\"\r\n    uploadArchives {\r\n        repositories {\r\n            mavenDeployer {\r\n                println \"groupId=$GROUPID, artifactId=$ARTIFACT_ID, version=$VERSION\"\r\n                pom.groupId = GROUPID\r\n                pom.artifactId = ARTIFACT_ID\r\n                pom.version = VERSION\r\n                pom.packaging = 'aar'\r\n                pom.name = project.name\r\n\r\n                repository(url: RELEASE_REPOSITORY_URL) {\r\n                    authentication(userName: NEXUS_USERNAME, password: NEXUS_PASSWORD)\r\n                }\r\n\/\/                snapshotRepository(url: SNAPSHOT_REPOSITORY_URL) {\r\n\/\/                    authentication(userName: NEXUS_USERNAME, password: NEXUS_PASSWORD)\r\n\/\/                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n上面添加了打印信息，看下打印日志：\r\n\r\n![image-20200113143725884](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200113143725884.png)\r\n\r\n\r\n\r\n\r\n\r\n# 0x05 maven依赖添加\r\n\r\n上面已经完成了aar的打包和上传。\r\n\r\n我们做了这么多都是为了这一步：使用\r\n\r\n接下来我们就希望像使用第三方库一样依赖使用。\r\n\r\n创建一个新项目`mavenTest`。\r\n\r\n由于我们使用了私有maven库，所以在项目的`build.gradle`添加私有repository：\r\n\r\n```groovy\r\nallprojects {\r\n    repositories {\r\n        maven {\r\n            url 'http:\/\/127.0.0.1:8081\/repository\/user\/'\r\n        }\r\n        google()\r\n        jcenter()\r\n    }\r\n}\r\n```\r\n\r\n在模块下添加依赖：\r\n\r\n```groovy\r\n    implementation 'top.jenson.user:libuser:1.1.1@aar'\r\n```\r\n\r\n同步之后查看external library：\r\n\r\n![image-20200113141159102](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200113141159102.png)\r\n\r\n可以看到通过新依赖已经成功下载到新项目中，\r\n\r\n后面就可以随意使用了。\r\n\r\n\r\n\r\n\r\n\r\n# 0x06 结尾\r\n\r\n你可能好奇`implementation 'top.jenson.user:libuser:1.1.1@aar'`这个是怎么来的？为什么加个aar？\r\n\r\n![image-20200113141450534](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200113141450534.png)\r\n\r\n在repository中，可以选择要添加的方式。\r\n\r\n这里选择了gradle后，下面直接给出了依赖代码。\r\n\r\n如果不加aar，好像会查找相应的jar。\r\n\r\n\r\n\r\n> windows下有个巨坑问题就是其他操作都正常情况下，\r\n>\r\n> 每次添加依赖同步时都会出现`Unable to resolve dependency`错误。\r\n>\r\n> 总的来说就是找不到依赖包。\r\n>\r\n> 网上找了一天信息都没有遇到这个问题的。。\r\n>\r\n> 最终通过如下方式应该可以解决：\r\n>\r\n> 第一种入手点是\r\n>\r\n> 启动nexus服务时，系统会弹出通信提示窗口，\r\n>\r\n> 意思是nexus.exe要请求通信，\r\n>\r\n> 给出2个勾选框，1是家里、办公室环境2是机场、咖啡厅\r\n>\r\n> 这里把这两个都勾选上。尤其是1。如果你已经错过这个了，建议从新解压运行。\r\n>\r\n> 第二种入手点是\r\n>\r\n> 找到`C:\\Users\\Jenson\\Downloads\\nexus-3.20.0-04-win64\\sonatype-work\\nexus3\\etc\\nexus.properties`配置文件。\r\n>\r\n> 把`application-host=0.0.0.0`改为`127.0.0.1`。\r\n>\r\n> 第三种入手点是降级下载旧版,\r\n>\r\n> 比如[这个文章](https:\/\/blog.csdn.net\/xiaxiayige\/article\/details\/80636091)使用了3.12版本而且可以正常使用。\r\n>\r\n> 你也可以安装这个版本,然后参照文章按步操作。\r\n\r\n\r\n\r\n\r\n\r\n我当时问题是3.20新版没有勾选家里、办公室环境那个。\r\n\r\n最终删除新版安装旧版时又弹窗，然后勾选了。\r\n\r\n然后旧版竟然可以用了，接着从新解压新版并运行，此时新版也可以使用了。"
  },
  {
    "title": "Android修改系统返回键颜色",
    "created_time": "2020-05-16 06:22:58",
    "body": "# 0x00 使用自定义toolbar\r\n\r\n\r\n\r\n通过`setSupportActionBar(toolbar)`设置使用\r\n\r\n# 0x01 设置系统返回键可用\r\n\r\n通过`supportActionBar.setDisplayHomeAsUpEnabled(true)`设置系统返回键可用。\r\n\r\n# 0x02 修改返回键颜色\r\n\r\n```kotlin\r\nval upArrow = ContextCompat.getDrawable(this, R.drawable.abc_ic_ab_back_material)\r\n                    upArrow?.setColorFilter(ContextCompat.getColor(this, android.R.color.black), PorterDuff.Mode.SRC_ATOP)\r\n                    supportActionBar?.setHomeAsUpIndicator(upArrow)\r\n```"
  }
]