[
  {
    "title": "Flutter常见问题之软键盘顶起布局问题",
    "created_time": "2019-12-30 03:09:28",
    "body": "Flutter中默认情况下，页面弹出软键盘时会对当前布局产生影响：\r\n\r\n即会把底部布局挤压上去，如果不想软键盘顶起布局，可以在\r\n\r\n`scaffold`上设置：`resizeToAvoidBottomInset: false,`。\r\n\r\n默认为true会顶起布局。\r\n\r\n```dart\r\nreturn Scaffold(\r\n      resizeToAvoidBottomInset: false,\r\n      appBar: AppBar(\r\n        title: Text(\"意见反馈\"),\r\n      ),);\r\n```\r\n\r\n\r\n\r\n在`scaffold`属性中还有一个类似的属性：`resizeToAvoidBottomPadding`。\r\n\r\n该属性被标记为`@Deprecated`，推荐使用`resizeToAvoidBottomInset`。"
  },
  {
    "title": "Flutter常见问题之软键盘显示隐藏",
    "created_time": "2019-12-30 02:10:13",
    "body": "如果想在`页面启动`时就设置软键盘的显示隐藏，\r\n\r\n可以通过给`TextField`设置`autofocus:`属性。\r\n\r\n `autofocus:true`表示默认弹出软键盘，\r\n\r\n`autofocus:false`表示不弹出软键盘：\r\n\r\n```dart\r\nTextField(\r\n                controller: controller,\r\n                maxLines: 8,\r\n                autofocus: true,\r\n                decoration: InputDecoration(hintText: _hintext),\r\n              )\r\n```\r\n\r\n\r\n\r\n如果想在操作过程中设置软键盘的显示隐藏，\r\n\r\n可以通过给`TextField`设置`focusNode:`属性。\r\n\r\n首先创建一个`FocusNode`实例：`FocusNode _focusNode = FocusNode();`\r\n\r\n为`TextField`设置`focusNode属性：\r\n\r\n```dart\r\nTextField(\r\n                focusNode: _focusNode,\r\n                controller: controller,\r\n                maxLines: 8,\r\n                autofocus: true,\r\n                decoration: InputDecoration(hintText: _hintext),\r\n              ),\r\n```\r\n\r\n当想让它隐藏软键盘时，设置`_focusNode.unfocus();`。\r\n\r\n当想让它显示软键盘时，设置`FocusScope.of(context).requestFocus(_focusNode);`."
  },
  {
    "title": "Flutter常见问题之setstate内存泄漏问题",
    "created_time": "2020-01-01 01:45:47",
    "body": "在做延时任务返回刷新UI时，任务完成前退出页面出现了这个问题。\r\n\r\n大概意思就是在`dispose()`之后调用了`setstate()`造成的内存泄漏。\r\n\r\n既然是`setstate`使用不当造成的，就看看源码注释怎么解释的：\r\n\r\n```dart\r\n  \/\/\/ Notify the framework that the internal state of this object has changed.\r\n  \/\/\/\r\n  \/\/\/ Whenever you change the internal state of a [State] object, make the\r\n  \/\/\/ change in a function that you pass to [setState]:\r\n  \/\/\/\r\n  \/\/\/ ```dart\r\n  \/\/\/ setState(() { _myState = newValue });\r\n  \/\/\/ ```\r\n  \/\/\/\r\n  \/\/\/ The provided callback is immediately called synchronously. It must not\r\n  \/\/\/ return a future (the callback cannot be `async`), since then it would be\r\n  \/\/\/ unclear when the state was actually being set.\r\n  \/\/\/\r\n  \/\/\/ Calling [setState] notifies the framework that the internal state of this\r\n  \/\/\/ object has changed in a way that might impact the user interface in this\r\n  \/\/\/ subtree, which causes the framework to schedule a [build] for this [State]\r\n  \/\/\/ object.\r\n  \/\/\/\r\n  \/\/\/ If you just change the state directly without calling [setState], the\r\n  \/\/\/ framework might not schedule a [build] and the user interface for this\r\n  \/\/\/ subtree might not be updated to reflect the new state.\r\n  \/\/\/\r\n  \/\/\/ Generally it is recommended that the `setState` method only be used to\r\n  \/\/\/ wrap the actual changes to the state, not any computation that might be\r\n  \/\/\/ associated with the change. For example, here a value used by the [build]\r\n  \/\/\/ function is incremented, and then the change is written to disk, but only\r\n  \/\/\/ the increment is wrapped in the `setState`:\r\n  \/\/\/\r\n  \/\/\/ ```dart\r\n  \/\/\/ Future<void> _incrementCounter() async {\r\n  \/\/\/   setState(() {\r\n  \/\/\/     _counter++;\r\n  \/\/\/   });\r\n  \/\/\/   Directory directory = await getApplicationDocumentsDirectory();\r\n  \/\/\/   final String dirName = directory.path;\r\n  \/\/\/   await File('$dir\/counter.txt').writeAsString('$_counter');\r\n  \/\/\/ }\r\n  \/\/\/ ```\r\n  \/\/\/\r\n  \/\/\/ It is an error to call this method after the framework calls [dispose].\r\n  \/\/\/ You can determine whether it is legal to call this method by checking\r\n  \/\/\/ whether the [mounted] property is true.\r\n  @protected\r\n  void setState(VoidCallback fn) {\r\n  \r\n  }\r\n```\r\n\r\n注释前面主要介绍如何正确使用`setstate`：\r\n\r\n**只在`setstate`中包裹和状态直接相关的变更值。**\r\n\r\n**其他诸如计算、IO操作不要放在里面。**\r\n\r\n最后介绍了当框架层调用了`dispose`后，你再调用`setstate`会出现异常。\r\n\r\n你可以通过使用`mounted`检查它是否为`true`。然后再调用`setstate`。\r\n\r\n所以我们目前可以这样使用：\r\n\r\n```dart\r\nif (mounted) {\r\n      setState(() {\r\n        visiable = !visiable;\r\n      });\r\n    }\r\n```\r\n\r\n\r\n\r\n顺便看一下`mounted`是什么东西：\r\n\r\n```dart\r\n\/\/\/ Whether this [State] object is currently in a tree.\r\n  \/\/\/\r\n  \/\/\/ After creating a [State] object and before calling [initState], the\r\n  \/\/\/ framework \"mounts\" the [State] object by associating it with a\r\n  \/\/\/ [BuildContext]. The [State] object remains mounted until the framework\r\n  \/\/\/ calls [dispose], after which time the framework will never ask the [State]\r\n  \/\/\/ object to [build] again.\r\n  \/\/\/\r\n  \/\/\/ It is an error to call [setState] unless [mounted] is true.\r\n  bool get mounted => _element != null;\r\n```\r\n\r\n注释中说明了`mounted`用来判断你的`state`对象是否还在控件树。\r\n\r\n创建`state`对象后到调用`initState`之前，框架层通过关联`state`和`BuildContext`来完成挂载。\r\n\r\n在框架层调用`dispose`之前都是存在的。\r\n\r\n**可以知道通过`mounted`来判断`state`是否还存活。**\r\n\r\n**如果返回`true`，才可以安全的调用`setstate`更新状态。**\r\n\r\n\r\n\r\n**如果业务中需要使用延时操作，可以使用`Timer`代替`Future`。**\r\n\r\n**因为`Timer.cancel`可以在`dispose`回调方法中取消延时，而`Future`没有取消操作。**"
  },
  {
    "title": "Flutter入门之Dialog使用",
    "created_time": "2020-01-04 08:59:55",
    "body": "Flutter为我们提供了两种Dialog：\r\n\r\n`SimpleDialog`和`AlertDialog`。\r\n\r\n通过`showDialog`方法，可以避免我们在`build`方法的一大串布局控件中去添加dialog。\r\n\r\n而是把dialog提取到一个方法中：\r\n\r\n```dart\r\n  \/\/\/显示提示对话框\r\n  Future showAlertDialog() async {\r\n    return showDialog(\r\n        context: context,\r\n        builder: (context) {\r\n          return AlertDialog(\r\n            title: Text(\"此操作会删除数据\"),\r\n            content: Text(\"确定删除吗？\"),\r\n            actions: <Widget>[\r\n              FlatButton(\r\n                child: Text(\"取消\"),\r\n                onPressed: () {\r\n                  Navigator.of(context).pop();\r\n                },\r\n              ),\r\n              FlatButton(\r\n                child: Text(\"确定\"),\r\n                onPressed: () {\r\n                  Navigator.of(context).pop();\r\n                },\r\n              ),\r\n            ],\r\n          );\r\n        });\r\n  }\r\n\r\n  \/\/\/显示简单对话框\r\n  Future showSimpleDialog() async {\r\n    return showDialog(\r\n        context: context,\r\n        builder: (context) {\r\n          return SimpleDialog(\r\n            title: Text(\"这是simpledialog\"),\r\n            children: <Widget>[\r\n              SimpleDialogOption(\r\n                onPressed: () {},\r\n                child: Text(\"第一行信息\"),\r\n              ),\r\n              SimpleDialogOption(\r\n                onPressed: () {},\r\n                child: Text(\"第二行信息\"),\r\n              ),\r\n            ],\r\n          );\r\n        });\r\n  }\r\n```\r\n\r\n\r\n\r\n`AlertDialog`通过`actions`属性添加操作。\r\n\r\n`SimpleDialog`通过`children`添加内容，其中可以通过`SimpleDialogOption`添加简单操作。"
  },
  {
    "title": "Flutter入门之Loading使用",
    "created_time": "2020-01-04 09:01:11",
    "body": "loading使用一般有2种场景：\r\n\r\n场景一：点击某个按钮进行耗时操作前弹出loading直到耗时操作完成，才可继续操作页面。\r\n\r\n场景二：刚进入某个页面时就执行耗时操作，直到耗时操作完成才显示页面。\r\n\r\n\r\n\r\n场景一可以使用`Stack`，它类似Android中的`FrameLayout`。\r\n\r\n最后声明的控件在最上层，这样把loading声明最后，在需要的时候显示出来，\r\n\r\n可以阻止对页面进行其他操作，实现如下：\r\n\r\n```dart\r\n@override\r\n  Widget build(BuildContext context) {\r\n    final TextEditingController controller = TextEditingController();\r\n    controller.addListener(() {\r\n      _feedText = controller.text;\r\n    });\r\n    return Scaffold(\r\n      appBar: AppBar(\r\n        title: Text(\"意见反馈\"),\r\n      ),\r\n      body: Container(\r\n        width: double.infinity,\r\n        height: double.infinity,\r\n        margin: const EdgeInsets.all(20),\r\n        child: Stack(\r\n          children: <Widget>[\r\n            Align(\r\n              alignment: FractionalOffset.topCenter,\r\n              child: TextField(\r\n                focusNode: _focusNode,\r\n                controller: controller,\r\n                maxLines: 8,\r\n                autofocus: true,\r\n                decoration: InputDecoration(hintText: _hintext),\r\n              ),\r\n            ),\r\n            Align(\r\n              alignment: FractionalOffset.bottomCenter,\r\n              child: RaisedButton(\r\n                color: Colors.blue,\r\n                shape: RoundedRectangleBorder(\r\n                    borderRadius: BorderRadius.all(Radius.circular(6))),\r\n                onPressed: () {\r\n                  submitFeedBack();\r\n                },\r\n                child: Text(\r\n                  \"提交\",\r\n                  style: TextStyle(fontSize: 16, color: Colors.white),\r\n                ),\r\n              ),\r\n            ),\r\n            Offstage(\r\n              offstage: visiable,\r\n              child: LoadingWidget(),\/\/封装的loading控件\r\n            ),\r\n          ],\r\n        ),\r\n      ),\r\n    );\r\n  }\r\n```\r\n\r\n\r\n\r\n场景二可以使用`visiable ? Loading(): Center()`方式：\r\n\r\n```dart\r\nclass _FirstPageState extends State<FirstPage> {\r\n  bool visiable = true;\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    print(\"FirstPage - build\");\r\n    Future.delayed(Duration(seconds: 6), () {\r\n      if (mounted) {\r\n        setState(() {\r\n          visiable = false;\r\n        });\r\n      }\r\n    });\r\n\r\n    return Scaffold(\r\n      appBar: AppBar(\r\n        title: Text(\"firstPage\"),\r\n      ),\r\n      body: visiable\/\/初始为true显示loading。\r\n          ? Text(\"loading....\")\r\n          : Center(),\r\n    );\r\n  }\r\n}\r\n\r\n```"
  },
  {
    "title": "Dart入门之扩展函数",
    "created_time": "2020-01-15 04:20:27",
    "body": "# 0x00 前言\r\n\r\nDart2.7提供了一个令人期待的功能，就是扩展函数。\r\n\r\n用过Kotlin或Groovy的应该很熟悉。\r\n\r\n它是向既有库添加新功能的方式。\r\n\r\n虽然是扩展函数，但是和使用普通函数没有什么区别，\r\n\r\n所以你并不会感知到它。\r\n\r\n一般来说，如果你使用别人的API或者被广泛使用的库时，你想修改它是不现实的。\r\n\r\n但是仍然想扩展它的一些功能。\r\n\r\n这时扩展函数就派上用场了。\r\n\r\n\r\n\r\n# 0x01 介绍\r\n\r\n通常我们会像选这样把字符串转为int：\r\n\r\n```dart\r\nint.parse('42')\r\n```\r\n\r\n但是如果在String类上有类似的替代函数，想必它会更简短易用：\r\n\r\n```dart\r\n'42'.parseInt()\r\n```\r\n\r\n要使用这个功能，你可以导入包含String的扩展类库：\r\n\r\n```dart\r\nimport 'string_apis.dart';\r\nprint('42'.parseInt()); \/\/ Use an extension method.\r\n```\r\n\r\n扩展功能不仅可以定义方法，还能定义成员，如getter、setter、operators。\r\n\r\n另外扩展也可以有名称，这在API冲突时很有用。\r\n\r\n# 0x02 定义\r\n\r\n下面看看如何实现对字符串进行操作的扩展函数`parseInt()`：\r\n\r\n```dart\r\nextension NumberParsing on String {\r\n  int parseInt() {\r\n    return int.parse(this);\r\n  }\r\n  \/\/ ···\r\n}\r\n```\r\n\r\n**定义扩展函数时，**\r\n\r\n**先使用`extension`关键字，后面跟`扩展名`，**\r\n\r\n**`扩展名`后面接 关键字 `on`，**\r\n\r\n**`on`关键字后面接要作用的类。**\r\n\r\n**然后是代码块定义函数。**\r\n\r\n语法格式：\r\n\r\n```dart\r\nextension <extension name> on <type> {\r\n  (<member definition>)*\r\n}\r\n```\r\n\r\n**如果你想要创建一个只在声明它的库中使用的扩展函数，**\r\n\r\n**可以省略它的扩展名或者扩展名以下划线(_)开头：**\r\n\r\n```dart\r\nextension on String {\r\n  double parseDouble() {\r\n    return double.parse(this);\r\n  }\r\n}\r\n\r\nextension _NumParseon on String {\r\n  double parseDouble() {\r\n    return double.parse(this);\r\n  }\r\n}\r\n```\r\n\r\n\r\n\r\n# 0x03 使用\r\n\r\n## 静态和动态类型\r\n\r\n**不能在动态变量上使用扩展函数**\r\n\r\n例如，下面这样做会出现异常：\r\n\r\n```dart\r\ndynamic d = '2';\r\nprint(d.parseInt()); \/\/ Runtime exception: NoSuchMethodError\r\n```\r\n\r\n**扩展函数可以和类型推断一起使用**\r\n\r\n例如，下面代码会正常运行：\r\n\r\n```dart\r\nvar v = '2';\r\nprint(v.parseInt()); \/\/ Output: 2\r\n```\r\n\r\n**`dynamic`不能使用是因为扩展函数是静态解析的。**\r\n\r\n**`dynamic`只有在运行期才能确定其类型，**\r\n\r\n**也由于扩展函数的静态解析原因，所以不用担心它的性能问题。**\r\n\r\n\r\n\r\n## API冲突问题\r\n\r\n现在定义了2个string扩展文件：\r\n\r\nstring_ex.dart：\r\n\r\n```dart\r\nextension NumberParsing on String {\r\n  int parseInt() {\r\n    return int.parse(this);\r\n  }\r\n}\r\n```\r\n\r\nstring_ex2.dart：\r\n\r\n```dart\r\nextension NumberParsing2 on String {\r\n  int parseInt() {\r\n    return int.parse(this);\r\n  }\r\n}\r\n\r\nextension PhoneParsing on String {\r\n  bool isPhone() {\r\n    return false;\r\n  }\r\n}\r\n```\r\n\r\n都引入的时候会出现冲突问题：\r\n\r\n![image-20200115104953260](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200115104953260.png)\r\n\r\n如果你的扩展成员和其他接口或者其他扩展成员冲突，那么你不得不采取一些措施。\r\n\r\n**使用`show`或`hide`限制公开的API**：\r\n\r\n```dart\r\nimport 'string_ex.dart';\r\nimport 'string_ex2.dart' hide NumberParsing2;\r\n\r\nvoid main() {\r\n  print(\"22\".parseInt());\r\n  print(\"33\".isPhone());\r\n}\r\n```\r\n\r\n\r\n\r\n**使用`显示扩展`，即通过扩展名调用扩展函数。不过这会让你的代码看起来像包装类**：\r\n\r\n```dart\r\nimport 'string_ex.dart';\r\nimport 'string_ex2.dart';\r\n\r\nvoid main() {\r\n  \/\/ print('42'.parseInt()); \/\/ Doesn't work.\r\n  print(NumberParsing('22').parseInt());\r\n  print(NumberParsing2('33').parseInt());\r\n  print(\"33\".isPhone());\r\n}\r\n```\r\n\r\n\r\n\r\n**如果扩展名都相同了，可以通过`as`给`导入文件`定义别名**：\r\n\r\nstring_ex3.dar:\r\n\r\n```dart\r\nextension NumberParsing on String {\r\n  int parseInt() {\r\n    return int.parse(this);\r\n  }\r\n}\r\n```\r\n\r\n这和sting_ex.dart扩展名冲突。\r\n\r\n通过`as`给导入文件定义别名：\r\n\r\n```dart\r\nimport 'string_ex.dart';\r\nimport 'string_ex2.dart';\r\nimport 'string_ex3.dart' as ex3;\r\n\r\nvoid main() {\r\n  \/\/ print('42'.parseInt()); \/\/ Doesn't work.\r\n  print(NumberParsing('22').parseInt());\r\n  print(NumberParsing2('33').parseInt());\r\n  print(ex3.NumberParsing('55').parseInt());\r\n  print(\"33\".isPhone());\r\n}\r\n\r\n```"
  },
  {
    "title": "Flutter框架之CachedNetworkImage源码分析",
    "created_time": "2020-01-16 06:32:41",
    "body": "# 0x00 前言\r\n\r\n图片框架是各个平台必备产品，Flutter也不例外。\r\n\r\n目前Flutter生态还在发展阶段，可选择性并不多。\r\n\r\n在做信息流时，我选择了`CachedNetworkImage`作为图片显示框架。\r\n\r\n因为别说对框架不熟悉，就连Flutter都才刚上手。\r\n\r\n所以瞅瞅框架源码如何实现以便更好使用是有必要的。\r\n\r\n# 0x01 介绍\r\n\r\n在使用之前要先添加库的依赖，\r\n\r\n关于`cached_network_image`信息可以在这查找：[cached_network_image](https:\/\/pub.dev\/packages\/cached_network_image)。\r\n\r\n添加依赖后看下如何使用：\r\n\r\n```dart\r\n        child: CachedNetworkImage(\r\n          imageUrl: imgs[i].imgUrl,\r\n        )\r\n```\r\n\r\n没错最基本的使用，就是这么简单。\r\n\r\n看下构造函数：\r\n\r\n```dart\r\n  CachedNetworkImage({\r\n    Key key,\r\n    @required this.imageUrl,\r\n    this.imageBuilder,\r\n    this.placeholder,\r\n    this.errorWidget,\r\n    this.fadeOutDuration: const Duration(milliseconds: 1000),\r\n    this.fadeOutCurve: Curves.easeOut,\r\n    this.fadeInDuration: const Duration(milliseconds: 500),\r\n    this.fadeInCurve: Curves.easeIn,\r\n    this.width,\r\n    this.height,\r\n    this.fit,\r\n    this.alignment: Alignment.center,\r\n    this.repeat: ImageRepeat.noRepeat,\r\n    this.matchTextDirection: false,\r\n    this.httpHeaders,\r\n    this.cacheManager,\r\n    this.useOldImageOnUrlChange: false,\r\n    this.color,\r\n    this.filterQuality: FilterQuality.low,\r\n    this.colorBlendMode,\r\n    this.placeholderFadeInDuration,\r\n  }) \r\n```\r\n\r\n可以看到虽然参数很多，但必须的就只有`imageUrl`这一项。\r\n\r\n所以只要设置了`imageUrl`就能显示图片了。\r\n\r\n如果为了更好地体验，\r\n\r\n可以使用`placeholder`作为加载中的占位符，\r\n\r\n可以使用`errorWidget`作为加载失败的占位符。\r\n\r\n但是作为图片框架，其核心功能应该是缓存功能，下面看看如何实现缓存的。\r\n\r\n# 0x02 缓存分析\r\n\r\n\r\n\r\n`CachedNetworkImage`是一个`StatefulWidget`，\r\n\r\n所以必然有一个与之对应的`State`类，\r\n\r\n通过`createState`看到了是`CachedNetworkImageState`:\r\n\r\n```dart\r\n  @override\r\n  CachedNetworkImageState createState() {\r\n    return CachedNetworkImageState();\r\n  }\r\n```\r\n\r\n进去`CachedNetworkImageState`类看看`build`：\r\n\r\n```dart\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return _animatedWidget();\r\n  }\r\n```\r\n\r\n一行代码，只是简单调用了内部方法，\r\n\r\n看看该方法实现：\r\n\r\n```dart\r\n  _animatedWidget() {\r\n    var fromMemory = _cacheManager().getFileFromMemory(widget.imageUrl);\r\n\r\n    return StreamBuilder<FileInfo>(\r\n      key: _streamBuilderKey,\r\n      initialData: fromMemory,\r\n      stream: _cacheManager()\r\n          .getFile(widget.imageUrl, headers: widget.httpHeaders)\r\n          \/\/ ignore errors if not mounted\r\n          .handleError(() {}, test: (_) => !mounted)\r\n          .where((f) =>\r\n              f?.originalUrl != fromMemory?.originalUrl ||\r\n              f?.validTill != fromMemory?.validTill),\r\n      builder: (BuildContext context, AsyncSnapshot<FileInfo> snapshot) {\r\n        if (snapshot.hasError) {\r\n          \/\/ error\r\n          if (_imageHolders.length == 0 || _imageHolders.last.error == null) {\r\n            _addImage(image: null, error: snapshot.error);\r\n          }\r\n        } else {\r\n          var fileInfo = snapshot.data;\r\n          if (fileInfo == null) {\r\n            \/\/ placeholder\r\n            if (_imageHolders.length == 0 || _imageHolders.last.image != null) {\r\n              _addImage(\r\n                  image: null,\r\n                  duration: widget.placeholderFadeInDuration ?? Duration.zero);\r\n            }\r\n          } else if (_imageHolders.length == 0 ||\r\n              _imageHolders.last.image?.originalUrl != fileInfo.originalUrl ||\r\n              _imageHolders.last.image?.validTill != fileInfo.validTill) {\r\n            _addImage(\r\n                image: fileInfo,\r\n                duration: _imageHolders.length > 0 ? null : Duration.zero);\r\n          }\r\n        }\r\n\r\n        var children = <Widget>[];\r\n        for (var holder in _imageHolders) {\r\n          if (holder.error != null) {\r\n            children.add(_transitionWidget(\r\n                holder: holder, child: _errorWidget(context, holder.error)));\r\n          } else if (holder.image == null) {\r\n            children.add(_transitionWidget(\r\n                holder: holder, child: _placeholder(context)));\r\n          } else {\r\n            children.add(_transitionWidget(\r\n                holder: holder,\r\n                child: _image(\r\n                  context,\r\n                  FileImage(holder.image.file),\r\n                )));\r\n          }\r\n        }\r\n\r\n        return Stack(\r\n          fit: StackFit.passthrough,\r\n          alignment: widget.alignment,\r\n          children: children.toList(),\r\n        );\r\n      },\r\n    );\r\n  }\r\n```\r\n\r\n里面代码较多，莫慌，简单抽取下看看主要实现：\r\n\r\n```dart\r\n  _animatedWidget() {\r\n      \/\/标注1\r\n    var fromMemory = _cacheManager().getFileFromMemory(widget.imageUrl);\r\n\r\n    return StreamBuilder<FileInfo>(\r\n      key: _streamBuilderKey,\r\n      initialData: fromMemory,\r\n      stream: _cacheManager() \/\/标注2\r\n          .getFile(widget.imageUrl, headers: widget.httpHeaders)\r\n         ,\r\n      builder: (BuildContext context, AsyncSnapshot<FileInfo> snapshot) { \/\/标注3\r\n      },\r\n    );\r\n  }\r\n```\r\n\r\n精简后的代码标注了123点。\r\n\r\n分别看下这三个地方。\r\n\r\n开始之前先看下`_cacheManager()`实现：\r\n\r\n```dart\r\n  BaseCacheManager _cacheManager() {\r\n    return widget.cacheManager ?? DefaultCacheManager();\r\n  \r\n```\r\n\r\n**可以看到如果我们自己没有设置`cacheManager`，**\r\n\r\n**那么框架会给我们自动设置一个`DefaultCacheManager`。**\r\n\r\n**所以不用担心不设置缓存器就会每次从网络拉取图片的问题。**\r\n\r\n## 内存缓存\r\n\r\n标注1其实就是从内存获取缓存，看名字就知道了。\r\n\r\n然后把获取到的值赋作为`StreamBuilder`构造函数参数`initialData`传进去。\r\n\r\n基础缓存框架`BaseCacheManager`是一个抽象类，\r\n\r\n`DefaultCacheManager`是它的默认实现。\r\n\r\n看下方法内容：\r\n\r\n```dart\r\n  \/\/\/Returns the file from memory if it has already been fetched\r\n  FileInfo getFileFromMemory(String url) {\r\n    return store.getFileFromMemory(url);\r\n  }\r\n```\r\n\r\n可以看到它啥也没干，派了手下人`store`去干了。\r\n\r\n这里的`store`是`CacheStore`类型。\r\n\r\n看下它里面方法实现：\r\n\r\n```dart\r\n  FileInfo getFileFromMemory(String url) {\r\n    if (_memCache[url] == null || _filePath == null) {\r\n      return null;\r\n    }\r\n    var cacheObject = _memCache[url];\r\n\r\n    var path = p.join(_filePath, cacheObject.relativePath);\r\n    return new FileInfo(\r\n        File(path), FileSource.Cache, cacheObject.validTill, url);\r\n  }\r\n```\r\n\r\n这里主要逻辑就是从`_memCache`里面使用`url`作为key，看看能不能拿到什么东西。\r\n\r\n如果没拿到返回null，\r\n\r\n如果侥幸拿到了，那我根据拿到的对象里的`relativePath`并拼接缓存目录`_filePath`，\r\n\r\n组成缓存文件的完整路径。\r\n\r\n根据完整路径创建一个`FileInfo`。\r\n\r\n这就完成了内存缓存获取。\r\n\r\n\r\n\r\n下面看看标准2的实现\r\n\r\n\r\n\r\n## 本地缓存\r\n\r\n标注2获取本地缓存的逻辑主要是`getFile`部分。\r\n\r\n下面看看具体实现：\r\n\r\n```dart\r\n\/\/\/ Get the file from the cache and\/or online, depending on availability and age.\r\n\/\/\/ Downloaded form [url], [headers] can be used for example for authentication.\r\n\/\/\/ The files are returned as stream. First the cached file if available, when the\r\n\/\/\/ cached file is too old the newly downloaded file is returned afterwards.\r\nStream<FileInfo> getFile(String url, {Map<String, String> headers}) {\r\n  var streamController = new StreamController<FileInfo>();\r\n  _pushFileToStream(streamController, url, headers);\r\n  return streamController.stream;\r\n}\r\n```\r\n\r\n可以看到这个方法里只创建了一个`StreamController`实例。\r\n\r\n然后就把事情交给`_pushFileToStream`处理了，\r\n\r\n继续看：\r\n\r\n```dart\r\n  _pushFileToStream(StreamController streamController, String url,\r\n      Map<String, String> headers) async {\r\n    FileInfo cacheFile;\r\n    try {\r\n      cacheFile = await getFileFromCache(url);\r\n      if (cacheFile != null) {\r\n        streamController.add(cacheFile);\r\n      }\r\n    } catch (e) {\r\n      print(\r\n          \"CacheManager: Failed to load cached file for $url with error:\\n$e\");\r\n    }\r\n    if (cacheFile == null || cacheFile.validTill.isBefore(DateTime.now())) {\r\n      try {\r\n        var webFile = await webHelper.downloadFile(url, authHeaders: headers);\r\n        if (webFile != null) {\r\n          streamController.add(webFile);\r\n        }\r\n      } catch (e) {\r\n        assert(() {\r\n          print(\r\n              \"CacheManager: Failed to download file from $url with error:\\n$e\");\r\n          return true;\r\n        }());\r\n        if (cacheFile == null && streamController.hasListener) {\r\n          streamController.addError(e);\r\n        }\r\n      }\r\n    }\r\n    streamController.close();\r\n  }\r\n```\r\n\r\n从代码不难看出，从中间if分开。\r\n\r\n上部分逻辑是从本地获取缓存并添加到`streamController`\r\n\r\n下部分逻辑是从网络获取数据并添加到`streamController`。\r\n\r\n下面分别看看实现逻辑。\r\n\r\n看下`getFileFromCache`的实现：\r\n\r\n```dart\r\n  \/\/\/Get the file from the cache\r\n  Future<FileInfo> getFileFromCache(String url) async {\r\n    return await store.getFile(url);\r\n  }\r\n```\r\n\r\n日常甩锅给`store`，\r\n\r\n现在我们知道不管从内存还是从本地都是由`CacheStore`经手。\r\n\r\n看下里面实现：\r\n\r\n```dart\r\n  Future<FileInfo> getFile(String url) async {\r\n    var cacheObject = await retrieveCacheData(url);\r\n    if (cacheObject == null || cacheObject.relativePath == null) {\r\n      return null;\r\n    }\r\n    var path = p.join(await filePath, cacheObject.relativePath);\r\n    return new FileInfo(\r\n        File(path), FileSource.Cache, cacheObject.validTill, url);\r\n  }\r\n```\r\n\r\n这里面通过`retrieveCacheData`获取缓存，后面的都是判断和封装。\r\n\r\n其实现内容为：\r\n\r\n```dart\r\n  Future<CacheObject> retrieveCacheData(String url) {\r\n    if (_memCache.containsKey(url)) {\r\n      return Future.value(_memCache[url]);\r\n    }\r\n    if (!_futureCache.containsKey(url)) {\r\n      var completer = new Completer<CacheObject>();\r\n      _getCacheDataFromDatabase(url).then((cacheObject) async {\r\n        if (cacheObject != null && !await _fileExists(cacheObject)) {\r\n          final provider = await _cacheObjectProvider;\r\n          provider.delete(cacheObject.id);\r\n          cacheObject = null;\r\n        }\r\n        completer.complete(cacheObject);\r\n\r\n        _memCache[url] = cacheObject;\r\n        _futureCache[url] = null;\r\n      });\r\n\r\n      _futureCache[url] = completer.future;\r\n    }\r\n    return _futureCache[url];\r\n  }\r\n```\r\n\r\n第一个if语句：\r\n\r\n```dart\r\nif (_memCache.containsKey(url)) {\r\n      return Future.value(_memCache[url]);\r\n    }\r\n```\r\n\r\n这里又从内存获取一遍，\r\n\r\n如果没有获取到，且第二个if也没有取到，\r\n\r\n则执行`_getCacheDataFromDatabase(url)`：\r\n\r\n```dart\r\n  Future<CacheObject> _getCacheDataFromDatabase(String url) async {\r\n    var provider = await _cacheObjectProvider;\r\n    var data = await provider.get(url);\r\n    if (await _fileExists(data)) {\r\n      _updateCacheDataInDatabase(data);\r\n    }\r\n    _scheduleCleanup();\r\n    return data;\r\n  }\r\n```\r\n\r\n到这里真相慢慢浮出水面了，因为名字里带了`database`。\r\n\r\n看来快要从数据库取数据了。\r\n\r\n`_cacheObjectProvider`其泛型类型为`CacheObjectProvider`。\r\n\r\n所以`provider.get(url);`调用的就是`CacheObjectProvider`中`get`方法：\r\n\r\n```dart\r\n  Future<CacheObject> get(String url) async {\r\n    List<Map> maps = await db.query(tableCacheObject,\r\n        columns: null, where: \"$columnUrl = ?\", whereArgs: [url]);\r\n    if (maps.length > 0) {\r\n      return new CacheObject.fromMap(maps.first);\r\n    }\r\n    return null;\r\n  }\r\n```\r\n\r\n到这里可以看到终于调用了database，进行了sqlite查询以获取缓存。\r\n\r\n**上面说了不管从内存还是从本地都是由`CacheStore`经手。**\r\n\r\n**只是从内存获取时直接从其Map类型属性`_memCache`中获取就完事了，**\r\n\r\n**而如果是获取本地缓存时，交给了其`Future<CacheObjectProvider >`类型**\r\n\r\n**`_cacheObjectProvider`来处理。**\r\n\r\n**关于`CacheObjectProvider`本类只是sqlite基本操作的封装类。**\r\n\r\n至此本地缓存获取流程结束。\r\n\r\n\r\n\r\n**总结一下：**\r\n\r\n**本地缓存也还是调用了一下内存缓存，**\r\n\r\n**内存缓存没有数据，则从本地sqlite查询。**\r\n\r\n**sqlite缓存的是源图片url和本地图片path的对应关系。**\r\n\r\n**通过url找到了path，进而找到了本地图片。**\r\n\r\n\r\n\r\n如果首次加载，前面都是获取不到数据的，接下来看看网络获取。\r\n\r\n## 网络获取\r\n\r\n继续回到`_pushFileToStream`方法，看看下部分：\r\n\r\n```dart\r\n  try {\r\n        var webFile = await webHelper.downloadFile(url, authHeaders: headers);\r\n        if (webFile != null) {\r\n          streamController.add(webFile);\r\n        }\r\n      } catch (e) {\r\n        assert(() {\r\n          print(\r\n              \"CacheManager: Failed to download file from $url with error:\\n$e\");\r\n          return true;\r\n        }());\r\n        if (cacheFile == null && streamController.hasListener) {\r\n          streamController.addError(e);\r\n        }\r\n      }\r\n```\r\n\r\n可以看到这里使用了`WebHelper`来下载文件。\r\n\r\n```dart\r\n  \/\/\/Download the file from the url\r\n  Future<FileInfo> downloadFile(String url,\r\n      {Map<String, String> authHeaders, bool ignoreMemCache = false}) async {\r\n    if (!_memCache.containsKey(url) || ignoreMemCache) {\r\n      var completer = new Completer<FileInfo>();\r\n      () async {\r\n        try {\r\n          final cacheObject =\r\n              await _downloadRemoteFile(url, authHeaders: authHeaders);\r\n          completer.complete(cacheObject);\r\n        } catch (e) {\r\n          completer.completeError(e);\r\n        } finally {\r\n          _memCache.remove(url);\r\n        }\r\n      }();\r\n\r\n      _memCache[url] = completer.future;\r\n    }\r\n    return _memCache[url];\r\n  }\r\n```\r\n\r\n**`WebHelper`不仅是对`http`网络库进行了包装调用，**\r\n\r\n**还持有了`CacheStore`的引用，以便在下载完数据后进行数据缓存。**\r\n\r\n**有意思的是这里又进行了一次`_memCache`判断，这次的`_memCache`并非`CacheStore`里面的。**\r\n\r\n**而是`WebHelper`在构造函数中自己创建的。**\r\n\r\n**就是说`WebHelper`也有做了自己的内存缓存。**\r\n\r\n继续看代码，\r\n\r\n`downloadFile`里面调用了内部方法`_downloadRemoteFile`。\r\n\r\n```dart\r\n  \/\/\/Download the file from the url\r\n  Future<FileInfo> _downloadRemoteFile(String url,\r\n      {Map<String, String> authHeaders}) async {\r\n    var cacheObject = await _store.retrieveCacheData(url);\r\n    if (cacheObject == null) {\r\n      cacheObject = new CacheObject(url);\r\n    }\r\n\r\n    var headers = new Map<String, String>();\r\n    if (authHeaders != null) {\r\n      headers.addAll(authHeaders);\r\n    }\r\n\r\n    if (cacheObject.eTag != null) {\r\n      headers[\"If-None-Match\"] = cacheObject.eTag;\r\n    }\r\n\r\n    var success = false;\r\n\r\n    var response = await _fileFetcher(url, headers: headers);\r\n    success = await _handleHttpResponse(response, cacheObject);\r\n\r\n    if (!success) {\r\n      throw HttpException(\r\n          \"No valid statuscode. Statuscode was ${response?.statusCode}\");\r\n    }\r\n\r\n    _store.putFile(cacheObject);\r\n    var filePath = p.join(await _store.filePath, cacheObject.relativePath);\r\n\r\n    return FileInfo(\r\n        new File(filePath), FileSource.Online, cacheObject.validTill, url);\r\n  }\r\n```\r\n\r\n这里使用`_fileFetcher`执行网络请求返回`reposnse`。\r\n\r\n通过`_handleHttpResponse`从`response`取出值赋给`cacheObject`。\r\n\r\n这里`_fileFetcher`是在`WebHelper`构造函数进行赋值的：\r\n\r\n```dart\r\n  WebHelper(this._store, this._fileFetcher) {\r\n    _memCache = new Map();\r\n    if (_fileFetcher == null) {\r\n        \/\/这里赋值\r\n      _fileFetcher = _defaultHttpGetter;\r\n    }\r\n  }\r\n  \r\n    Future<FileFetcherResponse> _defaultHttpGetter(String url,\r\n      {Map<String, String> headers}) async {\r\n    var httpResponse = await http.get(url, headers: headers);\r\n    return new HttpFileFetcherResponse(httpResponse);\r\n  }\r\n```\r\n\r\n给它赋值的`_defaultHttpGetter`本质是`HttpFileFetcherResponse`的实例。\r\n\r\n而该类只是包装了`http.get`请求返回的结果。\r\n\r\n至此网络获取流程也已经结束。\r\n\r\n整个缓存调用流程可以简单理解为：\r\n\r\n![image-20200116105412493](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200116105412493.png)\r\n\r\n\r\n\r\n\r\n\r\n# 0x03 流程分析\r\n\r\n## 瞎比比\r\n\r\n前面看了三种缓存的实现，所以你懂了该框架实现流程了吗？\r\n\r\n不，你顶多只是了解了三种缓存流程大概实现方式。\r\n\r\n至于框架的调用流程才刚开始。。。\r\n\r\n先来个类图看下主要类的关系：\r\n\r\n<img src=\"https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200115232508547.png\" alt=\"image-20200115232508547\" style=\"zoom:200%;\" \/>\r\n\r\n在上面缓存流程中，我们标注了123点。\r\n\r\n这三点是围绕`StreamBuilder`展开的。\r\n\r\n这三点分别对应了`StreamBuilder`构造函数中的\r\n\r\n`initialData`、`stream`、`builder`。\r\n\r\n你几乎可以认为掌握了这三块流程，也就掌握了该框架实现流程原理。\r\n\r\n\r\n\r\n## 入正题\r\n\r\n通过类图我们知道逻辑开始渐入复杂，\r\n\r\n是从`CachedNetworkImageState`的`build`方法开始的。\r\n\r\n因为这里调用了它所依赖的`StreamBuilder`。\r\n\r\n我们的标注也是从这里开始的。\r\n\r\n进入`StreamBuilder`类：\r\n\r\n```dart\r\nclass StreamBuilder<T> extends StreamBuilderBase<T, AsyncSnapshot<T>> {\r\n  \/\/\/ The [builder] must not be null.\r\n  const StreamBuilder({\r\n    Key key,\r\n    this.initialData,\r\n    Stream<T> stream,\r\n    @required this.builder,\r\n  }) : assert(builder != null),\r\n       super(key: key, stream: stream);\r\n\r\n  final AsyncWidgetBuilder<T> builder;\r\n\r\n  final T initialData;\r\n\r\n  @override\r\n  AsyncSnapshot<T> initial() => AsyncSnapshot<T>.withData(ConnectionState.none, initialData);\r\n\r\n  @override\r\n  AsyncSnapshot<T> afterConnected(AsyncSnapshot<T> current) => current.inState(ConnectionState.waiting);\r\n\r\n  @override\r\n  AsyncSnapshot<T> afterData(AsyncSnapshot<T> current, T data) {\r\n    return AsyncSnapshot<T>.withData(ConnectionState.active, data);\r\n  }\r\n\r\n  @override\r\n  AsyncSnapshot<T> afterError(AsyncSnapshot<T> current, Object error) {\r\n    return AsyncSnapshot<T>.withError(ConnectionState.active, error);\r\n  }\r\n\r\n  @override\r\n  AsyncSnapshot<T> afterDone(AsyncSnapshot<T> current) => current.inState(ConnectionState.done);\r\n\r\n  @override\r\n  AsyncSnapshot<T> afterDisconnected(AsyncSnapshot<T> current) => current.inState(ConnectionState.none);\r\n\r\n  @override\r\n  Widget build(BuildContext context, AsyncSnapshot<T> currentSummary) => builder(context, currentSummary);\r\n}\r\n```\r\n\r\n类的代码并不多，\r\n\r\n`StreamBuilder`是个泛型类，注意它和其父类的泛型类型即可。\r\n\r\n构造函数中`initialData`直接赋值给了属性`final T initialData`。\r\n\r\n`stream`传递给了父类，该类本身没有调用。\r\n\r\n`builder`直接赋值给了属性`final AsyncWidgetBuilder<T> builder`。\r\n\r\n\r\n\r\n**最后的方法`build`方法调用了函数类型属性`builder`。**\r\n\r\n**记住`StreamBuilder`的这个`builder`实现是我们构造`StreamBuilder`时传入完成的。**\r\n\r\n剩下好些个重写方法，暂时不管，小憩一下，\r\n\r\n\r\n\r\n继续看看它的父类：\r\n\r\n```dart\r\nabstract class StreamBuilderBase<T, S> extends StatefulWidget {\r\n  \/\/\/ Creates a [StreamBuilderBase] connected to the specified [stream].\r\n  const StreamBuilderBase({ Key key, this.stream }) : super(key: key);\r\n\r\n  final Stream<T> stream;\r\n\r\n  S initial();\r\n\r\n  S afterConnected(S current) => current;\r\n\r\n  S afterData(S current, T data);\r\n\r\n  S afterError(S current, Object error) => current;\r\n\r\n  S afterDone(S current) => current;\r\n\r\n  S afterDisconnected(S current) => current;\r\n\r\n  \/\/\/ Returns a Widget based on the [currentSummary].\r\n  Widget build(BuildContext context, S currentSummary);\r\n\r\n  @override\r\n  State<StreamBuilderBase<T, S>> createState() => _StreamBuilderBaseState<T, S>();\r\n}\r\n```\r\n\r\n`StreamBuilderBase`是一个抽象泛型类。\r\n\r\n通过这两处泛型类，可以知道这里的泛型 `<S>` 其实就是 `AsyncSnapshot<T>`。\r\n\r\n下面提供了很多关于 `S`的抽象方法，暂且放一放，知道这些抽象方法在`StreamBuilder`实现了即可。\r\n\r\n`StreamBuilderBase`继承了`StatefulWidget`。\r\n\r\n由此它必定重写`createState`，创建了`_StreamBuilderBaseState`实例。\r\n\r\n创建了`_StreamBuilderBaseState`后，我们知道`State`生命周期有`initState`和`build`。\r\n\r\n看看它们的实现：\r\n\r\n```dart\r\nclass _StreamBuilderBaseState<T, S> extends State<StreamBuilderBase<T, S>> {\r\n  StreamSubscription<T> _subscription;\r\n  S _summary;\r\n\r\n  @override\r\n  void initState() {\r\n    super.initState();\r\n    _summary = widget.initial();\r\n    _subscribe();\r\n  }\r\n\r\n  @override\r\n  void didUpdateWidget(StreamBuilderBase<T, S> oldWidget) {\r\n    super.didUpdateWidget(oldWidget);\r\n    if (oldWidget.stream != widget.stream) {\r\n      if (_subscription != null) {\r\n        _unsubscribe();\r\n        _summary = widget.afterDisconnected(_summary);\r\n      }\r\n      _subscribe();\r\n    }\r\n  }\r\n\r\n  @override\r\n  Widget build(BuildContext context) => widget.build(context, _summary);\r\n\r\n  @override\r\n  void dispose() {\r\n    _unsubscribe();\r\n    super.dispose();\r\n  }\r\n\r\n  void _subscribe() {\r\n    if (widget.stream != null) {\r\n      _subscription = widget.stream.listen((T data) {\r\n        setState(() {\r\n          _summary = widget.afterData(_summary, data);\r\n        });\r\n      }, onError: (Object error) {\r\n        setState(() {\r\n          _summary = widget.afterError(_summary, error);\r\n        });\r\n      }, onDone: () {\r\n        setState(() {\r\n          _summary = widget.afterDone(_summary);\r\n        });\r\n      });\r\n      _summary = widget.afterConnected(_summary);\r\n    }\r\n  }\r\n\r\n  void _unsubscribe() {\r\n    if (_subscription != null) {\r\n      _subscription.cancel();\r\n      _subscription = null;\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n\r\n\r\n看下`initState`代码`_summary = widget.initial();`，\r\n\r\n调用了`widget`的`initial`方法。\r\n\r\n这个`widget`指向`StreamBuilderBase`，它的`initial`方法是抽象的。\r\n\r\n没关系，刚才说了它有实现类`StreamBuilder`,看看它的实现：\r\n\r\n```dart\r\n @override\r\n  AsyncSnapshot<T> initial() => AsyncSnapshot<T>.withData(ConnectionState.none, initialData);\r\n```\r\n\r\n看下`AsyncSnapshot`实现：\r\n\r\n```dart\r\n@immutable\r\nclass AsyncSnapshot<T> {\r\n  const AsyncSnapshot._(this.connectionState, this.data, this.error)\r\n    : assert(connectionState != null),\r\n      assert(!(data != null && error != null));\r\n\r\n  const AsyncSnapshot.nothing() : this._(ConnectionState.none, null, null);\r\n  const AsyncSnapshot.withData(ConnectionState state, T data) : this._(state, data, null);\r\n  const AsyncSnapshot.withError(ConnectionState state, Object error) : this._(state, null, error);\r\n\r\n  \/\/\/ Current state of connection to the asynchronous computation.\r\n  final ConnectionState connectionState;\r\n\r\n  final T data;\r\n}\r\n```\r\n\r\n可以看到这个异步快照(暂时这么叫)类并没有做什么，\r\n\r\n只是对从`StreamBuilder`传进来的`initialData`和`ConnectionState`以及一个`error`的一个包装。\r\n\r\n目前只要知道能从异步快照中拿到`initialData`和`error`及`ConnectionState`状态即可。\r\n\r\n包装好的异步快照赋值给了`_summary`。\r\n\r\n权且不管`initState`其他代码，现在我们已经拿到了异步快照，\r\n\r\n假如已经`initState`执行完毕，那么就该回调`build`方法构建widget了。\r\n\r\n\r\n\r\n看看`build`函数实现：`widget.build(context, _summary)`，就这一行调用。\r\n\r\n这个`State`没有自己创建widget，而是交给了其对应的`widget`的`build`处理。\r\n\r\n该`build`又是个抽象方法，如上所述具体实现在`StreamBuilder`：\r\n\r\n```dart\r\n@override\r\n  Widget build(BuildContext context, AsyncSnapshot<T> currentSummary) => builder(context, currentSummary);\r\n```\r\n\r\n**上面说了`StreamBuilder`里的这个`builder`就是当初我们创建`StreamBuilder`传参的`builder`。**\r\n\r\n**`builder`参数类型为`BuildContext context, AsyncSnapshot<T> snapshot`。**\r\n\r\n**所以搞了半天，你从`StreamBuilder`的`initialData`传进去的数据，**\r\n\r\n**经过异步快照包装一下，又从`StreamBuilder`的`builder`返回来供你使用了。**\r\n\r\n**`builder`最终返回`widget`类型。在`builder`代码块中你可以根据异步快照信息来显示你的控件。**\r\n\r\n**目前来看，如果不是首次获取的图片，并且内存缓存还没有被回收，那么可以通过`initialData`直接进行读取图片显示。**\r\n\r\n**至此你应该知道内存缓存数据的来去流程了。**\r\n\r\n\r\n\r\n上面我们说假如`initState`已经执行完毕，\r\n\r\n其实并没有啊，返回去继续看`initState`，里面还调用了`_subscribe`：\r\n\r\n```dart\r\n  void _subscribe() {\r\n    if (widget.stream != null) {\r\n      _subscription = widget.stream.listen((T data) {\r\n        setState(() {\r\n          _summary = widget.afterData(_summary, data);\r\n        });\r\n      }, onError: (Object error) {\r\n        setState(() {\r\n          _summary = widget.afterError(_summary, error);\r\n        });\r\n      }, onDone: () {\r\n        setState(() {\r\n          _summary = widget.afterDone(_summary);\r\n        });\r\n      });\r\n      _summary = widget.afterConnected(_summary);\r\n    }\r\n  }\r\n```\r\n\r\n如果`stream`不为空，则设置`stream`监听。\r\n\r\n看下监听函数参数：\r\n\r\n```dart\r\n  StreamSubscription<T> listen(void onData(T event),\r\n      {Function onError, void onDone(), bool cancelOnError});\r\n```\r\n\r\n这里有`onData`、`onError`、`onDone`三个函数参数。\r\n\r\n这三个参数分别会在`stream`对应的`StreamController`执行`add`、`addError`和`close`时进行触发。\r\n\r\n也就是说：\r\n\r\n**`StreamController.add`执行时，触发`_summary = widget.afterData(_summary, data);`**\r\n\r\n**`StreamController.addError`执行时，触发`_summary = widget.afterError(_summary, data);`**\r\n\r\n**`StreamController.close`执行时，触发`_summary = widget.afterConnected(_summary, data);`**\r\n\r\n至于`stream`和`StreamController`怎么扯上关系的，还要从`StreamBuilder`构造函数参数`stream`看起。\r\n\r\n\r\n\r\n我们看到`_cacheManager().getFile`是返回了`Stream`。\r\n\r\n在`getFile`里面创建了`StreamController`实例，\r\n\r\n而每个`StreamController`实例控制着一个`stream`：\r\n\r\n```dart\r\nabstract class StreamController<T> implements StreamSink<T> {\r\n  \/** The stream that this controller is controlling. *\/\r\n  Stream<T> get stream;\r\n}\r\n```\r\n\r\n通过`streamController.stream`直接返回了构造函数所需的`stream`实例。\r\n\r\n现在我们清楚了原来\r\n\r\n`streamController.stream`和上面`_subscribe`中`widget.stream`是同一个对象。\r\n\r\n由于上面设置了`widget.stream`监听，\r\n\r\n所以我们后面对`streamController`的操作都会通过监听回调相应的函数。\r\n\r\n关系绑定好了，我们继续看代码：\r\n\r\n```dart\r\n  _pushFileToStream(StreamController streamController, String url,\r\n      Map<String, String> headers) async {\r\n    FileInfo cacheFile;\r\n    try {\r\n      cacheFile = await getFileFromCache(url);\r\n      if (cacheFile != null) {\r\n        streamController.add(cacheFile);\r\n      }\r\n    } catch (e) {\r\n      print(\r\n          \"CacheManager: Failed to load cached file for $url with error:\\n$e\");\r\n    }\r\n    if (cacheFile == null || cacheFile.validTill.isBefore(DateTime.now())) {\r\n      try {\r\n        var webFile = await webHelper.downloadFile(url, authHeaders: headers);\r\n        if (webFile != null) {\r\n          streamController.add(webFile);\r\n        }\r\n      } catch (e) {\r\n        assert(() {\r\n          print(\r\n              \"CacheManager: Failed to download file from $url with error:\\n$e\");\r\n          return true;\r\n        }());\r\n        if (cacheFile == null && streamController.hasListener) {\r\n          streamController.addError(e);\r\n        }\r\n      }\r\n    }\r\n    streamController.close();\r\n  }\r\n```\r\n\r\n上面讲本地缓存已经看过一遍了，这次应该不慌了吧。\r\n\r\n代码大概流程就是\r\n\r\n如果我从`getFileFromCache`获取到了数据，将调用`streamController.add(cacheFile)`。\r\n\r\n如果没有获取到我将从网络获取，\r\n\r\n如果我从`webHelper.downloadFile`获取到了数据，也调用`streamController.add(webFile)`。\r\n\r\n如果期间出现异常，将调用`streamController.addError(e)`。\r\n\r\n到最后调用`streamController.close()`。\r\n\r\n上面说了这三个函数调用时，分别回调监听函数中的`onData`、`onError`、`onDone`。\r\n\r\n\r\n\r\n假如获取数据成功调用了`onData`，则调用`_summary = widget.afterData(_summary, data)`。\r\n\r\n这里的`widget`是抽象类，实现方法从`StreamBuilder`里面找：\r\n\r\n```dart\r\n@override\r\n  AsyncSnapshot<T> afterData(AsyncSnapshot<T> current, T data) {\r\n    return AsyncSnapshot<T>.withData(ConnectionState.active, data);\r\n  }\r\n\r\n  @override\r\n  AsyncSnapshot<T> afterError(AsyncSnapshot<T> current, Object error) {\r\n    return AsyncSnapshot<T>.withError(ConnectionState.active, error);\r\n  }\r\n\r\n  @override\r\n  AsyncSnapshot<T> afterDone(AsyncSnapshot<T> current) => current.inState(ConnectionState.done);\r\n```\r\n\r\n这里把三个实现函数都拿出来了，\r\n\r\n可以看到`afterData`调用后也只是对拿到的`<T>`和`ConnectionState`进行包装。\r\n\r\n而`afterError`是对一个`error`和`ConnectionState`进行包装。\r\n\r\n`afterDone`则只是把最后的`_summary`中`ConnectionState`状态改为`done`。\r\n\r\n你应该注意到这三个函数都是包裹在`setState`中的。\r\n\r\n因此导致这三个函数的调用都将导致该`State`的`build`函数调用。\r\n\r\n上面说了该`State`的`build`没有自己生成widget，\r\n\r\n而是调用`widget.build(context, _summary)`。\r\n\r\n而该实现方法调用了`builder(context, currentSummary)`\r\n\r\n最终把`_summary`外送到`StreamBuilder`的构造函数参数`builder`中。\r\n\r\n这块是我们自己实现的。\r\n\r\n\r\n\r\n总的来说，`initialData`和`stream`两个地方都是为`builder`提供数据的。\r\n\r\n最终的落脚点是`builder`的实现，我们来看看源码：\r\n\r\n```dart\r\n      builder: (BuildContext context, AsyncSnapshot<FileInfo> snapshot) {\r\n        if (snapshot.hasError) {\r\n          \/\/ error\r\n          if (_imageHolders.length == 0 || _imageHolders.last.error == null) {\r\n            _addImage(image: null, error: snapshot.error);\r\n          }\r\n        } else {\r\n          var fileInfo = snapshot.data;\r\n          if (fileInfo == null) {\r\n            \/\/ placeholder\r\n            if (_imageHolders.length == 0 || _imageHolders.last.image != null) {\r\n              _addImage(\r\n                  image: null,\r\n                  duration: widget.placeholderFadeInDuration ?? Duration.zero);\r\n            }\r\n          } else if (_imageHolders.length == 0 ||\r\n              _imageHolders.last.image?.originalUrl != fileInfo.originalUrl ||\r\n              _imageHolders.last.image?.validTill != fileInfo.validTill) {\r\n            _addImage(\r\n                image: fileInfo,\r\n                duration: _imageHolders.length > 0 ? null : Duration.zero);\r\n          }\r\n        }\r\n\r\n        var children = <Widget>[];\r\n        for (var holder in _imageHolders) {\r\n          if (holder.error != null) {\r\n            children.add(_transitionWidget(\r\n                holder: holder, child: _errorWidget(context, holder.error)));\r\n          } else if (holder.image == null) {\r\n            children.add(_transitionWidget(\r\n                holder: holder, child: _placeholder(context)));\r\n          } else {\r\n            children.add(_transitionWidget(\r\n                holder: holder,\r\n                child: _image(\r\n                  context,\r\n                  FileImage(holder.image.file),\r\n                )));\r\n          }\r\n        }\r\n\r\n        return Stack(\r\n          fit: StackFit.passthrough,\r\n          alignment: widget.alignment,\r\n          children: children.toList(),\r\n        );\r\n      }\r\n```\r\n\r\n这段代码从中间`var children = <Widget>[]`可以分为上下两部分。\r\n\r\n其中上部分就是根据`snapshot`的状态来填充`_imageHolders`：\r\n\r\n如果`snapshot.hasError`返回`true`，\r\n\r\n说明之前有调用过`streamControler.addError`，否则应该是false的。\r\n\r\n\r\n\r\n`_imageHolders`是`_ImageTransitionHolder`类型列表：\r\n\r\n```dart\r\nclass _ImageTransitionHolder {\r\n  final FileInfo image;\r\n  AnimationController animationController;\r\n  final Object error;\r\n  Curve curve;\r\n  final TickerFuture forwardTickerFuture;\r\n\r\n  _ImageTransitionHolder({\r\n    this.image,\r\n    @required this.animationController,\r\n    this.error,\r\n    this.curve: Curves.easeIn,\r\n  }) : forwardTickerFuture = animationController.forward();\r\n\r\n  dispose() {\r\n    if (animationController != null) {\r\n      animationController.dispose();\r\n      animationController = null;\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n通过源码可以看到`_ImageTransitionHolder`也是一个包装类。\r\n\r\n包装了`image`、`error`和动画控制器。\r\n\r\n\r\n\r\n当`snapshot.hasError`返回`true`时，\r\n\r\n添加一个包装了错误信息的`_ImageTransitionHolder`到`_imageHolders`。\r\n\r\n如果获取到了数据添加一个包装了`FileInfo`信息的`_ImageTransitionHolder`到`_imageHolders`。\r\n\r\n如果没有获取到数据就添加一个空`FileInfo`。\r\n\r\n\r\n\r\n下部分通过遍历`_imageHolders`，根据不同信息创建不同的widget：\r\n\r\n```dart\r\n        var children = <Widget>[];\r\n        for (var holder in _imageHolders) {\r\n          if (holder.error != null) {\r\n            children.add(_transitionWidget(\r\n                holder: holder, child: _errorWidget(context, holder.error)));\r\n          } else if (holder.image == null) {\r\n            children.add(_transitionWidget(\r\n                holder: holder, child: _placeholder(context)));\r\n          } else {\r\n            children.add(_transitionWidget(\r\n                holder: holder,\r\n                child: _image(\r\n                  context,\r\n                  FileImage(holder.image.file),\r\n                )));\r\n          }\r\n        }\r\n```\r\n\r\n拿到`error`的`_ImageTransitionHolder`时，\r\n\r\n会给`child`设置`_errorWidget`：\r\n\r\n```dart\r\n  _errorWidget(BuildContext context, Object error) {\r\n    return widget.errorWidget != null\r\n        ? widget.errorWidget(context, widget.imageUrl, error)\r\n        : _placeholder(context);\r\n  }\r\n```\r\n\r\n可以看到`_errorWidget`函数里面就是调用创建`CachedNetworkImage`时传递的`errorWidget`。\r\n\r\n如果没有设置`errorWidget`,则调用`_placeholder`函数。\r\n\r\n可知我们设置的错误信息占位控件是在此时被填充显示的。\r\n\r\n\r\n\r\n同样在遍历中，当`holder.image == null`为true时，\r\n\r\n也会调用`_placeholder`：\r\n\r\n```dart\r\n  _placeholder(BuildContext context) {\r\n    return widget.placeholder != null\r\n        ? widget.placeholder(context, widget.imageUrl)\r\n        : SizedBox(\r\n            width: widget.width,\r\n            height: widget.height,\r\n          );\r\n  }\r\n```\r\n\r\n同样你会发现，这里调用了我们创建`CachedNetworkImage`时传递的`placeholder`。\r\n\r\n这是加载到数据前的默认显示占位控件。\r\n\r\n\r\n\r\n如果前两个判断都没有成立，说明现在正常获取到了数据，\r\n\r\n调用了`_image`：\r\n\r\n```dart\r\n  _image(BuildContext context, ImageProvider imageProvider) {\r\n    return widget.imageBuilder != null\r\n        ? widget.imageBuilder(context, imageProvider)\r\n        : Image(\r\n            image: imageProvider,\r\n            fit: widget.fit,\r\n            width: widget.width,\r\n            height: widget.height,\r\n            alignment: widget.alignment,\r\n            repeat: widget.repeat,\r\n            color: widget.color,\r\n            colorBlendMode: widget.colorBlendMode,\r\n            matchTextDirection: widget.matchTextDirection,\r\n            filterQuality: widget.filterQuality,\r\n          );\r\n  }\r\n```\r\n\r\n这里调用了`widget.imageBuilder`，\r\n\r\n如果它没有值，则使用默认的`Image`控件显示图片，\r\n\r\n如果它有值，则把`imageProvider`交给它处理，\r\n\r\n这里的`imageProvider`是`FileImage`类型，它包装了从`FileInfo`获取到的`file`。\r\n\r\n而这里的`imageBuilder`又是我们自定义的部分。\r\n\r\n所以如果默认的`Image`显示不能满足你的要求，\r\n\r\n你可以通道自定义`imageBuilder`实现来达到理想效果。\r\n\r\n\r\n\r\n至此`CachedNetworkImage`框架大体流程分析完了，你看懂了多少？\r\n\r\n\r\n\r\n\r\n\r\n这里有个疑问，为什么`_imageHolders`要使用List，起了什么作用？\r\n\r\n另外还有个问题是之前说了stream监听，每次回调都最终从新调用`builder`。\r\n\r\n一个图片显示过程可能面临好几次的`build`。这块需要考虑是否有可能会有性能问题？"
  },
  {
    "title": "Flutter状态管理之Provider源码分析",
    "created_time": "2020-01-18 14:29:15",
    "body": "# 0x00 前言\r\n\r\nFlutter在做全局状态管理时，没有提供像Android中Application类来保存全局状态。\r\n\r\n好在还有框架可以使用，目前谷歌官方推荐使用Provider管理全局状态。\r\n\r\n所以花了点时间看了下源码大概实现流程。\r\n\r\n\r\n\r\n要了解Provider大概原理，个人觉得从以下三点入手即可：\r\n\r\n1、什么时候，如何存储data？存到哪里去了？\r\n\r\n2、如何取出data使用？\r\n\r\n3、如何刷新data以及为何刷新data也就刷新了widget？\r\n\r\n后面的源码分析会从这三点入手贯穿整个使用流程。\r\n\r\n当然在分析源码前看下简单的使用方法。\r\n\r\n# 0x01 使用\r\n\r\n## 添加依赖\r\n\r\n```yaml\r\nprovider: ^4.0.0\r\n```\r\n\r\n最新版从[pub获取](https:\/\/pub.dev\/packages\/provider)\r\n\r\n## 继承ChangeNotifier\r\n\r\n把自己创建的数据类继承`ChangeNotifier`，\r\n\r\n想监听哪些属性改变时进行刷新，则创建set方法，\r\n\r\n并在方法中调用`notifyListeners`：\r\n\r\n```dart\r\nclass UserBean with ChangeNotifier {\r\n  String avatarUrl;\r\n  String name;\r\n  String token;\r\n  String mobile;\r\n  String pwd;\r\n  String id;\r\n\r\n  UserBean([\r\n    this.id,\r\n    this.name,\r\n    this.mobile,\r\n    this.pwd,\r\n    this.token,\r\n    this.avatarUrl,\r\n  ]);\r\n\r\n  void setData(\r\n      {String name,\r\n      String mobile,\r\n      String pwd,\r\n      String token,\r\n      String avatarUrl,\r\n      String id,\r\n      bool isSaveDB = true}) async {\r\n    this.name = name;\r\n    this.mobile = mobile;\r\n    this.pwd = pwd;\r\n    this.token = token;\r\n    this.avatarUrl = avatarUrl;\r\n    this.id = id;\r\n    print(\"mobile=$mobile\");\r\n    notifyListeners();\r\n    if (isSaveDB) {\r\n      int id = await UserProvider.dao.update(this);\r\n      print(\"id=$id\");\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n## 配置MultiProvider\r\n\r\n由于我的所有页面都可能会检测登录状态，\r\n\r\n所以我把`MultiProvider`配置到了`main`入口处。\r\n\r\n我暂时只想管理`UserBean`，所以只配置了这一个类：\r\n\r\n```dart\r\nvoid main() => runApp(MyApp());\r\n\r\n\/\/\/ app入口\r\nclass MyApp extends StatelessWidget {\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    \/\/ 创建路由对象\r\n    final router = Router();\r\n    \/\/ 配置路由集Routes的路由对象\r\n    Routes.configureRoutes(router);\r\n    \/\/ 指定Application的路由对象\r\n    FindCatApp.router = router;\r\n\t\/\/配置MultiProvider\r\n    return MultiProvider(\r\n      providers: [\r\n        ChangeNotifierProvider(create: (_) => UserBean()),\/\/\r\n      ],\r\n      child: MaterialApp(\r\n        onGenerateRoute: FindCatApp.router.generator,\r\n        localizationsDelegates: [\r\n          GlobalMaterialLocalizations.delegate,\r\n          GlobalWidgetsLocalizations.delegate,\r\n          CatLocalizationsDelegate()\r\n        ],\r\n        supportedLocales: [const Locale('en', 'US'), const Locale('zh', 'CN')],\r\n        theme: ThemeData(\r\n          primarySwatch: Colors.blue,\r\n        ),\r\n        home: HomePage(),\r\n      ),\r\n    );\r\n  }\r\n}\r\n```\r\n\r\n\r\n\r\n## 获取(更新)数据\r\n\r\n配置完成后可以通过`Provider.of<UserBean>(context)`获取数据来判断用户状态。\r\n\r\n如果要更新状态，通过调用`Provider.of<UserBean>(context).setData`即可。\r\n\r\n\r\n\r\n最简单的使用大概就是这样，\r\n\r\n下面开始进入源码分析。\r\n\r\n# 0x02 分析\r\n\r\n\r\n\r\n<img src=\"https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/Provider%E6%B5%81%E7%A8%8B.jpeg\" alt=\"Provider流程\" style=\"zoom:300%;\" \/>\r\n\r\n后面的分析都是本着一个新手对一切都是未知的角度来分析，\r\n\r\n不会提前把一些知识点讲出来，以便提供一个最客观的视角。\r\n\r\n这里把前言中的三点概括为`data存储流程`，`data取出流程`，`data刷新流程`。\r\n\r\n下面分别看看各流程是如何执行的。\r\n\r\n## data存储流程\r\n\r\n通过上面的简单使用，你应该已经知道配置数据发生在\r\n\r\n使用`MultiProvider`时，我们提供的`providers`构造函数参数。\r\n\r\n我这里的`providers`使用的是`ChangeNotifierProvider`，\r\n\r\n它使用构造函数参数`create`带走了我的`UserBean`。\r\n\r\n看下它的构造函数：\r\n\r\n```dart\r\n  ChangeNotifierProvider({\r\n    Key key,\r\n    @required Create<T> create,\r\n    bool lazy,\r\n    Widget child,\r\n  }) : super(\r\n          key: key,\r\n          create: create,\r\n          dispose: _dispose,\r\n          lazy: lazy,\r\n          child: child,\r\n        );\r\n```\r\n\r\n这里的`create`是`Create<T>`。\r\n\r\n它是个函数类型参数：`typedef Create<T> = T Function(BuildContext context);`\r\n\r\n可以看到它提供一个`context`，然后返回一个`T`。\r\n\r\n这里的`context`返回给你是为了让你创建`widget`用的。\r\n\r\n目前我们知道我的`UserBean`被`create`携带。\r\n\r\n我们要做的就是盯住它走向哪里。\r\n\r\n这里并没有属性接收它，直接传给了`super`。\r\n\r\n\r\n\r\n别手软，点进去。\r\n\r\n然后来到了`ListenableProvider<T extends Listenable>`类中：\r\n\r\n```dart\r\n  ListenableProvider({\r\n    Key key,\r\n    @required Create<T> create,\r\n    Dispose<T> dispose,\r\n    bool lazy,\r\n    Widget child,\r\n  })  : assert(create != null),\r\n        super(\r\n          key: key,\r\n          startListening: _startListening,\r\n          create: create,\r\n          dispose: dispose,\r\n          debugCheckInvalidValueType: kReleaseMode\r\n              ? null\r\n              : (value) {\r\n                  if (value is ChangeNotifier) {\r\n                    \/\/ ignore: invalid_use_of_protected_member\r\n                    assert(!value.hasListeners, '''\r\nThe default constructor of ListenableProvider\/ChangeNotifierProvider\r\nmust create a new, unused Listenable.\r\n\r\nIf you want to reuse an existing Listenable, use the second constructor:\r\n\r\n- DO use ChangeNotifierProvider.value to provider an existing ChangeNotifier:\r\n\r\nMyChangeNotifier variable;\r\nChangeNotifierProvider.value(\r\n  value: variable,\r\n  child: ...\r\n)\r\n\r\n- DON'T reuse an existing ChangeNotifier using the default constructor.\r\n\r\nMyChangeNotifier variable;\r\nChangeNotifierProvider(\r\n  create: (_) => variable,\r\n  child: ...\r\n)\r\n''');\r\n                  }\r\n                },\r\n          lazy: lazy,\r\n          child: child,\r\n        );\r\n```\r\n\r\n仍然没有赋值给属性，而是又调用了`super`。\r\n\r\n难道它的存在感这么低？\r\n\r\n不管它，点进去，继续看。\r\n\r\n\r\n\r\n进入了`InheritedProvider<T>`类:\r\n\r\n```dart\r\n  InheritedProvider({\r\n    Key key,\r\n    Create<T> create,\r\n    T update(BuildContext context, T value),\r\n    UpdateShouldNotify<T> updateShouldNotify,\r\n    void Function(T value) debugCheckInvalidValueType,\r\n    StartListening<T> startListening,\r\n    Dispose<T> dispose,\r\n    bool lazy,\r\n    Widget child,\r\n  })  : _lazy = lazy,\r\n        _delegate = _CreateInheritedProvider(\r\n          create: create,\r\n          update: update,\r\n          updateShouldNotify: updateShouldNotify,\r\n          debugCheckInvalidValueType: debugCheckInvalidValueType,\r\n          startListening: startListening,\r\n          dispose: dispose,\r\n        ),\r\n        super(key: key, child: child);\r\n```\r\n\r\n可以看到这里虽然没有直接赋值给属性，\r\n\r\n但是把它包裹在了`_delegate`属性里面了。\r\n\r\n而且在`super`里面没有在传递`create`。\r\n\r\n既然数据通过`_delegate`能拿到，\r\n\r\n那就放眼望去，看看谁要使用它，\r\n\r\n类里面没有找到谁要调用该属性了。\r\n\r\n别慌，看下源码：\r\n\r\n```dart\r\nclass InheritedProvider<T> extends SingleChildStatelessWidget {\r\n  \/\/\/ Creates a value, then expose it to its descendants.\r\n  \/\/\/\r\n  \/\/\/ The value will be disposed of when [InheritedProvider] is removed from\r\n  \/\/\/ the widget tree.\r\n  InheritedProvider({\r\n    Key key,\r\n    Create<T> create,\r\n    T update(BuildContext context, T value),\r\n    UpdateShouldNotify<T> updateShouldNotify,\r\n    void Function(T value) debugCheckInvalidValueType,\r\n    StartListening<T> startListening,\r\n    Dispose<T> dispose,\r\n    bool lazy,\r\n    Widget child,\r\n  })  : _lazy = lazy,\r\n        _delegate = _CreateInheritedProvider(\r\n          create: create,\r\n          update: update,\r\n          updateShouldNotify: updateShouldNotify,\r\n          debugCheckInvalidValueType: debugCheckInvalidValueType,\r\n          startListening: startListening,\r\n          dispose: dispose,\r\n        ),\r\n        super(key: key, child: child);\r\n\r\n  \/\/\/ Expose to its descendants an existing value,\r\n  InheritedProvider.value({\r\n    Key key,\r\n    @required T value,\r\n    UpdateShouldNotify<T> updateShouldNotify,\r\n    StartListening<T> startListening,\r\n    bool lazy,\r\n    Widget child,\r\n  })  : _lazy = lazy,\r\n        _delegate = _ValueInheritedProvider(\r\n          value: value,\r\n          updateShouldNotify: updateShouldNotify,\r\n          startListening: startListening,\r\n        ),\r\n        super(key: key, child: child);\r\n\r\n  InheritedProvider._constructor({\r\n    Key key,\r\n    _Delegate<T> delegate,\r\n    bool lazy,\r\n    Widget child,\r\n  })  : _lazy = lazy,\r\n        _delegate = delegate,\r\n        super(key: key, child: child);\r\n\r\n  final _Delegate<T> _delegate;\r\n  final bool _lazy;\r\n\r\n  @override\r\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\r\n    super.debugFillProperties(properties);\r\n    _delegate.debugFillProperties(properties);\r\n  }\r\n\r\n  @override\r\n  _InheritedProvderElement<T> createElement() {\r\n    return _InheritedProvderElement<T>(this);\r\n  }\r\n\r\n  @override\r\n  Widget buildWithChild(BuildContext context, Widget child) {\r\n    return _DefaultInheritedProviderScope<T>(\r\n      owner: this,\r\n      child: child,\r\n    );\r\n  }\r\n}\r\n```\r\n\r\n我们看到`InheritedProvider<T>`继承了`SingleChildStatelessWidget`。\r\n\r\n既然继承了`Widget`，总归要调用`build`吧：\r\n\r\n我们发现只有`buildWithChild`，没有我们想要的方法，\r\n\r\n没关系，去`SingleChildStatelessWidget`里面看看，\r\n\r\n我有理由怀疑它继承了`StatelessWidget`：\r\n\r\n```dart\r\n\/\/\/ Its [build] method must **not** be overriden. Instead use [buildWithChild].\r\nabstract class SingleChildStatelessWidget extends StatelessWidget\r\n    implements SingleChildWidget {\r\n  \/\/\/ Creates a widget that has exactly one child widget.\r\n  const SingleChildStatelessWidget({Key key, Widget child})\r\n      : _child = child,\r\n        super(key: key);\r\n\r\n  final Widget _child;\r\n\r\n  \/\/\/ A [build] method that receives an extra `child` parameter.\r\n  \/\/\/\r\n  \/\/\/ This method may be called with a `child` different from the parameter\r\n  \/\/\/ passed to the constructor of [SingleChildStatelessWidget].\r\n  \/\/\/ It may also be called again with a different `child`, without this widget\r\n  \/\/\/ being recreated.\r\n  Widget buildWithChild(BuildContext context, Widget child);\r\n\r\n  @override\r\n  Widget build(BuildContext context) => buildWithChild(context, _child);\r\n\r\n  @override\r\n  SingleChildStatelessElement createElement() {\r\n    return SingleChildStatelessElement(this);\r\n  }\r\n}\r\n```\r\n\r\n果不其然，它自己添加了`buildWithChild`，让继承自`StatelessWidget`的\r\n\r\n`build`方法直接调用了`buildWithChild`方法，\r\n\r\n这样它的子类通过实现`buildWithChild`方法达到间接实现`build`。\r\n\r\n所以我能在子类中不用`buildWithChild`这个方法，再次重写`build`吗?\r\n\r\n我劝你善良，类开头注释已经说了：\r\n\r\n`\/\/\/ Its [build] method must **not** be overriden. Instead use [buildWithChild].`\r\n\r\n\r\n\r\n既然系统调用`build`方法时调用了`buildWithChild`，\r\n\r\n那我们返回`InheritedProvider<T>`看看该方法实现：\r\n\r\n```dart\r\n  @override\r\n  Widget buildWithChild(BuildContext context, Widget child) {\r\n    return _DefaultInheritedProviderScope<T>(\r\n      owner: this,\r\n      child: child,\r\n    );\r\n  }\r\n```\r\n\r\n这里的widget返回的是`_DefaultInheritedProviderScope<T>`类型。\r\n\r\n重要的一点`owner`参数中，传了`this`，`InheritedProvider<T>`把自己搭进去了。\r\n\r\n所以通过`InheritedProvider<T>`实例，间接拿到`_delegate`属性，进而取得我的数据。。\r\n\r\n想想就开心，因为很可能找对了路子。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n进去`_DefaultInheritedProviderScope<T>`类看看：\r\n\r\n```dart\r\nclass _DefaultInheritedProviderScope<T> extends InheritedWidget {\r\n  _DefaultInheritedProviderScope({\r\n    this.owner,\r\n    @required Widget child,\r\n  }) : super(child: child);\r\n\r\n  final InheritedProvider<T> owner;\r\n\r\n  @override\r\n  bool updateShouldNotify(InheritedWidget oldWidget) {\r\n    return false;\r\n  }\r\n\r\n  @override\r\n  _DefaultInheritedProviderScopeElement<T> createElement() {\r\n    return _DefaultInheritedProviderScopeElement<T>(this);\r\n  }\r\n}\r\n```\r\n\r\n这个类没有什么逻辑，甚至作为`Widget`，都没有`build`方法。\r\n\r\n然后查看了下`Widget`源码，原来还真没有，\r\n\r\n**`build`方法是在子类`StatelessWidget`、`StatefullWidget`中添加的。**\r\n\r\n那重点就放在了`createElement`。\r\n\r\n因为这个返回值`_DefaultInheritedProviderScopeElement<T>(this)`里面传递了\r\n\r\n`_DefaultInheritedProviderScope<T>`实例，\r\n\r\n通过该实例能得到属性`owner`，而`owner`是`InheritedProvider<T>`实例，\r\n\r\n通过`InheritedProvider<T>`进一步拿到`_delegate`。\r\n\r\n路径我们找到了\r\n\r\n**但是`createElement`什么时候调用呢？**\r\n\r\n### runapp启动粗略分析\r\n\r\n这个问题先弄清楚才好往下看，不骗你，真的。\r\n\r\n不知道该怎么进行的时候就从`runApp`开始试试：\r\n\r\n```dart\r\nvoid runApp(Widget app) {\r\n  WidgetsFlutterBinding.ensureInitialized()\r\n    ..scheduleAttachRootWidget(app)\r\n    ..scheduleWarmUpFrame();\r\n}\r\n```\r\n\r\n我们只看处理`Widget app`地方，进去`scheduleAttachRootWidget`看看：\r\n\r\n```dart\r\n  @protected\r\n  void scheduleAttachRootWidget(Widget rootWidget) {\r\n    Timer.run(() {\r\n      attachRootWidget(rootWidget);\r\n    });\r\n  \r\n```\r\n\r\n`attachRootWidget`看名字是把rootWidget添加到控件树，继续进去：\r\n\r\n```dart\r\n  void attachRootWidget(Widget rootWidget) {\r\n    _renderViewElement = RenderObjectToWidgetAdapter<RenderBox>(\r\n      container: renderView,\r\n      debugShortDescription: '[root]',\r\n      child: rootWidget,\r\n    ).attachToRenderTree(buildOwner, renderViewElement);\r\n  }\r\n```\r\n\r\n上面`RenderObjectToWidgetAdapter<RenderBox>`包裹了`rootWidget`后，调用渲染树：\r\n\r\n```dart\r\n  \/\/\/ Used by [runApp] to bootstrap applications.\r\n  RenderObjectToWidgetElement<T> attachToRenderTree(BuildOwner owner, [ RenderObjectToWidgetElement<T> element ]) {\r\n    if (element == null) {\r\n      owner.lockState(() {\r\n        element = createElement();\r\n        assert(element != null);\r\n        element.assignOwner(owner);\r\n      });\r\n      owner.buildScope(element, () {\r\n        element.mount(null, null);\r\n      });\r\n      \/\/ This is most likely the first time the framework is ready to produce\r\n      \/\/ a frame. Ensure that we are asked for one.\r\n      SchedulerBinding.instance.ensureVisualUpdate();\r\n    } else {\r\n      element._newWidget = this;\r\n      element.markNeedsBuild();\r\n    }\r\n    return element;\r\n  }\r\n```\r\n\r\n首次初始化时，`element`为空，所以会调用`createElement()`。\r\n\r\n然后后面紧跟着执行` owner.buildScope`,\r\n\r\n调用`element.mount(null, null);`：\r\n\r\n```dart\r\n @override\r\n  void mount(Element parent, dynamic newSlot) {\r\n    assert(parent == null);\r\n    super.mount(parent, newSlot);\r\n    _rebuild();\r\n  }\r\n```\r\n\r\n这里的`super.mount`函数会一直调用到`Element`的`mount`。\r\n\r\n这里的`rebuild`开始执行控件树构建：\r\n\r\n```dart\r\n  void _rebuild() {\r\n    try {\r\n        \/\/这里的widget是RenderObjectToWidgetAdapter<RenderBox>\r\n      _child = updateChild(_child, widget.child, _rootChildSlot);\r\n      assert(_child != null);\r\n    } catch (exception, stack) {\r\n      final FlutterErrorDetails details = FlutterErrorDetails(\r\n        exception: exception,\r\n        stack: stack,\r\n        library: 'widgets library',\r\n        context: ErrorDescription('attaching to the render tree'),\r\n      );\r\n      FlutterError.reportError(details);\r\n      final Widget error = ErrorWidget.builder(details);\r\n      _child = updateChild(null, error, _rootChildSlot);\r\n    }\r\n  }\r\n```\r\n\r\n继续看`updateChild(_child, widget.child, _rootChildSlot)`：\r\n\r\n```dart\r\n  @protected\r\n  Element updateChild(Element child, Widget newWidget, dynamic newSlot) {\r\n    assert(() {\r\n      if (newWidget != null && newWidget.key is GlobalKey) {\r\n        final GlobalKey key = newWidget.key;\r\n        key._debugReserveFor(this);\r\n      }\r\n      return true;\r\n    }());\r\n    if (newWidget == null) {\r\n      if (child != null)\r\n        deactivateChild(child);\r\n      return null;\r\n    }\r\n    if (child != null) {\r\n      if (child.widget == newWidget) {\r\n        if (child.slot != newSlot)\r\n          updateSlotForChild(child, newSlot);\r\n        return child;\r\n      }\r\n      if (Widget.canUpdate(child.widget, newWidget)) {\r\n        if (child.slot != newSlot)\r\n          updateSlotForChild(child, newSlot);\r\n        child.update(newWidget);\r\n        assert(child.widget == newWidget);\r\n        assert(() {\r\n          child.owner._debugElementWasRebuilt(child);\r\n          return true;\r\n        }());\r\n        return child;\r\n      }\r\n      deactivateChild(child);\r\n      assert(child._parent == null);\r\n    }\r\n      \/\/类似于Android中的View.inflate\r\n    return inflateWidget(newWidget, newSlot);\r\n  }\r\n```\r\n\r\n这方法中只看最后`inflateWidget(newWidget, newSlot);`，\r\n\r\n这里类似于`View.inflate`，\r\n\r\n不过`View.inflate`是把xml控件转成`View Tree`，\r\n\r\n而这里是把`widget`转成`Element`。\r\n\r\n看看`inflateWidget`实现：\r\n\r\n```dart\r\n  @protected\r\n  Element inflateWidget(Widget newWidget, dynamic newSlot) {\r\n    assert(newWidget != null);\r\n    final Key key = newWidget.key;\r\n    if (key is GlobalKey) {\r\n      final Element newChild = _retakeInactiveElement(key, newWidget);\r\n      if (newChild != null) {\r\n        assert(newChild._parent == null);\r\n        assert(() {\r\n          _debugCheckForCycles(newChild);\r\n          return true;\r\n        }());\r\n        newChild._activateWithParent(this, newSlot);\r\n        final Element updatedChild = updateChild(newChild, newWidget, newSlot);\r\n        assert(newChild == updatedChild);\r\n        return updatedChild;\r\n      }\r\n    }\r\n      \/\/调用了widget的createElement方法。\r\n      \/\/newWidget是myApp\r\n    final Element newChild = newWidget.createElement();\r\n    assert(() {\r\n      _debugCheckForCycles(newChild);\r\n      return true;\r\n    }());\r\n    newChild.mount(this, newSlot);\r\n    assert(newChild._debugLifecycleState == _ElementLifecycle.active);\r\n    return newChild;\r\n  }\r\n```\r\n\r\n看这一行`Element newChild = newWidget.createElement();`,\r\n\r\n由于`newWidget`是`myapp`实例，\r\n\r\n也就是`StatelessWidget`，而它创建了`StatelessElement`。\r\n\r\n所以下面的`newChild.mount(this, newSlot);`\r\n\r\n其实调用的是`StatelessElement`的`mount`函数，\r\n\r\n但是`StatelessElement`没有重写该函数，\r\n\r\n所以调用了其父类`ComponentElement`的`mount`函数：\r\n\r\n```dart\r\n  @override\r\n  void mount(Element parent, dynamic newSlot) {\r\n    super.mount(parent, newSlot);\r\n    assert(_child == null);\r\n    assert(_active);\r\n    _firstBuild();\r\n    assert(_child != null);\r\n  }\r\n```\r\n\r\n该函数中调用了`_firstBuild`:\r\n\r\n```dart\r\n  void _firstBuild() {\r\n    rebuild();\r\n  }\r\n  \r\n    void rebuild() {\r\n   \/\/***省略断言      \r\n    performRebuild();\r\n    assert(() {\r\n      assert(owner._debugCurrentBuildTarget == this);\r\n      owner._debugCurrentBuildTarget = debugPreviousBuildTarget;\r\n      return true;\r\n    }());\r\n    assert(!_dirty);\r\n  }\r\n```\r\n\r\n在`rebuild`中调用了`performRebuild`：\r\n\r\n```dart\r\n  @override\r\n  void performRebuild() {\r\n    if (!kReleaseMode && debugProfileBuildsEnabled)\r\n      Timeline.startSync('${widget.runtimeType}',  arguments: timelineWhitelistArguments);\r\n\r\n    assert(_debugSetAllowIgnoredCallsToMarkNeedsBuild(true));\r\n    Widget built;\r\n    try {\r\n       \/\/调用当前widget.build\r\n        \/\/比如statelesswidget.build,\r\n      built = build();\r\n      debugWidgetBuilderValue(widget, built);\r\n    } catch (e, stack) {\r\n      built = ErrorWidget.builder(\r\n        _debugReportException(\r\n          ErrorDescription('building $this'),\r\n          e,\r\n          stack,\r\n          informationCollector: () sync* {\r\n            yield DiagnosticsDebugCreator(DebugCreator(this));\r\n          },\r\n        ),\r\n      );\r\n    } finally {\r\n      \/\/ We delay marking the element as clean until after calling build() so\r\n      \/\/ that attempts to markNeedsBuild() during build() will be ignored.\r\n      _dirty = false;\r\n      assert(_debugSetAllowIgnoredCallsToMarkNeedsBuild(false));\r\n    }\r\n    try {\r\n        \/\/向下遍历\r\n      _child = updateChild(_child, built, slot);\r\n      assert(_child != null);\r\n    } catch (e, stack) {\r\n      built = ErrorWidget.builder(\r\n        _debugReportException(\r\n          ErrorDescription('building $this'),\r\n          e,\r\n          stack,\r\n          informationCollector: () sync* {\r\n            yield DiagnosticsDebugCreator(DebugCreator(this));\r\n          },\r\n        ),\r\n      );\r\n      _child = updateChild(null, built, slot);\r\n    }\r\n\r\n    if (!kReleaseMode && debugProfileBuildsEnabled)\r\n      Timeline.finishSync();\r\n  }\r\n```\r\n\r\n可以看到这里调用了`build`方法。\r\n\r\n目前这是在`myapp`的`StatelessWidget`实例中调用`build`方法，\r\n\r\n这样目前完成了一个很粗糙的`widget.build`调用。\r\n\r\n那`myapp`中的很多其他`widget`怎么办呢?\r\n\r\n当然通过`_child = updateChild(_child, built, slot)`继续遍历执行啊。\r\n\r\n不过这里的`built`是我们配置的`MultiProvider`了。\r\n\r\n总结一下执行步骤：\r\n\r\n1、`scheduleAttachRootWidget`\r\n\r\n2、`RenderObjectToWidgetAdapter<RenderBox>.attachToRenderTree()`\r\n\r\n3、`RenderObjectToWidgetElement<T>.mount(null, null)`\r\n\r\n4、`RenderObjectToWidgetElement<T>._rebuild()`\r\n\r\n5、`Element.updateChild(Element child, Widget newWidget, dynamic newSlot)`\r\n\r\n6、`Element.inflateWidget(Widget newWidget, dynamic newSlot)`\r\n\r\n7、`newWidget.createElement()`\r\n\r\n8、`newChild.mount(this, newSlot)`\r\n\r\n9、`ComponentElement.mount(Element parent, dynamic newSlot)`\r\n\r\n10、`ComponentElement._firstBuild()`\r\n\r\n11、`Element.rebuild()`\r\n\r\n12、`ComponentElement.performRebuild()`\r\n\r\n13、`Widget build()`\r\n\r\n**这里的`build`是`ComponentElement`调用`performRebuild`方法时，该方法里面调用的`build`，**\r\n\r\n**所以这里的`build`方法其实是`ComponentElement`定义的一个抽象方法，**\r\n\r\n**该抽象方法，在`StatefulElement`被实现为`state.build(this)`，**\r\n\r\n**在`StatelessElement`被实现为`widget.build(this)`。**\r\n\r\n**而我们只是实现这块的`build`内容返回`widget`。**\r\n\r\n**可见`widget`只是`Element`配置文件，`widget`很多方法调用受`Element`控制。**\r\n\r\n14、从新执行步骤5的`updateChild`，进行子控件遍历。\r\n\r\n了解了这些，我们继续往下看。\r\n\r\n上面我们讲到这里：\r\n\r\n```dart\r\n  @override\r\n  _DefaultInheritedProviderScopeElement<T> createElement() {\r\n    return _DefaultInheritedProviderScopeElement<T>(this);\r\n  }\r\n```\r\n\r\n然后就不知道`createElement`如何调用了。\r\n\r\n从上面步骤7可以知道：\r\n\r\n当我们在`inflate`  widget `_DefaultInheritedProviderScope<T>`时，\r\n\r\n用该实例调用`createElement`，\r\n\r\n然后创建并返回了`_DefaultInheritedProviderScopeElement<T>`实例`newChild`,\r\n\r\n然后步骤8，通过步骤7创建的`newChild`调用`mount`函数，\r\n\r\n`_DefaultInheritedProviderScopeElement<T>`本身没有实现`mount`，\r\n\r\n但是通过混入方式继承了`_InheritedProviderScopeMixin<T>`。\r\n\r\n这里有实现`mount`：\r\n\r\n```dart\r\n  @override\r\n  void mount(Element parent, dynamic newSlot) {\r\n    _providerCount++;\r\n    if (_providerCount == 1) {\r\n      _startWatchingScheduler();\r\n    }\r\n    super.mount(parent, newSlot);\r\n  }\r\n```\r\n\r\n通过`super.mount`，进入了`ComponentElement`的`mount`实现：\r\n\r\n```dart\r\n  @override\r\n  void mount(Element parent, dynamic newSlot) {\r\n    super.mount(parent, newSlot);\r\n    assert(_child == null);\r\n    assert(_active);\r\n    _firstBuild();\r\n    assert(_child != null);\r\n  }\r\n```\r\n\r\n再次通过`super.mount`，进入`Element`的`mount`基类实现：\r\n\r\n```dart\r\n  @mustCallSuper\r\n  void mount(Element parent, dynamic newSlot) {\r\n    _parent = parent;\r\n    _slot = newSlot;\r\n    _depth = _parent != null ? _parent.depth + 1 : 1;\r\n    _active = true;\r\n    if (parent != null) \/\/ Only assign ownership if the parent is non-null\r\n      _owner = parent.owner;\r\n    if (widget.key is GlobalKey) {\r\n      final GlobalKey key = widget.key;\r\n      key._register(this);\r\n    }\r\n    _updateInheritance();\r\n    assert(() {\r\n      _debugLifecycleState = _ElementLifecycle.active;\r\n      return true;\r\n    }());\r\n  }\r\n```\r\n\r\n看下`_updateInheritance()`实现：\r\n\r\n```dart\r\n  void _updateInheritance() {\r\n    assert(_active);\r\n    _inheritedWidgets = _parent?._inheritedWidgets;\r\n  }\r\n```\r\n\r\n**`_updateInheritance`这个方法其实是保存并下发你的全局数据的方法。**\r\n\r\n该方法具体实现在`ComponentElement`中：\r\n\r\n```dart\r\n  @override\r\n  void _updateInheritance() {\r\n    assert(_active);\r\n    final Map<Type, InheritedElement> incomingWidgets = _parent?._inheritedWidgets;\r\n    if (incomingWidgets != null)\r\n      _inheritedWidgets = HashMap<Type, InheritedElement>.from(incomingWidgets);\r\n    else\r\n      _inheritedWidgets = HashMap<Type, InheritedElement>();\r\n    _inheritedWidgets[widget.runtimeType] = this;\r\n  }\r\n```\r\n\r\n这里首先判断父`Element`的`_inheritedWidgets`是否有值，\r\n\r\n如果有值则根据既有值转化一个新的的`_inheritedWidgets`，\r\n\r\n如果没有值则创建一个新的空的`_inheritedWidgets`。\r\n\r\n最后保存当前值：` _inheritedWidgets[widget.runtimeType] = this;`\r\n\r\n这个操作发生在`Element`子类``_DefaultInheritedProviderScopeElement<T>`中。\r\n\r\n这里的保存当前值是指：\r\n\r\n`_DefaultInheritedProviderScope<T>`的`rumtimeType`作为`key`，\r\n\r\n`_DefaultInheritedProviderScopeElement<T>`实例作为`value`。\r\n\r\n看下截图：\r\n\r\n![image-20200118164531001](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200118164531001.png)\r\n\r\n\r\n\r\n你可能有疑问，因为这并不是我开始的`UserBean`。\r\n\r\n别慌，其实通过`_DefaultInheritedProviderScopeElement<T>`就能拿到你的数据。\r\n\r\n在取出流程中将会看到具体操作。\r\n\r\n\r\n\r\n## data取出流程\r\n\r\n看完了存储流程，下面来看看如何取出数据的。\r\n\r\n由于平时使用`Provider.of<UserBean>(context)`这种操作比较多，\r\n\r\n所以从这里的源码作为入口：\r\n\r\n```dart\r\n  static T of<T>(BuildContext context, {bool listen}) {\r\n    assert(\r\n      T != dynamic,\r\n      '''\r\nTried to call Provider.of<dynamic>. This is likely a mistake and is therefore\r\nunsupported.\r\n\r\nIf you want to expose a variable that can be anything, consider changing\r\n`dynamic` to `Object` instead.\r\n''',\r\n    );\r\n    assert(!(listen == true && !isWidgetTreeBuilding), '''\r\nTried to listen to a value exposed with provider, from outside of the widget tree.\r\n''');\r\n\r\n    InheritedContext<T> inheritedElement;\r\n\r\n    if (context.widget is _DefaultInheritedProviderScope<T>) {\r\n      \/\/ An InheritedProvider<T>'s update tries to obtain a parent provider of\r\n      \/\/ the same type.\r\n      context.visitAncestorElements((parent) {\r\n        inheritedElement = parent.getElementForInheritedWidgetOfExactType<_DefaultInheritedProviderScope<T>>()\r\n            as _DefaultInheritedProviderScopeElement<T>;\r\n        return false;\r\n      });\r\n    } else {\r\n      inheritedElement = context.getElementForInheritedWidgetOfExactType<_DefaultInheritedProviderScope<T>>()\r\n          as _DefaultInheritedProviderScopeElement<T>;\r\n    }\r\n\r\n    if (inheritedElement == null) {\r\n      throw ProviderNotFoundException(T, context.widget.runtimeType);\r\n    }\r\n\r\n    if (listen ?? isWidgetTreeBuilding) {\r\n      context.dependOnInheritedElement(inheritedElement as InheritedElement);\r\n    }\r\n\r\n    return inheritedElement.value;\r\n  }\r\n\r\n```\r\n\r\n参数的`context`一般就是我们使用`Provider.of<UserBean>`时，所在的widget对应的`Element`。\r\n\r\n```dart\r\nBuildContext get context => _element\r\n```\r\n\r\n这个一般不会是`_DefaultInheritedProviderScope<T>`。\r\n\r\n所以会通过 `else`方法来取值。\r\n\r\n看看`Element`中该方法实现：\r\n\r\n```dart\r\n  @override\r\n  InheritedElement getElementForInheritedWidgetOfExactType<T extends InheritedWidget>() {\r\n    assert(_debugCheckStateIsActiveForAncestorLookup());\r\n    final InheritedElement ancestor = _inheritedWidgets == null ? null : _inheritedWidgets[T];\r\n    return ancestor;\r\n  }\r\n```\r\n\r\n这里直接使用泛型`T`作为key了，\r\n\r\n而调用该方法地方的`T`指的是`_DefaultInheritedProviderScope<T>`，\r\n\r\n在使用时，我们又指定了`<UserBean>`。\r\n\r\n所以实际通过`_inheritedWidgets[_DefaultInheritedProviderScope<UserBean>]`来取值。\r\n\r\n想当然的能取到值了。\r\n\r\n取出`InheritedElement`值 使用`as`转成`_DefaultInheritedProviderScopeElement<T>`。\r\n\r\n最后直接通过`inheritedElement.value`来取值了。\r\n\r\n所以这算完事了吗？\r\n\r\n其实这才刚开始。\r\n\r\n刚才使用的`inheritedElement`是`InheritedContext<T>`类型。\r\n\r\n看下它的`value`：\r\n\r\n```dart\r\nT get value;\r\n```\r\n\r\n这是一个抽象的。\r\n\r\n它的实现在`_InheritedProviderScopeMixin<T>`类中：\r\n\r\n```dart\r\n  @override\r\n  T get value => _delegateState.value;\r\n```\r\n\r\n这个类又是`mixin`类型的，意思是只能其他类通过`with`方式实现？\r\n\r\n没关系先不管了，只要知道`_DefaultInheritedProviderScopeElement<T>` with 它就行了。\r\n\r\n这个类在上面有接触过。\r\n\r\n上面的`_delegateState.value` 中`_delegateState`其实就是\r\n\r\n`_DefaultInheritedProviderScopeElement<T>` 的属性：\r\n\r\n```dart\r\n@override\r\n_DelegateState<T, _Delegate<T>> _delegateState;\r\n```\r\n\r\n这个属性在`_mountDelegate`调用时才进行赋值的：\r\n\r\n```dart\r\n  @override\r\n  void _mountDelegate() {\r\n    _delegateState = widget.owner._delegate.createState()..element = this;\r\n  }\r\n```\r\n\r\n什么时候又会调用该方法呢？\r\n\r\n这是一个重写方法，抽象方法在那个`_InheritedProviderScopeMixin<T>`方法中：\r\n\r\n```dart\r\nmixin _InheritedProviderScopeMixin<T> on InheritedElement implements InheritedContext<T> {\r\n  void _mountDelegate();\r\n  \r\n  @override\r\n  void performRebuild() {\r\n    if (_firstBuild) {\r\n      _firstBuild = false;\r\n      _mountDelegate();\r\n    }\r\n    super.performRebuild();\r\n  }\r\n}\r\n```\r\n\r\n顺便看到了该方法是在`performRebuild()`中调用。\r\n\r\n只有首次构建时候调用一次。\r\n\r\n这里的`performRebuild`相当于上面步骤12、`ComponentElement.performRebuild()`。\r\n\r\n经过上面步骤完成了`_delegateState`的赋值。\r\n\r\n下面看下`_delegateState.value`的获取：\r\n\r\n```dart\r\nclass _CreateInheritedProviderState<T> extends _DelegateState<T, _CreateInheritedProvider<T>> {\r\n  T _value;\r\n\r\n  @override\r\n  T get value {\r\n      \/\/首次执行时_didInitValue=false,所以进入执行\r\n    if (!_didInitValue) {\r\n      _didInitValue = true;\r\n      if (delegate.create != null) {\r\n        assert(debugSetInheritedLock(true));\r\n        _value = delegate.create(element);\r\n        assert(debugSetInheritedLock(false));\r\n\r\n        assert(() {\r\n          delegate.debugCheckInvalidValueType?.call(_value);\r\n          return true;\r\n        }());\r\n      }\r\n      if (delegate.update != null) {\r\n        _value = delegate.update(element, _value);\r\n\r\n        assert(() {\r\n          delegate.debugCheckInvalidValueType?.call(_value);\r\n          return true;\r\n        }());\r\n      }\r\n    }\r\n\r\n    element._isNotifyDependentsEnabled = false;\r\n    _removeListener ??= delegate.startListening?.call(element, _value);\r\n    element._isNotifyDependentsEnabled = true;\r\n    assert(delegate.startListening == null || _removeListener != null);\r\n    return _value;\r\n  }\r\n\r\n}\r\n```\r\n\r\n可以看到`_CreateInheritedProviderState<T>`提供了存储值的最终地方`T _value`。\r\n\r\n同时提供了获取值方法`T get value`。\r\n\r\n首次进入时`_didInitValue=false`，\r\n\r\n所以必定执行`if`语句块，\r\n\r\n至于`delegate.create`我们早就设置过了，不会为空。\r\n\r\n所以会执行`delegate.create(element)`返回值赋给`_value`并返回。\r\n\r\n如果不是第一次获取值了，则不再执行`if`语句块，\r\n\r\n而是直接返回内容。\r\n\r\n通过这里我们知道了 `_value`只有首次调用时才会执行`create`函数予以返回。\r\n\r\n现在明白了为什么这块很多名字都叫`delegate`了。\r\n\r\n这块是延迟加载机制实现的。\r\n\r\n\r\n\r\n至此，数据取出流程分析完了。\r\n\r\n\r\n\r\n## data刷新流程\r\n\r\n分析完了数据存储和取出流程，\r\n\r\n下面该分析数据更新时为什么会自动刷新Widget了。\r\n\r\n这里从`UserBean`的`notifyListeners`看起：\r\n\r\n```dart\r\n  @protected\r\n  @visibleForTesting\r\n  void notifyListeners() {\r\n    assert(_debugAssertNotDisposed());\r\n    if (_listeners != null) {\r\n      final List<VoidCallback> localListeners = List<VoidCallback>.from(_listeners);\r\n      for (VoidCallback listener in localListeners) {\r\n        try {\r\n          if (_listeners.contains(listener))\r\n            listener();\r\n        } catch (exception, stack) {\r\n          FlutterError.reportError(FlutterErrorDetails(\r\n            exception: exception,\r\n            stack: stack,\r\n            library: 'foundation library',\r\n            context: ErrorDescription('while dispatching notifications for $runtimeType'),\r\n            informationCollector: () sync* {\r\n              yield DiagnosticsProperty<ChangeNotifier>(\r\n                'The $runtimeType sending notification was',\r\n                this,\r\n                style: DiagnosticsTreeStyle.errorProperty,\r\n              );\r\n            },\r\n          ));\r\n        }\r\n      }\r\n    }\r\n  }\r\n```\r\n\r\n这里知识遍历了`localListeners`并进行了函数调用。\r\n\r\n`localListeners`里面保存的就是函数类型`VoidCallback`。\r\n\r\n现在陷入死胡同了，因为这里只有调用，不知道什么时候添加的监听。。\r\n\r\n**回头想想，之所以调用监听，**\r\n\r\n**是因为数据刷新了，我需要使用该数据的控件即时知道。**\r\n\r\n**所以监听应该在使用该数据的地方。**\r\n\r\n不过这里还是从配置数据开始看一下。\r\n\r\n说到配置数据又要回去看`ChangeNotifierProvider<T extends ChangeNotifier>`了，\r\n\r\n不过里面没有找到相关调用，\r\n\r\n进去父类`ListenableProvider<T extends Listenable>`:\r\n\r\n```dart\r\nclass ListenableProvider<T extends Listenable> extends InheritedProvider<T> {\r\n  \/\/\/ Creates a [Listenable] using [create] and subscribes to it.\r\n  \/\/\/\r\n  \/\/\/ [dispose] can optionally passed to free resources\r\n  \/\/\/ when [ListenableProvider] is removed from the tree.\r\n  \/\/\/\r\n  \/\/\/ [create] must not be `null`.\r\n  ListenableProvider({\r\n    Key key,\r\n    @required Create<T> create,\r\n    Dispose<T> dispose,\r\n    bool lazy,\r\n    Widget child,\r\n  })  : assert(create != null),\r\n        super(\r\n          key: key,\r\n          startListening: _startListening,\r\n          create: create,\r\n          dispose: dispose,\r\n          debugCheckInvalidValueType: kReleaseMode\r\n              ? null\r\n              : (value) {\r\n                  if (value is ChangeNotifier) {\r\n                    \/\/ ignore: invalid_use_of_protected_member\r\n                    assert(!value.hasListeners, '''\r\nThe default constructor of ListenableProvider\/ChangeNotifierProvider\r\nmust create a new, unused Listenable.\r\n\r\nIf you want to reuse an existing Listenable, use the second constructor:\r\n\r\n- DO use ChangeNotifierProvider.value to provider an existing ChangeNotifier:\r\n\r\nMyChangeNotifier variable;\r\nChangeNotifierProvider.value(\r\n  value: variable,\r\n  child: ...\r\n)\r\n\r\n- DON'T reuse an existing ChangeNotifier using the default constructor.\r\n\r\nMyChangeNotifier variable;\r\nChangeNotifierProvider(\r\n  create: (_) => variable,\r\n  child: ...\r\n)\r\n''');\r\n                  }\r\n                },\r\n          lazy: lazy,\r\n          child: child,\r\n        );\r\n\r\n  \/\/\/ Provides an existing [Listenable].\r\n  ListenableProvider.value({\r\n    Key key,\r\n    @required T value,\r\n    UpdateShouldNotify<T> updateShouldNotify,\r\n    Widget child,\r\n  }) : super.value(\r\n          key: key,\r\n          value: value,\r\n          updateShouldNotify: updateShouldNotify,\r\n          startListening: _startListening,\r\n          child: child,\r\n        );\r\n\r\n}\r\n```\r\n\r\n上面有个`_startListening`静态函数，\r\n\r\n函数中调用了` value?.addListener(e.markNeedsNotifyDependents);`\r\n\r\n这里有可能就是添加数据监听器地方。\r\n\r\n但是`_startListening`没有在该类直接调用，\r\n\r\n而是传递给了父类，点进去看看：\r\n\r\n```dart\r\n  InheritedProvider({\r\n    Key key,\r\n    Create<T> create,\r\n    T update(BuildContext context, T value),\r\n    UpdateShouldNotify<T> updateShouldNotify,\r\n    void Function(T value) debugCheckInvalidValueType,\r\n    StartListening<T> startListening,\r\n    Dispose<T> dispose,\r\n    bool lazy,\r\n    Widget child,\r\n  })  : _lazy = lazy,\r\n        _delegate = _CreateInheritedProvider(\r\n          create: create,\r\n          update: update,\r\n          updateShouldNotify: updateShouldNotify,\r\n          debugCheckInvalidValueType: debugCheckInvalidValueType,\r\n          startListening: startListening,\r\n          dispose: dispose,\r\n        ),\r\n        super(key: key, child: child)\r\n```\r\n\r\n传递过来的`startListening`被包裹到了`_CreateInheritedProvider`：\r\n\r\n```dart\r\nclass _CreateInheritedProvider<T> extends _Delegate<T> {\r\n  _CreateInheritedProvider({\r\n    this.create,\r\n    this.update,\r\n    UpdateShouldNotify<T> updateShouldNotify,\r\n    this.debugCheckInvalidValueType,\r\n    this.startListening,\r\n    this.dispose,\r\n  })  : assert(create != null || update != null),\r\n        _updateShouldNotify = updateShouldNotify;\r\n\r\n  final Create<T> create;\r\n  final T Function(BuildContext context, T value) update;\r\n  final UpdateShouldNotify<T> _updateShouldNotify;\r\n  final void Function(T value) debugCheckInvalidValueType;\r\n  final StartListening<T> startListening;\r\n  final Dispose<T> dispose;\r\n\r\n  @override\r\n  _CreateInheritedProviderState<T> createState() => _CreateInheritedProviderState();\r\n}\r\n```\r\n\r\n这里虽然赋值给属性`startListening`，但是没有调用地方。\r\n\r\n进去`_CreateInheritedProviderState`看看：\r\n\r\n```dart\r\n  T _value;\r\n  _CreateInheritedProvider<T> _previousWidget;\r\n\r\n  @override\r\n  T get value {\r\n    if (!_didInitValue) {\r\n      _didInitValue = true;\r\n      if (delegate.create != null) {\r\n        assert(debugSetInheritedLock(true));\r\n        _value = delegate.create(element);\r\n        assert(debugSetInheritedLock(false));\r\n\r\n        assert(() {\r\n          delegate.debugCheckInvalidValueType?.call(_value);\r\n          return true;\r\n        }());\r\n      }\r\n      if (delegate.update != null) {\r\n        _value = delegate.update(element, _value);\r\n\r\n        assert(() {\r\n          delegate.debugCheckInvalidValueType?.call(_value);\r\n          return true;\r\n        }());\r\n      }\r\n    }\r\n\r\n    element._isNotifyDependentsEnabled = false;\r\n    _removeListener ??= delegate.startListening?.call(element, _value);\r\n    element._isNotifyDependentsEnabled = true;\r\n    assert(delegate.startListening == null || _removeListener != null);\r\n    return _value;\r\n  }\r\n```\r\n\r\n在`_CreateInheritedProviderState`类中发现\r\n\r\n在获取数据`value`的`get`方法中调用了`delegate.startListening?.call(element, _value);`。\r\n\r\n`call`函数第二个参数就是我们全局管理的数据。\r\n\r\n而在静态的`startListening`函数中，第二个参数`Listenable value`：\r\n\r\n```dart\r\n  static VoidCallback _startListening(\r\n    InheritedContext<Listenable> e,\r\n    Listenable value,\r\n  ) {\r\n    value?.addListener(e.markNeedsNotifyDependents);\r\n    return () => value?.removeListener(e.markNeedsNotifyDependents);\r\n  }\r\n```\r\n\r\n**看下这行代码`value?.addListener(e.markNeedsNotifyDependents);`。**\r\n\r\n**相当于调用了`userBean?.addListener`。**\r\n\r\n**所以每个使用全局数据的地方都会为其添加一个监听**\r\n\r\n那么`e.markNeedsNotifyDependents`是什么呢？\r\n\r\n这个`e`是`_InheritedProviderScopeMixin<T>`。\r\n\r\n`markNeedsNotifyDependents`方法为：\r\n\r\n```dart\r\n  @override\r\n  void markNeedsNotifyDependents() {\r\n    if (!_isNotifyDependentsEnabled) return;\r\n\r\n    markNeedsBuild();\r\n    _shouldNotifyDependents = true;\r\n  }\r\n```\r\n\r\n**这里把`_shouldNotifyDependents`设置为true。**\r\n\r\n**表示我这个全局数据更新了，应该通知所有依赖它的widget**\r\n\r\n\r\n\r\n这里调用了`markNeedsBuild`，表示自己要重建，\r\n\r\n```dart\r\n  void markNeedsBuild() {\r\n    assert(_debugLifecycleState != _ElementLifecycle.defunct);\r\n    if (!_active)\r\n      return;\r\n      \/\/去掉大部分断言\r\n    if (dirty)\r\n      return;\r\n    _dirty = true;\r\n    owner.scheduleBuildFor(this);\r\n  }\r\n```\r\n\r\n该方法中标记`dirty=true`表示需要重建。这样绘制下一帧时重建该widget。\r\n\r\n然后调用`scheduleBuildFor`，\r\n\r\n```dart\r\n  void scheduleBuildFor(Element element) {\r\n    if (element._inDirtyList) {\r\n      _dirtyElementsNeedsResorting = true;\r\n      return;\r\n    }\r\n    if (!_scheduledFlushDirtyElements && onBuildScheduled != null) {\r\n      _scheduledFlushDirtyElements = true;\r\n      onBuildScheduled();\r\n    }\r\n    _dirtyElements.add(element);\r\n    element._inDirtyList = true;\r\n    assert(() {\r\n      if (debugPrintScheduleBuildForStacks)\r\n        debugPrint('...dirty list is now: $_dirtyElements');\r\n      return true;\r\n    }());\r\n  }\r\n```\r\n\r\n这是计划重建，重建前把标记为`dirty`的`element`加入到`_dirtyElements`。\r\n\r\n还调用了`onBuildScheduled()`。\r\n\r\n这是一个函数类型属性`VoidCallback onBuildScheduled;`。\r\n\r\n它在`WidgetsBinding`调用`initInstances`时赋值：\r\n\r\n```dart\r\n  void initInstances() {\r\n    super.initInstances();\r\n    _instance = this;\r\n    \/\/ Initialization of [_buildOwner] has to be done after\r\n    \/\/ [super.initInstances] is called, as it requires [ServicesBinding] to\r\n    \/\/ properly setup the [defaultBinaryMessenger] instance.\r\n    _buildOwner = BuildOwner();\r\n      \/\/赋值\r\n    buildOwner.onBuildScheduled = _handleBuildScheduled;\r\n    window.onLocaleChanged = handleLocaleChanged;\r\n    window.onAccessibilityFeaturesChanged = handleAccessibilityFeaturesChanged;\r\n    SystemChannels.navigation.setMethodCallHandler(_handleNavigationInvocation);\r\n    FlutterErrorDetails.propertiesTransformers.add(transformDebugCreator);\r\n  }\r\n```\r\n\r\n所以`onBuildScheduled`指向的是`_handleBuildScheduled`：\r\n\r\n```dart\r\n  void _handleBuildScheduled() {\r\n    \/\/ If we're in the process of building dirty elements, then changes\r\n    \/\/ should not trigger a new frame.\r\n\r\n    ensureVisualUpdate();\r\n  }\r\n```\r\n\r\n在`ensureVisualUpdate`方法中调用了`scheduleFrame`。\r\n\r\n而`scheduleFrame`中调用了`window.scheduleFrame()`执行新一帧的刷新。\r\n\r\n\r\n\r\n上面`markNeedsBuild`是在`_DefaultInheritedProviderScopeElement<T>`中，\r\n\r\n如果重建，会调用旗下方法`build`：\r\n\r\n```dart\r\n  @override\r\n  Widget build() {\r\n    if (_isLazy(widget) == false) {\r\n      value; \/\/ this will force the value to be computed.\r\n    }\r\n    _delegateState.build();\r\n    if (_shouldNotifyDependents) {\r\n      _shouldNotifyDependents = false;\r\n      notifyClients(widget);\r\n    }\r\n    return super.build();\r\n  }\r\n```\r\n\r\n**可以看到如果`_shouldNotifyDependents`为true，**\r\n\r\n**会调用` notifyClients(widget)`。**\r\n\r\n**这里会通知使用该全局数据的控件：**\r\n\r\n```dart\r\n  @override\r\n  void notifyClients(InheritedWidget oldWidget) {\r\n    assert(_debugCheckOwnerBuildTargetExists('notifyClients'));\r\n    for (Element dependent in _dependents.keys) {\r\n      assert(() {\r\n        \/\/ check that it really is our descendant\r\n        Element ancestor = dependent._parent;\r\n        while (ancestor != this && ancestor != null)\r\n          ancestor = ancestor._parent;\r\n        return ancestor == this;\r\n      }());\r\n      \/\/ check that it really depends on us\r\n      assert(dependent._dependencies.contains(this));\r\n      notifyDependent(oldWidget, dependent);\r\n    }\r\n  }\r\n```\r\n\r\n看下`notifyDependent(oldWidget, dependent)`：\r\n\r\n```dart\r\n  @protected\r\n  void notifyDependent(covariant InheritedWidget oldWidget, Element dependent) {\r\n    dependent.didChangeDependencies();\r\n  }\r\n```\r\n\r\n看下这里调用了`dependent.didChangeDependencies();`。\r\n\r\n这个`dependent`就是你使用全局数据widget所对应的`Element`。\r\n\r\n看下该实现：\r\n\r\n```dart\r\n  @mustCallSuper\r\n  void didChangeDependencies() {\r\n    assert(_active); \/\/ otherwise markNeedsBuild is a no-op\r\n    assert(_debugCheckOwnerBuildTargetExists('didChangeDependencies'));\r\n    markNeedsBuild();\r\n  }\r\n```\r\n\r\n这里又调用了`markNeedsBuild`，上面介绍了这块设置`dirty`并准备下一帧刷新。\r\n\r\n这说明使用该数据的`widget`面临刷新，从而获取最新全局数据。\r\n\r\n\r\n\r\n至此完成了数据更新时即时刷新控件的流程分析。\r\n\r\n\r\n\r\n# 0x03 超精简全局状态管理实现\r\n\r\n## 创建保存\r\n\r\n在上面存储流程中我们了解到，\r\n\r\n实际存储数据的是`Map`类型，\r\n\r\n`key`为`Type`类型，但是一般使用`InheritedWidget`实现类的`runtimeType`作为key。\r\n\r\n`value`为`InheritedElement`类型，也就是你自定义的`InheritedWidget`所对应的`element`。\r\n\r\n绕不开的是需要自定义一个继承自`InheritedWidget`的类，为了便于扩展，使用了泛型：\r\n\r\n```dart\r\nclass JInherritedWidget<T> extends InheritedWidget {\r\n  final T data;\r\n\r\n  JInherritedWidget({this.data, Widget child}) : super(child: child);\r\n\r\n  @override\r\n  bool updateShouldNotify(JInherritedWidget oldWidget) {\r\n    return oldWidget.data != data;\r\n  }\r\n}\r\n\/\/顺便定义一个数据类People\r\nclass People {\r\n  String name;\r\n\r\n  People(this.name);\r\n}\r\n```\r\n\r\n这里我直接把`data`放到了widget中，\r\n\r\n通过阅读存储流程，应该了解到在构建`InheritedWidget`时候，\r\n\r\n系统自动调用了`_updateInheritance`执行了`JInherritedWidget`和`Element`存储。\r\n\r\n我们需要做的就是把它用到widget tree中。\r\n\r\n目前，我们完成了创建和保存工作。\r\n\r\n下面我们看看如何实现数据获取\r\n\r\n## 数据获取\r\n\r\n`BuildContext`为我们提供了获取`InheritedElement`以及`InheritedWidget`方法。\r\n\r\n通过`getElementForInheritedWidgetOfExactType`方法拿到保存在`Map`中的value值即`Element`。\r\n\r\n通过`dependOnInheritedElement`，使用`element`得到相应的`Widget`。\r\n\r\n拿到`InheritedWidget`转为我们自定义widget，随后即可拿到data：\r\n\r\n```dart\r\n  static T of<T>(BuildContext context) {\r\n    InheritedElement element =\r\n        context.getElementForInheritedWidgetOfExactType<JInherritedWidget<T>>();\r\n    return (element.dependOnInheritedElement(element) as JInherritedWidget<T>)\r\n        .data;\r\n  }\r\n```\r\n\r\n这就完成了数据的获取。\r\n\r\n目前还差数据更新，\r\n\r\n## 数据更新\r\n\r\n其实如果没有看源码的话，可能数据更新难度最大的部分\r\n\r\n（前提是没有给`JInherritedWidget`在包一层、使用Listenable情况下）。\r\n\r\n单纯的更新data值是很容易的：\r\n\r\n```dart\r\nJInherritedWidget.of<People>(context).name = \"jenson ,${i++}\";\r\n```\r\n\r\n但是我们把值更新了，管理该控件的`JInherritedWidget`不知道你更新了，\r\n\r\n使用该数据的控件也不知道你更新了。\r\n\r\n**Provider和网上很多例子都是用了`Listenable`，实现了`监听模式`。**\r\n\r\n**但是看过源码通过上面data刷新流程会了解到，**\r\n\r\n**系统为我们提供了`notifyClients`来通知使用该数据的控件，**\r\n\r\n**然后你也可以通过`markNeedsBuild`标记`JInherritedWidget`自身刷新。**\r\n\r\n**这里注意一点，通知其他控件要先于标记自身刷新，否则触发异常。**\r\n\r\n所以这里添加一个静态更新方法：\r\n\r\n```dart\r\n  static void update<T>(BuildContext context) {\r\n    InheritedElement element =\r\n        context.getElementForInheritedWidgetOfExactType<JInherritedWidget<T>>();\r\n    element.notifyClients(\r\n        (element.dependOnInheritedElement(element) as JInherritedWidget<T>));\r\n    element.markNeedsBuild();\r\n  }\r\n```\r\n\r\n所有代码只有一个类：\r\n\r\n```dart\r\nclass JInherritedWidget<T> extends InheritedWidget {\r\n  final T data;\r\n\r\n  JInherritedWidget({this.data, Widget child}) : super(child: child);\r\n\r\n  static T of<T>(BuildContext context) {\r\n    InheritedElement element =\r\n        context.getElementForInheritedWidgetOfExactType<JInherritedWidget<T>>();\r\n    return (element.dependOnInheritedElement(element) as JInherritedWidget<T>)\r\n        .data;\r\n  }\r\n\r\n  static void update<T>(BuildContext context) {\r\n    InheritedElement element =\r\n        context.getElementForInheritedWidgetOfExactType<JInherritedWidget<T>>();\r\n    element.notifyClients(\r\n        (element.dependOnInheritedElement(element) as JInherritedWidget<T>));\r\n    element.markNeedsBuild();\r\n  }\r\n\r\n  @override\r\n  bool updateShouldNotify(JInherritedWidget oldWidget) {\r\n    return oldWidget.data != data;\r\n  }\r\n}\r\n```\r\n\r\n\r\n\r\n点击刷新数据是代码：\r\n\r\n```dart\r\n          JInherritedWidget.of<People>(context).name = \"jenson ,${i++}\";\r\n          JInherritedWidget.update<People>(context);\r\n```\r\n\r\n使用代码：\r\n\r\n```dart\r\nchild: UserNameWidget(name: JInherritedWidget.of<People>(context).name)\r\n```\r\n\r\n效果如图：\r\n\r\n![image-20200119140606347](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200119140606347.png)"
  },
  {
    "title": "Android Studio创建Flutter项目卡住的解决办法",
    "created_time": "2020-02-16 08:31:10",
    "body": "# 0x00 前言\r\n\r\n最近这些天梯子不好用，导致使用Android Studio创建Flutter工程时一直停留在create project的加载页面，\r\n\r\n停留几分钟不带动的。\r\n\r\n梯子不知道什么时候才能好，等不及所以只能从Flutter入手。\r\n\r\n# 0x01 配置\r\n\r\n## Flutter设置到path变量\r\n\r\n把Flutter的安装目录的bin添加到path变量中：\r\n\r\n```\r\nD:\\flutter\\flutter\\bin\r\n```\r\n\r\n## 设置系统变量\r\n\r\n为系统变量添加：\r\n\r\nkey `PUB_HOSTED_URL `，value `https:\/\/pub.flutter-io.cn`\r\n\r\nkey `FLUTTER_STORAGE_BASE_URL`，value `https:\/\/storage.flutter-io.cn`\r\n\r\n## 设置Flutter doctor\r\n\r\n打开cmd，输入`flutter doctor`，\r\n\r\n如果有提示`Some Android License not accepted`，\r\n\r\n继续输入命令：`flutter doctor --android-licenses`，\r\n\r\n在后面的所有提示中全部选择`y`。\r\n\r\n# 0x02 结尾\r\n\r\n通过上面设置完成后，再次创建Flutter project时大概几秒钟就能创建完成。"
  },
  {
    "title": "Flutter project运行时一直卡在assembleDebug",
    "created_time": "2020-02-16 09:18:33",
    "body": "# 0x00 前言\r\n\r\n刚创建的Flutter project运行时一直卡在assembleDebug，\r\n\r\n估计也是梯子不能正常使用原因，因为之前都没有遇到这个问题。\r\n\r\n# 0x01 修改\r\n\r\n因为打包使用的是Gradle，所以把相关仓库依赖都改为国内阿里云。\r\n\r\n修改android moudle中`build.gradle`文件中`repositories`闭包：\r\n\r\n```groovy\r\nbuildscript {\r\n    ext.kotlin_version = '1.3.50'\r\n    repositories {\r\n        maven{ url 'https:\/\/maven.aliyun.com\/repository\/google' }\r\n        maven{ url 'https:\/\/maven.aliyun.com\/repository\/jcenter' }\r\n        maven{url 'http:\/\/maven.aliyun.com\/nexus\/content\/groups\/public'}\r\n\/\/        google()\r\n\/\/        jcenter()\r\n    }\r\n\r\n    dependencies {\r\n        classpath 'com.android.tools.build:gradle:3.5.0'\r\n        classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\"\r\n    }\r\n}\r\n\r\nallprojects {\r\n    repositories {\r\n        maven{ url 'https:\/\/maven.aliyun.com\/repository\/google' }\r\n        maven{ url 'https:\/\/maven.aliyun.com\/repository\/jcenter' }\r\n        maven{url 'http:\/\/maven.aliyun.com\/nexus\/content\/groups\/public'}\r\n\/\/        google()\r\n\/\/        jcenter()\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n修改Flutter SDK下的`flutter.gradle`：\r\n\r\n安装目录下`D:\\flutter\\flutter\\packages\\flutter_tools\\gradle`：\r\n\r\n```groovy\r\nbuildscript {\r\n    repositories {\r\n        \/\/google()\r\n        \/\/jcenter()\r\n\t\tmaven{ url 'https:\/\/maven.aliyun.com\/repository\/google' }\r\n        maven{ url 'https:\/\/maven.aliyun.com\/repository\/jcenter' }\r\n        maven{url 'http:\/\/maven.aliyun.com\/nexus\/content\/groups\/public'}\r\n    }\r\n    dependencies {\r\n        classpath 'com.android.tools.build:gradle:3.5.0'\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n同时如果`gradle-wrapper.properties`使用的版本在你本地没有，修改为本地已有版本：\r\n\r\n`distributionUrl=https\\:\/\/services.gradle.org\/distributions\/gradle-6.0.1-all.zip`"
  },
  {
    "title": "Provider优化Widget刷新",
    "created_time": "2020-02-22 16:55:16",
    "body": "# 0x00 前言\r\n\r\n在我们使用Provider监听数据更新时，\r\n\r\n通常会使用`Provider.of<T>(context).xxx`来获取数据填充给相应的Widget，\r\n\r\n比如：`Text(\"${Provider.of<User>(context).name}\")`\r\n\r\n但是这会带来严重的Widget刷新性能问题。\r\n\r\n因为这里的`context`实际是Widget所对应的Element对象。\r\n\r\n而这个`context`一般来自函数`Widget build(BuildContext context)`的参数，\r\n\r\n所以一旦传入了`context`，\r\n\r\n**在数据变更时，该Widget作为根节点的Widget树中，所有StatefulWidget都会被重新构建。**\r\n\r\n**也就是说我本来只想刷新使用该监听数据的Widget，结果却导致了相关Widget树的rebuild。**\r\n\r\n如果我们只想刷新使用该数据的Widget该怎么办？\r\n\r\nProvider已经为我们提供了相关方法。\r\n\r\n# 0x01 Consumer\r\n\r\n## 一般操作\r\n\r\n其实上面操作之所以会导致Widget树的rebuild，是因为使用的`context`范围较大的缘故。\r\n\r\n如果我们只使用监听数据的Widget所对应的`context`不就好了吗？\r\n\r\n确实是这样的！\r\n\r\n如何获取Widget对应的`context`？\r\n\r\n放在平时，我们一般的操作是为监听数据单独创建一个自定义Widget，\r\n\r\n从而得到该Widget的`context`：\r\n\r\n```dart\r\nimport 'package:flutter\/widgets.dart';\r\nimport 'package:flutter_t4\/bean\/user.dart';\r\nimport 'package:provider\/provider.dart';\r\n\r\nclass UserWidget extends StatefulWidget {\r\n  @override\r\n  State<StatefulWidget> createState() => _State();\r\n}\r\n\r\nclass _State extends State<UserWidget> {\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return Text(\"${Provider.of<User>(context).name}\");\r\n  }\r\n}\r\n\r\n```\r\n\r\n## 源码分析\r\n\r\n每监听一个数据就要自定义一个Widget是比较麻烦的事情。\r\n\r\nProvider想到了这一点，为我们提供了`Consumer`。\r\n\r\n看一下该类源码：\r\n\r\n```dart\r\nclass Consumer<T> extends SingleChildStatelessWidget {\r\n  \/\/\/ {@template provider.consumer.constructor}\r\n  \/\/\/ Consumes a [Provider<T>]\r\n  \/\/\/ {@endtemplate}\r\n  Consumer({\r\n    Key key,\r\n    @required this.builder,\r\n    Widget child,\r\n  })  : assert(builder != null),\r\n        super(key: key, child: child);\r\n\r\n  \/\/\/ {@template provider.consumer.builder}\r\n  \/\/\/ Build a widget tree based on the value from a [Provider<T>].\r\n  \/\/\/\r\n  \/\/\/ Must not be `null`.\r\n  \/\/\/ {@endtemplate}\r\n  final Widget Function(BuildContext context, T value, Widget child) builder;\r\n\r\n  @override\r\n  Widget buildWithChild(BuildContext context, Widget child) {\r\n    return builder(\r\n      context,\r\n      Provider.of<T>(context),\r\n      child,\r\n    );\r\n  }\r\n}\r\n```\r\n\r\n这是一个泛型类，\r\n\r\n构造函数有一个必须参数`builder`，这是一个函数类型参数，返回Widget类型\r\n\r\n`builder`函数有三个参数：\r\n\r\n`BuildContext context` 指的是该Widget对应的Element，\r\n\r\n`T value` 指的是要监听的值，\r\n\r\n`Widget child` 指的是子widget，\r\n\r\n`builder`函数由`buildWithChild`函数调用，\r\n\r\n那`buildWithChild`又是什么东西？我们只认识`build`函数的。\r\n\r\n没办法，进父类`SingleChildStatelessWidget`去看看：\r\n\r\n```dart\r\nabstract class SingleChildStatelessWidget extends StatelessWidget\r\n    implements SingleChildWidget {\r\n  \/\/\/ Creates a widget that has exactly one child widget.\r\n  const SingleChildStatelessWidget({Key key, Widget child})\r\n      : _child = child,\r\n        super(key: key);\r\n\r\n  final Widget _child;\r\n\r\n  \/\/\/ A [build] method that receives an extra `child` parameter.\r\n  \/\/\/\r\n  \/\/\/ This method may be called with a `child` different from the parameter\r\n  \/\/\/ passed to the constructor of [SingleChildStatelessWidget].\r\n  \/\/\/ It may also be called again with a different `child`, without this widget\r\n  \/\/\/ being recreated.\r\n  Widget buildWithChild(BuildContext context, Widget child);\r\n\r\n  @override\r\n  Widget build(BuildContext context) => buildWithChild(context, _child);\r\n\r\n  @override\r\n  SingleChildStatelessElement createElement() {\r\n    return SingleChildStatelessElement(this);\r\n  }\r\n}\r\n```\r\n\r\n可以看到原来这是一个`StatelessWidget`，\r\n\r\n而且从这里我们也看到了熟悉的`build`函数，\r\n\r\n它没有自己实现，直接调用了`buildWithChild`。\r\n\r\n而`buildWithChild`调用`builder`，交给我们来实现。\r\n\r\n这里我们注意一点，从`Consumer`构造函数传入的`child Widget`，\r\n\r\n在这里赋值给了`_child`，而后通过`buildWithChild`给返回了。\r\n\r\n这说明在调用`build`函数时，没有造成子Widget树的rebuild，\r\n\r\nrebuild的只有该Widget自身，大大提高了UI刷新效率。\r\n\r\n也可以说**Consumer对child Widget进行了缓存**。\r\n\r\n示例中我们只监听了`User`，可以这样实现：\r\n\r\n```dart\r\nConsumer<User>(builder: (context, data, child) {\r\n              return Text(\"${data.name}\");\r\n            }),\r\n```\r\n\r\n\r\n\r\n现在可以说相比之前有了很大进步，\r\n\r\n是不是可以就此止步，开心的使用`Consumer`了？\r\n\r\n事实上我就是这么做的，直到看了`Selector`源码。\r\n\r\n上面我们实现了当`User`发生变化时刷新其对应的Widget。\r\n\r\n但是有没有想过如果是一个复杂的类，有几十个属性，\r\n\r\n而这个Widget只显示某一条属性（name），那么其他几十条属性变化造成的刷新都是非必须的。\r\n\r\n这在无形中也造成了性能问题。\r\n\r\n那有没有办法只监听类的某一条属性变化，然后刷新Widget呢？\r\n\r\n答案是有的，就是我们接下来要讲的`Selector`。\r\n\r\n# 0x02 Selector\r\n\r\n## 源码分析\r\n\r\n看下`Selector`源码：\r\n\r\n```dart\r\nclass Selector<A, S> extends Selector0<S> {\r\n  \/\/\/ {@macro provider.selector}\r\n  Selector({\r\n    Key key,\r\n    @required ValueWidgetBuilder<S> builder,\r\n    @required S Function(BuildContext, A) selector,\r\n    ShouldRebuild<S> shouldRebuild,\r\n    Widget child,\r\n  })  : assert(selector != null),\r\n        super(\r\n          key: key,\r\n          shouldRebuild: shouldRebuild,\r\n          builder: builder,\r\n          selector: (context) => selector(context, Provider.of(context)),\r\n          child: child,\r\n        );\r\n}\r\n```\r\n\r\n它和`Consumer`一样也是泛型类，不过它有两个泛型参数，\r\n\r\n看下构造函数，\r\n\r\n`ValueWidgetBuilder<S> builder` 它和`Consumer`中的`builder`一样，通过泛型值返回Widget\r\n\r\n`Function(BuildContext, A) selector` 转换器，把A转换成S，也可以理解为属性选择器，选择A类的某一条属性返回。\r\n\r\n`ShouldRebuild<S> shouldRebuild` 函数类型参数，根据对比前后两次S值返回bool值表示是否需要rebuild Widget。\r\n\r\n`Widget child` 同`Consumer`一样，可以缓存的子Widget。非必须\r\n\r\n\r\n\r\n该类只有一个构造函数，要知道具体逻辑需要深入父类`Selector0`：\r\n\r\n```dart\r\nclass Selector0<T> extends SingleChildStatefulWidget {\r\n  \/\/\/ Both `builder` and `selector` must not be `null`.\r\n  Selector0({\r\n    Key key,\r\n    @required this.builder,\r\n    @required this.selector,\r\n    ShouldRebuild<T> shouldRebuild,\r\n    Widget child,\r\n  })  : assert(builder != null),\r\n        assert(selector != null),\r\n        _shouldRebuild = shouldRebuild,\r\n        super(key: key, child: child);\r\n\r\n  \/\/\/ A function that builds a widget tree from `child` and the last result of\r\n  \/\/\/ [selector].\r\n  \/\/\/\r\n  \/\/\/ [builder] will be called again whenever the its parent widget asks for an\r\n  \/\/\/ update, or if [selector] return a value that is different from the\r\n  \/\/\/ previous one using [operator==].\r\n  \/\/\/\r\n  \/\/\/ Must not be `null`.\r\n  final ValueWidgetBuilder<T> builder;\r\n\r\n  \/\/\/ A function that obtains some [InheritedWidget] and map their content into\r\n  \/\/\/ a new object with only a limited number of properties.\r\n  \/\/\/\r\n  \/\/\/ The returned object must implement [operator==].\r\n  \/\/\/\r\n  \/\/\/ Must not be `null`\r\n  final T Function(BuildContext) selector;\r\n\r\n  final ShouldRebuild<T> _shouldRebuild;\r\n\r\n  @override\r\n  _Selector0State<T> createState() => _Selector0State<T>();\r\n}\r\n```\r\n\r\n可以看到`Selector0`是一个`StatefulWidget`，\r\n\r\n不用想，它的主要逻辑肯定在其State里面了，打开看看：\r\n\r\n```dart\r\nclass _Selector0State<T> extends SingleChildState<Selector0<T>> {\r\n  T value;\r\n  Widget cache;\r\n  Widget oldWidget;\r\n\r\n  @override\r\n  Widget buildWithChild(BuildContext context, Widget child) {\r\n    final selected = widget.selector(context);\r\n\r\n    var shouldInvalidateCache = oldWidget != widget ||\r\n        (widget._shouldRebuild != null && widget._shouldRebuild.call(value, selected)) ||\r\n        (widget._shouldRebuild == null && !const DeepCollectionEquality().equals(value, selected));\r\n    if (shouldInvalidateCache) {\r\n      value = selected;\r\n      oldWidget = widget;\r\n      cache = widget.builder(\r\n        context,\r\n        selected,\r\n        child,\r\n      );\r\n    }\r\n    return cache;\r\n  }\r\n}\r\n```\r\n\r\n可以看到这类只有`buildWithChild`一个方法。\r\n\r\n有了`Consumer`经验，可以推断`SingleChildState`一定在其`build`方法中调用了`buildWithChild`。\r\n\r\n事实也是如此。\r\n\r\n所以我们只要看`buildWithChild`实现即可。\r\n\r\n首先调用了`widget.selector(context)`，\r\n\r\n`selector`实现方法为`(context) => selector(context, Provider.of(context))`。\r\n\r\n这里获取了监听的数据泛型A对应的值，然后根据A拿到S。\r\n\r\n\r\n\r\n然后是一个大表达式，返回`shouldInvalidateCache`值表示是否需要刷新。\r\n\r\n当我们首次执行`buildWithChild`时，\r\n\r\n`oldWidget`为null，所以`oldWidget != widget`一定为true，\r\n\r\n所以一定执行`if`语句块，也就是首次运行必调用`builder`。\r\n\r\n与此同时也进行了相关赋值，比如`value`、`oldWidget`、`cache`。\r\n\r\n\r\n\r\n当泛型A对应的监听对象发生变化时，\r\n\r\n再次执行`buildWithChild`，此时` oldWidget != widget`返回false。\r\n\r\n继续执行后面表达式，\r\n\r\n如果我们通过构造函数设置了`_shouldRebuild`，则调用它的实现来比较S的前后变化。\r\n\r\n如果没有设置，则使用`DeepCollectionEquality`进行S前后变化比较。\r\n\r\n也就是说\r\n\r\n**如果是A的其他属性变化引起的`build`，**\r\n\r\n**执行到此处时，由于比较返回false，不会执行`builder`函数调用。**\r\n\r\n**直接返回`cache`，也就不会造成显示的Widget rebuild。**\r\n\r\n\r\n\r\n示例User使用如下：\r\n\r\n```dart\r\nSelector<User, String>(\r\n                builder: (context, data, child) {\r\n                  return Text(\"$data\");\r\n                },\r\n                selector: (context, user) => user.name),\r\n```"
  },
  {
    "title": "关于couldn't find \"libflutter.so异常解决",
    "created_time": "2020-02-24 07:34:32",
    "body": "# 0x00 前言\r\n\r\nFlutter项目真机运行时出现`couldn't find \"libflutter.so\"异常信息。\r\n\r\n造成启动就崩溃。\r\n\r\n# 0x00 分析\r\n\r\n之前是可以正常运行的，在添加极光IM后修改了NDK架构类型支持就有了这个问题。\r\n\r\n所以可以基本确定是CPU架构类型支持修改的问题。\r\n\r\n先看下各CPU架构类型及支持范围：\r\n\r\n![cpu arm图](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/cpu%20arm.webp)\r\n\r\n我在修改NDK类型时，把`arm64-v8a`写成了`armeabi-v8a`，导致cpu架构类型的不支持。\r\n\r\n当我们修改了NDK配置后，记住即时点击`sync`同步，\r\n\r\n如果出现CPU架构不支持，在Running Device地方会给出提示信息。\r\n\r\n比如这里的模拟器只支持x86和x86_64，但是我的app只配置了arm64-v8a。\r\n\r\n这种情况下运行的app是闪退的，要及时修改配置。\r\n\r\n![image-20200320151730809](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200320151730809.png)"
  },
  {
    "title": "Flutter异常处理与崩溃收集",
    "created_time": "2020-02-25 15:35:41",
    "body": "# 0x00 前言\r\n\r\n通常我们在写程序时都是假设执行期间不会发生不正确的事情，然后一撸到底。\r\n\r\n但事实是我们需要把各种设备环境因素考虑进去，以便提供更好的用户体验。\r\n\r\n所以我们需要良好的异常处理。\r\n\r\n# 0x01 异常划分\r\n\r\n说到异常划分，作为Java过来人，\r\n\r\n下意识想到的就是受检异常(编译期异常)和非受检异常(运行时异常)。\r\n\r\n但是Dart和Kotlin一样，都是运行时异常。\r\n\r\n所以这里的异常是根据我使用Flutter过程中自己做的分类，\r\n\r\n姑且分为**UI异常(Widget异常)**和**逻辑异常**。\r\n\r\n## UI异常\r\n\r\n在Flutter中，我把 `build`方法中出现的异常称为UI异常也叫**Widget异常**。\r\n\r\n因为Flutter中的UI构建是基于通过`Widget build(BuildContext context)`方法的响应式构建。\r\n\r\nFramework中构建Widget树时会执行`performRebuild`方法。\r\n\r\n该方法中调用了我们熟知的`build`方法。\r\n\r\nFramework中对`build`方法专门做了`try catch`处理：\r\n\r\n```dart\r\n    Widget built;\r\n    try {\r\n      built = build();\r\n      debugWidgetBuilderValue(widget, built);\r\n    } catch (e, stack) {\r\n      built = ErrorWidget.builder(\r\n        _debugReportException(\r\n          ErrorDescription('building $this'),\r\n          e,\r\n          stack,\r\n          informationCollector: () sync* {\r\n            yield DiagnosticsDebugCreator(DebugCreator(this));\r\n          },\r\n        ),\r\n      );\r\n    } finally {\r\n      \/\/ We delay marking the element as clean until after calling build() so\r\n      \/\/ that attempts to markNeedsBuild() during build() will be ignored.\r\n      _dirty = false;\r\n      assert(_debugSetAllowIgnoredCallsToMarkNeedsBuild(false));\r\n    }\r\n```\r\n\r\n进入`_debugReportException`：\r\n\r\n```dart\r\nFlutterErrorDetails _debugReportException(\r\n  DiagnosticsNode context,\r\n  dynamic exception,\r\n  StackTrace stack, {\r\n  InformationCollector informationCollector,\r\n}) {\r\n  final FlutterErrorDetails details = FlutterErrorDetails(\r\n    exception: exception,\r\n    stack: stack,\r\n    library: 'widgets library',\r\n    context: context,\r\n    informationCollector: informationCollector,\r\n  );\r\n  FlutterError.reportError(details);\r\n  return details;\r\n}\r\n```\r\n\r\n可以看到这里调用了`FlutterError.reportError(details);`。\r\n\r\n看样子这个类是专门处理错误相关的？\r\n\r\n看看`reportError`操作：\r\n\r\n```dart\r\n  \/\/\/ Calls [onError] with the given details, unless it is null.\r\n  static void reportError(FlutterErrorDetails details) {\r\n    assert(details != null);\r\n    assert(details.exception != null);\r\n    if (onError != null)\r\n      onError(details);\r\n  }\r\n```\r\n\r\n可以看到这里有个判断，\r\n\r\n如果`onError`不为空则调用该函数。\r\n\r\n而`onError`默认值是`static FlutterExceptionHandler onError = dumpErrorToConsole;`。\r\n\r\n看来默认是打印异常信息到控制台的，\r\n\r\n不过这是一个静态变量，我们也可以从新赋值处理的。\r\n\r\n我们可以在app启动时这样处理：\r\n\r\n```dart\r\n    FlutterError.onError = (FlutterErrorDetails details,) {\r\n      reportExp(details.exception,details.stack);\/\/上报异常堆栈信息\r\n    };\r\n```\r\n\r\n这样在所有Flutter页面`build`方法出现异常时，我们都会捕捉并上报。\r\n\r\n**注意：并不是Widget在`build`中声明，那异常信息就一定是在`build`中抛出。**\r\n\r\n比如\r\n\r\n```dart\r\nColumn(\r\n            children: <Widget>[\r\n              Positioned(child: Text(\"哈哈\")),\r\n              ]\r\n```\r\n\r\n在这样摆放Widget时，IDE不会出现错误，\r\n\r\n但是在运行时会出现异常，而且你设置了`FlutterError.onError`也无效。\r\n\r\n究其原因是在把子Widget加入到Widget树时会对子Widget进行类型检查。\r\n\r\n检查发现`Positioned`只能放在`Stack`中，\r\n\r\n这一过程发生在`mount`到`build`调用之间。\r\n\r\n\r\n\r\n## 逻辑异常\r\n\r\n上面介绍了UI异常处理，那其他异常怎么办呢？\r\n\r\n说到这可能你上来就是`try catch finally`素质三连。\r\n\r\n但是我想说这素质三连只能在同步异常中有效。\r\n\r\n异步代码需要另外处理。\r\n\r\n### 同步异常\r\n\r\nFlutter中同步异常我们可以使用`try catch finally`捕获。\r\n\r\n使用方法和Java一样，不在细说：\r\n\r\n```dart\r\ntry{\r\n      String a;\r\n      a.substring(10);\r\n    }catch(error,stackTrace){\r\n      reportExp(error,stackTrace);\/\/上报异常堆栈信息\r\n    }finally{\r\n    }\r\n```\r\n\r\n\r\n\r\n### 异步异常\r\n\r\n#### Future.catchError\r\n\r\nFlutter中异步异常是无法通过素质三连进行捕获的。\r\n\r\nFlutter的异步是基于`async await`关键字和`Future`类实现的。\r\n\r\n在`Future`中可以通过`catchError`进行异步异常捕获，\r\n\r\n具体操作是：\r\n\r\n```dart\r\nFuture(() {\r\n      String a;\r\n      a.substring(10);\r\n    }).catchError((error,stackTrace) {\r\n      reportExp(error,stackTrace);\/\/上报异常堆栈信息\r\n    });\r\n```\r\n\r\n**注意：如果在你使用`await`等待`Future`完成，**\r\n\r\n**此时你通过素质三连、`catchError`均可捕获异常。**\r\n\r\n**但是如果你同时使用素质三连和`catchError`,那么只有`catchError`捕获到异常。**\r\n\r\n如下代码只会打印`catch1`内容：\r\n\r\n```dart\r\n    try {\r\n      await Future(() {\r\n        String a;\r\n        a.substring(10);\r\n      }).catchError((error) {\r\n        print(\"catch1 == ${error.toString()}\");\r\n      });\r\n    } catch (e) {\r\n      print(\"catch2 == ${e.toString()}\");\r\n    }\r\n```\r\n\r\n#### runZoned\r\n\r\n异步异常处理的另一种方法是使用`Zone`。\r\n\r\n`Zone`相当于一个沙盒，\r\n\r\n```dart\r\nR runZoned<R>(R body(),\r\n    {Map zoneValues, ZoneSpecification zoneSpecification, Function onError}){\r\n    \r\n}\r\n```\r\n\r\n其中`body`方法作为代码块运行在沙盒环境中。\r\n\r\n可以看到函数参数`onError`，通过该参数来进行异常处理。\r\n\r\n如何把Flutter的代码放在沙盒环境中？\r\n\r\n```dart\r\nvoid main() {\r\n  runZoned(() {\r\n    runApp(MyApp());\r\n  }, onError: (error, StackTrace stackTrace) {\r\n      reportExp(error,stackTrace);\/\/上报异常堆栈信息\r\n  });\r\n}\r\n```\r\n\r\n把`runApp`作为`runZoned`的`body`代码块运行即可。\r\n\r\n这样，在未使用`catchError`的`Future`代码块中出现异常时，\r\n\r\n会自动被`runZoned`的`onError`捕获：\r\n\r\n```dart\r\n        onPressed: () {\r\n          Future(() {\r\n            String a;\r\n            a.substring(10);\r\n          });\r\n        }\r\n```\r\n\r\n\r\n\r\n通过`zoneSpecification`可以对`Zone`进行一些配置，这里不详述。\r\n\r\n\r\n\r\n# 0x02 异常收集\r\n\r\n通过上面的操作基本完成了对常见情况下异常捕获，\r\n\r\n捕获到异常后的上报操作基本都基于现有平台(Android,iOS)，\r\n\r\n这就需要使用平台通信。\r\n\r\n在通信前可以把异常、堆栈信息转为String以便传递：\r\n\r\n```dart\r\nvoid reportExp(err, StackTrace stackTrace) {\r\n  var data = {\r\n    'message': err.toString(),\r\n    'trace': null == stackTrace ? [] : _getTrace(stackTrace),\r\n  };\r\n  \/\/MethodChannel通信\r\n    \r\n}\r\n\r\n_getTrace(StackTrace stackTrace) {\r\n  return Trace.format(stackTrace);\r\n}\r\n```\r\n\r\n如果不打算传递堆栈，而只传递造成异常原因，\r\n\r\n可以通过`Trace.from(stackTrace).frames.first.toString();`。\r\n\r\n转换后的堆栈信息可以通过`MethodChannel`发送给相应平台。\r\n\r\n关于`MethodChannel`使用这里不详述。"
  },
  {
    "title": "Flutter入门之实现可缩放移动的图片框架",
    "created_time": "2020-02-25 17:27:30",
    "body": "# 0x00 前言\r\n\r\n在图片预览页面一般都有图片缩放和移动功能，\r\n\r\n通过缩放和移动可以更容易的看起图片局部内容。\r\n\r\n在Flutter中一切皆是widget，其中`Transform`可以帮助我们实现widget的缩放和移动。\r\n\r\n# 0x01 Transform介绍\r\n\r\n`Transform`  是一个对子widget进行矩阵变换的控件。\r\n\r\n`Matrix4  `是使用的矩阵类。\r\n\r\n通过它来实现各种矩阵操作，如缩放、平移、旋转等。\r\n\r\n看下`Transform`  构造函数：\r\n\r\n```dart\r\n  const Transform({\r\n    Key key,\r\n    @required this.transform,\r\n    this.origin,\r\n    this.alignment,\r\n    this.transformHitTests = true,\r\n    Widget child,\r\n  })\r\n```\r\n\r\n参数`transform`是传递的矩阵设置，\r\n\r\n参数`child`是将要矩阵变换的子控件。\r\n\r\n参数`alignment`是矩阵变换围绕的中心点，可设置`Alignment  `。\r\n\r\n**这个构造函数是一个混合矩阵操作，就是说通过参数`transform`可以同时实现多种变换。**\r\n\r\n**如果要实现单一变换，可以使用相应静态函数：**\r\n\r\n**`Transform.rotate`旋转**\r\n\r\n**`Transform.translate`平移**\r\n\r\n**`Transform.scale`缩放**\r\n\r\n\r\n\r\n# 0x02 创建控件\r\n\r\n创建类`ScaleImageWidget`，继承`StatefulWidget`。\r\n\r\n因为内部要有缩放和平移变量，切随着变量的改变，Widget随着矩阵变换。\r\n\r\n```dart\r\nimport 'package:flutter\/material.dart';\r\n\r\n\/\/\/缩放图片\r\nclass ScaleImageWidget extends StatefulWidget {\r\n  final ImageProvider image;\r\n\r\n  const ScaleImageWidget({Key key, this.image}) : super(key: key);\r\n\r\n  @override\r\n  State<StatefulWidget> createState() => _State();\r\n}\r\n\r\nclass _State extends State<ScaleImageWidget> {\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return GestureDetector(\r\n      onTap: _onTap,\r\n      onLongPress: _onLongPress,\r\n      onScaleStart: _onScaleStart,\r\n      onScaleUpdate: _onScaleUpdate,\r\n      child: Transform(\r\n        transform: Matrix4.identity(),\r\n        alignment: Alignment.center,\r\n        child: Container(\r\n          color: Colors.red,\r\n          child: Center(\r\n            child: Image(image: widget.image),\r\n          ),\r\n        ),\r\n      ),\r\n    );\r\n  }\r\n\r\n  _onTap() {}\r\n\r\n  _onLongPress() {}\r\n\r\n  _onScaleStart(ScaleStartDetails details) {\r\n    print(\"_onScaleStart: focalPoint=${details.focalPoint}\");\r\n  }\r\n\r\n  _onScaleUpdate(ScaleUpdateDetails details) {\r\n    print(\"_onScaleUpdate: focalPoint=${details.focalPoint}\");\r\n    print(\"_onScaleUpdate: scale=${details.scale}\");\r\n  }\r\n}\r\n\r\n```\r\n\r\n上面是基本的框架内容。\r\n\r\n通过下面的调用：\r\n\r\n```dart\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return Scaffold(\r\n      appBar: AppBar(\r\n        title: Text(\"图片缩放\"),\r\n      ),\r\n      body: ScaleImageWidget(\r\n        image: AssetImage('images\/timg.jpg'),\r\n      ),\r\n    );\r\n  }\r\n```\r\n\r\n显示内容为：\r\n\r\n![image-20200325140009078](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200325140009078.png)\r\n\r\n当你在屏幕上做拖拽、缩放操作时，可以看到打印内容如下：\r\n\r\n```txt\r\nI\/flutter ( 4189): _onScaleStart: focalPoint=Offset(162.3, 455.8)\r\nI\/flutter ( 4189): _onScaleUpdate: focalPoint=Offset(162.3, 455.8)\r\nI\/flutter ( 4189): _onScaleUpdate: scale=1.5541888479517616\r\nI\/flutter ( 4189): _onScaleUpdate: focalPoint=Offset(162.3, 456.9)\r\nI\/flutter ( 4189): _onScaleUpdate: scale=1.5886558417246175\r\nI\/flutter ( 4189): _onScaleUpdate: focalPoint=Offset(162.1, 456.0)\r\nI\/flutter ( 4189): _onScaleUpdate: scale=1.6181237483206579\r\nI\/flutter ( 4189): _onScaleUpdate: focalPoint=Offset(162.3, 456.9)\r\nI\/flutter ( 4189): _onScaleUpdate: scale=1.6475941543845447\r\nI\/flutter ( 4189): _onScaleUpdate: focalPoint=Offset(162.1, 456.4)\r\nI\/flutter ( 4189): _onScaleUpdate: scale=1.665581750241805\r\nI\/flutter ( 4189): _onScaleUpdate: focalPoint=Offset(162.1, 457.1)\r\nI\/flutter ( 4189): _onScaleUpdate: scale=1.688553437419615\r\n```\r\n\r\n基础内容已经添加，下面看看具体如何实现。\r\n\r\n# 0x03 缩放实现\r\n\r\n矩阵变换我们这里说过使用`Matrix4`类，并没有使用`Transform`的静态方法。\r\n\r\n上面我们通过`Matrix4.identity()`得到了`Matrix4`实例，\r\n\r\n接着通过该实例实现缩放：\r\n\r\n```dart\r\nMatrix4.identity()\r\n          ..scale(x, y)\r\n```\r\n\r\n这里的`scale`函数接收2个参数，分别是x，y轴的缩放倍率。\r\n\r\n添加一个变量`_currentScale;`表示当前应该使用的倍率：\r\n\r\n```dart\r\ndouble _currentScale = 1.0;\r\nMatrix4.identity()\r\n          ..scale(_currentScale, _currentScale)\r\n```\r\n\r\n接下来要思考的就是在做缩放操作时，如何正确的变更`_currentScale`。\r\n\r\n通过上面日志可以看到\r\n\r\n**每次完整的缩放操作都会调用一次`_onScaleStart`及若干次`_onScaleUpdate`**\r\n\r\n其中`_onScaleUpdate`参数`ScaleUpdateDetails`包含的是缩放操作发生时，\r\n\r\n返回的缩放率`details.scale`。\r\n\r\n这时我们的想法一般是这样的：\r\n\r\n```dart\r\n  _onScaleUpdate(ScaleUpdateDetails details) {\r\n    print(\"_onScaleUpdate: focalPoint=${details.focalPoint}\");\r\n    print(\"_onScaleUpdate: scale=${details.scale}\");\r\n      setState(() {\r\n        _currentScale = details.scale;\r\n      });\r\n  }\r\n```\r\n\r\n运行后操作了下，会发现可以执行缩放了：\r\n\r\n![image-20200325180924466](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200325180924466.png)\r\n\r\n\r\n\r\n这么简单就完成了吗？\r\n\r\n其实多测试几次会发现，在单词缩放中目前是可以的。\r\n\r\n但是松开手后，想继续上次的大小继续缩放，\r\n\r\n**发现widget会先复原或者基本上先缩小，然后再缩放，这是个问题。**\r\n\r\n**这是因为我们缩放一次完成后，没有存储当前的倍率，让下一次缩放开始时使用当前倍率作为基数开始。**\r\n\r\n我们需要再额外添加变量`_lastScale`作为保存上次的倍率。\r\n\r\n在缩放发生时，即`_onScaleStart`调用时保存当前倍率。\r\n\r\n然后在缩放时，让上次的倍率和当前倍率乘积作为新的缩放倍率：\r\n\r\n所以目前代码为：\r\n\r\n```dart\r\n  double _currentScale = 1.0;\r\n  double _lastScale = 1.0;\r\n\r\n_onScaleStart(ScaleStartDetails details) {\r\n    print(\"_onScaleStart: focalPoint=${details.focalPoint}\");\r\n    _lastScale = _currentScale;\r\n  }  \r\n\r\n\r\n_onScaleUpdate(ScaleUpdateDetails details) {\r\n    print(\"_onScaleUpdate: focalPoint=${details.focalPoint}\");\r\n    print(\"_onScaleUpdate: scale=${details.scale}\");\r\n    var tmpScale = details.scale;\r\n    var currentScale = _lastScale * tmpScale;\r\n      setState(() {\r\n        _currentScale = currentScale;\r\n      });\r\n  }\r\n```\r\n\r\n然后再执行多次完整缩放操作，发现目前没有问题了。\r\n\r\n现在基本完成了图片的缩放操作。\r\n\r\n# 0x04 移动实现\r\n\r\n现在看看Widget平移的实现，\r\n\r\n首先创建一个变量`_currentOffset`表示当前的位置，\r\n\r\n有了没有保存上一次变量的教训，\r\n\r\n这次提交创建变量`_lastOffset`表示上一次移动的位置。\r\n\r\n平移操作同样交给`Matrix4`，目前代码为：\r\n\r\n```dart\r\n Offset _currentOffset = Offset.zero;\r\n Offset _lastOffset = Offset.zero;\r\n\r\n Transform(\r\n        transform: Matrix4.identity()\r\n          ..scale(_currentScale, _currentScale)\r\n          ..translate(_currentOffset.dx, _currentOffset.dy)\r\n     \r\n   _onScaleStart(ScaleStartDetails details) {\r\n    print(\"_onScaleStart: focalPoint=${details.focalPoint}\");\r\n    _lastScale = _currentScale;\r\n    _lastOffset = _currentOffset;\r\n  }    \r\n```\r\n\r\n接下来我们要做的就是计算好在什么时机刷新`_currentOffset`。\r\n\r\nWidget平移没有使用什么onDragxxx方法。\r\n\r\n这里仍然使用`_onScaleUpdate`方法。\r\n\r\n已经知道回调返回的参数`ScaleUpdateDetails`中带有缩放倍率。\r\n\r\n如果缩放倍率不为1说明我们正在执行缩放操作，\r\n\r\n如果缩放倍率为1说明我们只是在执行拖动操作。\r\n\r\n所以实现平移，我们需要添加倍率的判断操作：\r\n\r\n```dart\r\n  _onScaleUpdate(ScaleUpdateDetails details) {\r\n    var tmpScale = details.scale;\r\n    if (tmpScale == 1.0) {\r\n      var tmpFocalPoint = details.focalPoint;\r\n      var currentOffset;\/\/如何计算currentOffset\r\n      setState(() {\r\n        _currentOffset = currentOffset;\r\n      });\r\n    } else {\r\n      print(\"_onScaleUpdate: scale=${details.scale}\");\r\n      print(\"_onScaleUpdate: _lastScale=$_lastScale\");\r\n      var currentScale = _lastScale * tmpScale;\r\n      setState(() {\r\n        _currentScale = currentScale;\r\n      });\r\n    }\r\n  }\r\n```\r\n\r\n现在需要计算局部变量`currentOffset`的值。\r\n\r\n当我们在屏幕上滑动时，有个起始点就是`_onScaleStart`返回的`details.focalPoint`，\r\n\r\n有个更新点是`_onScaleUpdate`返回的`details.focalPoint`，\r\n\r\n**偏移量=更新点-起始点，**\r\n\r\n**但是偏移量并不是控件平移所需的最终值，**\r\n\r\n**而是应该使用上一次控件左上角的Offset即`_lastOffset`加上偏移量。**\r\n\r\n起始点的需要从`_onScaleStart`中计算，\r\n\r\n所以需要添加新的变量`_startOffset`，\r\n\r\n在`_onScaleStart`执行时为其赋值：`_startOffset = details.focalPoint;`\r\n\r\n现在更新`_onScaleUpdate`代码：\r\n\r\n```dart\r\n  _onScaleUpdate(ScaleUpdateDetails details) {\r\n    var tmpScale = details.scale;\r\n    if (tmpScale == 1.0) {\r\n      var tmpFocalPoint = details.focalPoint;\r\n      var currentOffset = _lastOffset + (tmpFocalPoint - _startOffset);\r\n      print(\"_onScaleUpdate: currentOffset=$currentOffset\");\r\n      setState(() {\r\n        _currentOffset = currentOffset;\r\n      });\r\n    } else {\r\n      var currentScale = _lastScale * tmpScale;\r\n      setState(() {\r\n        _currentScale = currentScale;\r\n      });\r\n      print(\"_onScaleUpdate: _currentScale=$_currentScale\");\r\n    }\r\n  }\r\n```\r\n\r\n运行代码基本没什么问题：\r\n\r\n![image-20200326012256347](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200326012256347.png)\r\n\r\n但是当放大或缩小到比较大的倍数时，进行拖动操作时会有漂移\/稍慢的现象\r\n\r\n因为可能是Widget已经被缩放过了，这个时候要考虑缩放因素，这里极端情况暂不考虑。\r\n\r\n\r\n\r\n\r\n\r\n# 0x05 恢复原图\r\n\r\n添加完了缩放和平移，现在添加恢复原样的功能。\r\n\r\n希望长按时恢复原样，\r\n\r\n这里恢复原样只要把用到的变量恢复默认值即可：\r\n\r\n```dart\r\n  _onLongPress() {\r\n    setState(() {\r\n      _resetToDefaultValues();\r\n    });\r\n  }\r\n    void _resetToDefaultValues() {\r\n    _startOffset = Offset.zero;\r\n    _lastOffset = Offset.zero;\r\n    _currentOffset = Offset.zero;\r\n    _lastScale = 1.0;\r\n    _currentScale = 1.0;\r\n  }\r\n```\r\n\r\n# 0x06 点击放大\r\n\r\n单击时调用的函数没有参数，所以单击放大倍率默认设置1.5。\r\n\r\n但是我们不能无限放大，当倍率大于16时，恢复原样。\r\n\r\n代码实现为：\r\n\r\n```dart\r\n  _onTap() {\r\n    double currentScale = _lastScale * 1.5;\r\n    if (currentScale > 16) {\r\n      currentScale = 1.0;\r\n      _resetToDefaultValues();\r\n    }\r\n    _lastScale = currentScale;\r\n    setState(() {\r\n      _currentScale = currentScale;\r\n    });\r\n  }\r\n```\r\n\r\n\r\n\r\n全部代码为：\r\n\r\n```dart\r\nimport 'package:flutter\/material.dart';\r\n\r\n\/\/\/缩放图片\r\nclass ScaleImageWidget extends StatefulWidget {\r\n  final ImageProvider image;\r\n\r\n  const ScaleImageWidget({Key key, this.image}) : super(key: key);\r\n\r\n  @override\r\n  State<StatefulWidget> createState() => _State();\r\n}\r\n\r\nclass _State extends State<ScaleImageWidget> {\r\n  double _currentScale = 1.0;\r\n  double _lastScale = 1.0;\r\n  double currentWidth = 0;\r\n  double currentHeight = 0;\r\n  Offset _currentOffset = Offset.zero;\r\n  Offset _lastOffset = Offset.zero;\r\n  Offset _startOffset = Offset.zero;\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return GestureDetector(\r\n      onTap: _onTap,\r\n      onLongPress: _onLongPress,\r\n      onScaleStart: _onScaleStart,\r\n      onScaleUpdate: _onScaleUpdate,\r\n      child: Transform(\r\n          transform: Matrix4.identity()\r\n            ..scale(_currentScale, _currentScale)\r\n            ..translate(_currentOffset.dx, _currentOffset.dy),\r\n          alignment: Alignment.center,\r\n          child: Container(\r\n            color: Colors.red,\r\n            child: Center(\r\n              child: LayoutBuilder(\r\n                builder: (BuildContext _context, BoxConstraints constraints) {\r\n                  if (currentWidth == 0) {\r\n                    currentWidth = constraints.maxWidth;\r\n                    currentHeight = constraints.maxHeight;\r\n                  }\r\n                  print(\r\n                      \"constraints,,,width=${constraints.maxWidth},,,height=${constraints.maxHeight}\");\r\n\r\n                  return Image(image: widget.image);\r\n                },\r\n              ),\r\n            ),\r\n          )),\r\n    );\r\n  }\r\n\r\n  void _resetToDefaultValues() {\r\n    _startOffset = Offset.zero;\r\n    _lastOffset = Offset.zero;\r\n    _currentOffset = Offset.zero;\r\n    _lastScale = 1.0;\r\n    _currentScale = 1.0;\r\n  }\r\n\r\n  _onTap() {\r\n    double currentScale = _lastScale * 1.5;\r\n    if (currentScale > 16) {\r\n      currentScale = 1.0;\r\n      _resetToDefaultValues();\r\n    }\r\n    _lastScale = currentScale;\r\n    setState(() {\r\n      _currentScale = currentScale;\r\n    });\r\n  }\r\n\r\n  _onLongPress() {\r\n    setState(() {\r\n      _resetToDefaultValues();\r\n    });\r\n  }\r\n\r\n  _onScaleStart(ScaleStartDetails details) {\r\n    print(\"_onScaleStart: focalPoint=${details.focalPoint}\");\r\n    _lastScale = _currentScale;\r\n    _lastOffset = _currentOffset;\r\n    _startOffset = details.focalPoint;\r\n  }\r\n\r\n  _onScaleUpdate(ScaleUpdateDetails details) {\r\n    print(\r\n        \"_onScaleUpdate: _lastScale=$_lastScale，，， _currentScale=$_currentScale\");\r\n    print(\r\n        \"_onScaleUpdate: _startOffset=$_startOffset，，， _lastOffset=$_lastOffset\");\r\n    var tmpScale = details.scale;\r\n    if (tmpScale == 1.0) {\r\n      var tmpFocalPoint = details.focalPoint;\r\n      var currentOffset = _lastOffset + (tmpFocalPoint - _startOffset);\r\n      print(\"_onScaleUpdate: currentOffset=$currentOffset\");\r\n      setState(() {\r\n        _currentOffset = currentOffset;\r\n      });\r\n    } else {\r\n      var currentScale = _lastScale * tmpScale;\r\n      setState(() {\r\n        _currentScale = currentScale;\r\n      });\r\n      print(\"_onScaleUpdate: _currentScale=$_currentScale\");\r\n    }\r\n  }\r\n}\r\n\r\n```"
  },
  {
    "title": "Flutter入门之搜索输入框分析实现",
    "created_time": "2020-04-16 14:29:38",
    "body": "# 前言\r\n\r\n基本上有列表的地方就会有搜索，通过搜索可以快速找到想要的数据。\r\n\r\n在Flutter中我原以为会Framework会提供一个类似`SearchView`的Widget。\r\n\r\n但是当我输入`search`时IDE提示给我的并没有类似Widget。\r\n\r\n经过查看文档发现要实现搜索，可以使用`showSearch`方法，\r\n\r\n这倒是和`showDialog`、`showBottomSheet`如出一辙。\r\n\r\n下面看看`showSearch`是如何实现搜索功能的。\r\n\r\n# showSearch介绍\r\n\r\n## 函数参数\r\n\r\n`showSearch`函数源码如下：\r\n\r\n```dart\r\nFuture<T> showSearch<T>({\r\n  @required BuildContext context,\r\n  @required SearchDelegate<T> delegate,\r\n  String query = '',\r\n})\r\n```\r\n\r\n可以看到使用`showSearch`方法，\r\n\r\n只要传递`context`和`delegate`两个必须参数即可。\r\n\r\n其中`context`不用解释都知道，\r\n\r\n`query`是要查找的关键字，一般不用设值。\r\n\r\n而`delegate`类型为`SearchDelegate`，这是一个抽象类。\r\n\r\n所以我们需要自定义一个类继承该类，实现相关方法。\r\n\r\n## SearchDelegate\r\n\r\n自定义`AccountSearchDelegate`继承`SearchDelegate`:\r\n\r\n```dart\r\nclass AccountSearchDelegate extends SearchDelegate {\r\n\r\n  @override\r\n  List<Widget> buildActions(BuildContext context) {\r\n  }\r\n\r\n  @override\r\n  Widget buildLeading(BuildContext context) {\r\n  }\r\n\r\n  @override\r\n  Widget buildResults(BuildContext context) {\r\n  }\r\n\r\n  @override\r\n  Widget buildSuggestions(BuildContext context) {\r\n  }\r\n}\r\n```\r\n\r\n上面四个函数是需要重写的。\r\n\r\n下面分别看看这些函数的作用：\r\n\r\n`buildSuggestions`：返回搜索建议列表。\r\n\r\n在输入内容改变的时候回调该方法，根据不同的内容返回不同的建议列表。\r\n\r\n记住：如果你选择了某个建议列表，也要更新输入内容为建议内容。\r\n\r\n**这里还有一个用法：**\r\n\r\n**在该方法中判断输入内容，如果输入内容存在就根据输入内容给出建议列表。**\r\n\r\n**如果输入内容不存在，就显示一个过去的搜索历史。**\r\n\r\n`buildResults`：返回结果列表。\r\n\r\n当用户提交搜索内容时回调该方法，一般返回`ListView`列表内容。\r\n\r\n`buildLeading`：返回一个显示在输入框前面的Widget。\r\n\r\n一般返回一个返回按钮，可以退出搜索页面。\r\n\r\n`buildActions`：返回一个在输入框后面的Widget用于查询完后显示。\r\n\r\n一般如果输入内容不为空的话，可以显示一个清除按钮，用来清除输入框内容。\r\n\r\n# showSearch使用\r\n\r\n上面介绍了相关函数功能，\r\n\r\n现在根据实际需求看看到底如何应用搜索功能。\r\n\r\n这样一个需求：\r\n\r\n> 1、进入搜索页面后有一个返回按钮，\r\n>\r\n> 如果当前有输入内容，点击返回按钮时清空输入内容，显示搜索建议。\r\n>\r\n> 如果当前没有输入内容，点击返回按钮时退出搜索页面。\r\n>\r\n> 2、搜索执行后，要有清空搜索按钮\r\n>\r\n> 3、没有输入内容时显示搜索历史标签，\r\n>\r\n> 有输入内容时给出搜索建议列表。\r\n>\r\n> 4、搜索有结果时显示结果列表。\r\n\r\n这四个需求分别对应了四个重写方法。\r\n\r\n下面分别实现各个需求。\r\n\r\n### 需求1实现\r\n\r\n我们已经知道`buildLeading`可以添加返回按钮。\r\n\r\n那需求1只要在这个方法完善即可。\r\n\r\n我们只返回一个`IconButton`，根据需求完善点击事件：\r\n\r\n```dart\r\n  @override\r\n  Widget buildLeading(BuildContext context) {\r\n    return IconButton(\r\n      icon: Icon(Icons.arrow_back),\r\n      onPressed: () {\r\n        if (query.isEmpty) {\r\n          close(context, null);\r\n        } else {\r\n          query = \"\";\r\n          showSuggestions(context);\r\n        }\r\n      },\r\n    );\r\n  }\r\n```\r\n\r\n这里注意：\r\n\r\n`close`方法表示退出搜索页面，不需要我们调用`Navigator`。\r\n\r\n`showSuggestions`方法表示显示建议Widget。\r\n\r\n效果图：\r\n\r\n![image-20200416183535752](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200416183535752.png)\r\n\r\n### 需求2实现\r\n\r\n清空按钮实现更简单了，`buildActions`实现即可：\r\n\r\n```dart\r\n  @override\r\n  List<Widget> buildActions(BuildContext context) {\r\n    if (query.isEmpty) {\r\n      return [Container()];\r\n    } else\r\n      return [\r\n        IconButton(\r\n          icon: Icon(Icons.clear),\r\n          onPressed: () {\r\n            query = \"\";\r\n            showSuggestions(context);\r\n          },\r\n        ),\r\n      ];\r\n  }\r\n\r\n```\r\n\r\n效果图：\r\n\r\n![image-20200416183604976](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200416183604976.png)\r\n\r\n### 需求3实现\r\n\r\n没有输入内容时显示搜索历史标签，有输入内容时给出搜索建议列表。\r\n\r\n这里涉及到两种布局：标签布局和建议列表。\r\n\r\n布局的显示根据搜索内容判断：\r\n\r\n```dart\r\n@override\r\n  Widget buildSuggestions(BuildContext context) {\r\n    if (query.isEmpty) {\r\n      return getLables();\r\n    } else\r\n      return getSuggestions();\r\n  }\r\n\r\n  Widget getLabels() {\r\n    return Wrap(\r\n      spacing: 5,\r\n      children: <Widget>[\r\n        RaisedButton(\r\n            onPressed: () {}, child: Text(\"标签1\"), shape: StadiumBorder()),\r\n        RaisedButton(\r\n            onPressed: () {}, child: Text(\"标签2\"), shape: StadiumBorder()),\r\n        RaisedButton(\r\n            onPressed: () {}, child: Text(\"标签3\"), shape: StadiumBorder()),\r\n        RaisedButton(\r\n            onPressed: () {}, child: Text(\"标签4\"), shape: StadiumBorder()),\r\n        RaisedButton(\r\n            onPressed: () {}, child: Text(\"标签5\"), shape: StadiumBorder()),\r\n        RaisedButton(\r\n            onPressed: () {}, child: Text(\"标签6\"), shape: StadiumBorder()),\r\n      ],\r\n    );\r\n  }\r\n\r\n  Widget getSuggestions() {\r\n    return ListView(\r\n      children: <Widget>[\r\n        ListTile(\r\n          title: Text(\"我是建议1\"),\r\n        ),\r\n        ListTile(\r\n          title: Text(\"我是建议2\"),\r\n        ),\r\n        ListTile(\r\n          title: Text(\"我是建议3\"),\r\n        ),\r\n        ListTile(\r\n          title: Text(\"我是建议4\"),\r\n        ),\r\n        ListTile(\r\n          title: Text(\"我是建议5\"),\r\n        ),\r\n      ],\r\n    );\r\n  }\r\n```\r\n\r\n标签效果图：\r\n\r\n![image-20200416183656827](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200416183656827.png)\r\n\r\n建议效果图：\r\n\r\n![image-20200416183714266](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200416183714266.png)\r\n\r\n### 需求4实现\r\n\r\n搜索有结果时显示结果列表，没有结果时提示没有搜索到。\r\n\r\n```dart\r\n  @override\r\n  Widget buildResults(BuildContext context) {\r\n    return ListView(\r\n      children: <Widget>[\r\n        ListTile(\r\n          title: Text(\"我是结果1\"),\r\n        ),\r\n        ListTile(\r\n          title: Text(\"我是结果2\"),\r\n        ),\r\n        ListTile(\r\n          title: Text(\"我是结果3\"),\r\n        ),\r\n        ListTile(\r\n          title: Text(\"我是结果4\"),\r\n        ),\r\n        ListTile(\r\n          title: Text(\"我是结果5\"),\r\n        ),\r\n      ],\r\n    );\r\n  }\r\n```\r\n\r\n有内容结果图：\r\n\r\n![image-20200416184113935](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200416184113935.png)\r\n\r\n### 需求4完善\r\n\r\n本节的title是需求4的完善，\r\n\r\n之所以是完善是因为需求4中的实现在网上的例子太多了，\r\n\r\n因为这都是直接就返回了结果列表，没有进行耗时操作的模拟和实现。\r\n\r\n然鹅搜索这个流程最起码是本地文件\/数据库搜索，更多的是网络操作，\r\n\r\n也就是说其实`Widget buildResults(BuildContext context)`并不能立马得到搜索结果。\r\n\r\n既然得不到搜索结果，你又怎么知道该如何显示呢？\r\n\r\n也就是说回调`buildResults`时，你应该根据输入内容去进行耗时查询。\r\n\r\n所以现在应该是这样：\r\n\r\n```dart\r\n  @override\r\n  Widget buildResults(BuildContext context) {\r\n    final String text = query;\r\n    List data =await getDataFromNet(text); \r\n  \treturn build(data);\r\n  }\r\n```\r\n\r\n但是一旦在函数中使用了`await`，那么该函数就要被声明为`async`函数。\r\n\r\n而函数一旦声明`async`，函数返回类型就是`Future<T>`。\r\n\r\n这时IDE是报错的，因为这个函数是重写函数，不能修改返回值类型。\r\n\r\n既然同步方式实现不行，那就走异步方式，\r\n\r\n就是说我先判断数据集合是否为空，\r\n\r\n如果为空就执行网络请求，同时返回一个空Widget，\r\n\r\n等到网络执行完毕刷新Widget。\r\n\r\n如果不为空就直接使用数据创建结果列表。\r\n\r\n所以现在代码样式如下：\r\n\r\n```dart\r\nList data; \r\n@override\r\n  Widget buildResults(BuildContext context) {\r\n    final String text = query;\r\n    if(data==null){\r\n        getDataFromNet(text).then((value){\r\n            this.data = value;\r\n            showResults(context);\r\n        }); \r\n    }else\r\n  \t\treturn build(data);\r\n  }\r\n```\r\n\r\n其中`showResults`表示以结果列表的形式刷新搜索页。\r\n\r\n上面这种方式功能上没有问题，但是代码并不好。\r\n\r\n所以下面我们以更符合**响应式编程**方式来从新实现这块。\r\n\r\n首先创建一个枚举类：\r\n\r\n```dart\r\nenum FutureState {\r\n  wait,\r\n  done,\r\n}\r\n```\r\n\r\n`FutureState`表示Future执行状态，\r\n\r\n`wait`表示执行中，`done`表示执行完成，包括出现异常。\r\n\r\n然后创建一个包装类，包装泛型数据T和错误信息以及Future状态：\r\n\r\n```dart\r\nclass DataWrapper<T> {\r\n  final Object error;\r\n  final T data;\r\n  final FutureState state;\r\n\r\n  DataWrapper._(\r\n    this.state,\r\n    this.data,\r\n    this.error,\r\n  );\r\n\r\n  factory DataWrapper.wrap(\r\n    FutureState state,\r\n    T data,\r\n    Object error,\r\n  ) =>\r\n      DataWrapper._(state, data, error);\r\n\r\n  bool get hasError => this.error != null;\r\n}\r\n```\r\n\r\n命名一个新函数:\r\n\r\n```dart\r\ntypedef FutureWidgetBuilder = Widget Function(\r\n    BuildContext context, DataWrapper wrapper);\r\n```\r\n\r\n接下来是重点，\r\n\r\n创建`FutureBuild<T>`，它是一个有`StatefulWidget`。\r\n\r\n构造函数接收`Future`和`FutureWidgetBuilder`：\r\n\r\n```dart\r\nclass FutureBuild<T> extends StatefulWidget {\r\n  final FutureWidgetBuilder builder;\r\n  final Future future;\r\n\r\n  const FutureBuild({this.builder, this.future});\r\n\r\n  @override\r\n  State<StatefulWidget> createState() => _FutureBuildState<T>();\r\n}\r\n```\r\n\r\n创建对应的State，`_FutureBuildState<T>`：\r\n\r\n```dart\r\nclass _FutureBuildState<T> extends State<FutureBuild> {\r\n  DataWrapper<T> _wrapper;\r\n\r\n  @override\r\n  void initState() {\r\n    super.initState();\r\n    _wrapper = DataWrapper.wrap(FutureState.wait, null, null);\r\n    if (widget.future != null) {\r\n      final future = widget.future;\r\n      future.then((value) {\r\n        setState(() {\r\n          _wrapper = DataWrapper<T>.wrap(FutureState.done, value, null);\r\n        });\r\n      }).catchError((error) {\r\n        setState(() {\r\n          _wrapper = DataWrapper<T>.wrap(FutureState.done, null, error);\r\n        });\r\n      });\r\n    }\r\n  }\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return widget.builder(context, _wrapper);\r\n  }\r\n}\r\n```\r\n\r\n在State开始的时候会调用`initState`，\r\n\r\n这时给`_wrapper`赋初始值`DataWrapper.wrap(FutureState.wait, null, null);`。\r\n\r\n紧接着对`future`的`then`和`catchError`分别进行实现，重新对`_wrapper`赋值。\r\n\r\n这样不管执行的是`then`还是`catchError`，\r\n\r\n在调用`setState`时都会再次调用`build`，进而调用`FutureWidgetBuilder`。\r\n\r\n最后我们只需要根据`FutureState`和`wrapper.hasError`分别进行判断来返回不同的Widget即可：\r\n\r\n```dart\r\n  @override\r\n  Widget buildResults(BuildContext context) {\r\n    final String text = query;\r\n    return FutureBuild<List<AccountData>>(\r\n      future: AccountProvider.provider.queryByFilter(text),\r\n      builder: (BuildContext context, DataWrapper wrapper) {\r\n        if (wrapper.state == FutureState.wait) {\r\n          return Container();\r\n        } else {\r\n          if (wrapper.hasError) {\r\n            return Text(wrapper.error);\r\n          }\r\n          final data = wrapper.data;\r\n          return ListView.separated(\r\n              itemBuilder: (BuildContext context, int index) =>\r\n                  itemBuilder(context, data[index], null),\r\n              separatorBuilder: (BuildContext context, int index) => Divider(\r\n                    height: 1,\r\n                    color: Colors.grey,\r\n                  ),\r\n              itemCount: data.length);\r\n        }\r\n      },\r\n    );\r\n```\r\n\r\n这样的实现看起来代码量多了，\r\n\r\n但是这块封装适用于以后所有类似的异步请求。\r\n\r\n最关键的问题是通过封装把异步操作封装到FutureBuild的Widget里面。\r\n\r\n对于使用该Widget的人来说只要把注意力放在业务实现即可。\r\n\r\n但是其实Flutter已经想到了这一点，\r\n\r\n所以为我们提供了`FutureBuilder`，我们可以直接拿来使用。\r\n\r\n上面的自己封装代码如果你懂了，那么`FutureBuilder`实现原理你也就懂了。"
  },
  {
    "title": "Flutter入门之如何判断dialog是否显示",
    "created_time": "2020-04-30 09:40:13",
    "body": "# 0x01 dialog中禁止返回键\r\n\r\n禁止返回键后，不用考虑显示loading过程中，突然返回键取消dialog。然后打开新的页面，这样会造成判断请求loading页面是否在栈顶准确性问题。\r\n\r\n首先弹出一个禁止返回键的dialog：\r\n\r\n```dart\r\n  void showdialog(BuildContext context) {\r\n    showDialog(\r\n        context: context,\r\n        barrierDismissible: false,\r\n        builder: (_context) {\r\n          return UnconstrainedBox(\r\n            constrainedAxis: Axis.vertical,\r\n            child: WillPopScope(\r\n                child: SizedBox(\r\n                  width: 250,\r\n                  child: Builder(builder: (__context) {\r\n                    return AlertDialog(\r\n                      elevation: 0,\r\n                      backgroundColor: Colors.transparent,\r\n                      content: Column(\r\n                        mainAxisSize: MainAxisSize.min,\r\n                        children: <Widget>[\r\n                          LoadingWidget(),\r\n                        ],\r\n                      ),\r\n                    );\r\n                  }),\r\n                ),\r\n                onWillPop: () async => false),\r\n          );\r\n        });\r\n  }\r\n```\r\n\r\n接下来判断请求loading的页面是否在栈顶，\r\n\r\n如果该页面在栈顶可以认为当前没有显示loading，\r\n\r\n如果该页面没有在栈顶可以认为当前loading还在显示。\r\n\r\n因为禁用了loading返回键，你不可能取消loading进入新页面。\r\n\r\n我们使用`ModalRoute`判断是否在栈顶：\r\n\r\n```dart\r\nModalRoute.of(context).isCurrent\r\n```\r\n\r\n注意一定要使用`isCurrent`，\r\n\r\n不要被它的兄弟属性`isFirst`和`isActive`迷惑。\r\n\r\n如果返回false，说明不在栈顶，那就间接说明有dialog；\r\n\r\n如果返回true，说明在栈顶，间接说明没有弹出dialog。\r\n\r\n# 0x02 不禁止返回键\r\n\r\n\r\n\r\n既然不禁止返回键，那上面取消dialog然后再进入新页面的情况就要考虑进去。\r\n\r\n我这里的解决方案是创建一个可以显示loadingDialog的基类`MyLoadingWidget`，\r\n\r\n所有需要显示loadingDialog的widget继承该类：\r\n\r\n相关state继承`MyLoadingState`：\r\n\r\n```dart\r\nimport 'package:flutter\/material.dart';\r\n\r\nimport 'LoadingWidget.dart';\r\n\r\nabstract class MyLoadingWidget extends StatefulWidget {\r\n  const MyLoadingWidget({Key key}) : super(key: key);\r\n\r\n  @override\r\n  MyLoadingState createState();\r\n}\r\n\r\nabstract class MyLoadingState<T extends MyLoadingWidget> extends State<T> {\r\n  BuildContext dialogContext;\r\n\r\n  void showdialog(BuildContext context) {\r\n    showDialog(\r\n        context: context,\r\n        barrierDismissible: false,\r\n        builder: (_context) {\r\n          return UnconstrainedBox(\r\n            constrainedAxis: Axis.vertical,\r\n            child: WillPopScope(\r\n                child: SizedBox(\r\n                  width: 250,\r\n                  child: Builder(builder: (__context) {\r\n                    dialogContext = __context;\r\n                    return AlertDialog(\r\n                      elevation: 0,\r\n                      backgroundColor: Colors.transparent,\r\n                      content: Column(\r\n                        mainAxisSize: MainAxisSize.min,\r\n                        children: <Widget>[\r\n                          LoadingWidget(),\r\n                        ],\r\n                      ),\r\n                    );\r\n                  }),\r\n                ),\r\n                onWillPop: () async {\r\n                  dialogContext = null;\r\n                  return true;\r\n                }),\r\n          );\r\n        });\r\n  }\r\n\r\n  bool isShow() {\r\n    if (dialogContext == null) return false;\r\n    return ModalRoute.of(dialogContext) is PopupRoute;\r\n  }\r\n}\r\n\r\n```\r\n\r\n通过`showdialog`显示dialog；\r\n\r\n通过`isShow`判断是否显示dialog；"
  },
  {
    "title": "Flutter状态管理之Redux使用",
    "created_time": "2020-05-01 11:59:53",
    "body": "# 0x00 介绍\r\n\r\nRedux也是一个数据(状态)管理的框架。\r\n\r\n为啥要用**也**字？因为前面介绍的[Flutter框架之Provider源码分析](http:\/\/www.jenson.top\/post\/154\/)的也是一个数据管理的框架。\r\n\r\n通过前面Provider的源码分析了解到最终Provider的实现其实就是围绕**InheritedWidget**实现的。\r\n\r\n巧得很，Redux也是通过**InheritedWidget**来实现的。\r\n\r\n不过这里只介绍Redux的基本使用，关于源码分析留在后面。\r\n\r\n废话少说，直接看看Redux如何使用。\r\n\r\n# 0x01 使用\r\n\r\n介绍使用之前先看下谷歌搜到的一个Redux流程图：\r\n\r\n![redux流程](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/redux%E6%B5%81%E7%A8%8B.png)\r\n\r\n表达出来大概意思是：\r\n\r\n用户操作Widget时触发Action，\r\n\r\nReducer收到当前State和相应Action然后生成新的State。\r\n\r\n新的State保存到Store，\r\n\r\n保存后的Store通知Widget刷新为最新状态。\r\n\r\n其中Action是**dynamic**类型，\r\n\r\nReducer是纯函数，它接收State和Action然后返回新的State。\r\n\r\n## 创建State\r\n\r\n既然Redux也是基于**InheritedWidget**的。\r\n\r\n那也就是说我们应该和Provider一样，把自定义的State放在根Widget中。\r\n\r\n所以我们创建MyState类：\r\n\r\n```dart\r\nclass MyState {\r\n  int count;\r\n\r\n  MyState({this.count});\r\n\r\n  factory MyState.initial() {\r\n    return MyState(count: 110);\r\n  }\r\n}\r\n```\r\n\r\n## 创建Store\r\n\r\nState创建后需要由Store持有的，所以我们需要创建泛型为MyState的Store实例：\r\n\r\n```dart\r\n  var store = Store<MyState>(appReducer, initialState: MyState.initial());\r\n```\r\n\r\n参数**appReducer**：Reducer函数，接收State和Action然后返回新的State。\r\n\r\n参数**initialState**：默认初始化，提供默认值。\r\n\r\n## 创建reducer\r\n\r\n上面说了，reducer是接收State和Action然后根据Action返回新的State。\r\n\r\n所以这里实现为：\r\n\r\n```dart\r\nMyState appReducer(MyState myState, dynamic action) {\r\n  debugPrint(\"appReducer\");\r\n  var _count;\r\n  if ('inc' == action) {\r\n    _count = myState.count + 1;\r\n  } else if ('dec' == action) {\r\n    _count = myState.count - 1;\r\n  } else {\r\n    _count = myState.count;\r\n  }\r\n  return MyState(\r\n    count: _count,\r\n  );\r\n}\r\n```\r\n\r\n网上很多例子都是把Action设置为`enum`类型：\r\n\r\n```dart\r\nenum Action{\r\nINCREMENT,\r\n}\r\n```\r\n\r\n然后看官网demo时，发现也是如此，，所以当时我的第一感觉是Action只能是enum！！！\r\n\r\n唉，不想多说。\r\n\r\n但其实上面说了**Action是**dynamic**类型，可以是字符串，enum，也可以是对象。**\r\n\r\n## 保存Store到根Widget\r\n\r\n上面已经完成了创建Store所需工作，\r\n\r\n这里需要把Store实例保存到根Widget，以便其他页面可以来获取。\r\n\r\n其实只要使用**StoreProvider**包裹一下我们当前根Widget即可：\r\n\r\n```dart\r\nclass MyApp extends StatelessWidget {\r\n  final Store store;\r\n\r\n  const MyApp({Key key, this.store}) : super(key: key);\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return StoreProvider<MyState>(\r\n        store: store,\r\n        child: MaterialApp(\r\n          title: 'Flutter Demo',\r\n          theme: ThemeData(\r\n            primarySwatch: Colors.blue,\r\n            visualDensity: VisualDensity.adaptivePlatformDensity,\r\n          ),\r\n          home: MyHomePage(\r\n            title: \"增加数据\",\r\n          ),\r\n        ));\r\n  }\r\n}\r\n```\r\n\r\n然后在main函数中修改为：\r\n\r\n```dart\r\nvoid main() {\r\n  var store = Store<MyState>(appReducer, initialState: MyState.initial());\r\n  runApp(MyApp(\r\n    store: store,\r\n  ));\r\n}\r\n```\r\n\r\n## 获取数据\r\n\r\n获取数据可以通过**StoreConnector**和**StoreBuilder**。\r\n\r\n这里以**StoreConnector**为例，在MyHomePage代码为：\r\n\r\n```dart\r\n StoreConnector<MyState, int>(\r\n            builder: (ctx, count) {\r\n              debugPrint(\"build..StoreConnector\");\r\n              return Column(\r\n                mainAxisAlignment: MainAxisAlignment.center,\r\n                children: <Widget>[\r\n                  Text(\r\n                    'You have pushed the button this many times:',\r\n                  ),\r\n                  Text(\r\n                    '$count',\r\n                    style: Theme.of(context).textTheme.headline4,\r\n                  ),\r\n                ],\r\n              );\r\n            },\r\n            converter: (store) => store.state.count)\r\n```\r\n\r\n**StoreConnector**类为泛型`StoreConnector<S, ViewModel>`。\r\n\r\n其中`S`为我们定义的MyState类型；\r\n\r\n`ViewModel`为MyState中的某一(某些)属性类型。\r\n\r\n构造函数中，\r\n\r\n参数`converter`将Store类换到ViewModel类型的属性。\r\n\r\n参数`builder`负责根据ViewModel构建Widget。\r\n\r\n## 刷新数据\r\n\r\n上面介绍完了如何获取数据，\r\n\r\n但是数据并不是一成不变的，根据用户操作会呈现不同的样式。\r\n\r\n那么Redux如何刷新Widget呢？\r\n\r\n上面流程图已经介绍过了，\r\n\r\n用户操作触发Action，所以我们只要发送Action就好了：\r\n\r\n```dart\r\nStoreProvider.of<MyState>(context, listen: false).dispatch('inc')\r\n```\r\n\r\n这里的操作和Provider基本一样了。\r\n\r\n至此Redux最基本的使用流程基本讲完了。\r\n\r\n# 0x02 疑问\r\n\r\n## 如何存储多个State\r\n\r\n上面介绍完基本使用流程后就能在项目中直接使用了吗？\r\n\r\n告诉你并不能啊！！\r\n\r\n难道你的项目简单到只有一个State需要管理吗？\r\n\r\n在Provider中我们可以通过这样来管理多个状态类：\r\n\r\n```dart\r\nMultiProvider(\r\n      providers: [\r\n        ChangeNotifierProvider(create: (_) => ScreenSizeBean()),\r\n        ChangeNotifierProvider(create: (_) => UserBean()),\r\n        ChangeNotifierProvider(create: (_) => ChatUser()),\r\n      ],\r\n      child: MaterialApp(\r\n        onGenerateRoute: FindCatApp.router.generator,\r\n        localizationsDelegates: [\r\n          GlobalMaterialLocalizations.delegate,\r\n          GlobalWidgetsLocalizations.delegate,\r\n          CatLocalizationsDelegate()\r\n        ],\r\n        supportedLocales: [const Locale('en', 'US'), const Locale('zh', 'CN')],\r\n        theme: ThemeData(\r\n          primaryColor: Colors.yellow[700],\r\n        ),\r\n        home: HomePage(),\r\n      ),\r\n    )\r\n```\r\n\r\n**那Redux中如何管理多个State呢？**\r\n\r\n**抱歉，Redux中只有一个`Store`，而这一个`Store`只能管理一个`State`。。**\r\n\r\n**那如果还要UserInfo的登录信息要管理怎么办？**\r\n\r\n**往自定义`State`中塞属性！！**\r\n\r\n先定义好`UserInfo`：\r\n\r\n```dart\r\nclass UserInfo {\r\n  String name;\r\n  String pwd;\r\n  String mobile;\r\n\r\n  UserInfo({this.name, this.pwd, this.mobile});\r\n\r\n  factory UserInfo.empty() => UserInfo();\r\n\r\n  bool get isEmpty {\r\n    return (null == name || name.isEmpty) &&\r\n        (null == pwd || pwd.isEmpty) &&\r\n        (null == mobile || mobile.isEmpty);\r\n  }\r\n}\r\n```\r\n\r\n再定义MyState:\r\n\r\n```dart\r\nclass MyState {\r\n  int count;\r\n  UserInfo userInfo;\r\n\r\n  MyState({this.count, this.userInfo});\r\n\r\n  factory MyState.initial() {\r\n    return MyState(count: 110, userInfo: UserInfo.empty());\r\n  }\r\n}\r\n```\r\n\r\n上面我们已经创建好的Store可以不用改变，继续拿来使用。\r\n\r\n但是`appReducer`需要修改，因为现在已经有多个状态需要管理了，\r\n\r\n所以在大于一个状态时，我们需要为每个状态都提供单独的`reducer`：\r\n\r\n```dart\r\nMyState appReducer(MyState myState, dynamic action) {\r\n  debugPrint(\"appReducer\");\r\n  return MyState(\r\n    count: countReducer(myState, action),\r\n    userInfo: userReducer(myState, action),\r\n  );\r\n}\r\n\r\nUserInfo userReducer(MyState myState, action) {\r\n  if (action == 'logout') {\r\n    \/\/\/登出\r\n    return UserInfo.empty();\r\n  }\r\n  return myState.userInfo;\r\n}\r\n\r\nint countReducer(MyState myState, action) {\r\n  var _count;\r\n  if ('inc' == action) {\r\n    _count = myState.count + 1;\r\n  } else if ('dec' == action) {\r\n    _count = myState.count - 1;\r\n  } else {\r\n    _count = myState.count;\r\n  }\r\n  return _count;\r\n}\r\n```\r\n\r\n至此我们完成了多个State属性存储。\r\n\r\n## Action为对象类型如何操作\r\n\r\n上面我们完成了多State属性的存储，但是我们看到userReducer只判断enum，字符串的Action类型。\r\n\r\n如果我们要从Widget获取name、pwd和mobile值，然后封装到UserInfo中，\r\n\r\n那么我们的Action应该如何把新封装的UserInfo传递到`appReducer`呢？\r\n\r\n这时就涉及到对象类型的Action了。\r\n\r\n创建一个UserInfoUpdateAction类：\r\n\r\n```dart\r\nclass UserInfoUpdateAction {\r\n  final UserInfo userInfo;\r\n\r\n  UserInfoUpdateAction(this.userInfo);\r\n}\r\n```\r\n\r\n修改`userReducer`，添加`UserInfoUpdateAction`处理：\r\n\r\n```dart\r\nUserInfo userReducer(MyState myState, action) {\r\n  if (action == 'logout') {\r\n    \/\/\/登出\r\n    return UserInfo.empty();\r\n  }\r\n  if (action is UserInfoUpdateAction) {\r\n    return action.userInfo;\r\n  }\r\n  return myState.userInfo;\r\n}\r\n```\r\n\r\n**这里使用了**is**判断Action，**\r\n\r\n**有没有更好方式？**\r\n\r\n**Redux提供了**combineReducers  **，它接收`Reducer<State>列表`，返回`Reducer<State>`。**\r\n\r\n**列表中的item使用**TypedReducer**来定义,两个泛型参数为State、Action。**\r\n\r\n**构造函数接收纯函数`final State Function(State state, Action action) reducer;`**\r\n\r\n```dart\r\nfinal UserInfoAction = combineReducers<UserInfo>([\r\n  TypedReducer<UserInfo, UserInfoUpdateAction>(userUpdateAction),\r\n  \/\/\/其他Action\r\n \/\/\/其他Action\r\n]);\r\n\r\nUserInfo userUpdateAction(UserInfo userInfo, UserInfoUpdateAction action) {\r\n  return action.userInfo;\r\n}\r\n```\r\n\r\n所以`appReducer`修改为：\r\n\r\n```dart\r\nMyState appReducer(MyState myState, dynamic action) {\r\n  debugPrint(\"appReducer\");\r\n  return MyState(\r\n    count: countReducer(myState, action),\r\n    userInfo: userInfoAction(myState.userInfo, action),\r\n  );\r\n}\r\n```\r\n\r\n下面直接通过Action更新状态：\r\n\r\n```dart\r\n  void _updateUser() {\r\n    var userUpdateAction = UserInfoUpdateAction(\r\n        UserInfo(name: 'Jenson', pwd: '1234', mobile: '158013822222'));\r\n    StoreProvider.of<MyState>(context, listen: false)\r\n        .dispatch(userUpdateAction);\r\n  }\r\n```\r\n\r\n\r\n\r\n## 异步Action\/Store\r\n\r\n参考[redux_thunk](https:\/\/pub.dev\/packages\/redux_thunk)"
  },
  {
    "title": "关于Flutter运行在windows桌面端",
    "created_time": "2020-05-03 09:32:32",
    "body": "# 0x00 前言\r\n\r\nFlutter除了移动端，还能运行在桌面(win,osx,linux)。\r\n\r\n本节以Windows为例，记录Flutter项目运行流程。\r\n\r\n# 0x01 安装Visual Studio\r\n\r\n安装Visual Studio时选择工作负载时选择**使用C++的桌面开发**。\r\n\r\n同时在单个组件中把**win10 SDK**的几个选项勾上。\r\n\r\n如图：\r\n\r\n![image-20200611171253015](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200611171253015.png)\r\n\r\n\r\n\r\n# 0x02 切换分支\r\n\r\n我们开发使用的分支一般是**stable**稳定分支，而**Flutter desktop**是新特性，\r\n\r\n在稳定分支是不存在的，所以需要切换到**master**。\r\n\r\n如果**Flutter desktop**已经是**stable**了，则忽略此步。\r\n\r\n使用`flutter channel`查看当前分支\r\n\r\n使用`flutter channel master`切换到master\r\n\r\n使用`flutter upgrade`升级\r\n\r\n使用`flutter doctor`检查环境\r\n\r\n其中使用`flutter doctor`检查时确保Visual Studio环境是绿色的，如下图：\r\n\r\n![image-20200611171839342](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200611171839342.png)\r\n\r\n# 0x03 下载\r\n\r\n克隆**flutter-desktop-embedding**：`git clone https:``\/\/github.com\/google\/flutter-desktop-embedding`\r\n\r\n我这里直接在**flutter安装目录下执行克隆**\r\n\r\n# 0x04 设置可用\r\n\r\n进入桌面端测试例子目录：`D:\\flutter\\flutter-desktop-embedding\\testbed`。\r\n\r\n执行`flutter config --enable-windows-desktop`\r\n\r\nhuo`flutter config --enable-linux-desktop`\r\n\r\n或`flutter config --enable-macos-desktop`。\r\n\r\n# 0x05 运行\r\n\r\n执行`flutter run`运行该例子到桌面端。\r\n\r\n启动后的桌面端如图：\r\n\r\n![image-20200611172752189](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/image-20200611172752189.png)\r\n\r\n# 0x06 异常\r\n\r\n如果出现Unable to find suitable Visual Studio toolchain. Please run `flutter doctor` for more details.\r\n\r\n说明你的Visual Studio安装有问题。\r\n\r\n解决方案参考：https:\/\/stackoverflow.com\/questions\/60334570\/unable-to-find-suitable-visual-studio-toolchain-please-run-flutter-doctor-for"
  },
  {
    "title": "另一种方式实现Flutter国际化",
    "created_time": "2020-06-18 15:58:27",
    "body": "# 0x00 前言\r\n\r\n看了一下Flutter国际化实现，看的是Intl库。\r\n\r\n看资料过程发现需要使用命令行生成什么arb文件。\r\n\r\n然后还有几个其他不明所以的文件。\r\n\r\n看的一愣一愣的，遂放弃。\r\n\r\n印象中不论flutter_localization还是Intl都是需要\r\n\r\n在`MaterialApp`中声明**localizationsDelegates**和**supportedLocales**。\r\n\r\n既然这是每个库的共性，那索性进去看看里面大概实现是如何的。\r\n\r\n# 0x01流程分析\r\n\r\n流程开始前先看下大概流程图：\r\n\r\n![flutter国际化](https:\/\/jenson-1258324340.cos.ap-beijing.myqcloud.com\/flutter%E5%9B%BD%E9%99%85%E5%8C%96.jpg)\r\n\r\n接下来进入源码分析阶段：\r\n\r\n## 第一阶段：MaterialApp\r\n\r\n**localizationsDelegates**和**supportedLocales**首先被`MaterialApp`接收，\r\n\r\n但它是一个`StatefulWidget`，自己并不处理，交给对应`State`(`_MaterialAppState`)。\r\n\r\n在`_MaterialAppState`中，对`localizationsDelegates`和`DefaultMaterialLocalizations.delegate`、`DefaultCupertinoLocalizations.delegate`进行了合并处理，并将合并后的`Iterable`继续传递：\r\n\r\n```dart\r\n  Iterable<LocalizationsDelegate<dynamic>> get _localizationsDelegates sync* {\r\n    if (widget.localizationsDelegates != null)\r\n      yield* widget.localizationsDelegates;\r\n    yield DefaultMaterialLocalizations.delegate;\r\n    yield DefaultCupertinoLocalizations.delegate;\r\n  }\r\n```\r\n\r\n然后`supportedLocales`没有处理，和`Iterable`同样在`build`方法中传入到`WidgetsApp`中。\r\n\r\n## 第二阶段：WidgetsApp\r\n\r\n发现`WidgetsApp`也是一个`StatefulWidget`，\r\n\r\n所以直接进入对应`State`(`_WidgetsAppState`)的`build`中，\r\n\r\n查看`supportedLocales`和`localizationsDelegates`是否有处理:\r\n\r\n```\r\n  Iterable<LocalizationsDelegate<dynamic>> get _localizationsDelegates sync* {\r\n    if (widget.localizationsDelegates != null)\r\n      yield* widget.localizationsDelegates;\r\n    yield DefaultWidgetsLocalizations.delegate;\r\n  }\r\n```\r\n\r\n发现这里又一次进行了合并返回新的`Iterable`。\r\n\r\n而`supportedLocales`没有继续传递了，\r\n\r\n而是把`locale`和`supportedLocales`处理后返回一个`appLocale`和`Iterable`传递给`Localizations`:\r\n\r\n```dart\r\nLocalizations(\r\n              locale: appLocale,\r\n              delegates: _localizationsDelegates.toList(),\r\n              child: title,\r\n            )\r\n```\r\n\r\n这里返回`appLocale`的逻辑大概是\r\n\r\n**如果最开始设置了`locale`那么根据`locale`和`supportedLocales`返回一个传递。**\r\n\r\n**如果没有设置则根据系统支持(`WidgetsBinding.instance.window.locales`)和`supportedLocales`返回一个。**\r\n\r\n具体细节参考源码\r\n\r\n## 第三阶段：Localizations\r\n\r\n进入`Localizations`发现其仍然是一个`StatefulWidget`。\r\n\r\n直接去其对应的`_LocalizationsState`中`build`查看是否对\r\n\r\n`locale`和`delegates`有处理过：\r\n\r\n```dart\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    if (_locale == null)\r\n      return Container();\r\n    return Semantics(\r\n      textDirection: _textDirection,\r\n      child: _LocalizationsScope(\r\n        key: _localizedResourcesScopeKey,\r\n        locale: _locale,\r\n        localizationsState: this,\r\n        typeToResources: _typeToResources,\r\n        child: Directionality(\r\n          textDirection: _textDirection,\r\n          child: widget.child,\r\n        ),\r\n      ),\r\n    );\r\n  }\r\n```\r\n\r\n在这里我们看到并没有把传过来的参数继续传递。\r\n\r\n就目前情况来看如果继续传递是传递给`_LocalizationsScope`的。\r\n\r\n但是其接收的嫌疑参数只有`_locale`、`this`、`_typeToResources`。\r\n\r\n下面分别看看这三个参数有什么含义，\r\n\r\n`this`就是`_LocalizationsState`自身，\r\n\r\n我们发现`_locale`和`_typeToResources`赋值是在`load`函数进行的：\r\n\r\n```dart\r\n  @override\r\n  void initState() {\r\n    super.initState();\r\n    load(widget.locale);\r\n  }\r\n\r\nvoid load(Locale locale) {\r\n    final Iterable<LocalizationsDelegate<dynamic>> delegates = widget.delegates;\r\n    if (delegates == null || delegates.isEmpty) {\r\n      _locale = locale;\r\n      return;\r\n    }\r\n\r\n    Map<Type, dynamic> typeToResources;\r\n    final Future<Map<Type, dynamic>> typeToResourcesFuture = _loadAll(locale, delegates)\r\n      .then<Map<Type, dynamic>>((Map<Type, dynamic> value) {\r\n        return typeToResources = value;\r\n      });\r\n\r\n    if (typeToResources != null) {\r\n      \/\/ All of the delegates' resources loaded synchronously.\r\n      _typeToResources = typeToResources;\r\n      _locale = locale;\r\n    } else {\r\n      \/\/ - Don't rebuild the dependent widgets until the resources for the new locale\r\n      \/\/ have finished loading. Until then the old locale will continue to be used.\r\n      \/\/ - If we're running at app startup time then defer reporting the first\r\n      \/\/ \"useful\" frame until after the async load has completed.\r\n      RendererBinding.instance.deferFirstFrame();\r\n      typeToResourcesFuture.then<void>((Map<Type, dynamic> value) {\r\n        if (mounted) {\r\n          setState(() {\r\n            _typeToResources = value;\r\n            _locale = locale;\r\n          });\r\n        }\r\n        RendererBinding.instance.allowFirstFrame();\r\n      });\r\n    }\r\n  }\r\n```\r\n\r\n可以看到在State初始化时执行了`load`。\r\n\r\n函数大概意思就是把`widget.locale`赋值给`_locale`，\r\n\r\n遍历`delegates`,由于每个`delegate`都继承**LocalizationsDelegate**并实现了\r\n\r\n`bool isSupported(Locale locale)`\r\n\r\n`Future<T> load(Locale locale)`\r\n\r\n`bool shouldReload(covariant LocalizationsDelegate<T> old)`\r\n\r\n三个方法。\r\n\r\n遍历时调用`delegate.load()`返回泛型**Future<T>**实例。\r\n\r\n把**T**类型作为`key`，**T**实例作为`value`存入`Map<Type, dynamic>`返回赋值给`_typeToResources`。\r\n\r\n## 第四阶段：_LocalizationsScope\r\n\r\n上面已经了解了三个嫌疑参数的含义。\r\n\r\n接下来看看`_LocalizationsScope`，它继承了`InheritedWidget`。\r\n\r\n根据以前对`InheritedWidget`的分析，\r\n\r\n`_LocalizationsScope`对应`InheritedElement`的被存储到`_inheritedWidgets`中。\r\n\r\n我们应该通过`_LocalizationsScope`.of`方法返回该`Widget`进而拿到相关数据。\r\n\r\n但是这是一个隐藏类，我们不能使用。\r\n\r\n但是通过搜索发现`Localizations`中有如下方法：\r\n\r\n```dart\r\n  static T of<T>(BuildContext context, Type type) {\r\n    assert(context != null);\r\n    assert(type != null);\r\n    final _LocalizationsScope scope = context.dependOnInheritedWidgetOfExactType<_LocalizationsScope>();\r\n    return scope?.localizationsState?.resourcesFor<T>(type);\r\n  }\r\n```\r\n\r\n这里的`Type`为泛型T的类型，\r\n\r\n虽然`_LocalizationsScope`我们不能使用，但是`Localizations`已经为我们封装了现成可用方法。\r\n\r\n在分析Provider源码时说过，关于`InheritedWidget`主要掌握三个地方：\r\n\r\n保存数据、更新数据和获取数据。\r\n\r\n数据保存流程刚才已经分析完了，\r\n\r\n假设更新数据由切换系统语言自动触发，我们无需操作。\r\n\r\n那么我们只要获取数据就好了，这里通过`Localizations.of`也已经完成。\r\n\r\n## 第五阶段：如何实现多语言\r\n\r\n流程分析完了，但是系统是如何提供多语言呢？\r\n\r\n上面说了自定义Delegate要继承`LocalizationsDelegate<T>`重新三个方法。\r\n\r\n其中`Future<T> load(Locale locale)`根据不同`locale`加载不同的资源**T**。\r\n\r\n通过`_MaterialLocalizationsDelegate`类，我们看下具体实现：\r\n\r\n```dart\r\nclass _MaterialLocalizationsDelegate extends LocalizationsDelegate<MaterialLocalizations> {\r\n  const _MaterialLocalizationsDelegate();\r\n\r\n  @override\r\n  bool isSupported(Locale locale) => locale.languageCode == 'en';\r\n\r\n  @override\r\n  Future<MaterialLocalizations> load(Locale locale) => DefaultMaterialLocalizations.load(locale);\r\n\r\n  @override\r\n  bool shouldReload(_MaterialLocalizationsDelegate old) => false;\r\n\r\n  @override\r\n  String toString() => 'DefaultMaterialLocalizations.delegate(en_US)';\r\n}\r\n```\r\n\r\n其中`DefaultMaterialLocalizations.load(locale)`为：\r\n\r\n```dart\r\n  static Future<MaterialLocalizations> load(Locale locale) {\r\n    return SynchronousFuture<MaterialLocalizations>(const DefaultMaterialLocalizations());\r\n  }\r\n```\r\n\r\n这里的`DefaultMaterialLocalizations`为`MaterialLocalizations`子类，\r\n\r\n以`SynchronousFuture`方式返回。\r\n\r\n看看 `DefaultMaterialLocalizations`部分代码：\r\n\r\n```\r\n  @override\r\n  String get invalidDateFormatLabel => 'Invalid format.';\r\n\r\n  @override\r\n  String get invalidDateRangeLabel => 'Invalid range.';\r\n\r\n  @override\r\n  String get dateOutOfRangeLabel => 'Out of range.';\r\n\r\n  @override\r\n  String get saveButtonLabel => 'SAVE';\r\n\r\n  @override\r\n  String get datePickerHelpText => 'SELECT DATE';\r\n\r\n  @override\r\n  String get dateRangePickerHelpText => 'SELECT RANGE';\r\n```\r\n\r\n**子类重写了父类变量，也就是说可以根据不同的`Locale`返回不同的资源**T**。**\r\n\r\n# 0x02 实现国际化\r\n\r\n上面介绍了相关流程，\r\n\r\n接下来看看如何从另一种方式实现国际化\r\n\r\n## 创建资源T\r\n\r\n通过上面我们知道`LocalizationsDelegate<T>`带有泛型的。\r\n\r\n那我们就先实现这个泛型类：\r\n\r\n```dart\r\nclass MyLocalization{\r\n\r\n}\r\n```\r\n\r\n我们要在该类中添加我们app要支持的语言：\r\n\r\n```dart\r\n  \/\/\/支持的Locales\r\n  static List<Locale> get supportedLocales {\r\n    return const <Locale>[\r\n      Locale.fromSubtags(languageCode: 'zh'),\r\n      Locale.fromSubtags(languageCode: 'en'),\r\n    ];\r\n  }\r\n```\r\n\r\n然后封装能获取`MyLocalization`的方法：\r\n\r\n```dart\r\n  static MyLocalization of(BuildContext context) {\r\n    return Localizations.of<MyLocalization>(context, MyLocalization);\r\n  }\r\n```\r\n\r\n上面说了根据不同的`Locale`返回不同的资源**T**，\r\n\r\n所以我们这里`MyLocalization`要抽象化，提供未实现的属性，完整代码为：\r\n\r\n```dart\r\nabstract class MyLocalization {\r\n  \/\/\/支持的Locales\r\n  static List<Locale> get supportedLocales {\r\n    return const <Locale>[\r\n      Locale.fromSubtags(languageCode: 'zh'),\r\n      Locale.fromSubtags(languageCode: 'en'),\r\n    ];\r\n  }\r\n\r\n  static MyLocalization of(BuildContext context) {\r\n    return Localizations.of<MyLocalization>(context, MyLocalization);\r\n  }\r\n\r\n  String get title;\r\n\r\n  String get app_name;\r\n}\r\n```\r\n\r\n由于我们支持了中文和英文，所以还要有2个`MyLocalization`的实现类：\r\n\r\n`EnLocalization`和`CnLocalization`，代码实现为：\r\n\r\n```dart\r\nclass EnLocalization extends MyLocalization {\r\n  @override\r\n  String get title => \"international\";\r\n\r\n  @override\r\n  String get app_name => \"test international\";\r\n}\r\n\r\nclass CnLocalization extends MyLocalization {\r\n  @override\r\n  String get title => \"国际化\";\r\n\r\n  @override\r\n  String get app_name => \"测试国际化\";\r\n}\r\n```\r\n\r\n**注意：以后所有需要国际化的文本首先声明在`MyLocalization`然后在其子类予以实现即可。**\r\n\r\n## 创建delegate\r\n\r\n接下来创建自定义`MyDelegate`:\r\n\r\n```dart\r\nclass MyDelegate extends LocalizationsDelegate<MyLocalization> {\r\n  static MyDelegate delegate = MyDelegate();\r\n\r\n  const MyDelegate();\r\n\r\n  @override\r\n  bool isSupported(Locale locale) {\r\n    if (locale != null) {\r\n      for (var supportedLocale in MyLocalization.supportedLocales) {\r\n        if (supportedLocale.languageCode == locale.languageCode) {\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  @override\r\n  Future<MyLocalization> load(Locale locale) {\r\n    if (locale.languageCode == 'en') {\r\n      return SynchronousFuture<MyLocalization>(EnLocalization());\r\n    } else if (locale.languageCode == 'zh') {\r\n      return SynchronousFuture<MyLocalization>(CnLocalization());\r\n    }\r\n    return SynchronousFuture<MyLocalization>(CnLocalization());\r\n  }\r\n\r\n  @override\r\n  bool shouldReload(LocalizationsDelegate<MyLocalization> old) => false;\r\n}\r\n```\r\n\r\n`isSupported`中根据参数`locale`和`MyLocalization.supportedLocales`进行比较判断是否支持此`locale`\r\n\r\n`load`根据不同的`locale.languageCode`创建不同的语言资源。\r\n\r\n## 添加Delegate\r\n\r\n在`MaterialApp`中添加`localizationsDelegates`和`supportedLocales`：\r\n\r\n```\r\n MaterialApp(\r\n        localizationsDelegates: [\r\n          GlobalMaterialLocalizations.delegate,\r\n          GlobalWidgetsLocalizations.delegate,\r\n          MyDelegate.delegate,\r\n        ],\r\n        supportedLocales: MyLocalization.supportedLocales,\r\n        home: TestKeyPage(),\r\n      )\r\n```\r\n\r\n## 使用\r\n\r\n通过`MyLocalization.of(context).title`直接使用即可。\r\n\r\n## 优化\r\n\r\n在`load`方法中如果语言较多时，要写很多硬性诸如`zh`、`en`等比较\r\n\r\n而且每次都要从新创建`xxLocalization`，性能不好。\r\n\r\n所以在`MyLocalization`添加静态变量：\r\n\r\n```dart\r\n  static Map<String, MyLocalization> localizations = {\r\n    'zh': CnLocalization(),\r\n    'en': EnLocalization(),\r\n  };\r\n```\r\n\r\n`load`修改为：\r\n\r\n```dart\r\n  @override\r\n  Future<MyLocalization> load(Locale locale) {\r\n    if (MyLocalization.localizations.containsKey(locale.languageCode)) {\r\n      return SynchronousFuture(\r\n          MyLocalization.localizations[locale.languageCode]);\r\n    } else {\r\n      return SynchronousFuture(MyLocalization.localizations['zh']);\r\n    }\r\n  }\r\n```\r\n\r\n这样减少了过多的if else判断和硬性编码，也减少了每次创建`xxLocalization`对象。"
  },
  {
    "title": "另一种方式实现Flutter国际化(二)之App内部语言切换",
    "created_time": "2020-06-21 14:12:03",
    "body": "# 0x00 前言\r\n\r\n在做语言切换的时候要注意你的语言切换是内部切换还是外部切换。\r\n\r\n内部切换是系统语言没有改变，单纯在app内的语言切换。\r\n\r\n外部切换是指系统语言切换导致的app语言切换。\r\n\r\n内部切换，切换后我们需要自己去刷新。\r\n\r\n外部切换，系统会自动回调，无需我们实现。\r\n\r\n下面分别说说这两种。\r\n\r\n# 0x01 外部切换\r\n\r\n[另一种方式实现Flutter国际化](\/flutterblog.io\/#\/markdown_page?type=flutter&name=另一种方式实现Flutter国际化)里面的语言切换就是外部切换。\r\n\r\n但是我们App是怎么知道系统语言发生变化了呢？\r\n\r\n在`runApp`运行的时候回初始化`WidgetsFlutterBinding`:\r\n\r\n```dart\r\nvoid runApp(Widget app) {\r\n  WidgetsFlutterBinding.ensureInitialized()\r\n    ..scheduleAttachRootWidget(app)\r\n    ..scheduleWarmUpFrame();\r\n}\r\n```\r\n\r\n其中`ensureInitialized`调用了`WidgetsFlutterBinding()`。\r\n\r\n而构造函数调用的时候会调用`initInstances()`：\r\n\r\n```dart\r\n  @override\r\n  void initInstances() {\r\n    super.initInstances();\r\n    _instance = this;\r\n\r\n    assert(() {\r\n      _debugAddStackFilters();\r\n      return true;\r\n    }());\r\n\r\n    \/\/ Initialization of [_buildOwner] has to be done after\r\n    \/\/ [super.initInstances] is called, as it requires [ServicesBinding] to\r\n    \/\/ properly setup the [defaultBinaryMessenger] instance.\r\n    _buildOwner = BuildOwner();\r\n    buildOwner.onBuildScheduled = _handleBuildScheduled;\r\n    window.onLocaleChanged = handleLocaleChanged;\r\n    window.onAccessibilityFeaturesChanged = handleAccessibilityFeaturesChanged;\r\n    SystemChannels.navigation.setMethodCallHandler(_handleNavigationInvocation);\r\n    FlutterErrorDetails.propertiesTransformers.add(transformDebugCreator);\r\n  }\r\n```\r\n\r\n注意这里面为`window`设置了一个属性`onLocaleChanged`。\r\n\r\n这是一个函数类型，而`handleLocaleChanged`是这样：\r\n\r\n```dart\r\n  @protected\r\n  @mustCallSuper\r\n  void handleLocaleChanged() {\r\n    dispatchLocalesChanged(window.locales);\r\n  }\r\n\r\n```\r\n\r\n其中`window.locales`表示系统使用的语言列表，\r\n\r\n当我们修改系统语言时，`window.locales`的变化会回调`handleLocaleChanged`。\r\n\r\n```dart\r\n  @protected\r\n  @mustCallSuper\r\n  void dispatchLocalesChanged(List<Locale> locales) {\r\n    for (final WidgetsBindingObserver observer in _observers)\r\n      observer.didChangeLocales(locales);\r\n  }\r\n```\r\n\r\n遍历观察者，告知系统语言发生变化，注意处理。\r\n\r\n那么`_observers`中的数据是什么时候被添加进去的呢？\r\n\r\n[另一种方式实现Flutter国际化](http:\/\/www.jenson.top\/post\/166\/)里面有说到`WidgetsApp`,其对应`_WidgetsAppState`。\r\n\r\n其`initState`方法为：\r\n\r\n```dart\r\n  @override\r\n  void initState() {\r\n    super.initState();\r\n    _updateNavigator();\r\n    _locale = _resolveLocales(WidgetsBinding.instance.window.locales, widget.supportedLocales);\r\n    WidgetsBinding.instance.addObserver(this);\r\n  }\r\n```\r\n\r\n可以看到这里添加了Observer。\r\n\r\n当执行`observer.didChangeLocales(locales)`时，\r\n\r\n其实会调用`_WidgetsAppState`中的`didChangeLocales`：\r\n\r\n```dart\r\n  @override\r\n  void didChangeLocales(List<Locale> locales) {\r\n    final Locale newLocale = _resolveLocales(locales, widget.supportedLocales);\r\n    if (newLocale != _locale) {\r\n      setState(() {\r\n        _locale = newLocale;\r\n      });\r\n    }\r\n  }\r\n```\r\n\r\n既然调用了`setState`，那么接下来就是调用`build`。\r\n\r\n把新的`_locale`向下传递，导致页面根据新的`_locale`获取新的资源显示文本。\r\n\r\n这就完成了外部切换。\r\n\r\n# 0x02 内部切换\r\n\r\n内部切换最直接的方法就是切换语言时，我们执行`MaterialApp`参数`locale`的刷新。\r\n\r\n如何切换时刷新`locale`?\r\n\r\n当然是把`Locale`加入到状态管理。\r\n\r\n以`Provider`为例，\r\n\r\n## 创建`Locale`包裹类\r\n\r\n```dart\r\nclass LocaleWrap with ChangeNotifier {\r\n  Locale locale;\r\n\r\n\r\n  void update(Locale locale) {\r\n    this.locale = locale;\r\n    notifyListeners();\r\n  }\r\n}\r\n```\r\n\r\n## 添加到`MultiProvider`中\r\n\r\n```dart\r\n ChangeNotifierProvider(\r\n            create: (_) =>\r\n                LocaleWrap()..locale = Locale.fromSubtags(languageCode: 'zh'))\r\n```\r\n\r\n既然已经把`Locale`纳入了状态管理，接下来要做的就是\r\n\r\n## Provider提供locale\r\n\r\n`MaterialApp`中使用的`locale`的值需要从`Provider`中获取了：\r\n\r\n```dart\r\nConsumer<LocaleWrap>(builder: (ctx, data, child) {\r\n        return MaterialApp(\r\n          onGenerateRoute: FindCatApp.router.generator,\r\n          localizationsDelegates: [\r\n            CatDelegate.delegate,\r\n            GlobalMaterialLocalizations.delegate,\r\n            GlobalWidgetsLocalizations.delegate,\r\n          ],\r\n          locale: data.locale,\/\/\/使用状态管理提供的Locale\r\n          supportedLocales: BaseLocalization.supportedLocales,\r\n          theme: ThemeData(\r\n            primaryColor: Colors.yellow[700],\r\n          ),\r\n          home: HomePage(),\r\n        );\r\n      })\r\n```\r\n\r\n## 切换语言时发送刷新通知\r\n\r\n```dart\r\nProvider.of<LocaleWrap>(context, listen: false)\r\n                  .update(Locale.fromSubtags(languageCode: val));\r\n```"
  },
  {
    "title": "Flutter状态管理之scoped_model源码分析",
    "created_time": "2020-06-29 10:13:54",
    "body": "# 0x00 前言\r\n\r\n状态管理对于Flutter这种响应式编程来说是很重要的。\r\n\r\n对于要入手状态管理框架，**scoped_model**是一个不错的选择。\r\n\r\n因为这个框架只有一个文件，6个类。\r\n\r\n学起来比较容易上手。\r\n\r\n这里首先看一下如何使用，然后在对其进行源码分析。\r\n\r\n# 0x01 使用\r\n\r\n**scoped_model**使用起来非常简单，因为它只有6个类。\r\n\r\n`Model`：我们的数据类继承该类，在数据变化需要通知其他使用该属性的Widget刷新时调用`notifyListeners`即可。\r\n\r\n`ScopedModel`：用作root widget，可以看做为我们提供数据的容器。\r\n\r\n`ScopedModelDescendant`：Descendant是后裔，子孙的意思。\r\n\r\n上面有提供数据的root widget。这个自然就是获取`Model`的widget。\r\n\r\n`_InheritedModel`：是`ScopedModel`可以被后裔获取的关键。\r\n\r\n`ModelFinder`：过时类，使用`ScopedModel.of`方法获取`Model`即可。\r\n\r\n`ScopedModelError`：错误类，获取不到`ScopedModel`时抛出该异常。\r\n\r\n可以看到后面三个是内部类、过时类和错误信息类。\r\n\r\n所以使用时，我们只需要使用前3个类。\r\n\r\n分析完这让我们使用更简单专注了。\r\n\r\n## 创建Model类\r\n\r\n\r\n\r\n```dart\r\nclass UserInfoByScoped extends Model {\r\n  String username;\r\n\r\n  UserInfoByScoped.empty() {\r\n    username = \"Jenson\";\r\n  }\r\n\r\n  void update(String name) {\r\n    username = name;\r\n    notifyListeners();\r\n  }\r\n}\r\n```\r\n\r\n**在你认为所有属性变更需要通知其他使用该属性地方的Widget时，调用`notifyListeners`。**\r\n\r\n## 添加ScopedModel\r\n\r\n添加`ScopedModel`在Root Widget。\r\n\r\n```dart\r\nWidget useScoped() {\r\n  return ScopedModel<UserInfoByScoped>(\r\n      model: UserInfoByScoped.empty(),\r\n      child: MaterialApp(\r\n        home: ScopedHomePage(),\r\n      ));\r\n}\r\n```\r\n\r\n## 添加ScopedModelDescendant\r\n\r\n```dart\r\nScopedModelDescendant<UserInfoByScoped>(\r\n              builder: (context, child, model) {\r\n            return Text(model.username);\r\n          })\r\n```\r\n\r\n## 获取Model并更新\r\n\r\n```dart\r\nRaisedButton(\r\n            onPressed: () {\r\n              var name = \"Jenson \" + DateTime.now().toString();\r\n              ScopedModel.of<UserInfoByScoped>(context).update(name);\r\n            },\r\n            child: Text(\"改变名称\"),\r\n          )\r\n```\r\n\r\n\r\n\r\n## 多个moudle情况\r\n\r\n### ScopedModel嵌套\r\n\r\n首先声明多个**moudle**：\r\n\r\n```dart\r\nclass UserInfoByScoped extends Model {\r\n  String username;\r\n\r\n  UserInfoByScoped.empty() {\r\n    username = \"Jenson\";\r\n  }\r\n\r\n  void update(String name) {\r\n    username = name;\r\n    notifyListeners();\r\n  }\r\n}\r\n\r\nclass Card extends Model {\r\n  List<String> goods = [];\r\n\r\n  void add(String good) {\r\n    goods.add(good);\r\n    notifyListeners();\r\n  }\r\n\r\n  void remove(String good) {\r\n    goods.remove(good);\r\n    notifyListeners();\r\n  }\r\n}\r\n```\r\n\r\n其次为了让后裔能获取多个moudle，但是每个**ScopedModel**只支持一个moudle。\r\n\r\n所以可以在root widget嵌套多个**ScopedModel**：\r\n\r\n```dart\r\nWidget useScoped() {\r\n  return ScopedModel<UserInfoByScoped>(\r\n      model: UserInfoByScoped.empty(),\r\n      child: ScopedModel<Card>(\r\n          model: Card(),\r\n          child: MaterialApp(\r\n            home: ScopedHomePage(),\r\n          )));\r\n}\r\n```\r\n\r\n使用时仍然使用`ScopedModelDescendant`。\r\n\r\n但是`ScopedModelDescendant`也只支持获取一个moudle，\r\n\r\n如果一个Widget使用到多个moudle，\r\n\r\n可以使用`ScopedModel.of<Card>(context)`和`ScopedModel.of<UserInfoByScoped>`分别获取需要的moudle。\r\n\r\n最后在Widget处组装：\r\n\r\n```dart\r\nvar cards = ScopedModel.of<Card>(context);\r\nvar name =ScopedModel.of<UserInfoByScoped>(context).username;\r\nText(\"$name的购物车清单：${cards.toString()}\");\r\n```\r\n\r\n### 多moudle混入方式\r\n\r\n多moudle混入方式就是根据不同的业务声明不同的**mixin**类：\r\n\r\n```dart\r\nmixin UserInfoByScoped on Model {\r\n  String username = \"Jenson\";\r\n\r\n  void update(String name) {\r\n    username = name;\r\n    notifyListeners();\r\n  }\r\n}\r\n\r\nmixin Card on Model {\r\n  List<String> goods = [];\r\n\r\n  void add(String good) {\r\n    goods.add(good);\r\n    notifyListeners();\r\n  }\r\n\r\n  void remove(String good) {\r\n    goods.remove(good);\r\n    notifyListeners();\r\n  }\r\n}\r\n```\r\n\r\n**注意这里的业务moudle一定要使用`mixin`修饰而不是`class`。**\r\n\r\n**如果使用`class`修饰，那么就需要`class Card  extends Model`。**\r\n\r\n**但是当**AppMoudle**在`mixin Card`时会出现如下异常：**\r\n\r\n**The class 'xxx' can't be used as a mixin because it extends a class other than Object.**\r\n\r\n\r\n\r\n最后声明一个全局的**AppMoudle**，继承moudle且混入其他业务moudle：\r\n\r\n```dart\r\nclass AppMoudle extends Model with Card, UserInfoByScoped {}\r\n\r\n```\r\n\r\n在root widget使用：\r\n\r\n```dart\r\nWidget useScoped() {\r\n  return ScopedModel<AppMoudle>(\r\n      model: AppMoudle(),\r\n      child: MaterialApp(\r\n        home: ScopedHomePage(),\r\n      ));\r\n}\r\n```\r\n\r\n在后裔widget获取：\r\n\r\n```dart\r\nColumn(\r\n        children: [\r\n          ScopedModelDescendant<AppMoudle>(builder: (context, child, model) {\r\n            return Text(model.username);\r\n          }),\r\n          RaisedButton(\r\n            onPressed: () {\r\n              var name = \"Jenson \" + DateTime.now().toString();\r\n              ScopedModel.of<AppMoudle>(context).update(name);\r\n            },\r\n            child: Text(\"改变名称\"),\r\n          ),\r\n          ScopedModelDescendant<AppMoudle>(builder: (context, child, model) {\r\n            return Text(model.goods.toString());\r\n          }),\r\n          RaisedButton(\r\n            onPressed: () {\r\n              var name = \"Jenson \" + DateTime.now().toString();\r\n              ScopedModel.of<AppMoudle>(context).add(name);\r\n            },\r\n            child: Text(\"改变名称\"),\r\n          ),\r\n        ],\r\n      )\r\n```\r\n\r\n# 0x02 分析\r\n\r\n\r\n\r\n## Model源码\r\n\r\n`Model`继承`Listenable`并实现了`addListener`，`removeListener`。\r\n\r\n当我们数据有更新时调用`notifyListeners`通知监听的Widget刷新。\r\n\r\n这里的Widget是指`AnimatedBuilder`。\r\n\r\n这在`ScopedModel`中有体现。\r\n\r\n看下Model源码：\r\n\r\n```dart\r\nabstract class Model extends Listenable {\r\n  final Set<VoidCallback> _listeners = Set<VoidCallback>();\r\n  int _version = 0;\r\n  int _microtaskVersion = 0;\r\n\r\n  \/\/\/ [listener] will be invoked when the model changes.\r\n  @override\r\n  void addListener(VoidCallback listener) {\r\n    _listeners.add(listener);\r\n  }\r\n\r\n  \/\/\/ [listener] will no longer be invoked when the model changes.\r\n  @override\r\n  void removeListener(VoidCallback listener) {\r\n    _listeners.remove(listener);\r\n  }\r\n\r\n  \/\/\/ Returns the number of listeners listening to this model.\r\n  int get listenerCount => _listeners.length;\r\n\r\n  \/\/\/ Should be called only by [Model] when the model has changed.\r\n  @protected\r\n  void notifyListeners() {\r\n    \/\/ We schedule a microtask to debounce multiple changes that can occur\r\n    \/\/ all at once.\r\n    if (_microtaskVersion == _version) {\r\n      _microtaskVersion++;\r\n      scheduleMicrotask(() {\r\n        _version++;\r\n        _microtaskVersion = _version;\r\n\r\n        \/\/ Convert the Set to a List before executing each listener. This\r\n        \/\/ prevents errors that can arise if a listener removes itself during\r\n        \/\/ invocation!\r\n        _listeners.toList().forEach((VoidCallback listener) => listener());\r\n      });\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n## ScopedModel源码\r\n\r\n`ScopedModel`的`build`方法中使用了`AnimatedBuilder`。\r\n\r\n```dart\r\nclass ScopedModel<T extends Model> extends StatelessWidget {\r\n  \/\/\/ The [Model] to provide to [child] and its descendants.\r\n  final T model;\r\n\r\n  \/\/\/ The [Widget] the [model] will be available to.\r\n  final Widget child;\r\n\r\n  ScopedModel({@required this.model, @required this.child})\r\n      : assert(model != null),\r\n        assert(child != null);\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return AnimatedBuilder(\r\n      animation: model,\r\n      builder: (context, _) => _InheritedModel<T>(model: model, child: child),\r\n    );\r\n  }\r\n  static T of<T extends Model>(\r\n    BuildContext context, {\r\n    bool rebuildOnChange = false,\r\n  }) {\r\n    final Type type = _type<_InheritedModel<T>>();\r\n\r\n    Widget widget = rebuildOnChange\r\n        ? context.inheritFromWidgetOfExactType(type)\r\n        : context.ancestorWidgetOfExactType(type);\r\n\r\n    if (widget == null) {\r\n      throw new ScopedModelError();\r\n    } else {\r\n      return (widget as _InheritedModel<T>).model;\r\n    }\r\n  }\r\n\r\n  static Type _type<T>() => T;\r\n}\r\n```\r\n\r\n`ScopedModel`并没有在自身方法中调用`Model`的`addListener`和`removeListener`。\r\n\r\n而是交给了`AnimatedBuilder`去处理，这时我们需要进去看看它是如何处理的。\r\n\r\n## AnimatedBuilder源码\r\n\r\n`AnimatedBuilder`很简单，只是在`build`方法中直接调用了外部实现的`builder`方法：\r\n\r\n```dart\r\nclass AnimatedBuilder extends AnimatedWidget {\r\n  const AnimatedBuilder({\r\n    Key key,\r\n    @required Listenable animation,\r\n    @required this.builder,\r\n    this.child,\r\n  }) : assert(animation != null),\r\n       assert(builder != null),\r\n       super(key: key, listenable: animation);\r\n\r\n  \/\/\/ Called every time the animation changes value.\r\n  final TransitionBuilder builder;\r\n  final Widget child;\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return builder(context, child);\r\n  }\r\n}\r\n```\r\n\r\n但是我们发现实参`model`在这里以`animation`名称继续向父类传递。\r\n\r\n那我们只能从其父类入手：\r\n\r\n```dart\r\nabstract class AnimatedWidget extends StatefulWidget {\r\n  \/\/\/ Creates a widget that rebuilds when the given listenable changes.\r\n  \/\/\/\r\n  \/\/\/ The [listenable] argument is required.\r\n  const AnimatedWidget({\r\n    Key key,\r\n    @required this.listenable,\r\n  }) : assert(listenable != null),\r\n       super(key: key);\r\n\r\n  \/\/\/ The [Listenable] to which this widget is listening.\r\n  \/\/\/\r\n  \/\/\/ Commonly an [Animation] or a [ChangeNotifier].\r\n  final Listenable listenable;\r\n\r\n  \/\/\/ Override this method to build widgets that depend on the state of the\r\n  \/\/\/ listenable (e.g., the current value of the animation).\r\n  @protected\r\n  Widget build(BuildContext context);\r\n\r\n  \/\/\/ Subclasses typically do not override this method.\r\n  @override\r\n  _AnimatedState createState() => _AnimatedState();\r\n\r\n  @override\r\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\r\n    super.debugFillProperties(properties);\r\n    properties.add(DiagnosticsProperty<Listenable>('animation', listenable));\r\n  }\r\n}\r\n\r\nclass _AnimatedState extends State<AnimatedWidget> {\r\n  @override\r\n  void initState() {\r\n    super.initState();\r\n    widget.listenable.addListener(_handleChange);\r\n  }\r\n\r\n  @override\r\n  void didUpdateWidget(AnimatedWidget oldWidget) {\r\n    super.didUpdateWidget(oldWidget);\r\n    if (widget.listenable != oldWidget.listenable) {\r\n      oldWidget.listenable.removeListener(_handleChange);\r\n      widget.listenable.addListener(_handleChange);\r\n    }\r\n  }\r\n\r\n  @override\r\n  void dispose() {\r\n    widget.listenable.removeListener(_handleChange);\r\n    super.dispose();\r\n  }\r\n\r\n  void _handleChange() {\r\n    setState(() {\r\n      \/\/ The listenable's state is our build state, and it changed already.\r\n    });\r\n  }\r\n\r\n  @override\r\n  Widget build(BuildContext context) => widget.build(context);\r\n}\r\n```\r\n\r\n由于`AnimatedWidget`是`StatefulWidget`，\r\n\r\n所以主要看`_AnimatedState`即可，\r\n\r\n我们发现在`initState`方法中调用了`addListener`,\r\n\r\n在`dispose`调用了`removeListener`，\r\n\r\n传入的函数参数是`_handleChange`：\r\n\r\n```\r\n  void _handleChange() {\r\n    setState(() {\r\n      \/\/ The listenable's state is our build state, and it changed already.\r\n    });\r\n  }\r\n```\r\n\r\n而这只是简单地调用了`setState`，意图rebuilt。\r\n\r\n目前为止的流程是使用`ScopedModel`时，会调用`addListener`添加事件监听。\r\n\r\n当我们调用`ScopedModel.of<AppMoudle>(context).update(name);`时，\r\n\r\n调用了`notifyListeners`，遍历出`VoidCallback`，这里是`_handleChange`调用函数。\r\n\r\n调用`setState`后标记当前Element为dirty。\r\n\r\n当`BuildOwner`遍历`_dirtyElements`执行`rebuild`时，调用到`performRebuild`：\r\n\r\n```dart\r\n @override\r\n  void performRebuild() {\r\n    if (!kReleaseMode && debugProfileBuildsEnabled)\r\n      Timeline.startSync('${widget.runtimeType}',  arguments: timelineWhitelistArguments);\r\n\r\n    assert(_debugSetAllowIgnoredCallsToMarkNeedsBuild(true));\r\n    Widget built;\r\n    try {\r\n      assert(() {\r\n        _debugDoingBuild = true;\r\n        return true;\r\n      }());\r\n      built = build();\r\n      assert(() {\r\n        _debugDoingBuild = false;\r\n        return true;\r\n      }());\r\n      debugWidgetBuilderValue(widget, built);\r\n    } catch (e, stack) {\r\n      _debugDoingBuild = false;\r\n      built = ErrorWidget.builder(\r\n        _debugReportException(\r\n          ErrorDescription('building $this'),\r\n          e,\r\n          stack,\r\n          informationCollector: () sync* {\r\n            yield DiagnosticsDebugCreator(DebugCreator(this));\r\n          },\r\n        ),\r\n      );\r\n    } finally {\r\n      \/\/ We delay marking the element as clean until after calling build() so\r\n      \/\/ that attempts to markNeedsBuild() during build() will be ignored.\r\n      _dirty = false;\r\n      assert(_debugSetAllowIgnoredCallsToMarkNeedsBuild(false));\r\n    }\r\n    try {\r\n      _child = updateChild(_child, built, slot);\r\n      assert(_child != null);\r\n    } catch (e, stack) {\r\n      built = ErrorWidget.builder(\r\n        _debugReportException(\r\n          ErrorDescription('building $this'),\r\n          e,\r\n          stack,\r\n          informationCollector: () sync* {\r\n            yield DiagnosticsDebugCreator(DebugCreator(this));\r\n          },\r\n        ),\r\n      );\r\n      _child = updateChild(null, built, slot);\r\n    }\r\n\r\n    if (!kReleaseMode && debugProfileBuildsEnabled)\r\n      Timeline.finishSync();\r\n  }\r\n```\r\n\r\n其中调用`built = build();`这里的`build`最终回调我们在`ScopedModel`中为 \r\n\r\n`AnimatedBuilder`实现的`builder`函数，此时`built`是`_InheritedModel`类型实例。\r\n\r\n接下来执行`updateChild`，由于是rebuild，所以`child!=null`。会执行下面的else if代码：\r\n\r\n```dart\r\n      if (hasSameSuperclass && child.widget == newWidget) {\r\n        if (child.slot != newSlot)\r\n          updateSlotForChild(child, newSlot);\r\n        newChild = child;\r\n      } else if (hasSameSuperclass && Widget.canUpdate(child.widget, newWidget)) {\r\n        if (child.slot != newSlot)\r\n          updateSlotForChild(child, newSlot);\r\n        child.update(newWidget);\r\n        assert(child.widget == newWidget);\r\n        assert(() {\r\n          child.owner._debugElementWasRebuilt(child);\r\n          return true;\r\n        }());\r\n        newChild = child;\r\n      } else {\r\n        deactivateChild(child);\r\n        assert(child._parent == null);\r\n        newChild = inflateWidget(newWidget, newSlot);\r\n      }\r\n```\r\n\r\n在调用` child.update(newWidget);`时，这里的`child`其实是`InheritedElement`，\r\n\r\n所以它的`update`实现为：\r\n\r\n```dart\r\n  @override\r\n  void update(ProxyWidget newWidget) {\r\n    final ProxyWidget oldWidget = widget;\r\n    assert(widget != null);\r\n    assert(widget != newWidget);\r\n    super.update(newWidget);\r\n    assert(widget == newWidget);\r\n    updated(oldWidget);\r\n    _dirty = true;\r\n    rebuild();\r\n  }\r\n```\r\n\r\n这里的流程很简单\r\n\r\n通过`super.update(newWidget);`把当前Element的`_widget`设置为`newWidget`。\r\n\r\n然后通过`updated(oldWidget);`调用`notifyClients`告知所有通过`ScopedModel.of`方式获取数据的Widget该刷新了。\r\n\r\n通过`ScopedModel.of`方式获取数据，除了我们直接使用这种方式，那么就剩下`ScopedModelDescendant`了。\r\n\r\n## ScopedModelDescendant源码\r\n\r\nScopedModelDescendant只是帮我们获取到了数据并通过`builder`函数返回给我们`Model`\r\n\r\n```dart\r\nclass ScopedModelDescendant<T extends Model> extends StatelessWidget {\r\n  \/\/\/ Called whenever the [Model] changes.\r\n  final ScopedModelDescendantBuilder<T> builder;\r\n\r\n  \/\/\/ An optional constant child that does not depend on the model.  This will\r\n  \/\/\/ be passed as the child of [builder].\r\n  final Widget child;\r\n\r\n  \/\/\/ An optional constant that determines whether the\r\n  final bool rebuildOnChange;\r\n\r\n  \/\/\/ Constructor.\r\n  ScopedModelDescendant({\r\n    @required this.builder,\r\n    this.child,\r\n    this.rebuildOnChange = true,\r\n  });\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return builder(\r\n      context,\r\n      child,\r\n      ScopedModel.of<T>(context, rebuildOnChange: rebuildOnChange),\r\n    );\r\n  }\r\n}\r\n```\r\n\r\n# 0x03 结尾\r\n\r\nscoped_model和使用起来和Provider基本一样。\r\n\r\n但是scoped_model实现精简，导致不能像Provider那样精细化控制某一个类乃至某一属性更新才刷新Widget。\r\n\r\n像上面实现的那样，当Card更新时，由于scoped_model实现，UserInfoByScoped相关Widget也会刷新，造成性能问题。"
  },
  {
    "title": "为何Flutter状态管理框架只能用在root widget(源码分析)",
    "created_time": "2020-07-02 09:47:54",
    "body": "# 0x00 前言\r\n\r\n在试用状态框架时发现一个问题就是：\r\n\r\n**状态管理框架的xxProvider Widget只能用在Root Widget。**\r\n\r\n**用在HomePage时，其他Page获取不到。**\r\n\r\n现在就看看是什么原因造成的。\r\n\r\n# 0x01 分析\r\n\r\n\r\n\r\nApp启动时的Root Widget一般我们使用`MaterialApp`。\r\n\r\n所以分析就从这个Widget开始入手。\r\n\r\n## MaterialApp\r\n\r\nMaterialApp一般会设置home属性：\r\n\r\n```dart\r\nMaterialApp(\r\n            home: ScopedHomePage(),\r\n          )\r\n```\r\n\r\n它是一个`StatefulWidget`，\r\n\r\n在其对应的`_MaterialAppState`的`build`方法实现为：\r\n\r\n```dart\r\n @override\r\n  Widget build(BuildContext context) {\r\n    Widget result = HeroControllerScope(\r\n      controller: _heroController,\r\n      child: WidgetsApp(\r\n        key: GlobalObjectKey(this),\r\n        navigatorKey: widget.navigatorKey,\r\n        navigatorObservers: widget.navigatorObservers,\r\n        pageRouteBuilder: <T>(RouteSettings settings, WidgetBuilder builder) {\r\n          return MaterialPageRoute<T>(settings: settings, builder: builder);\r\n        },\r\n        home: widget.home,\r\n        routes: widget.routes,\r\n        initialRoute: widget.initialRoute,\r\n        onGenerateRoute: widget.onGenerateRoute,\r\n        onGenerateInitialRoutes: widget.onGenerateInitialRoutes,\r\n        onUnknownRoute: widget.onUnknownRoute,\r\n        builder: (BuildContext context, Widget child) {\r\n          \/\/ Use a light theme, dark theme, or fallback theme.\r\n          final ThemeMode mode = widget.themeMode ?? ThemeMode.system;\r\n          ThemeData theme;\r\n          if (widget.darkTheme != null) {\r\n            final ui.Brightness platformBrightness = MediaQuery.platformBrightnessOf(context);\r\n            if (mode == ThemeMode.dark ||\r\n              (mode == ThemeMode.system && platformBrightness == ui.Brightness.dark)) {\r\n              theme = widget.darkTheme;\r\n            }\r\n          }\r\n          theme ??= widget.theme ?? ThemeData.fallback();\r\n\r\n          return AnimatedTheme(\r\n            data: theme,\r\n            isMaterialAppTheme: true,\r\n            child: widget.builder != null\r\n              ? Builder(\r\n                  builder: (BuildContext context) {\r\n                    \/\/ Why are we surrounding a builder with a builder?\r\n                    \/\/\r\n                    \/\/ The widget.builder may contain code that invokes\r\n                    \/\/ Theme.of(), which should return the theme we selected\r\n                    \/\/ above in AnimatedTheme. However, if we invoke\r\n                    \/\/ widget.builder() directly as the child of AnimatedTheme\r\n                    \/\/ then there is no Context separating them, and the\r\n                    \/\/ widget.builder() will not find the theme. Therefore, we\r\n                    \/\/ surround widget.builder with yet another builder so that\r\n                    \/\/ a context separates them and Theme.of() correctly\r\n                    \/\/ resolves to the theme we passed to AnimatedTheme.\r\n                    return widget.builder(context, child);\r\n                  },\r\n                )\r\n              : child,\r\n          );\r\n        },\r\n        title: widget.title,\r\n        onGenerateTitle: widget.onGenerateTitle,\r\n        textStyle: _errorTextStyle,\r\n        \/\/ The color property is always pulled from the light theme, even if dark\r\n        \/\/ mode is activated. This was done to simplify the technical details\r\n        \/\/ of switching themes and it was deemed acceptable because this color\r\n        \/\/ property is only used on old Android OSes to color the app bar in\r\n        \/\/ Android's switcher UI.\r\n        \/\/\r\n        \/\/ blue is the primary color of the default theme\r\n        color: widget.color ?? widget.theme?.primaryColor ?? Colors.blue,\r\n        locale: widget.locale,\r\n        localizationsDelegates: _localizationsDelegates,\r\n        localeResolutionCallback: widget.localeResolutionCallback,\r\n        localeListResolutionCallback: widget.localeListResolutionCallback,\r\n        supportedLocales: widget.supportedLocales,\r\n        showPerformanceOverlay: widget.showPerformanceOverlay,\r\n        checkerboardRasterCacheImages: widget.checkerboardRasterCacheImages,\r\n        checkerboardOffscreenLayers: widget.checkerboardOffscreenLayers,\r\n        showSemanticsDebugger: widget.showSemanticsDebugger,\r\n        debugShowCheckedModeBanner: widget.debugShowCheckedModeBanner,\r\n        inspectorSelectButtonBuilder: (BuildContext context, VoidCallback onPressed) {\r\n          return FloatingActionButton(\r\n            child: const Icon(Icons.search),\r\n            onPressed: onPressed,\r\n            mini: true,\r\n          );\r\n        },\r\n        shortcuts: widget.shortcuts,\r\n        actions: widget.actions,\r\n      ),\r\n    );\r\n\r\n    assert(() {\r\n      if (widget.debugShowMaterialGrid) {\r\n        result = GridPaper(\r\n          color: const Color(0xE0F9BBE0),\r\n          interval: 8.0,\r\n          divisions: 2,\r\n          subdivisions: 1,\r\n          child: result,\r\n        );\r\n      }\r\n      return true;\r\n    }());\r\n\r\n    return ScrollConfiguration(\r\n      behavior: _MaterialScrollBehavior(),\r\n      child: result,\r\n    );\r\n  }\r\n```\r\n\r\n可以看到`HeroControllerScope`的`child`设置了`WidgetsApp`，\r\n\r\n在外层的`home`属性被设置到了`WidgetsApp`。\r\n\r\n\r\n\r\n## WidgetsApp\r\n\r\n`WidgetsApp`也是一个`StatefulWidget`，\r\n\r\n在其对应的`_WidgetsAppState`的`build`方法实现为：\r\n\r\n```dart\r\n@override\r\n  Widget build(BuildContext context) {\r\n    Widget navigator;\r\n    if (_navigator != null) {\r\n      navigator = Navigator(\r\n        key: _navigator,\r\n        \/\/ If window.defaultRouteName isn't '\/', we should assume it was set\r\n        \/\/ intentionally via `setInitialRoute`, and should override whatever\r\n        \/\/ is in [widget.initialRoute].\r\n        initialRoute: WidgetsBinding.instance.window.defaultRouteName != Navigator.defaultRouteName\r\n            ? WidgetsBinding.instance.window.defaultRouteName\r\n            : widget.initialRoute ?? WidgetsBinding.instance.window.defaultRouteName,\r\n        onGenerateRoute: _onGenerateRoute,\r\n        onGenerateInitialRoutes: widget.onGenerateInitialRoutes == null\r\n          ? Navigator.defaultGenerateInitialRoutes\r\n          : (NavigatorState navigator, String initialRouteName) {\r\n            return widget.onGenerateInitialRoutes(initialRouteName);\r\n          },\r\n        onUnknownRoute: _onUnknownRoute,\r\n        observers: widget.navigatorObservers,\r\n      );\r\n    }\r\n\r\n    Widget result;\r\n    if (widget.builder != null) {\r\n      result = Builder(\r\n        builder: (BuildContext context) {\r\n          return widget.builder(context, navigator);\r\n        },\r\n      );\r\n    } else {\r\n      assert(navigator != null);\r\n      result = navigator;\r\n    }\r\n\r\n    if (widget.textStyle != null) {\r\n      result = DefaultTextStyle(\r\n        style: widget.textStyle,\r\n        child: result,\r\n      );\r\n    }\r\n\r\n    PerformanceOverlay performanceOverlay;\r\n    \/\/ We need to push a performance overlay if any of the display or checkerboarding\r\n    \/\/ options are set.\r\n    if (widget.showPerformanceOverlay || WidgetsApp.showPerformanceOverlayOverride) {\r\n      performanceOverlay = PerformanceOverlay.allEnabled(\r\n        checkerboardRasterCacheImages: widget.checkerboardRasterCacheImages,\r\n        checkerboardOffscreenLayers: widget.checkerboardOffscreenLayers,\r\n      );\r\n    } else if (widget.checkerboardRasterCacheImages || widget.checkerboardOffscreenLayers) {\r\n      performanceOverlay = PerformanceOverlay(\r\n        checkerboardRasterCacheImages: widget.checkerboardRasterCacheImages,\r\n        checkerboardOffscreenLayers: widget.checkerboardOffscreenLayers,\r\n      );\r\n    }\r\n    if (performanceOverlay != null) {\r\n      result = Stack(\r\n        children: <Widget>[\r\n          result,\r\n          Positioned(top: 0.0, left: 0.0, right: 0.0, child: performanceOverlay),\r\n        ],\r\n      );\r\n    }\r\n\r\n    if (widget.showSemanticsDebugger) {\r\n      result = SemanticsDebugger(\r\n        child: result,\r\n      );\r\n    }\r\n\r\n    assert(() {\r\n      if (widget.debugShowWidgetInspector || WidgetsApp.debugShowWidgetInspectorOverride) {\r\n        result = WidgetInspector(\r\n          child: result,\r\n          selectButtonBuilder: widget.inspectorSelectButtonBuilder,\r\n        );\r\n      }\r\n      if (widget.debugShowCheckedModeBanner && WidgetsApp.debugAllowBannerOverride) {\r\n        result = CheckedModeBanner(\r\n          child: result,\r\n        );\r\n      }\r\n      return true;\r\n    }());\r\n\r\n    Widget title;\r\n    if (widget.onGenerateTitle != null) {\r\n      title = Builder(\r\n        \/\/ This Builder exists to provide a context below the Localizations widget.\r\n        \/\/ The onGenerateTitle callback can refer to Localizations via its context\r\n        \/\/ parameter.\r\n        builder: (BuildContext context) {\r\n          final String title = widget.onGenerateTitle(context);\r\n          assert(title != null, 'onGenerateTitle must return a non-null String');\r\n          return Title(\r\n            title: title,\r\n            color: widget.color,\r\n            child: result,\r\n          );\r\n        },\r\n      );\r\n    } else {\r\n      title = Title(\r\n        title: widget.title,\r\n        color: widget.color,\r\n        child: result,\r\n      );\r\n    }\r\n\r\n    final Locale appLocale = widget.locale != null\r\n      ? _resolveLocales(<Locale>[widget.locale], widget.supportedLocales)\r\n      : _locale;\r\n\r\n    assert(_debugCheckLocalizations(appLocale));\r\n    return Shortcuts(\r\n      shortcuts: widget.shortcuts ?? WidgetsApp.defaultShortcuts,\r\n      debugLabel: '<Default WidgetsApp Shortcuts>',\r\n      child: Actions(\r\n        actions: widget.actions ?? WidgetsApp.defaultActions,\r\n        child: FocusTraversalGroup(\r\n          policy: ReadingOrderTraversalPolicy(),\r\n          child: _MediaQueryFromWindow(\r\n            child: Localizations(\r\n              locale: appLocale,\r\n              delegates: _localizationsDelegates.toList(),\r\n              child: title,\r\n            ),\r\n          ),\r\n        ),\r\n      ),\r\n    );\r\n  }\r\n```\r\n\r\n`build`方法一开始就判断了`_navigator`是否为空，如果不为空则创建一个`Navigator`控件。\r\n\r\n那么`_navigator`到底为空吗？\r\n\r\n在`initState`中调用了`_updateNavigator`方法：\r\n\r\n```dart\r\n  void _updateNavigator() {\r\n    _navigator = widget.navigatorKey ?? GlobalObjectKey<NavigatorState>(this);\r\n  }\r\n```\r\n\r\n看来`_navigator`是有值的。\r\n\r\n那么就会执行：\r\n\r\n```dart\r\n      navigator = Navigator(\r\n        key: _navigator,\r\n        \/\/ If window.defaultRouteName isn't '\/', we should assume it was set\r\n        \/\/ intentionally via `setInitialRoute`, and should override whatever\r\n        \/\/ is in [widget.initialRoute].\r\n        initialRoute: WidgetsBinding.instance.window.defaultRouteName != Navigator.defaultRouteName\r\n            ? WidgetsBinding.instance.window.defaultRouteName\r\n            : widget.initialRoute ?? WidgetsBinding.instance.window.defaultRouteName,\r\n        onGenerateRoute: _onGenerateRoute,\r\n        onGenerateInitialRoutes: widget.onGenerateInitialRoutes == null\r\n          ? Navigator.defaultGenerateInitialRoutes\r\n          : (NavigatorState navigator, String initialRouteName) {\r\n            return widget.onGenerateInitialRoutes(initialRouteName);\r\n          },\r\n        onUnknownRoute: _onUnknownRoute,\r\n        observers: widget.navigatorObservers,\r\n      );\r\n```\r\n\r\n在这里有一个函数参数`onGenerateRoute`，给它的赋值`_onGenerateRoute`实现为：\r\n\r\n```dart\r\nRoute<dynamic> _onGenerateRoute(RouteSettings settings) {\r\n    final String name = settings.name;\r\n    final WidgetBuilder pageContentBuilder = name == Navigator.defaultRouteName && widget.home != null\r\n        ? (BuildContext context) => widget.home\r\n        : widget.routes[name];\r\n\r\n    if (pageContentBuilder != null) {\r\n      assert(widget.pageRouteBuilder != null,\r\n        'The default onGenerateRoute handler for WidgetsApp must have a '\r\n        'pageRouteBuilder set if the home or routes properties are set.');\r\n      final Route<dynamic> route = widget.pageRouteBuilder<dynamic>(\r\n        settings,\r\n        pageContentBuilder,\r\n      );\r\n      assert(route != null,\r\n        'The pageRouteBuilder for WidgetsApp must return a valid non-null Route.');\r\n      return route;\r\n    }\r\n    if (widget.onGenerateRoute != null)\r\n      return widget.onGenerateRoute(settings);\r\n    return null;\r\n  }\r\n```\r\n\r\n可以看到如果`name == Navigator.defaultRouteName && widget.home != null`成立，\r\n\r\n返回`(BuildContext context) => widget.home`赋值给`pageContentBuilder`。\r\n\r\n紧接着调用了`widget.pageRouteBuilder`，把得到的`pageContentBuilder`作为参数传入返回`route`。\r\n\r\n那么这个`widget.pageRouteBuilder`是如何实现的？\r\n\r\n看一下`MaterialApp`状态的`build`中有实现：\r\n\r\n```dart\r\npageRouteBuilder: <T>(RouteSettings settings, WidgetBuilder builder) {\r\n          return MaterialPageRoute<T>(settings: settings, builder: builder);\r\n        }\r\n```\r\n\r\n可以看到我们最初的`home`属性经过一些列操作被包装到了`MaterialPageRoute`。\r\n\r\n这个类熟悉吗？\r\n\r\n我们跳转打开新页面时经常使用的那句：\r\n\r\n```dart\r\nNavigator.of(context)\r\n                .push(MaterialPageRoute(builder: (_) => ScopedSecondPage()));\r\n```\r\n\r\n这`home`设置的页面和我们直接跳转是否有所不同，还不能直接下结论。\r\n\r\n回过头还要继续往下看。\r\n\r\n\r\n\r\n## Navigator\r\n\r\n它对应的`NavigatorState`。\r\n\r\n在`initState`有这样一段实现：\r\n\r\n```dart\r\nString initialRoute = widget.initialRoute;\r\n    if (widget.pages.isNotEmpty) {\r\n      _history.addAll(\r\n        widget.pages.map((Page<dynamic> page) => _RouteEntry(\r\n          page.createRoute(context),\r\n          initialState: _RouteLifecycle.add,\r\n        ))\r\n      );\r\n    } else {\r\n      \/\/ If there is no page provided, we will need to provide default route\r\n      \/\/ to initialize the navigator.\r\n      initialRoute = initialRoute ?? Navigator.defaultRouteName;\r\n    }\r\n    if (initialRoute != null) {\r\n      _history.addAll(\r\n        widget.onGenerateInitialRoutes(\r\n          this,\r\n          widget.initialRoute ?? Navigator.defaultRouteName\r\n        ).map((Route<dynamic> route) =>\r\n          _RouteEntry(\r\n            route,\r\n            initialState: _RouteLifecycle.add,\r\n          ),\r\n        ),\r\n      );\r\n    }\r\n```\r\n\r\n`initialRoute`在`WidgetsApp`中已经赋值了，所以这里不会为null。\r\n\r\n那么自然会执行`_history.addAll`，\r\n\r\n首先`widget.onGenerateInitialRoutes`生成`List<Route>`，通过`map`转成`_RouteEntry`。\r\n\r\n然后紧接着执行`_flushHistoryUpdates`方法，实现为：\r\n\r\n```dart\r\nvoid _flushHistoryUpdates({bool rearrangeOverlay = true}) {\r\n    assert(_debugLocked && !_debugUpdatingPage);\r\n    \/\/ Clean up the list, sending updates to the routes that changed. Notably,\r\n    \/\/ we don't send the didChangePrevious\/didChangeNext updates to those that\r\n    \/\/ did not change at this point, because we're not yet sure exactly what the\r\n    \/\/ routes will be at the end of the day (some might get disposed).\r\n    int index = _history.length - 1;\r\n    _RouteEntry next;\r\n    _RouteEntry entry = _history[index];\r\n    _RouteEntry previous = index > 0 ? _history[index - 1] : null;\r\n    bool canRemoveOrAdd = false; \/\/ Whether there is a fully opaque route on top to silently remove or add route underneath.\r\n    Route<dynamic> poppedRoute; \/\/ The route that should trigger didPopNext on the top active route.\r\n    bool seenTopActiveRoute = false; \/\/ Whether we've seen the route that would get didPopNext.\r\n    final List<_RouteEntry> toBeDisposed = <_RouteEntry>[];\r\n    while (index >= 0) {\r\n      switch (entry.currentState) {\r\n        case _RouteLifecycle.add:\r\n          assert(rearrangeOverlay);\r\n          entry.handleAdd(\r\n            navigator: this,\r\n            previousPresent: _getRouteBefore(index - 1, _RouteEntry.isPresentPredicate)?.route,\r\n          );\r\n          assert(entry.currentState == _RouteLifecycle.adding);\r\n          continue;\r\n        case _RouteLifecycle.adding:\r\n          if (canRemoveOrAdd || next == null) {\r\n            entry.didAdd(\r\n              navigator: this,\r\n              isNewFirst: next == null\r\n            );\r\n            assert(entry.currentState == _RouteLifecycle.idle);\r\n            continue;\r\n          }\r\n          break;\r\n        case _RouteLifecycle.push:\r\n        case _RouteLifecycle.pushReplace:\r\n        case _RouteLifecycle.replace:\r\n          assert(rearrangeOverlay);\r\n          entry.handlePush(\r\n            navigator: this,\r\n            previous: previous?.route,\r\n            previousPresent: _getRouteBefore(index - 1, _RouteEntry.isPresentPredicate)?.route,\r\n            isNewFirst: next == null,\r\n          );\r\n          assert(entry.currentState != _RouteLifecycle.push);\r\n          assert(entry.currentState != _RouteLifecycle.pushReplace);\r\n          assert(entry.currentState != _RouteLifecycle.replace);\r\n          if (entry.currentState == _RouteLifecycle.idle) {\r\n            continue;\r\n          }\r\n          break;\r\n        case _RouteLifecycle.pushing: \/\/ Will exit this state when animation completes.\r\n          if (!seenTopActiveRoute && poppedRoute != null)\r\n            entry.handleDidPopNext(poppedRoute);\r\n          seenTopActiveRoute = true;\r\n          break;\r\n        case _RouteLifecycle.idle:\r\n          if (!seenTopActiveRoute && poppedRoute != null)\r\n            entry.handleDidPopNext(poppedRoute);\r\n          seenTopActiveRoute = true;\r\n          \/\/ This route is idle, so we are allowed to remove subsequent (earlier)\r\n          \/\/ routes that are waiting to be removed silently:\r\n          canRemoveOrAdd = true;\r\n          break;\r\n        case _RouteLifecycle.pop:\r\n          if (!seenTopActiveRoute) {\r\n            if (poppedRoute != null)\r\n              entry.handleDidPopNext(poppedRoute);\r\n            poppedRoute = entry.route;\r\n          }\r\n          entry.handlePop(\r\n            navigator: this,\r\n            previousPresent: _getRouteBefore(index, _RouteEntry.willBePresentPredicate)?.route,\r\n          );\r\n          assert(entry.currentState == _RouteLifecycle.popping);\r\n          canRemoveOrAdd = true;\r\n          break;\r\n        case _RouteLifecycle.popping:\r\n          \/\/ Will exit this state when animation completes.\r\n          break;\r\n        case _RouteLifecycle.remove:\r\n          if (!seenTopActiveRoute) {\r\n            if (poppedRoute != null)\r\n              entry.route.didPopNext(poppedRoute);\r\n            poppedRoute = null;\r\n          }\r\n          entry.handleRemoval(\r\n            navigator: this,\r\n            previousPresent: _getRouteBefore(index, _RouteEntry.willBePresentPredicate)?.route,\r\n          );\r\n          assert(entry.currentState == _RouteLifecycle.removing);\r\n          continue;\r\n        case _RouteLifecycle.removing:\r\n          if (!canRemoveOrAdd && next != null) {\r\n            \/\/ We aren't allowed to remove this route yet.\r\n            break;\r\n          }\r\n          entry.currentState = _RouteLifecycle.dispose;\r\n          continue;\r\n        case _RouteLifecycle.dispose:\r\n          \/\/ Delay disposal until didChangeNext\/didChangePrevious have been sent.\r\n          toBeDisposed.add(_history.removeAt(index));\r\n          entry = next;\r\n          break;\r\n        case _RouteLifecycle.disposed:\r\n        case _RouteLifecycle.staging:\r\n          assert(false);\r\n          break;\r\n      }\r\n      index -= 1;\r\n      next = entry;\r\n      entry = previous;\r\n      previous = index > 0 ? _history[index - 1] : null;\r\n    }\r\n\r\n    \/\/ Informs navigator observers about route changes.\r\n    _flushObserverNotifications();\r\n\r\n    \/\/ Now that the list is clean, send the didChangeNext\/didChangePrevious\r\n    \/\/ notifications.\r\n    _flushRouteAnnouncement();\r\n\r\n    \/\/ Announces route name changes.\r\n    final _RouteEntry lastEntry = _history.lastWhere(_RouteEntry.isPresentPredicate, orElse: () => null);\r\n    final String routeName = lastEntry?.route?.settings?.name;\r\n    if (routeName != _lastAnnouncedRouteName) {\r\n      RouteNotificationMessages.maybeNotifyRouteChange(routeName, _lastAnnouncedRouteName);\r\n      _lastAnnouncedRouteName = routeName;\r\n    }\r\n\r\n    \/\/ Lastly, removes the overlay entries of all marked entries and disposes\r\n    \/\/ them.\r\n    for (final _RouteEntry entry in toBeDisposed) {\r\n      for (final OverlayEntry overlayEntry in entry.route.overlayEntries)\r\n        overlayEntry.remove();\r\n      entry.dispose();\r\n    }\r\n    if (rearrangeOverlay)\r\n      overlay?.rearrange(_allRouteOverlayEntries);\r\n  }\r\n```\r\n\r\n这个方法就是根据`_RouteLifecycle`不同的生命周期状态执行不同的操作。\r\n\r\n其中当我们执行到\r\n\r\n`_RouteLifecycle.add`、\r\n\r\n`_RouteLifecycle.push`、\r\n\r\n`_RouteLifecycle.pushReplace`\r\n\r\n`_RouteLifecycle.replace`这些操作时，会执行`route.install()`方法：\r\n\r\n```dart\r\n  @override\r\n  void install() {\r\n    assert(_overlayEntries.isEmpty);\r\n    _overlayEntries.addAll(createOverlayEntries());\r\n    super.install();\r\n  }\r\n```\r\n\r\n其中`createOverlayEntries`执行时会创建`OverlayEntry`。\r\n\r\n其中的参数`builder`赋值`_buildModalScope`，\r\n\r\n这里最终会回调到`MaterialPageRoute(builder: (_) => ScopedSecondPage())`中的`builder`。\r\n\r\n也就是说之前Page设置的Widget。现在被以`builder`函数形式存放到了**OverlayEntry**中。\r\n\r\n其中`_overlayEntries`就是当前`route`的属性，以`overlayEntries`名称对外提供。\r\n\r\n以上这些操作是在`initState`方法中进行的。\r\n\r\n下面看看`build`方法：\r\n\r\n```dart\r\n@override\r\n  Widget build(BuildContext context) {\r\n    assert(!_debugLocked);\r\n    assert(_history.isNotEmpty);\r\n    \/\/ Hides the HeroControllerScope for the widget subtree so that the other\r\n    \/\/ nested navigator underneath will not pick up the hero controller above\r\n    \/\/ this level.\r\n    return HeroControllerScope(\r\n      child: Listener(\r\n        onPointerDown: _handlePointerDown,\r\n        onPointerUp: _handlePointerUpOrCancel,\r\n        onPointerCancel: _handlePointerUpOrCancel,\r\n        child: AbsorbPointer(\r\n          absorbing: false, \/\/ it's mutated directly by _cancelActivePointers above\r\n          child: FocusScope(\r\n            node: focusScopeNode,\r\n            autofocus: true,\r\n            child: Overlay(\r\n              key: _overlayKey,\r\n              initialEntries: overlay == null ?  _allRouteOverlayEntries.toList(growable: false) : const <OverlayEntry>[],\r\n            ),\r\n          ),\r\n        ),\r\n      ),\r\n    );\r\n  }\r\n```\r\n\r\n可以看到终点是`Overlay`，通过`initialEntries`参数接收`_allRouteOverlayEntries`的值。\r\n\r\n这里的`_allRouteOverlayEntries`就是从上面创建的`overlayEntries`集合：\r\n\r\n```dart\r\n  Iterable<OverlayEntry> get _allRouteOverlayEntries sync* {\r\n    for (final _RouteEntry entry in _history)\r\n      yield* entry.route.overlayEntries;\r\n  }\r\n```\r\n\r\n\r\n\r\n## Overlay\r\n\r\n那么`Overlay`接收到`overlayEntries`如何处理的呢？\r\n\r\n在`OverlayState`中的`initState`里，把数据全部添加到了`List<OverlayEntry> _entries`。\r\n\r\n```dart\r\n @override\r\n  Widget build(BuildContext context) {\r\n    \/\/ This list is filled backwards and then reversed below before\r\n    \/\/ it is added to the tree.\r\n    final List<Widget> children = <Widget>[];\r\n    bool onstage = true;\r\n    int onstageCount = 0;\r\n    for (int i = _entries.length - 1; i >= 0; i -= 1) {\r\n      final OverlayEntry entry = _entries[i];\r\n      if (onstage) {\r\n        onstageCount += 1;\r\n        children.add(_OverlayEntryWidget(\r\n          key: entry._key,\r\n          entry: entry,\r\n        ));\r\n        if (entry.opaque)\r\n          onstage = false;\r\n      } else if (entry.maintainState) {\r\n        children.add(_OverlayEntryWidget(\r\n          key: entry._key,\r\n          entry: entry,\r\n          tickerEnabled: false,\r\n        ));\r\n      }\r\n    }\r\n    return _Theatre(\r\n      skipCount: children.length - onstageCount,\r\n      children: children.reversed.toList(growable: false),\r\n    );\r\n  }\r\n```\r\n\r\n在`build`中根据清情况遍历`_entries`，为每个`entry`外包裹一层`_OverlayEntryWidget`。\r\n\r\n并将`children`添加到`_Theatre`中。\r\n\r\n## _Theatre\r\n\r\n`_Theatre`是一种特殊的`Stack`。\r\n\r\n上面说了不管通过`home`属性设置还是通过`Navigator.of(context).push`都会调用`route.install`。\r\n\r\n而上面用到的`_entries`是所有`route`的`List<OverLayEntry>`集合。\r\n\r\n**由于`_Theatre`是一种`Stack`，**\r\n\r\n**也就是说`home`也好`push`也罢，所有页面都以children方式被`_Theatre`管理。**\r\n\r\n**所以所有页面是以兄弟形式存在，在Widget tree中它们是平级，**\r\n\r\n**所以在HomePage设置了xxProvider后，其他页面是不能获取到的**"
  },
  {
    "title": "Dio不打印请求头信息",
    "created_time": "2020-08-13 14:31:25",
    "body": "DioInspector->DioPluggableState->_ResponseCard->_ResponseCardState->\n\n```dart\n  Widget _detailedContent(BuildContext context) {\n    return ValueListenableBuilder<bool>(\n      valueListenable: _isExpanded,\n      builder: (_, bool value, __) {\n        if (!value) {\n          return const SizedBox.shrink();\n        }\n        return Container(\n          padding: const EdgeInsets.symmetric(vertical: 8),\n          child: Column(\n            crossAxisAlignment: CrossAxisAlignment.start,\n            children: <Widget>[\n              //这里添加一行\n                _TagText(tag: 'Request header', content: _request.headers.toString()),\n\n              if (_requestDataBuilder != null)\n                _TagText(tag: 'Request data', content: _requestDataBuilder!),\n              _TagText(tag: 'Response body', content: _responseDataBuilder),\n              _TagText(\n                tag: 'Response headers',\n                content: '\\n${_response.headers}',\n              ),\n            ],\n          ),\n        );\n      },\n    );\n  }\n```"
  },
  {
    "title": "Get.put对象如何自动被回收的(源码分析)",
    "created_time": "2020-08-15 14:31:25",
    "body": "# put的存储流程\n\n首先调用 **GetInstance()** 的**put** 方法：\n\n```dart\nS put<S>(S dependency,\n          {String? tag,\n          bool permanent = false,\n          InstanceBuilderCallback<S>? builder}) =>\n      GetInstance().put<S>(dependency, tag: tag, permanent: permanent);\n```\n\n进入这个方法发现先是插入数据，然后再查找返回：\n\n```dart\n  S put<S>(\n    S dependency, {\n    String? tag,\n    bool permanent = false,\n    @deprecated InstanceBuilderCallback<S>? builder,\n  }) {\n    _insert(\n        isSingleton: true,\n        name: tag,\n        permanent: permanent,\n        builder: builder ?? (() => dependency));\n    return find<S>(tag: tag);\n  }\n```\n\n所以我们使用某个共享对象时使用**Object obj = Get.put(Object())**。\n\n继续分析，\n\n调用 **_insert** 方法时根据**S**和**tag** 生成**key**然后存入到\n\n**static final Map<String, _InstanceBuilderFactory> _singl = {}** 中：\n\n```dart\n  void _insert<S>({\n    bool? isSingleton,\n    String? name,\n    bool permanent = false,\n    required InstanceBuilderCallback<S> builder,\n    bool fenix = false,\n  }) {\n    final key = _getKey(S, name);\n\n    if (_singl.containsKey(key)) {\n      final dep = _singl[key];\n      if (dep != null && dep.isDirty) {\n        _singl[key] = _InstanceBuilderFactory<S>(\n          isSingleton,\n          builder,\n          permanent,\n          false,\n          fenix,\n          name,\n          lateRemove: dep as _InstanceBuilderFactory<S>,\n        );\n      }\n    } else {\n      _singl[key] = _InstanceBuilderFactory<S>(\n        isSingleton,\n        builder,\n        permanent,\n        false,\n        fenix,\n        name,\n      );\n    }\n  }\n```\n\n然后分析**find**方法：\n\n```dart\n  S find<S>({String? tag}) {\n    final key = _getKey(S, tag);\n    if (isRegistered<S>(tag: tag)) {\n      final dep = _singl[key];\n      if (dep == null) {\n        if (tag == null) {\n          throw 'Class \"$S\" is not registered';\n        } else {\n          throw 'Class \"$S\" with tag \"$tag\" is not registered';\n        }\n      }\n      final i = _initDependencies<S>(name: tag);\n      return i ?? dep.getDependency() as S;\n    } else {\n      // ignore: lines_longer_than_80_chars\n      throw '\"$S\" not found. You need to call \"Get.put($S())\" or \"Get.lazyPut(()=>$S())\"';\n    }\n  }\n```\n\n这个时候**isRegistered**是返回**true**的，所以会执行 **_initDependencies**方法：\n\n```dart\n  S? _initDependencies<S>({String? name}) {\n    final key = _getKey(S, name);\n    final isInit = _singl[key]!.isInit;\n    S? i;\n    if (!isInit) {\n      i = _startController<S>(tag: name);\n      if (_singl[key]!.isSingleton!) {\n        _singl[key]!.isInit = true;\n        if (Get.smartManagement != SmartManagement.onlyBuilder) {\n          RouterReportManager.reportDependencyLinkedToRoute(_getKey(S, name));\n        }\n      }\n    }\n    return i;\n  }\n```\n\n在 **_insert**方法中构建 **_InstanceBuilderFactory**时**isInit**是**false**。\n\n所以这个会执行**if**。由于**Get.smartManagement**默认值是**full**：\n\n```dart\nSmartManagement smartManagement = SmartManagement.full;\n```\n\n所以会调用`RouterReportManager.reportDependencyLinkedToRoute(_getKey(S, name));`\n\n看下这个方法实现：\n\n```dart\n  static void reportDependencyLinkedToRoute(String depedencyKey) {\n    if (_current == null) return;\n    if (_routesKey.containsKey(_current)) {\n      _routesKey[_current!]!.add(depedencyKey);\n    } else {\n      _routesKey[_current] = <String>[depedencyKey];\n    }\n  }\n```\n\n这里 **_current**类型为`static Route? _current;`也就是当前页面对象，\n\n**_routesKey**类型为`static final Map<Route?, List<String>> _routesKey = {};`,\n\n这个 **_routesKey**存储的是当前页面所有调用**Get.put**时通过**S**和**tag**生成的**key**。\n\n也就是说我通过 **_routesKey**根据当前页面能拿到所有**key**，\n\n在**static final Map<String, _InstanceBuilderFactory> _singl = {}** 里**String**为**key**，**_InstanceBuilderFactory**中存储着我们创建的对象。\n\n下面分析页面弹出时流程\n\n# Get.back弹出流程\n\n看下**back**方法：\n\n```dart\n  void back<T>({\n    T? result,\n    bool closeOverlays = false,\n    bool canPop = true,\n    int? id,\n  }) {\n    if (isSnackbarOpen && !closeOverlays) {\n      closeCurrentSnackbar();\n      return;\n    }\n\n    if (closeOverlays && isOverlaysOpen) {\n      if (isSnackbarOpen) {\n        closeAllSnackbars();\n      }\n      navigator?.popUntil((route) {\n        return (!isDialogOpen! && !isBottomSheetOpen!);\n      });\n    }\n    if (canPop) {\n      if (global(id).currentState?.canPop() == true) {\n        global(id).currentState?.pop<T>(result);\n      }\n    } else {\n      global(id).currentState?.pop<T>(result);\n    }\n  }\n```\n\n可以看到最后主要调用**pop**方法，看下实现：\n\n```dart\n  void pop<T extends Object?>([ T? result ]) {\n    final _RouteEntry entry = _history.lastWhere(_RouteEntry.isPresentPredicate);\n    if (entry.hasPage) {\n      if (widget.onPopPage!(entry.route, result) && entry.currentState == _RouteLifecycle.idle) {\n        entry.currentState = _RouteLifecycle.pop;\n      }\n    } else {\n      entry.pop<T>(result);\n      assert (entry.currentState == _RouteLifecycle.pop);\n    }\n    if (entry.currentState == _RouteLifecycle.pop)\n      _flushHistoryUpdates(rearrangeOverlay: false);\n    _afterNavigation(entry.route);\n  }\n```\n\n这里主要看`_flushHistoryUpdates`方法：\n\n```dart\n  void _flushHistoryUpdates({bool rearrangeOverlay = true}) {\n    assert(_debugLocked && !_debugUpdatingPage);\n    _flushingHistory = true;\n    // Clean up the list, sending updates to the routes that changed. Notably,\n    // we don't send the didChangePrevious/didChangeNext updates to those that\n    // did not change at this point, because we're not yet sure exactly what the\n    // routes will be at the end of the day (some might get disposed).\n    int index = _history.length - 1;\n    _RouteEntry? next;\n    _RouteEntry? entry = _history[index];\n    _RouteEntry? previous = index > 0 ? _history[index - 1] : null;\n    bool canRemoveOrAdd = false; // Whether there is a fully opaque route on top to silently remove or add route underneath.\n    Route<dynamic>? poppedRoute; // The route that should trigger didPopNext on the top active route.\n    bool seenTopActiveRoute = false; // Whether we've seen the route that would get didPopNext.\n    final List<_RouteEntry> toBeDisposed = <_RouteEntry>[];\n    while (index >= 0) {\n      switch (entry!.currentState) {\n        case _RouteLifecycle.add:\n          assert(rearrangeOverlay);\n          entry.handleAdd(\n            navigator: this,\n            previousPresent: _getRouteBefore(index - 1, _RouteEntry.isPresentPredicate)?.route,\n          );\n          assert(entry.currentState == _RouteLifecycle.adding);\n          continue;\n        case _RouteLifecycle.adding:\n          if (canRemoveOrAdd || next == null) {\n            entry.didAdd(\n              navigator: this,\n              isNewFirst: next == null,\n            );\n            assert(entry.currentState == _RouteLifecycle.idle);\n            continue;\n          }\n          break;\n        case _RouteLifecycle.push:\n        case _RouteLifecycle.pushReplace:\n        case _RouteLifecycle.replace:\n          assert(rearrangeOverlay);\n          entry.handlePush(\n            navigator: this,\n            previous: previous?.route,\n            previousPresent: _getRouteBefore(index - 1, _RouteEntry.isPresentPredicate)?.route,\n            isNewFirst: next == null,\n          );\n          assert(entry.currentState != _RouteLifecycle.push);\n          assert(entry.currentState != _RouteLifecycle.pushReplace);\n          assert(entry.currentState != _RouteLifecycle.replace);\n          if (entry.currentState == _RouteLifecycle.idle) {\n            continue;\n          }\n          break;\n        case _RouteLifecycle.pushing: // Will exit this state when animation completes.\n          if (!seenTopActiveRoute && poppedRoute != null)\n            entry.handleDidPopNext(poppedRoute);\n          seenTopActiveRoute = true;\n          break;\n        case _RouteLifecycle.idle:\n          if (!seenTopActiveRoute && poppedRoute != null)\n            entry.handleDidPopNext(poppedRoute);\n          seenTopActiveRoute = true;\n          // This route is idle, so we are allowed to remove subsequent (earlier)\n          // routes that are waiting to be removed silently:\n          canRemoveOrAdd = true;\n          break;\n        case _RouteLifecycle.pop:\n          if (!entry.handlePop(\n                navigator: this,\n                previousPresent: _getRouteBefore(index, _RouteEntry.willBePresentPredicate)?.route)){\n            assert(entry.currentState == _RouteLifecycle.idle);\n            continue;\n          }\n          if (!seenTopActiveRoute) {\n            if (poppedRoute != null)\n              entry.handleDidPopNext(poppedRoute);\n            poppedRoute = entry.route;\n          }\n          _observedRouteDeletions.add(\n            _NavigatorPopObservation(entry.route, _getRouteBefore(index, _RouteEntry.willBePresentPredicate)?.route),\n          );\n          if (entry.currentState == _RouteLifecycle.dispose) {\n            // The pop finished synchronously. This can happen if transition\n            // duration is zero.\n            continue;\n          }\n          assert(entry.currentState == _RouteLifecycle.popping);\n          canRemoveOrAdd = true;\n          break;\n        case _RouteLifecycle.popping:\n          // Will exit this state when animation completes.\n          break;\n        case _RouteLifecycle.complete:\n          entry.handleComplete();\n          assert(entry.currentState == _RouteLifecycle.remove);\n          continue;\n        case _RouteLifecycle.remove:\n          if (!seenTopActiveRoute) {\n            if (poppedRoute != null)\n              entry.route.didPopNext(poppedRoute);\n            poppedRoute = null;\n          }\n          entry.handleRemoval(\n            navigator: this,\n            previousPresent: _getRouteBefore(index, _RouteEntry.willBePresentPredicate)?.route,\n          );\n          assert(entry.currentState == _RouteLifecycle.removing);\n          continue;\n        case _RouteLifecycle.removing:\n          if (!canRemoveOrAdd && next != null) {\n            // We aren't allowed to remove this route yet.\n            break;\n          }\n          entry.currentState = _RouteLifecycle.dispose;\n          continue;\n        case _RouteLifecycle.dispose:\n          // Delay disposal until didChangeNext/didChangePrevious have been sent.\n          toBeDisposed.add(_history.removeAt(index));\n          entry = next;\n          break;\n        case _RouteLifecycle.disposed:\n        case _RouteLifecycle.staging:\n          assert(false);\n          break;\n      }\n      index -= 1;\n      next = entry;\n      entry = previous;\n      previous = index > 0 ? _history[index - 1] : null;\n    }\n    // Informs navigator observers about route changes.\n    _flushObserverNotifications();\n\n    // Now that the list is clean, send the didChangeNext/didChangePrevious\n    // notifications.\n    _flushRouteAnnouncement();\n\n    // Announce route name changes.\n    if (widget.reportsRouteUpdateToEngine) {\n      final _RouteEntry? lastEntry = _history.cast<_RouteEntry?>().lastWhere(\n        (_RouteEntry? e) => e != null && _RouteEntry.isPresentPredicate(e), orElse: () => null,\n      );\n      final String? routeName = lastEntry?.route.settings.name;\n      if (routeName != null && routeName != _lastAnnouncedRouteName) {\n        SystemNavigator.routeInformationUpdated(location: routeName);\n        _lastAnnouncedRouteName = routeName;\n      }\n    }\n\n    // Lastly, removes the overlay entries of all marked entries and disposes\n    // them.\n    for (final _RouteEntry entry in toBeDisposed) {\n      for (final OverlayEntry overlayEntry in entry.route.overlayEntries)\n        overlayEntry.remove();\n      entry.dispose();\n    }\n    if (rearrangeOverlay) {\n      overlay?.rearrange(_allRouteOverlayEntries);\n    }\n    if (bucket != null) {\n      _serializableHistory.update(_history);\n    }\n    _flushingHistory = false;\n  }\n```\n\n这个方法看着代码很多，但其实**switch**那一大段代码都是对不同操作的的处理比如**pop**。\n\n注意最后这一块：\n\n```dart\n// Lastly, removes the overlay entries of all marked entries and disposes\n    // them.\n    for (final _RouteEntry entry in toBeDisposed) {\n      for (final OverlayEntry overlayEntry in entry.route.overlayEntries)\n        overlayEntry.remove();\n      entry.dispose();\n    }\n```\n\n**entry**的**dispose**回调页面**route**的**dispose**方法：\n\n```dart\n  void dispose() {\n    assert(currentState.index < _RouteLifecycle.disposed.index);\n    currentState = _RouteLifecycle.disposed;\n\n    final Iterable<OverlayEntry> mountedEntries = route.overlayEntries.where((OverlayEntry e) => e.mounted);\n\n    if (mountedEntries.isEmpty) {\n      route.dispose();\n    } else {\n      int mounted = mountedEntries.length;\n      assert(mounted > 0);\n      for (final OverlayEntry entry in mountedEntries) {\n        late VoidCallback listener;\n        listener = () {\n          assert(mounted > 0);\n          assert(!entry.mounted);\n          mounted--;\n          entry.removeListener(listener);\n          if (mounted == 0) {\n            assert(route.overlayEntries.every((OverlayEntry e) => !e.mounted));\n            route.dispose();\n          }\n        };\n        entry.addListener(listener);\n      }\n    }\n  }\n```\n\n使用**Get**路由导航的页面都是使用了**GetPageRoute**,\n\n查看**dispose**中调用了`RouterReportManager.reportRouteDispose(this)`:\n\n```dart\n  static void reportRouteDispose(Route disposed) {\n    if (Get.smartManagement != SmartManagement.onlyBuilder) {\n      ambiguate(WidgetsBinding.instance)?.addPostFrameCallback((_) {\n        _removeDependencyByRoute(disposed);\n      });\n    }\n  }\n```\n\n看下 **_removeDependencyByRoute**实现：\n\n```dart\n  static void _removeDependencyByRoute(Route routeName) {\n    final keysToRemove = <String>[];\n\n    _routesKey[routeName]?.forEach(keysToRemove.add);\n\n    /// Removes `Get.create()` instances registered in `routeName`.\n    if (_routesByCreate.containsKey(routeName)) {\n      for (final onClose in _routesByCreate[routeName]!) {\n        // assure the [DisposableInterface] instance holding a reference\n        // to onClose() wasn't disposed.\n        onClose();\n      }\n      _routesByCreate[routeName]!.clear();\n      _routesByCreate.remove(routeName);\n    }\n\n    for (final element in keysToRemove) {\n      final value = GetInstance().delete(key: element);\n      if (value) {\n        _routesKey[routeName]?.remove(element);\n      }\n    }\n\n    keysToRemove.clear();\n  }\n```\n\n这个方法释放了当前页面产生的一些资源，\n\n`_routesKey[routeName]`在put流程有提到，\n\n根据**routeName**作为**key**，可以拿到所有的`Get.find`所需要的**key**集合。\n\n最后遍历的时候执行了`GetInstance().delete(key: element);`进行清理操作：\n\n```dart\n  bool delete<S>({String? tag, String? key, bool force = false}) {\n    final newKey = key ?? _getKey(S, tag);\n\n    if (!_singl.containsKey(newKey)) {\n      Get.log('Instance \"$newKey\" already removed.', isError: true);\n      return false;\n    }\n\n    final dep = _singl[newKey];\n\n    if (dep == null) return false;\n\n    final _InstanceBuilderFactory builder;\n    if (dep.isDirty) {\n      builder = dep.lateRemove ?? dep;\n    } else {\n      builder = dep;\n    }\n\n    if (builder.permanent && !force) {\n      Get.log(\n        // ignore: lines_longer_than_80_chars\n        '\"$newKey\" has been marked as permanent, SmartManagement is not authorized to delete it.',\n        isError: true,\n      );\n      return false;\n    }\n    final i = builder.dependency;\n\n    if (i is GetxServiceMixin && !force) {\n      return false;\n    }\n\n    if (i is GetLifeCycleBase) {\n      i.onDelete();\n      Get.log('\"$newKey\" onDelete() called');\n    }\n\n    if (builder.fenix) {\n      builder.dependency = null;\n      builder.isInit = false;\n      return true;\n    } else {\n      if (dep.lateRemove != null) {\n        dep.lateRemove = null;\n        Get.log('\"$newKey\" deleted from memory');\n        return false;\n      } else {\n        _singl.remove(newKey);\n        if (_singl.containsKey(newKey)) {\n          Get.log('Error removing object \"$newKey\"', isError: true);\n        } else {\n          Get.log('\"$newKey\" deleted from memory');\n        }\n        return true;\n      }\n    }\n  }\n```\n\n最后可以发现调用了`_singl.remove(newKey);`移除了通过**put**方法存储的对象。\n\n总结一下流程就是：\n\n**S**和**tag**生成了**key**，Map类型变量 **_singl**根据**key**存储了**S**实例的封装。\n\nMap类型变量 **_routesKey**根据当前页面route存储了**key**列表。\n\n因为一个页面可能使用多个业务实例(GetController)。\n\n当页面弹出时，清空 **_singl**和 **_routesKey_**。"
  },
  {
    "title": "Get如何通过arguments传递参数的(源码分析)",
    "created_time": "2020-08-18 14:31:25",
    "body": "# arguments从哪获取的数据\n\n看下`Get.arguments`实现：`dynamic get arguments => routing.args;`\n\n期中**routing**实现是`Routing get routing => _getxController.routing;`\n\n而 **_getxController** 实现是 `static GetMaterialController _getxController = GetMaterialController();`\n\n也就是**arguments**来自**GetMaterialController**的`final routing = Routing();`\n\n**Routing**构造函数：\n\n```dart\n  Routing({\n    this.current = '',\n    this.previous = '',\n    this.args,\n    this.removed = '',\n    this.route,\n    this.isBack,\n    // this.isSnackbar,\n    this.isBottomSheet,\n    this.isDialog,\n  });\n```\n\n可以看到**arguments**实际上就是**Routing**的**args**\n\n那接下来只要找到哪里给**Routing**的**args**赋值的即可。\n\n# args在哪赋值\n\n既然我们是调用`Get.toNamed()`时候传递的**arguments**。首先看看这个值的传递路径是怎样的。\n\n```dart\n  Future<T?>? toNamed<T>(\n    String page, {\n    dynamic arguments,\n    int? id,\n    bool preventDuplicates = true,\n    Map<String, String>? parameters,\n  }) {\n    if (preventDuplicates && page == currentRoute) {\n      return null;\n    }\n\n    if (parameters != null) {\n      final uri = Uri(path: page, queryParameters: parameters);\n      page = uri.toString();\n    }\n\n    return global(id).currentState?.pushNamed<T>(\n          page,\n          arguments: arguments,\n        );\n  }\n```\n\n最后一行调用了**pushNamed**：\n\n```dart\n  Future<T?> pushNamed<T extends Object?>(\n    String routeName, {\n    Object? arguments,\n  }) {\n    return push<T>(_routeNamed<T>(routeName, arguments: arguments)!);\n  }\n```\n\n可以看到**arguments**被 **_routeNamed**封装到了**Route**，然后调用了**push**方法。\n\n先进去看看是如何被封装的：\n\n```dart\n  Route<T>? _routeNamed<T>(String name, { required Object? arguments, bool allowNull = false }) {\n    assert(!_debugLocked);\n    assert(name != null);\n    if (allowNull && widget.onGenerateRoute == null)\n      return null;\n    assert(() {\n      if (widget.onGenerateRoute == null) {\n        throw FlutterError(\n          'Navigator.onGenerateRoute was null, but the route named \"$name\" was referenced.\\n'\n          'To use the Navigator API with named routes (pushNamed, pushReplacementNamed, or '\n          'pushNamedAndRemoveUntil), the Navigator must be provided with an '\n          'onGenerateRoute handler.\\n'\n          'The Navigator was:\\n'\n          '  $this',\n        );\n      }\n      return true;\n    }());\n    final RouteSettings settings = RouteSettings(\n      name: name,\n      arguments: arguments,\n    );\n    Route<T>? route = widget.onGenerateRoute!(settings) as Route<T>?;\n    if (route == null && !allowNull) {\n      assert(() {\n        if (widget.onUnknownRoute == null) {\n          throw FlutterError.fromParts(<DiagnosticsNode>[\n            ErrorSummary('Navigator.onGenerateRoute returned null when requested to build route \"$name\".'),\n            ErrorDescription(\n              'The onGenerateRoute callback must never return null, unless an onUnknownRoute '\n              'callback is provided as well.',\n            ),\n            DiagnosticsProperty<NavigatorState>('The Navigator was', this, style: DiagnosticsTreeStyle.errorProperty),\n          ]);\n        }\n        return true;\n      }());\n      route = widget.onUnknownRoute!(settings) as Route<T>?;\n      assert(() {\n        if (route == null) {\n          throw FlutterError.fromParts(<DiagnosticsNode>[\n            ErrorSummary('Navigator.onUnknownRoute returned null when requested to build route \"$name\".'),\n            ErrorDescription('The onUnknownRoute callback must never return null.'),\n            DiagnosticsProperty<NavigatorState>('The Navigator was', this, style: DiagnosticsTreeStyle.errorProperty),\n          ]);\n        }\n        return true;\n      }());\n    }\n    assert(route != null || allowNull);\n    return route;\n  }\n```\n\n可以看到**arguments**其实被封装到了**RouteSettings**。\n\n通过`widget.onGenerateRoute!(settings)`传入**settings**返回了**Route**。\n\n这个**Route**是个抽象类，`widget.onGenerateRoute`生成的应该是一个实现类。\n\n看看`widget.onGenerateRoute`如何实现的：\n\n我们使用路由功能时需要**GetMaterialApp**替代原来的**MaterialApp**，看下如何实现的：\n\n```dart\nMaterialApp(\n                key: _.unikey,\n                navigatorKey: (navigatorKey == null\n                    ? Get.key\n                    : Get.addKey(navigatorKey!)),\n                scaffoldMessengerKey:\n                    scaffoldMessengerKey ?? _.scaffoldMessengerKey,\n                home: home,\n                routes: routes ?? const <String, WidgetBuilder>{},\n                initialRoute: initialRoute,\n                onGenerateRoute:\n                    (getPages != null ? generator : onGenerateRoute),\n                onGenerateInitialRoutes: (getPages == null || home != null)\n                    ? onGenerateInitialRoutes\n                    : initialRoutesGenerate,\n                onUnknownRoute: onUnknownRoute,\n                navigatorObservers: (navigatorObservers == null\n                    ? <NavigatorObserver>[\n                        GetObserver(routingCallback, Get.routing)\n                      ]\n                    : <NavigatorObserver>[\n                        GetObserver(routingCallback, Get.routing)\n                      ]\n                  ..addAll(navigatorObservers!)),\n                builder: defaultBuilder,\n                title: title,\n                onGenerateTitle: onGenerateTitle,\n                color: color,\n                theme: _.theme ?? theme ?? ThemeData.fallback(),\n                darkTheme:\n                    _.darkTheme ?? darkTheme ?? theme ?? ThemeData.fallback(),\n                themeMode: _.themeMode ?? themeMode,\n                locale: Get.locale ?? locale,\n                localizationsDelegates: localizationsDelegates,\n                localeListResolutionCallback: localeListResolutionCallback,\n                localeResolutionCallback: localeResolutionCallback,\n                supportedLocales: supportedLocales,\n                debugShowMaterialGrid: debugShowMaterialGrid,\n                showPerformanceOverlay: showPerformanceOverlay,\n                checkerboardRasterCacheImages: checkerboardRasterCacheImages,\n                checkerboardOffscreenLayers: checkerboardOffscreenLayers,\n                showSemanticsDebugger: showSemanticsDebugger,\n                debugShowCheckedModeBanner: debugShowCheckedModeBanner,\n                shortcuts: shortcuts,\n                scrollBehavior: scrollBehavior,\n                useInheritedMediaQuery: useInheritedMediaQuery,\n                //   actions: actions,\n              )\n```\n\n在**build**方法中也是通过**MaterialApp**实现的，只是对其进行了封装。\n\n这里有两点属性要注意：\n\n首先是`onGenerateRoute:(getPages != null ? generator : onGenerateRoute)`。\n\n其次是\n\n```dart\nnavigatorObservers: (navigatorObservers == null\n    ? <NavigatorObserver>[\n        GetObserver(routingCallback, Get.routing)\n      ]\n    : <NavigatorObserver>[\n        GetObserver(routingCallback, Get.routing)\n      ]\n  ..addAll(navigatorObservers!))\n```\n\n由于设置了**getPages**所以这里传递的是**generator**函数：\n\n```dart\n Route<dynamic> generator(RouteSettings settings) {\n    return PageRedirect(settings: settings, unknownRoute: unknownRoute).page();\n  }\n```\n\n这两个属性又传递给了**WidgetsApp**,而**WidgetsApp**中又调用了**Navigator** Widget：\n\n```dart\nNavigator(\n        restorationScopeId: 'nav',\n        key: _navigator,\n        initialRoute: _initialRouteName,\n        onGenerateRoute: _onGenerateRoute,\n        onGenerateInitialRoutes: widget.onGenerateInitialRoutes == null\n          ? Navigator.defaultGenerateInitialRoutes\n          : (NavigatorState navigator, String initialRouteName) {\n            return widget.onGenerateInitialRoutes!(initialRouteName);\n          },\n        onUnknownRoute: _onUnknownRoute,\n        observers: widget.navigatorObservers!,\n        reportsRouteUpdateToEngine: true,\n      )\n```\n\n**Navigator**中的**observers**直接来自**GetMaterialApp**传递过来的，\n\n**onGenerateRoute**则是对传递过来的进行了封装：\n\n```dart\n  Route<dynamic>? _onGenerateRoute(RouteSettings settings) {\n    final String? name = settings.name;\n    final WidgetBuilder? pageContentBuilder = name == Navigator.defaultRouteName && widget.home != null\n        ? (BuildContext context) => widget.home!\n        : widget.routes![name];\n\n    if (pageContentBuilder != null) {\n      assert(\n        widget.pageRouteBuilder != null,\n        'The default onGenerateRoute handler for WidgetsApp must have a '\n        'pageRouteBuilder set if the home or routes properties are set.',\n      );\n      final Route<dynamic> route = widget.pageRouteBuilder!<dynamic>(\n        settings,\n        pageContentBuilder,\n      );\n      assert(route != null, 'The pageRouteBuilder for WidgetsApp must return a valid non-null Route.');\n      return route;\n    }\n    if (widget.onGenerateRoute != null)\n      return widget.onGenerateRoute!(settings);\n    return null;\n  }\n```\n\n可以看到虽然封装了但最终还是调用了外部传递的：\n\n```dart\nRoute<dynamic> generator(RouteSettings settings) {\n    return PageRedirect(settings: settings, unknownRoute: unknownRoute).page();\n  }\n```\n\n查看**page**方法：\n\n```dart\nGetPageRoute<T> page<T>() {\n    while (needRecheck()) {}\n    final _r = (isUnknown ? unknownRoute : route)!;\n    return GetPageRoute<T>(\n      page: _r.page,\n      parameter: _r.parameters,\n      settings: isUnknown\n          ? RouteSettings(\n              name: _r.name,\n              arguments: settings!.arguments,\n            )\n          : settings,\n      curve: _r.curve,\n      opaque: _r.opaque,\n      showCupertinoParallax: _r.showCupertinoParallax,\n      gestureWidth: _r.gestureWidth,\n      customTransition: _r.customTransition,\n      binding: _r.binding,\n      bindings: _r.bindings,\n      transitionDuration:\n          _r.transitionDuration ?? Get.defaultTransitionDuration,\n      transition: _r.transition,\n      popGesture: _r.popGesture,\n      fullscreenDialog: _r.fullscreenDialog,\n      middlewares: _r.middlewares,\n    );\n  }\n```\n\n看到**arguments**最终被封装到**GetPageRoute**中，而**GetPageRoute**就是**Route**子类。\n\n刚才说的第二个属性**navigatorObservers**传递到**Navigator**的**observers**属性。\n\n继续刚才的**push**流程：\n\n```dart\n  Future<T?> push<T extends Object?>(Route<T> route) {\n    assert(_debugCheckIsPagelessRoute(route));\n    _pushEntry(_RouteEntry(route, initialState: _RouteLifecycle.push));\n    return route.popped;\n  }\n```\n\n这里把刚才生成的**Route**又封装到了**RouteEntry**\n\n进入 **_pushEntry**:\n\n```dart\n  void _pushEntry(_RouteEntry entry) {\n    _history.add(entry);\n    _flushHistoryUpdates();\n    _afterNavigation(entry.route);\n  }\n```\n\n**_history**这是一个存储打开页面集合，加入到集合后通过 **_flushHistoryUpdates**执行相关操作：\n\n```dart\n        case _RouteLifecycle.push:\n        case _RouteLifecycle.pushReplace:\n        case _RouteLifecycle.replace:\n          assert(rearrangeOverlay);\n          entry.handlePush(\n            navigator: this,\n            previous: previous?.route,\n            previousPresent: _getRouteBefore(index - 1, _RouteEntry.isPresentPredicate)?.route,\n            isNewFirst: next == null,\n          );\n          assert(entry.currentState != _RouteLifecycle.push);\n          assert(entry.currentState != _RouteLifecycle.pushReplace);\n          assert(entry.currentState != _RouteLifecycle.replace);\n          if (entry.currentState == _RouteLifecycle.idle) {\n            continue;\n          }\n          break;\n\n    _flushObserverNotifications();\n```\n\n这是该方法部分代码，由于现在是**push**页面所以**switch**流程执行`case _RouteLifecycle.push:`\n\n调用`entry.handlePush`：\n\n```dart\n  void handlePush({ required NavigatorState navigator, required bool isNewFirst, required Route<dynamic>? previous, required Route<dynamic>? previousPresent }) {\n    assert(currentState == _RouteLifecycle.push || currentState == _RouteLifecycle.pushReplace || currentState == _RouteLifecycle.replace);\n    assert(navigator != null);\n    assert(navigator._debugLocked);\n    assert(\n      route._navigator == null,\n      'The pushed route has already been used. When pushing a route, a new '\n      'Route object must be provided.',\n    );\n    final _RouteLifecycle previousState = currentState;\n    route._navigator = navigator;\n    route.install();\n    assert(route.overlayEntries.isNotEmpty);\n    if (currentState == _RouteLifecycle.push || currentState == _RouteLifecycle.pushReplace) {\n      final TickerFuture routeFuture = route.didPush();\n      currentState = _RouteLifecycle.pushing;\n      routeFuture.whenCompleteOrCancel(() {\n        if (currentState == _RouteLifecycle.pushing) {\n          currentState = _RouteLifecycle.idle;\n          assert(!navigator._debugLocked);\n          assert(() { navigator._debugLocked = true; return true; }());\n          navigator._flushHistoryUpdates();\n          assert(() { navigator._debugLocked = false; return true; }());\n        }\n      });\n    } else {\n      assert(currentState == _RouteLifecycle.replace);\n      route.didReplace(previous);\n      currentState = _RouteLifecycle.idle;\n    }\n    if (isNewFirst) {\n      route.didChangeNext(null);\n    }\n\n    if (previousState == _RouteLifecycle.replace || previousState == _RouteLifecycle.pushReplace) {\n      navigator._observedRouteAdditions.add(\n        _NavigatorReplaceObservation(route, previousPresent),\n      );\n    } else {\n      assert(previousState == _RouteLifecycle.push);\n      navigator._observedRouteAdditions.add(\n        _NavigatorPushObservation(route, previousPresent),\n      );\n    }\n  }\n```\n\n这里会先调用`final TickerFuture routeFuture = route.didPush();`然后通过`whenCompleteOrCancel`等待完成回调。\n\n接着调用`navigator._observedRouteAdditions.add( _NavigatorPushObservation(route, previousPresent), );`\n\n等到页面**push**完成时回调时再次调用`navigator._flushHistoryUpdates();`\n\n该方法底部调用了`_flushObserverNotifications`：\n\n```dart\n  void _flushObserverNotifications() {\n    if (_effectiveObservers.isEmpty) {\n      _observedRouteDeletions.clear();\n      _observedRouteAdditions.clear();\n      return;\n    }\n    while (_observedRouteAdditions.isNotEmpty) {\n      final _NavigatorObservation observation = _observedRouteAdditions.removeLast();\n      _effectiveObservers.forEach(observation.notify);\n    }\n\n    while (_observedRouteDeletions.isNotEmpty) {\n      final _NavigatorObservation observation = _observedRouteDeletions.removeFirst();\n      _effectiveObservers.forEach(observation.notify);\n    }\n  }\n```\n\n方法中 **_effectiveObservers**的赋值：\n\n```\n  void initState() {\n    _effectiveObservers = widget.observers;\n}\n```\n\n这个**widget**是**Navigator**，上面说了**Navigator**中的**observers**直接来自**GetMaterialApp**传递过来的：\n\n```dart\n    navigatorObservers: (navigatorObservers == null\n                    ? <NavigatorObserver>[\n                        GetObserver(routingCallback, Get.routing)\n                      ]\n                    : <NavigatorObserver>[\n                        GetObserver(routingCallback, Get.routing)\n                      ]\n                  ..addAll(navigatorObservers!)),\n```\n\n所以 **_effectiveObservers**不为空，而 **_observedRouteAdditions**在**handlePush**添加了对象，\n\n所以调用`_effectiveObservers.forEach(observation.notify)`时进入 **_NavigatorPushObservation**的**notify**方法查看：\n\n```dart\nvoid notify(NavigatorObserver observer) {\n    observer.didPush(primaryRoute, secondaryRoute);\n  }\n```\n\n这里的**observer**为外部传递的**GetObserver**:\n\n```dart\n  void didPush(Route route, Route? previousRoute) {\n    super.didPush(route, previousRoute);\n    final newRoute = _RouteData.ofRoute(route);\n\n    if (newRoute.isBottomSheet || newRoute.isDialog) {\n      Get.log(\"OPEN ${newRoute.name}\");\n    } else if (newRoute.isGetPageRoute) {\n      Get.log(\"GOING TO ROUTE ${newRoute.name}\");\n    }\n\n    RouterReportManager.reportCurrentRoute(route);\n    _routeSend?.update((value) {\n      // Only PageRoute is allowed to change current value\n      if (route is PageRoute) {\n        value.current = newRoute.name ?? '';\n      }\n      final previousRouteName = _extractRouteName(previousRoute);\n      if (previousRouteName != null) {\n        value.previous = previousRouteName;\n      }\n\n      value.args = route.settings.arguments;\n      value.route = route;\n      value.isBack = false;\n      value.removed = '';\n      value.isBottomSheet =\n          newRoute.isBottomSheet ? true : value.isBottomSheet ?? false;\n      value.isDialog = newRoute.isDialog ? true : value.isDialog ?? false;\n    });\n\n    if (routing != null) {\n      routing!(_routeSend);\n    }\n  }\n```\n\n看到 **_routeSend**更新了自身的属性值拿到了`route.settings.arguments`。\n\n**_routeSend**来自构造函数`GetObserver([this.routing, this._routeSend])`。而在**GetMaterialApp**中传递时是这样的：\n\n```dart\nGetObserver(routingCallback, Get.routing)\n```\n\n也就是说 **_routeSend**就是**Get.routing**，也就是`Routing get routing => _getxController.routing`\n\n这和上一节**arguments从哪获取的数据**说到的**Routing**是同一个值。\n\n就是说本节在调用`Get.toNamed()`后通过一些列流程最后更新了`_getxController.routing`值。\n\n然后`Get.arguments`调用拿到该值。"
  },
  {
    "title": "Flutter web部署后显示中文乱码",
    "created_time": "2020-08-20 14:31:25",
    "body": "web部署运行后页面中文会先显示带叉号的方格，然后过一会又刷新正常。\n\n通过查找发现有2种方式可以修复乱码问题。\n\n# 更换渲染方式\n\nFlutter web有2种渲染方式：**html**和**canvaskit**。\n\n打包时可以指定编码方式，也可以不指定，使用**auto**即默认方式。\n\n点击运行按钮时就是**auto**方式，移动端使用**html**，pc端使用**canvaskit**。\n\n问题源自**canvaskit**渲染方式，所以切换为**html**就好了。\n\n更换渲染方式有2种方式：\n\n## 命令行切换\n\ndebug 模式（使用 chrome 浏览器）\n\n`flutter run -d chrome --web-renderer html`\n\ndebug 模式（不指定浏览器）\n\n`flutter run -d web-server --web-renderer html`\n\nrelease 模式\n\n`flutter build web --web-renderer html`\n\n`flutter build web --web-renderer html --release`\n\n`flutter build web --web-renderer canvaskit --release`\n\n## 页面切换\n\n在`web/index.html`的`script`中添加：\n\n```javascript\nwindow.flutterWebRenderer = \"html\";\n```\n\n# 更换字体\n\n更换渲染方式会有其他问题，所以采用更换字体方式更合适。\n\n## 下载Roboto-Mono字体，进行配置：\n\n```yaml\n  fonts:\n    - family: RobotoMono\n      fonts:\n        - asset: fonts/RobotoMono-Bold.ttf\n        - asset: fonts/RobotoMono-Italic.ttf\n        - asset: fonts/RobotoMono-Regular.ttf\n```\n\n## 根widget使用字体\n\n```dart\nGetMaterialApp(\n      debugShowCheckedModeBanner: false,\n      title: '笔记',\n      theme: ThemeData(\n        colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple),\n        useMaterial3: true,\n        fontFamily: 'RobotoMono'//配置字体\n      ),\n      home: const MyHomePage(title: '笔记'),\n    );\n```"
  },
  {
    "title": "Flutter性能优化",
    "created_time": "2021-08-20 14:31:25",
    "body": "# 减少不必要的UI绘制\n\n缩小Widget刷新范围，越小越好。例如Provider的selector。\n\n使用Builder缩小Context范围，避免在State范围内调用`setState`。\n\n# 减少build中耗时和widget数量。\n\n# const widget\n\n对于dart语法，需要分清楚final和const关键字的区别。\n\n关键字final的意思是一次赋值，不能改变；\n\n关键字const的意思是常量，确定的值。\n\n这两者的区别是final变量在第一次使用时被初始化，\n\n而const 变量是一个编译时替换为常量值。\n\n同样const widget的widget在编译阶段就已经确定，不会有状态的变化和成员变量更新。\n\nconst widget特别适合于标签、特殊Icon等可以复用的UI，性能开销较小。\n\n# 圆角使用BoxDecoration替换Clipxxx\n\n# 耗时计算放到Isolate\n\n# 超大图片检测\n\nFlutter Inspector：点击 “Highlight Oversizeded Images”，\n\n它会识别出那些解码大小超过展示大小的图片，并且系统会将其倒置，\n\n这些你就能更容易在 App 页面中找到它。\n\n针对这些图片，你可以指定 cacheWidth 和 cacheHeight 为展示大小，\n\n这样可以让 flutter 引擎以指定大小解析图片，减少内存消耗。\n\n# RepaintBoundary区分变与不变图层\n\n对于经常刷新的Widget使用RepaintBoundary包裹起来成为一个单独的layer。\n\n# Opacity减少使用\n\n特别是动画中，淡入效果可以使用AnimatedOpacity和FadeInImage,透明效果可以设置widget的背景颜色实现。\n\n# 避免调用 saveLayer\n\n（调用 saveLayer() 会开辟一片离屏缓冲区。将内容绘制到离屏缓冲区可能会触发渲染目标切换，这些切换在较早期的 GPU 中特别慢）\n\n1 ShaderMask\n\n2 ColorFilter\n\n3 Chip -- might cause call to saveLayer() if disabledColorAlpha != 0xff （简单的圆角效果可以使用Container 实现）\n\n4 Text -- might cause call to saveLayer() if there’s an overflowShader\n\n# 分帧渲染\n\n复杂列表或者长列表使用分帧渲染减少卡顿。\n\n分帧渲染的原理是将一棵Widget树中的部分绘制时间较长的节点\n\n在第一帧时只占位不绘制，等到下一帧开始时，节点替换占位UI，单独使用一帧时间绘制。\n\n# 内存泄露\n\n内存泄漏是一个比较严重的问题，\n\n在监控方面Flutter现在比较通用的方法就是利用Expando中的弱引用去监控是否有泄漏的对象，如果出现则从VM中获取其引用链接，从而分析其泄漏原因。\n\n另外通过Flutter的Dev tool中的内存监控工具也能实现对泄漏对象的发现。"
  },
  {
    "title": "Flutter事件分析(源码分析)",
    "created_time": "2021-09-20 14:31:25",
    "body": "Flutter事件主要分为两大块。\n\n一是事件发生时在触摸范围内收集所有符合条件的Widget，这一流程叫**hitTest**。\n\n二是对收集的所有Widget进行事件分发，这一流程叫**dispatchEvent**。\n\n# hitTest\n\n首先**RendererBinding**调用`hitTest`：\n\n```dart\n  @override\n  void hitTest(HitTestResult result, Offset position) {\n    renderView.hitTest(result, position: position);\n    super.hitTest(result, position);\n  }\n```\n\n进入**renderView**的`hittest`：\n\n```dart\n  bool hitTest(HitTestResult result, { required Offset position }) {\n    if (child != null) {\n      child!.hitTest(BoxHitTestResult.wrap(result), position: position);\n    }\n    result.add(HitTestEntry(this));\n    return true;\n  }\n```\n\n看到这里调用了子**RenderObject**的`hitTest`方法，然后把自己封装加入到了**HitTestResult**。\n\n查看**RenderObject**的`hittest`：\n\n```dart\n  bool hitTest(BoxHitTestResult result, { required Offset position }) {\n    if (_size!.contains(position)) {\n      if (hitTestChildren(result, position: position) || hitTestSelf(position)) {\n        result.add(BoxHitTestEntry(this, position));\n        return true;\n      }\n    }\n    return false;\n  }\n```\n\n判断如果触摸点位包含在**RenderObject**大小内，就进行所有子**RenderObject**的`hitTest`\n\n这里`hitTestChildren`为空方法，实际调用内容在`defaultHitTestChildren`：\n\n```dart\n  bool defaultHitTestChildren(BoxHitTestResult result, { required Offset position }) {\n    ChildType? child = lastChild;\n    while (child != null) {\n      // The x, y parameters have the top left of the node's box as the origin.\n      final ParentDataType childParentData = child.parentData! as ParentDataType;\n      final bool isHit = result.addWithPaintOffset(\n        offset: childParentData.offset,\n        position: position,\n        hitTest: (BoxHitTestResult result, Offset transformed) {\n          assert(transformed == position - childParentData.offset);\n          return child!.hitTest(result, position: transformed);\n        },\n      );\n      if (isHit) {\n        return true;\n      }\n      child = childParentData.previousSibling;\n    }\n    return false;\n  }\n```\n\n---\n\n这里的逻辑很简单，就是从最后一个child开始判断，只要有一个符合就退出循环。\n\n为什么会有这种操作，估计是包含多个情况下，要么兄弟Widget之间位置不同，要么像**Stack**这种有重叠，但是实际看到的只有最后面的那个Widget。所以为了节省时间只取一个符合条件的。现在看来是没毛病的。\n\n返回上面的**hittest**看一下`\n\n```dart\n  if (hitTestChildren(result, position: position) || hitTestSelf(position)) {`\n```\n\n如果子RenderObject有符合条件德尔或者设置了**hitTestSelf返回true**，那么父RenderObject本身也会加入到**result**。\n\n这就形成了一条顺序链`HitTestResult._path`。\n\nhitTest采取深度优先原则符合条件的封装加入到**HitTestResult**\n\n越深的越排序靠前，遍历时最先取出。\n\n# dispatchEvent\n\n**GestureBinding**调用`dispatchEvent`\n\n```dart\n  void dispatchEvent(PointerEvent event, HitTestResult? hitTestResult) {\n    for (final HitTestEntry entry in hitTestResult.path) {\n      try {\n        entry.target.handleEvent(event.transformed(entry.transform), entry);\n      } catch (exception, stack) {\n        FlutterError.reportError(FlutterErrorDetailsForPointerEventDispatcher(\n          exception: exception,\n          stack: stack,\n          library: 'gesture library',\n          context: ErrorDescription('while dispatching a pointer event'),\n          event: event,\n          hitTestEntry: entry,\n          informationCollector: () => <DiagnosticsNode>[\n            DiagnosticsProperty<PointerEvent>('Event', event, style: DiagnosticsTreeStyle.errorProperty),\n            DiagnosticsProperty<HitTestTarget>('Target', entry.target, style: DiagnosticsTreeStyle.errorProperty),\n          ],\n        ));\n      }\n    }\n  }\n```\n\n遍历`hitTestResult`调用`handleEvent`处理事件，\n\n这里的**target**是**RenderObject**子类**RenderPointerListener**：\n\n```dart\n  @override\n  void handleEvent(PointerEvent event, HitTestEntry entry) {\n    assert(debugHandleEvent(event, entry));\n    if (event is PointerDownEvent) {\n      return onPointerDown?.call(event);\n    }\n    if (event is PointerMoveEvent) {\n      return onPointerMove?.call(event);\n    }\n    if (event is PointerUpEvent) {\n      return onPointerUp?.call(event);\n    }\n    if (event is PointerHoverEvent) {\n      return onPointerHover?.call(event);\n    }\n    if (event is PointerCancelEvent) {\n      return onPointerCancel?.call(event);\n    }\n    if (event is PointerPanZoomStartEvent) {\n      return onPointerPanZoomStart?.call(event);\n    }\n    if (event is PointerPanZoomUpdateEvent) {\n      return onPointerPanZoomUpdate?.call(event);\n    }\n    if (event is PointerPanZoomEndEvent) {\n      return onPointerPanZoomEnd?.call(event);\n    }\n    if (event is PointerSignalEvent) {\n      return onPointerSignal?.call(event);\n    }\n  }\n```\n\n这里所有**onPointerxxx**变量都是从构造函数传过来的。\n\n创建RenderObject对象是由Widget调用的，比如**Listener**：\n\n```dart\n  @override\n  RenderPointerListener createRenderObject(BuildContext context) {\n    return RenderPointerListener(\n      onPointerDown: onPointerDown,\n      onPointerMove: onPointerMove,\n      onPointerUp: onPointerUp,\n      onPointerHover: onPointerHover,\n      onPointerCancel: onPointerCancel,\n      onPointerPanZoomStart: onPointerPanZoomStart,\n      onPointerPanZoomUpdate: onPointerPanZoomUpdate,\n      onPointerPanZoomEnd: onPointerPanZoomEnd,\n      onPointerSignal: onPointerSignal,\n      behavior: behavior,\n    );\n  }\n```\n\n所以这里就是调用从**Listener**传递过来的事件进行响应。\n\n## listener测试\n\n嵌套一个Listener进行事件测试：\n\n```dart\n  Listener buildListener() {\n    return Listener(\n      onPointerUp: (event) {\n        print('父 onPointerUp');\n      },\n      onPointerDown: (event) {\n        print('父 onPointerDown');\n      },\n      child: Listener(\n        onPointerUp: (event) {\n          print('子 onPointerUp');\n        },\n        onPointerDown: (event) {\n          print('子 onPointerDown');\n        },\n        child: const Text(\n          'Listener测试',\n        ),\n      ),\n    );\n  }\n```\n\n```\n2023-09-14 11:12:10.681 11012-11040 flutter                 com.example.untitled                 I  子 onPointerDown\n2023-09-14 11:12:10.681 11012-11040 flutter                 com.example.untitled                 I  父 onPointerDown\n2023-09-14 11:12:10.743 11012-11040 flutter                 com.example.untitled                 I  子 onPointerUp\n2023-09-14 11:12:10.743 11012-11040 flutter                 com.example.untitled                 I  父 onPointerUp\n```\n\n可以看到先调用了子Widget再调用了父Widget，这符合**hittest**中的深度优先。\n\n## 手势竞技\n\n基本流程完了，但是好像还没有看到手势竞技代码。\n\n手势竞技需要在有手势分析处理的Widget才有，比如**GestureDetector**：\n\n```dart\n  Widget build(BuildContext context) {\n    final Map<Type, GestureRecognizerFactory> gestures = <Type, GestureRecognizerFactory>{};\n    final DeviceGestureSettings? gestureSettings = MediaQuery.maybeGestureSettingsOf(context);\n\n    if (onTapDown != null ||\n        onTapUp != null ||\n        onTap != null ||\n        onTapCancel != null ||\n        onSecondaryTap != null ||\n        onSecondaryTapDown != null ||\n        onSecondaryTapUp != null ||\n        onSecondaryTapCancel != null||\n        onTertiaryTapDown != null ||\n        onTertiaryTapUp != null ||\n        onTertiaryTapCancel != null\n    ) {\n      gestures[TapGestureRecognizer] = GestureRecognizerFactoryWithHandlers<TapGestureRecognizer>(\n        () => TapGestureRecognizer(debugOwner: this, supportedDevices: supportedDevices),\n        (TapGestureRecognizer instance) {\n          instance\n            ..onTapDown = onTapDown\n            ..onTapUp = onTapUp\n            ..onTap = onTap\n            ..onTapCancel = onTapCancel\n            ..onSecondaryTap = onSecondaryTap\n            ..onSecondaryTapDown = onSecondaryTapDown\n            ..onSecondaryTapUp = onSecondaryTapUp\n            ..onSecondaryTapCancel = onSecondaryTapCancel\n            ..onTertiaryTapDown = onTertiaryTapDown\n            ..onTertiaryTapUp = onTertiaryTapUp\n            ..onTertiaryTapCancel = onTertiaryTapCancel\n            ..gestureSettings = gestureSettings\n            ..supportedDevices = supportedDevices;\n        },\n      );\n    }\n\n    if (onDoubleTap != null ||\n        onDoubleTapDown != null ||\n        onDoubleTapCancel != null) {\n      gestures[DoubleTapGestureRecognizer] = GestureRecognizerFactoryWithHandlers<DoubleTapGestureRecognizer>(\n        () => DoubleTapGestureRecognizer(debugOwner: this, supportedDevices: supportedDevices),\n        (DoubleTapGestureRecognizer instance) {\n          instance\n            ..onDoubleTapDown = onDoubleTapDown\n            ..onDoubleTap = onDoubleTap\n            ..onDoubleTapCancel = onDoubleTapCancel\n            ..gestureSettings = gestureSettings\n            ..supportedDevices = supportedDevices;\n        },\n      );\n    }\n\n    if (onLongPressDown != null ||\n        onLongPressCancel != null ||\n        onLongPress != null ||\n        onLongPressStart != null ||\n        onLongPressMoveUpdate != null ||\n        onLongPressUp != null ||\n        onLongPressEnd != null ||\n        onSecondaryLongPressDown != null ||\n        onSecondaryLongPressCancel != null ||\n        onSecondaryLongPress != null ||\n        onSecondaryLongPressStart != null ||\n        onSecondaryLongPressMoveUpdate != null ||\n        onSecondaryLongPressUp != null ||\n        onSecondaryLongPressEnd != null ||\n        onTertiaryLongPressDown != null ||\n        onTertiaryLongPressCancel != null ||\n        onTertiaryLongPress != null ||\n        onTertiaryLongPressStart != null ||\n        onTertiaryLongPressMoveUpdate != null ||\n        onTertiaryLongPressUp != null ||\n        onTertiaryLongPressEnd != null) {\n      gestures[LongPressGestureRecognizer] = GestureRecognizerFactoryWithHandlers<LongPressGestureRecognizer>(\n        () => LongPressGestureRecognizer(debugOwner: this, supportedDevices: supportedDevices),\n        (LongPressGestureRecognizer instance) {\n          instance\n            ..onLongPressDown = onLongPressDown\n            ..onLongPressCancel = onLongPressCancel\n            ..onLongPress = onLongPress\n            ..onLongPressStart = onLongPressStart\n            ..onLongPressMoveUpdate = onLongPressMoveUpdate\n            ..onLongPressUp = onLongPressUp\n            ..onLongPressEnd = onLongPressEnd\n            ..onSecondaryLongPressDown = onSecondaryLongPressDown\n            ..onSecondaryLongPressCancel = onSecondaryLongPressCancel\n            ..onSecondaryLongPress = onSecondaryLongPress\n            ..onSecondaryLongPressStart = onSecondaryLongPressStart\n            ..onSecondaryLongPressMoveUpdate = onSecondaryLongPressMoveUpdate\n            ..onSecondaryLongPressUp = onSecondaryLongPressUp\n            ..onSecondaryLongPressEnd = onSecondaryLongPressEnd\n            ..onTertiaryLongPressDown = onTertiaryLongPressDown\n            ..onTertiaryLongPressCancel = onTertiaryLongPressCancel\n            ..onTertiaryLongPress = onTertiaryLongPress\n            ..onTertiaryLongPressStart = onTertiaryLongPressStart\n            ..onTertiaryLongPressMoveUpdate = onTertiaryLongPressMoveUpdate\n            ..onTertiaryLongPressUp = onTertiaryLongPressUp\n            ..onTertiaryLongPressEnd = onTertiaryLongPressEnd\n            ..gestureSettings = gestureSettings\n            ..supportedDevices = supportedDevices;\n        },\n      );\n    }\n\n    if (onVerticalDragDown != null ||\n        onVerticalDragStart != null ||\n        onVerticalDragUpdate != null ||\n        onVerticalDragEnd != null ||\n        onVerticalDragCancel != null) {\n      gestures[VerticalDragGestureRecognizer] = GestureRecognizerFactoryWithHandlers<VerticalDragGestureRecognizer>(\n        () => VerticalDragGestureRecognizer(debugOwner: this, supportedDevices: supportedDevices),\n        (VerticalDragGestureRecognizer instance) {\n          instance\n            ..onDown = onVerticalDragDown\n            ..onStart = onVerticalDragStart\n            ..onUpdate = onVerticalDragUpdate\n            ..onEnd = onVerticalDragEnd\n            ..onCancel = onVerticalDragCancel\n            ..dragStartBehavior = dragStartBehavior\n            ..gestureSettings = gestureSettings\n            ..supportedDevices = supportedDevices;\n        },\n      );\n    }\n\n    if (onHorizontalDragDown != null ||\n        onHorizontalDragStart != null ||\n        onHorizontalDragUpdate != null ||\n        onHorizontalDragEnd != null ||\n        onHorizontalDragCancel != null) {\n      gestures[HorizontalDragGestureRecognizer] = GestureRecognizerFactoryWithHandlers<HorizontalDragGestureRecognizer>(\n        () => HorizontalDragGestureRecognizer(debugOwner: this, supportedDevices: supportedDevices),\n        (HorizontalDragGestureRecognizer instance) {\n          instance\n            ..onDown = onHorizontalDragDown\n            ..onStart = onHorizontalDragStart\n            ..onUpdate = onHorizontalDragUpdate\n            ..onEnd = onHorizontalDragEnd\n            ..onCancel = onHorizontalDragCancel\n            ..dragStartBehavior = dragStartBehavior\n            ..gestureSettings = gestureSettings\n            ..supportedDevices = supportedDevices;\n        },\n      );\n    }\n\n    if (onPanDown != null ||\n        onPanStart != null ||\n        onPanUpdate != null ||\n        onPanEnd != null ||\n        onPanCancel != null) {\n      gestures[PanGestureRecognizer] = GestureRecognizerFactoryWithHandlers<PanGestureRecognizer>(\n        () => PanGestureRecognizer(debugOwner: this, supportedDevices: supportedDevices),\n        (PanGestureRecognizer instance) {\n          instance\n            ..onDown = onPanDown\n            ..onStart = onPanStart\n            ..onUpdate = onPanUpdate\n            ..onEnd = onPanEnd\n            ..onCancel = onPanCancel\n            ..dragStartBehavior = dragStartBehavior\n            ..gestureSettings = gestureSettings\n            ..supportedDevices = supportedDevices;\n        },\n      );\n    }\n\n    if (onScaleStart != null || onScaleUpdate != null || onScaleEnd != null) {\n      gestures[ScaleGestureRecognizer] = GestureRecognizerFactoryWithHandlers<ScaleGestureRecognizer>(\n        () => ScaleGestureRecognizer(debugOwner: this, supportedDevices: supportedDevices),\n        (ScaleGestureRecognizer instance) {\n          instance\n            ..onStart = onScaleStart\n            ..onUpdate = onScaleUpdate\n            ..onEnd = onScaleEnd\n            ..dragStartBehavior = dragStartBehavior\n            ..gestureSettings = gestureSettings\n            ..trackpadScrollCausesScale = trackpadScrollCausesScale\n            ..trackpadScrollToScaleFactor = trackpadScrollToScaleFactor\n            ..supportedDevices = supportedDevices;\n        },\n      );\n    }\n\n    if (onForcePressStart != null ||\n        onForcePressPeak != null ||\n        onForcePressUpdate != null ||\n        onForcePressEnd != null) {\n      gestures[ForcePressGestureRecognizer] = GestureRecognizerFactoryWithHandlers<ForcePressGestureRecognizer>(\n        () => ForcePressGestureRecognizer(debugOwner: this, supportedDevices: supportedDevices),\n        (ForcePressGestureRecognizer instance) {\n          instance\n            ..onStart = onForcePressStart\n            ..onPeak = onForcePressPeak\n            ..onUpdate = onForcePressUpdate\n            ..onEnd = onForcePressEnd\n            ..gestureSettings = gestureSettings\n            ..supportedDevices = supportedDevices;\n        },\n      );\n    }\n\n    return RawGestureDetector(\n      gestures: gestures,\n      behavior: behavior,\n      excludeFromSemantics: excludeFromSemantics,\n      child: child,\n    );\n  }\n```\n\ns上面代码尝试把几种手势识别如**TapGestureRecognizer**存到**gestures**，传给**RawGestureDetector**，这是一个**StatefulWidget**，查看它的State **RawGestureDetectorState**\n\n```dart\n  @override\n  void initState() {\n    super.initState();\n    _semantics = widget.semantics ?? _DefaultSemanticsGestureDelegate(this);\n    _syncAll(widget.gestures);\n  }\n  \n    void _syncAll(Map<Type, GestureRecognizerFactory> gestures) {\n    assert(_recognizers != null);\n    final Map<Type, GestureRecognizer> oldRecognizers = _recognizers!;\n    _recognizers = <Type, GestureRecognizer>{};\n    for (final Type type in gestures.keys) {\n      assert(gestures[type] != null);\n      assert(gestures[type]!._debugAssertTypeMatches(type));\n      assert(!_recognizers!.containsKey(type));\n      _recognizers![type] = oldRecognizers[type] ?? gestures[type]!.constructor();\n      assert(_recognizers![type].runtimeType == type, 'GestureRecognizerFactory of type $type created a GestureRecognizer of type ${_recognizers![type].runtimeType}. The GestureRecognizerFactory must be specialized with the type of the class that it returns from its constructor method.');\n      gestures[type]!.initializer(_recognizers![type]!);\n    }\n    for (final Type type in oldRecognizers.keys) {\n      if (!_recognizers!.containsKey(type)) {\n        oldRecognizers[type]!.dispose();\n      }\n    }\n  }\n```\n\n这里的 **_syncAll**把**gestures**转存到了 **_recognizers**。\n\n查看**build**：\n\n```dart\n  @override\n  Widget build(BuildContext context) {\n    Widget result = Listener(\n      onPointerDown: _handlePointerDown,\n      onPointerPanZoomStart: _handlePointerPanZoomStart,\n      behavior: widget.behavior ?? _defaultBehavior,\n      child: widget.child,\n    );\n    if (!widget.excludeFromSemantics) {\n      result = _GestureSemantics(\n        behavior: widget.behavior ?? _defaultBehavior,\n        assignSemantics: _updateSemanticsForRenderObject,\n        child: result,\n      );\n    }\n    return result;\n  }\n```\n\n这里同样调用了**Listener**控件，看看 **_handlePointerDown**：\n\n```dart\n  void _handlePointerDown(PointerDownEvent event) {\n    assert(_recognizers != null);\n    for (final GestureRecognizer recognizer in _recognizers!.values) {\n      recognizer.addPointer(event);\n    }\n  }\n```\n\n把事件添加到对应的**recognizer**，如果只设置了**onTap**事件，那么这里的**recognizer**就是**TapGestureRecognizer**。\n\n```dart\n  void addPointer(PointerDownEvent event) {\n    _pointerToKind[event.pointer] = event.kind;\n    if (isPointerAllowed(event)) {\n      addAllowedPointer(event);\n    } else {\n      handleNonAllowedPointer(event);\n    }\n  }\n```\n\n这里的**addAllowedPointer**实现在**BaseTapGestureRecognizer**：\n\n```dart\n  @override\n  void addAllowedPointer(PointerDownEvent event) {\n    if (state == GestureRecognizerState.ready) {\n      // If there is no result in the previous gesture arena,\n      // we ignore them and prepare to accept a new pointer.\n      if (_down != null && _up != null) {\n        assert(_down!.pointer == _up!.pointer);\n        _reset();\n      }\n\n      assert(_down == null && _up == null);\n      // `_down` must be assigned in this method instead of `handlePrimaryPointer`,\n      // because `acceptGesture` might be called before `handlePrimaryPointer`,\n      // which relies on `_down` to call `handleTapDown`.\n      _down = event;\n    }\n    if (_down != null) {\n      // This happens when this tap gesture has been rejected while the pointer\n      // is down (i.e. due to movement), when another allowed pointer is added,\n      // in which case all pointers are ignored. The `_down` being null\n      // means that _reset() has been called, since it is always set at the\n      // first allowed down event and will not be cleared except for reset(),\n      super.addAllowedPointer(event);\n    }\n  }\n```\n\n经过连续调用到了**OneSequenceGestureRecognizer**的**startTrackingPointer**：\n\n```dart\n  @protected\n  void startTrackingPointer(int pointer, [Matrix4? transform]) {\n    GestureBinding.instance.pointerRouter.addRoute(pointer, handleEvent, transform);\n    _trackedPointers.add(pointer);\n    // TODO(goderbauer): Enable assert after recognizers properly clean up their defunct `_entries`, see https://github.com/flutter/flutter/issues/117356.\n    // assert(!_entries.containsKey(pointer));\n    _entries[pointer] = _addPointerToArena(pointer);\n  }\n```\n\n这里就做了两件事：\n\n`GestureBinding.instance.pointerRouter.addRoute(pointer, handleEvent, transform);`加入到**pointerRouter**的 **_routeMap**。\n\n`GestureBinding.instance.gestureArena.add(pointer, this);`加入到**GestureArenaManager**的 **_arenas**。\n\n## GestureBinding\n\n上面把事件加入到那两个Map里就完事了，但是竞技还没开始，\n\n回到最开始的**RenderBinding**的**hittest**：\n\n```dart\n  @override\n  void hitTest(HitTestResult result, Offset position) {\n    renderView.hitTest(result, position: position);\n    super.hitTest(result, position);\n  }\n```\n\n这里的**super.hitTest**就是**GestureBinding**：\n\n```dart\n    result.add(HitTestEntry(this));\n```\n\n**GestureBinding**把自己加入到了最后，那么看看它的**handleEvent**：\n\n```dart\n  @override // from HitTestTarget\n  void handleEvent(PointerEvent event, HitTestEntry entry) {\n    pointerRouter.route(event);\n    if (event is PointerDownEvent || event is PointerPanZoomStartEvent) {\n      gestureArena.close(event.pointer);\n    } else if (event is PointerUpEvent || event is PointerPanZoomEndEvent) {\n      gestureArena.sweep(event.pointer);\n    } else if (event is PointerSignalEvent) {\n      pointerSignalResolver.resolve(event);\n    }\n  }\n```\n\n## PointerDownEvent\n\n如果是**PointerDownEvent**，看下**close**方法：\n\n```dart\n  void close(int pointer) {\n    final _GestureArena? state = _arenas[pointer];\n    if (state == null) {\n      return; // This arena either never existed or has been resolved.\n    }\n    state.isOpen = false;\n    assert(_debugLogDiagnostic(pointer, 'Closing', state));\n    _tryToResolveArena(pointer, state);\n  }\n```\n\n如果像Listener测试里只使用Listener控件时，没有涉及手势和竞技场添加，所以这里**state==null**，不会继续执行的。\n\n相反如果使用**GestureDetector**涉及了手势，会执行 **_tryToResolveArena**：\n\n```dart\n  void _tryToResolveArena(int pointer, _GestureArena state) {\n    assert(_arenas[pointer] == state);\n    assert(!state.isOpen);\n    if (state.members.length == 1) {\n      scheduleMicrotask(() => _resolveByDefault(pointer, state));\n    } else if (state.members.isEmpty) {\n      _arenas.remove(pointer);\n      assert(_debugLogDiagnostic(pointer, 'Arena empty.'));\n    } else if (state.eagerWinner != null) {\n      assert(_debugLogDiagnostic(pointer, 'Eager winner: ${state.eagerWinner}'));\n      _resolveInFavorOf(pointer, state, state.eagerWinner!);\n    }\n  }\n```\n\n如果是**PointerDownEvent**且竞技场成员只有一个，那么胜出者就是它，否则胜出者是**eagerWinner**。\n\n## PointerUpEvent\n\n看下**sweep**方法：\n\n```dart\n  void sweep(int pointer) {\n    final _GestureArena? state = _arenas[pointer];\n    if (state == null) {\n      return; // This arena either never existed or has been resolved.\n    }\n    assert(!state.isOpen);\n    if (state.isHeld) {\n      state.hasPendingSweep = true;\n      assert(_debugLogDiagnostic(pointer, 'Delaying sweep', state));\n      return; // This arena is being held for a long-lived member.\n    }\n    assert(_debugLogDiagnostic(pointer, 'Sweeping', state));\n    _arenas.remove(pointer);\n    if (state.members.isNotEmpty) {\n      // First member wins.\n      assert(_debugLogDiagnostic(pointer, 'Winner: ${state.members.first}'));\n      state.members.first.acceptGesture(pointer);\n      // Give all the other members the bad news.\n      for (int i = 1; i < state.members.length; i++) {\n        state.members[i].rejectGesture(pointer);\n      }\n    }\n  }\n```\n\n触摸抬起时，成员不为空，强制第一个成员接收事件。\n\n也就是说如果**GestureDetector**嵌套了，那么只会调用最深层的**GestureDetector**相关事件，比如**onTapUp**。"
  },
  {
    "title": "Flutter setState之后发生了什么(源码分析)",
    "created_time": "2021-10-20 14:31:25",
    "body": "# setState\n\n**setState**代码很简单，就是执行了传入的函数及**markNeedsBuild**：\n\n```dart\n  void setState(VoidCallback fn) {\n    final Object? result = fn() as dynamic;\n    _element!.markNeedsBuild();\n  }\n```\n\n**markNeedsBuild**是标记重建。\n\n# markNeedsBuild\n\n```dart\n  void markNeedsBuild() {\n    if (_lifecycleState != _ElementLifecycle.active) {\n      return;\n    }\n    if (dirty) {\n      return;\n    }\n    _dirty = true;\n    owner!.scheduleBuildFor(this);\n  }\n```\n\n**markNeedsBuild**关键代码就2行，设置当前**Element**为 **dirty**，\n\n然后调用**scheduleBuildFor**传入当前**Element**对象。\n\n# owner!.scheduleBuildFor\n\n```dart\n  void scheduleBuildFor(Element element) {\n    if (element._inDirtyList) {\n      _dirtyElementsNeedsResorting = true;\n      return;\n    }\n    if (!_scheduledFlushDirtyElements && onBuildScheduled != null) {\n      _scheduledFlushDirtyElements = true;\n      onBuildScheduled!();\n    }\n    _dirtyElements.add(element);\n    element._inDirtyList = true;\n  }\n```\n\n该方法把传入的**Element**对象加入到集合 **_dirtyElements**。\n\n然后呢？\n\n往上看**onBuildScheduled**。\n\n# onBuildScheduled\n\n这个函数是在**WidgetsBinding**初始化时回调的函数**initInstances**中传入的：\n\n```dart\n    _buildOwner = BuildOwner();\n    buildOwner!.onBuildScheduled = _handleBuildScheduled;\n```\n\n调用**onBuildScheduled**就是调用 **_handleBuildScheduled**：\n\n```dart\n  void _handleBuildScheduled() {\n    ensureVisualUpdate();\n  }\n```\n\n# ensureVisualUpdate\n\n该函数是注册**Vsync**信号的监听。\n\n```dart\n  void ensureVisualUpdate() {\n    switch (schedulerPhase) {\n      case SchedulerPhase.idle:\n      case SchedulerPhase.postFrameCallbacks:\n        scheduleFrame();\n        return;\n      case SchedulerPhase.transientCallbacks:\n      case SchedulerPhase.midFrameMicrotasks:\n      case SchedulerPhase.persistentCallbacks:\n        return;\n    }\n  }\n```\n\n默认情况下**schedulerPhase**状态是**idle**，\n\n所以会执行**scheduleFrame**。\n\n# scheduleFrame\n\n```dart\n  void scheduleFrame() {\n    if (_hasScheduledFrame || !framesEnabled) {\n      return;\n    }\n    ensureFrameCallbacksRegistered();\n    platformDispatcher.scheduleFrame();\n    _hasScheduledFrame = true;\n  }\n```\n\n**ensureFrameCallbacksRegistered**注册监听回调：\n\n```dart\n  void ensureFrameCallbacksRegistered() {\n    platformDispatcher.onBeginFrame ??= _handleBeginFrame;\n    platformDispatcher.onDrawFrame ??= _handleDrawFrame;\n  }\n```\n\n当上一节的**Vsync**信号到来时会先后调用 **_handleBeginFrame**和 **_handleDrawFrame**。\n\n**Element**重建绘制在 **_handleDrawFrame**中，里面直接调用了**handleDrawFrame**\n\n# handleDrawFrame\n\n```dart\n  void handleDrawFrame() {\n    _frameTimelineTask?.finish(); // end the \"Animate\" phase\n    try {\n      // PERSISTENT FRAME CALLBACKS\n      _schedulerPhase = SchedulerPhase.persistentCallbacks;\n      for (final FrameCallback callback in _persistentCallbacks) {\n        _invokeFrameCallback(callback, _currentFrameTimeStamp!);\n      }\n\n      // POST-FRAME CALLBACKS\n      _schedulerPhase = SchedulerPhase.postFrameCallbacks;\n      final List<FrameCallback> localPostFrameCallbacks =\n          List<FrameCallback>.of(_postFrameCallbacks);\n      _postFrameCallbacks.clear();\n      for (final FrameCallback callback in localPostFrameCallbacks) {\n        _invokeFrameCallback(callback, _currentFrameTimeStamp!);\n      }\n    } finally {\n      _schedulerPhase = SchedulerPhase.idle;\n      _frameTimelineTask?.finish(); // end the Frame\n      _currentFrameTimeStamp = null;\n    }\n  }\n```\n\n这里主要调用了永久性回调 **_persistentCallbacks**和一次性回调 **_postFrameCallbacks**。\n\n期中三棵树的更新在永久性回调 **_persistentCallbacks**中。\n\n**_persistentCallbacks**是通过**addPersistentFrameCallback**添加的。\n\n那么**addPersistentFrameCallback**在什么时候调用的呢？\n\n在**RendererBinding**初始化回调**initInstances**调用的：\n\n```dart\n    addPersistentFrameCallback(_handlePersistentFrameCallback);\n```\n\n**_handlePersistentFrameCallback**函数：\n\n```dart\n  void _handlePersistentFrameCallback(Duration timeStamp) {\n    drawFrame();\n    _scheduleMouseTrackerUpdate();\n  }\n```\n\n# drawFrame\n\n**WidgetsBinding**重写了**RendererBinding**的方法：\n\n```dart\n  void drawFrame() {\n    TimingsCallback? firstFrameCallback;\n    if (_needToReportFirstFrame) {\n      firstFrameCallback = (List<FrameTiming> timings) {\n        SchedulerBinding.instance.removeTimingsCallback(firstFrameCallback!);\n        firstFrameCallback = null;\n        _firstFrameCompleter.complete();\n      };\n      // Callback is only invoked when FlutterView.render is called. When\n      // sendFramesToEngine is set to false during the frame, it will not be\n      // called and we need to remove the callback (see below).\n      SchedulerBinding.instance.addTimingsCallback(firstFrameCallback!);\n    }\n\n    try {\n      if (rootElement != null) {\n        buildOwner!.buildScope(rootElement!);\n      }\n      super.drawFrame();\n      buildOwner!.finalizeTree();\n    } finally {\n    \n    }\n  \n    _needToReportFirstFrame = false;\n    if (firstFrameCallback != null && !sendFramesToEngine) {\n      // This frame is deferred and not the first frame sent to the engine that\n      // should be reported.\n      _needToReportFirstFrame = true;\n      SchedulerBinding.instance.removeTimingsCallback(firstFrameCallback!);\n    }\n  }\n```\n\n这里主要看3点：\n\n第一点：`buildOwner!.buildScope(rootElement!);`调用重建\n\n第二点：`super.drawFrame();`调用重新布局和绘制\n\n第三点：`buildOwner!.finalizeTree();`回收**inactive**的**Element**\n\n## buildScope重建\n\n```dart\n  void buildScope(Element context, [ VoidCallback? callback ]) {\n    if (callback == null && _dirtyElements.isEmpty) {\n      return;\n    }\n    try {\n      _scheduledFlushDirtyElements = true;\n      if (callback != null) {\n        assert(_debugStateLocked);\n        Element? debugPreviousBuildTarget;\n        assert(() {\n          debugPreviousBuildTarget = _debugCurrentBuildTarget;\n          _debugCurrentBuildTarget = context;\n          return true;\n        }());\n        _dirtyElementsNeedsResorting = false;\n        try {\n          callback();\n        } finally {\n        }\n      }\n      _dirtyElements.sort(Element._sort);\n      _dirtyElementsNeedsResorting = false;\n      int dirtyCount = _dirtyElements.length;\n      int index = 0;\n      while (index < dirtyCount) {\n        final Element element = _dirtyElements[index];\n\n        final bool isTimelineTracked = !kReleaseMode && _isProfileBuildsEnabledFor(element.widget);\n   \n        try {\n          element.rebuild();\n        } catch (e, stack) {\n          _reportException(\n            ErrorDescription('while rebuilding dirty elements'),\n            e,\n            stack,\n            informationCollector: () => <DiagnosticsNode>[\n              if (kDebugMode && index < _dirtyElements.length)\n                DiagnosticsDebugCreator(DebugCreator(element)),\n              if (index < _dirtyElements.length)\n                element.describeElement('The element being rebuilt at the time was index $index of $dirtyCount')\n              else\n                ErrorHint('The element being rebuilt at the time was index $index of $dirtyCount, but _dirtyElements only had ${_dirtyElements.length} entries. This suggests some confusion in the framework internals.'),\n            ],\n          );\n        }\n        if (isTimelineTracked) {\n          Timeline.finishSync();\n        }\n        index += 1;\n        if (dirtyCount < _dirtyElements.length || _dirtyElementsNeedsResorting!) {\n          _dirtyElements.sort(Element._sort);\n          _dirtyElementsNeedsResorting = false;\n          dirtyCount = _dirtyElements.length;\n          while (index > 0 && _dirtyElements[index - 1].dirty) {\n            // It is possible for previously dirty but inactive widgets to move right in the list.\n            // We therefore have to move the index left in the list to account for this.\n            // We don't know how many could have moved. However, we do know that the only possible\n            // change to the list is that nodes that were previously to the left of the index have\n            // now moved to be to the right of the right-most cleaned node, and we do know that\n            // all the clean nodes were to the left of the index. So we move the index left\n            // until just after the right-most clean node.\n            index -= 1;\n          }\n        }\n      }\n    } finally {\n      for (final Element element in _dirtyElements) {\n        assert(element._inDirtyList);\n        element._inDirtyList = false;\n      }\n      _dirtyElements.clear();\n      _scheduledFlushDirtyElements = false;\n      _dirtyElementsNeedsResorting = null;\n      if (!kReleaseMode) {\n        Timeline.finishSync();\n      }\n    }\n  }\n```\n\n该函数主要是对 **_dirtyElements**进行排序，而后遍历调用**rebuild**重建，\n\n最后清空 **_dirtyElements**。\n\n**rebuild**调用了**performRebuild**\n\n### performRebuild\n\n**Element**类函数很简单只设置了 **_dirty**值：\n\n```dart\n  void performRebuild() {\n    _dirty = false;\n  }\n```\n\n这里和开头的**markNeedsBuild**呼应了。\n\n要知道我们是调用**setState**刷新的，\n\n所以对应的**Element**为**StatefulElement**，它又继承了**ComponentElement**。\n\n**StatefulElement**的实现为：\n\n```dart\n  @override\n  void performRebuild() {\n    if (_didChangeDependencies) {\n      state.didChangeDependencies();\n      _didChangeDependencies = false;\n    }\n    super.performRebuild();\n  }\n```\n\n**ComponentElement**的实现为：\n\n```dart\n  void performRebuild() {\n    Widget? built;\n    try {\n      built = build();\n    } catch (e, stack) {\n      _debugDoingBuild = false;\n      built = ErrorWidget.builder(\n        _reportException(\n          ErrorDescription('building $this'),\n          e,\n          stack,\n          informationCollector: () => <DiagnosticsNode>[\n            if (kDebugMode)\n              DiagnosticsDebugCreator(DebugCreator(this)),\n          ],\n        ),\n      );\n    } finally {\n      // We delay marking the element as clean until after calling build() so\n      // that attempts to markNeedsBuild() during build() will be ignored.\n      super.performRebuild(); // clears the \"dirty\" flag\n    }\n    try {\n      _child = updateChild(_child, built, slot);\n      assert(_child != null);\n    } catch (e, stack) {\n      built = ErrorWidget.builder(\n        _reportException(\n          ErrorDescription('building $this'),\n          e,\n          stack,\n          informationCollector: () => <DiagnosticsNode>[\n            if (kDebugMode)\n              DiagnosticsDebugCreator(DebugCreator(this)),\n          ],\n        ),\n      );\n      _child = updateChild(null, built, slot);\n    }\n  }\n```\n\n先调用了**build**函数，因为是**StatefulElement**，所以会调用`state.build(this);`。\n\n至此实现了从**state**来又到**state**去的闭环，但目前仅仅完成了**Widget**重建，\n\n对应的**Element**和**RenderObject**更新在**updateChild**完成。\n\n### updateChild\n\n```dart\n  Element? updateChild(Element? child, Widget? newWidget, Object? newSlot) {\n    if (newWidget == null) {\n      if (child != null) {\n        deactivateChild(child);\n      }\n      return null;\n    }\n\n    final Element newChild;\n    if (child != null) {\n      bool hasSameSuperclass = true;\n\n      if (hasSameSuperclass && child.widget == newWidget) {\n        if (child.slot != newSlot) {\n          updateSlotForChild(child, newSlot);\n        }\n        newChild = child;\n      } else if (hasSameSuperclass && Widget.canUpdate(child.widget, newWidget)) {\n        if (child.slot != newSlot) {\n          updateSlotForChild(child, newSlot);\n        }      \n        child.update(newWidget);\n        newChild = child;\n      } else {\n        deactivateChild(child);\n     \n        newChild = inflateWidget(newWidget, newSlot);\n      }\n    } else {\n \n      newChild = inflateWidget(newWidget, newSlot);\n    }\n    return newChild;\n  }\n```\n\n该函数首先判断**newWidget**如果为null，说明**build**后移除了Widget，那么Element类型的**child**应该从Element tree移除，调用了**deactivateChild**。\n\n接着根据**child**是否有值产生2个分支：\n\n分支2：如果**child**不存在，是首次渲染，调用**inflateWidget**通过`Widget.createElement`创建Element挂在并返回。\n\n分支1：如果**child**存在，说明不是首次渲染，又分为3种情况：\n\n情况1：如果`child.widget == newWidget`，直接复用**child**\n\n情况2：如果`Widget.canUpdate(child.widget, newWidget)`，调用**update**更新Element的**_widget**，如果该Element是**StatefulElement**，还会更新**state**的Widget属性；\n\n如果是**RenderObjectElement**，还会调用**updateRenderObject**更新**RenderObject**对象。\n\n情况3：新的Widget类型和旧的类型不同，需要移除旧的Element，同时**inflateWidget**新的\n\n## 重新布局绘制\n\n上边说了**WidgetsBinding**重写了**RendererBinding**的方法，\n\n**super.drawFrame**调用了重新布局和绘制：\n\n```dart\nvoid drawFrame() {\n    pipelineOwner.flushLayout();\n    pipelineOwner.flushCompositingBits();\n    pipelineOwner.flushPaint();\n    if (sendFramesToEngine) {\n      renderView.compositeFrame(); // this sends the bits to the GPU\n      pipelineOwner.flushSemantics(); // this also sends the semantics to the OS.\n      _firstFrameSent = true;\n    }\n  }\n```\n\n## 回收无用Element\n\n### finalizeTree\n\n```dart\n  void finalizeTree() {\n    try {\n      lockState(_inactiveElements._unmountAll); // this unregisters the GlobalKeys\n    } catch (e, stack) {\n      // Catching the exception directly to avoid activating the ErrorWidget.\n      // Since the tree is in a broken state, adding the ErrorWidget would\n      // cause more exceptions.\n      _reportException(ErrorSummary('while finalizing the widget tree'), e, stack);\n    } finally {\n      if (!kReleaseMode) {\n        Timeline.finishSync();\n      }\n    }\n  }\n```\n\n**lockState**里调用了`_inactiveElements._unmountAll`：\n\n```dart\n  void _unmountAll() {\n    _locked = true;\n    final List<Element> elements = _elements.toList()..sort(Element._sort);\n    _elements.clear();\n    try {\n      elements.reversed.forEach(_unmount);\n    } finally {\n      assert(_elements.isEmpty);\n      _locked = false;\n    }\n  }\n```\n\n这里遍历 **_inactiveElements**调用 **_unmount**：\n\n```dart\n  void _unmount(Element element) {\n    element.visitChildren((Element child) {\n      assert(child._parent == element);\n      _unmount(child);\n    });\n    element.unmount();\n  }\n```\n\n**_unmount**递归调用子Element的 **unmount**。"
  },
  {
    "title": "Flutter InheritedWidget原理(源码分析)",
    "created_time": "2022-01-20 14:31:25",
    "body": "状态管理是Flutter避不开的话题，而**InheritedWidget**又是状态管理的基础。\n\n一起看看**InheritedWidget**底层是怎么实现的。\n\n# dependOnInheritedWidgetOfExactType\n\n这个函数是学习状态管理时的首先接触到的，所以把这个函数当成入口看看：\n\n```dart\n  @override\n  T? dependOnInheritedWidgetOfExactType<T extends InheritedWidget>({Object? aspect}) {\n    final InheritedElement? ancestor = _inheritedElements == null ? null : _inheritedElements![T];\n    if (ancestor != null) {\n      return dependOnInheritedElement(ancestor, aspect: aspect) as T;\n    }\n    _hadUnsatisfiedDependencies = true;\n    return null;\n  }\n```\n\n可以看到每个**Element**都有一个`PersistentHashMap<Type, InheritedElement>? _inheritedElements;`属性。\n\n这个属性哪里来的呢？\n\n## _updateInheritance\n\n**_inheritedElements**值来自 **_updateInheritance**函数：\n\n```dart\n  void _updateInheritance() {\n    _inheritedElements = _parent?._inheritedElements;\n  }\n```\n\n然后**InheritedElement**重写了该函数：\n\n```dart\n  @override\n  void _updateInheritance() {\n    final PersistentHashMap<Type, InheritedElement> incomingWidgets =\n        _parent?._inheritedElements ?? const PersistentHashMap<Type, InheritedElement>.empty();\n    _inheritedElements = incomingWidgets.put(widget.runtimeType, this);\n  }\n```\n\n由此可知**普通ELement**该值来自父类对象，\n\n**InheritedElement**该值除了来自父类对象，而后又把自身所持Widget和自身放了进去。\n\n该函数在**mount**挂在时被调用。\n\n我们继续**dependOnInheritedWidgetOfExactType**函数分析，\n\n**ancestor**为我们根据指定的**InheritedWidget**返回的**InheritedElement**。\n\n如果在这个Element tree上存在该**InheritedWidget**，那么**ancestor**是会有值的，\n\n所以调用**dependOnInheritedElement**\n\n## dependOnInheritedElement\n\n```dart\n  @override\n  InheritedWidget dependOnInheritedElement(InheritedElement ancestor, { Object? aspect }) {\n    _dependencies ??= HashSet<InheritedElement>();\n    _dependencies!.add(ancestor);\n    ancestor.updateDependencies(this, aspect);\n    return ancestor.widget as InheritedWidget;\n  }\n```\n\n这里又看到了一个新变量`Set<InheritedElement>? _dependencies;`。\n\n把刚刚拿到的`InheritedElement ancestor`添加进去。\n\n这是告诉我们，我这个Element依赖了某一祖先结点**ancestor**。\n\n然后调用了**updateDependencies**函数：\n\n```dart\n  @protected\n  void updateDependencies(Element dependent, Object? aspect) {\n    setDependencies(dependent, null);\n  }\n  \n    @protected\n  void setDependencies(Element dependent, Object? value) {\n    _dependents[dependent] = value;\n  }\n```\n\n注意这个函数是**ancestor**调用的，它是**InheritedElement**类型。\n\n也就是**InheritedElement**有一个变量：\n\n`final Map<Element, Object?> _dependents = HashMap<Element, Object?>();`。\n\n现在**InheritedElement**通过该变量又持有了使用它的所有ELement。\n\n所以现在情况来看是互相持有了。\n\n最后通过`ancestor.widget as InheritedWidget;`返回我们需要的\n\nInheritedWidget。\n\n# update\n\n现在流程看，虽然它们互相持有对方了，而且也能从祖先结点获取到InheritedWidget，\n\n进而获取所需数据。\n\n但是InheritedWidget中数据是如何变化的？子类又是如何刷新的呢?\n\n先说InheritedWidget中数据是如何变化的，\n\n一般InheritedWidget外层会套一个StatefulWidget。\n\nStatefulWidget的State的**build**函数中调用InheritedWidget并传入从外部接收的数据。\n\n这个数据一般是**ChangeNotifier**实现类，在State中为其添加**addListener**。\n\n当该值发生变化时调用**notifyListeners**，进而调用**setState**，最终导致ELement重建。\n\n自然**InheritedWidget**也会跟随重建，具体流程可以参考文章**setState流程分析**。\n\n当**InheritedWidget**重建时，**updateChild**函数中，\n\n由于Widget类型没有变，所以`Widget.canUpdate(child.widget, newWidget)`会返回true，进而调用`child.update(newWidget)`。\n\n由于**child**类型为**InheritedElement**，所以会调用：\n\n```dart\n@override\n  void update(ProxyWidget newWidget) {\n    final ProxyWidget oldWidget = widget as ProxyWidget;\n    super.update(newWidget);\n    updated(oldWidget);\n    rebuild(force: true);\n  }\n\n\n  @protected\n  void updated(covariant ProxyWidget oldWidget) {\n    notifyClients(oldWidget);\n  }\n\n\n  @override\n  void notifyClients(InheritedWidget oldWidget) {\n    for (final Element dependent in _dependents.keys) {\n      // check that it really depends on us\n      assert(dependent._dependencies!.contains(this));\n      notifyDependent(oldWidget, dependent);\n    }\n  }\n\n\n  @protected\n  void notifyDependent(covariant InheritedWidget oldWidget, Element dependent) {\n    dependent.didChangeDependencies();\n  }\n```\n\n通过这几个函数的连续调用，可以看到**InheritedElement**重建时，\n\n会遍历上边讲到的变量 **_dependents**，并调用**didChangeDependencies**。\n\n至此所有依赖该**InheritedElement**的Element都被调用了**didChangeDependencies**。\n\n而**didChangeDependencies**又调用了**markNeedsBuild**，以达到刷新所有依赖它的Element。\n\n这里有一点注意下，如果依赖的Element是**StatefulElement**，\n\n在调用**didChangeDependencies**时会设置`_didChangeDependencies = true;`。\n\n这个值用来判断**State**是否调用**didChangeDependencies**条件：\n\n```dart\n  @override\n  void performRebuild() {\n    if (_didChangeDependencies) {\n      state.didChangeDependencies();\n      _didChangeDependencies = false;\n    }\n    super.performRebuild();\n  }\n```\n\n# getInheritedWidgetOfExactType\n\n上面说了调用**dependOnInheritedWidgetOfExactType**会注册当前**Element**，\n\n所以数据改变时会刷新。\n\n那么如果我不想要监听刷新，只是单纯的想获取值该怎么办？\n\n可以调用**getInheritedWidgetOfExactType**函数来实现：\n\n```dart\n  @override\n  T? getInheritedWidgetOfExactType<T extends InheritedWidget>() {\n    return getElementForInheritedWidgetOfExactType<T>()?.widget as T?;\n  }\n\n  @override\n  InheritedElement? getElementForInheritedWidgetOfExactType<T extends InheritedWidget>() {\n    final InheritedElement? ancestor = _inheritedElements == null ? null : _inheritedElements![T];\n    return ancestor;\n  }\n```\n\n可以发现该函数只是获取**ancestor**，没有向其添加当前Element。\n\n# _dependencies\n\n有一点你们是不是忽略了，\n\n前边说了子Element和InheritedElement互相持有的。\n\n子Element通过 **_dependencies** 持有它依赖的 **InheritedElement**，\n\n而**InheritedElement**通过 **_dependents**持有依赖它的Element。\n\n其中 **_dependents**在 **notifyDependent**中用到了，\n\n那 **_dependencies**有什么用了？？\n\n不知道你们有没有这个疑惑。。。\n\n看下**deactivate**实现：\n\n```dart\n  void deactivate() {\n    assert(_lifecycleState == _ElementLifecycle.active);\n    if (_dependencies != null && _dependencies!.isNotEmpty) {\n      for (final InheritedElement dependency in _dependencies!) {\n        dependency._dependents.remove(this);\n      }\n    }\n    _inheritedElements = null;\n    _lifecycleState = _ElementLifecycle.inactive;\n  }\n```\n\n当Element从tree中移除后调用**deactivate**。\n\n此时它在UI中不可见，也就没必要跟随数据刷新了，\n\n所以就告诉它依赖的所有**InheritedElement**：\n\n我不在了，你们可以删除我了，数据改变时不要通知我了。"
  },
  {
    "title": "Flutter延迟加载",
    "created_time": "2022-02-20 14:31:25",
    "body": "Flutter web仅仅几个页面构建后的`main.dart.js`文件就有3.7m大小。\n\n文件过大导致首次加载很慢，需要将该文件进行分包。\n\n延迟加载**deferred as**功能可以实现分包，\n\n实现那些通过跳转的深层页面使用延迟加载。\n\n看看分包前大小：\n\n![未分包](https://jenson-1258324340.cos.ap-beijing.myqcloud.com/%E6%9C%AA%E5%88%86%E5%8C%85main.dart.jpg)\n\n# 0x00 创建新route文件\n\n## 1、创建 blog_route.dart\n\n## 2、deferred as 深层page\n\n导入所有要延迟加载的深层页面：\n\n```dart\nimport 'page/markdown_page.dart' deferred as post_detail;\nimport 'page/gq_page.dart' deferred as gq_page;\nimport 'page/gqdetail_page.dart' deferred as gqdetail_page;\nimport 'page/phb_page.dart' deferred as phb_page;\n```\n\n## 3、创建BlogRoute类\n\n为深层page声明静态变量\n\n同时创建函数**onGenerateRoute**：\n\n```dart\nclass BlogRoute {\n  static const String MARKDOWN_PAGE = 'markdown_page';\n  static const String GQ_PAGE = 'gq_page';\n  static const String GQDETAIL_PAGE = 'gqdetail_page';\n  static const String PHB_PAGE = 'phb_page';\n\n  static Route<dynamic>? onGenerateRoute(RouteSettings settings) {\n    print('BlogRoute onGenerateRoute');\n    return MaterialPageRoute(\n        settings: settings,\n        builder: (context) => DefferedLoadWidget(settings: settings));\n  }\n}\n```\n\n为**materialapp**的**onGenerateRoute**配置`onGenerateRoute: BlogRoute.onGenerateRoute`，这样所有的路由会通过这里。\n\n## 4、定义顶层函数 WidgetConstructor\n\n`typedef WidgetConstructor = Widget Function();`\n\n## 5、定义顶层变量 defferLoadMap\n\nmap中**key**为命名页面的常量，**value**为每个延迟页面的**loadLibrary**：\n\n```dart\nvar defferLoadMap = {\n  BlogRoute.MARKDOWN_PAGE: post_detail.loadLibrary,\n  BlogRoute.GQ_PAGE: gq_page.loadLibrary,\n  BlogRoute.GQDETAIL_PAGE: gqdetail_page.loadLibrary,\n  BlogRoute.PHB_PAGE: phb_page.loadLibrary\n};\n```\n\n## 6、定义顶层变量 constructorMap\n\n```dart\nvar constructorMap = {\n  ///注意这里value是函数类型，不能直接post_detail.newWidget ，会出现DeferredNotLoadedError\n  BlogRoute.MARKDOWN_PAGE: () => post_detail.newWidget,\n  BlogRoute.GQ_PAGE: () => gq_page.newWidget,\n  BlogRoute.GQDETAIL_PAGE: () => gqdetail_page.newWidget,\n  BlogRoute.PHB_PAGE: () => phb_page.newWidget\n};\n```\n\n这里的**newWidget**实现为:\n\n```dart\nWidgetConstructor newWidget = () {\n  return const xxxxPage();\n};\n```\n\n注意每个深层页面里都要有这样一个对应的函数。\n\n# 0x01 创建DefferedLoadWidget\n\n这里的**DefferedLoadWidget**是一个**StatefulWidget**\n\n```dart\nclass DefferedLoadWidget extends StatefulWidget {\n  final RouteSettings settings;\n\n  const DefferedLoadWidget({super.key, required this.settings});\n\n  @override\n  State<StatefulWidget> createState() => _DefferLoadState();\n}\n```\n\n创建 **_DefferLoadState**：\n\n```dart\nclass _DefferLoadState extends State<DefferedLoadWidget> {\n  Future Function()? fun;\n  String path = '';\n  late Future future;\n\n  @override\n  void initState() {\n    super.initState();\n    Uri uri = Uri.parse(widget.settings.name ?? \"\");\n    path = uri.path;\n    fun = defferLoadMap[path];\n    future = fun!.call();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return FutureBuilder(\n      future: future,\n      builder: (context, snap) {\n        if (snap.connectionState == ConnectionState.done) {\n          if (snap.hasError) {\n            return const Center(\n              child: Text('页面加载失败'),\n            );\n          }\n          return constructorMap[path]!().call();\n        }\n        return const UnconstrainedBox(\n          child: SizedBox(\n            width: 40,\n            height: 40,\n            child: CircularProgressIndicator(),\n          ),\n        );\n      },\n    );\n  }\n}\n```\n\n**initState**中通过**settings**拿到**path**，这里的**path**就是命名路由的**key**。\n\n所以通过`defferLoadMap[path]`能得到对应延迟加载页面的**loadLibrary**函数。\n\n调用该函数返回**future**，传递给**FutureBuilder**。\n\n在返回结果前是不能直接使用对应页面的。\n\n所以使用前先展示loading，状态完成时\n\n`snap.connectionState == ConnectionState.done`且没有错误\n\n表示延迟加载完成，\n\n此时调用`constructorMap[path]!()`拿到并执行**constructorMap**的**value**函数，\n\n这个函数返回的是创建各个页面实例的函数，继续调用执行即可。\n\n看看分包后的大小：\n![分包后大小](https://jenson-1258324340.cos.ap-beijing.myqcloud.com/%E5%88%86%E5%8C%85%E7%9A%84main.dart.jpg)"
  },
  {
    "title": "Flutter新项目依赖库代理设置",
    "created_time": "2020-07-20 14:31:25",
    "body": "# 项目代理设置\n\n找到android下的**build.gradle**设置两处**repositories**：\n\n```yaml\n        maven { url 'https://maven.aliyun.com/repository/public' }\n        maven { url 'https://maven.aliyun.com/repository/google' }\n        maven { url 'https://maven.aliyun.com/repository/jcenter' }\n        maven { url 'https://maven.aliyun.com/repository/central' }\n        maven { url \"https://maven.aliyun.com/nexus/content/repositories/jcenter/\" }\n        maven { url 'https://maven.aliyun.com/nexus/content/groups/public' }\n        maven { url \"https://download.flutter.io\" }\n//        maven { url 'https://storage.googleapis.com/download.flutter.io' }\n        maven { url 'https://jitpack.io' }\n```\n\n# 全局设置\n\n如果运行时出现了如下错误：\n\n```log\nCould not download armeabi_v7a_debug-1.0.0-45f6e009110df4f34ec2cf99f63cf73b71b7a420.jar (io.flutter:armeabi_v7a_debug:1.0.0-45f6e009110df4f34ec2cf99f63cf73b71b7a420)\n > Could not get resource 'https://storage.googleapis.com/download.flutter.io/io/flutter/armeabi_v7a_debug/1.0.0-45f6e009110df4f34ec2cf99f63cf73b71b7a420/armeabi_v7a_debug-1.0.0-45f6e009110df4f34ec2cf99f63cf73b71b7a420.jar'.\n```\n\n找到**flutter sdk目录下的**几处地方：\n\n```yaml\n   flutter/packages/flutter_tools/gradle/resolve_dependencies.gradle\n   flutter/packages/flutter_tools/gradle/aar_init_script.gradle\n   flutter/packages/flutter_tools/gradle/flutter.gradle\n```\n\n找到`https://storage.googleapis.com/download.flutter.io`\n\n替换为`https://download.flutter.io`。"
  },
  {
    "title": "flutter.minSdkVersion在哪设置",
    "created_time": "2020-06-20 14:31:25",
    "body": "在FlutterSDK目录下\n\n`/Users/jenson/Library/flutter/packages/flutter_tools/gradle/flutter.gradle`"
  },
  {
    "title": "Get是如何通过parameter传递参数的(源码分析)",
    "created_time": "2022-02-23 14:31:25",
    "body": "# 没有拿到数据\n\n跳转到文章详情页面时通过\n\n`Get.toNamed(BlogRoute.MARKDOWN_PAGE, \nparameters: {\"name\": post.title})`传递了文章名称。\n\n详情页面通过`String? name = Get.parameters['name'];`\n\n获取传入的**parameter**但是为null导致页面显示异常。\n\n# 获取parameter流程\n\n看下`Get.parameter`方法：\n\n```dart\nMap<String, String?> get parameters => _getxController.parameters;\n```\n\n这里的 **_getxController**是一个静态变量：\n\n`static GetMaterialController _getxController = GetMaterialController();`\n\n**parameters**类型`Map<String, String?> parameters = {};`。\n\n没有什么复杂逻辑，就是获取变量**parameters**的值。\n\n# parameter赋值流程\n\n接下来看看 **parameter**是如何赋值的。\n\n上面的**get**方法下其实还带了**set**：\n\n```dart\n  Map<String, String?> get parameters => _getxController.parameters;\n  set parameters(Map<String, String?> newParameters) =>\n      _getxController.parameters = newParameters;\n```\n\n有两处调用了**set**方法：\n\n```dart\n  void addPageParameter(GetPage route) {\n    if (route.parameters == null) return;\n\n    final parameters = Get.parameters;\n    parameters.addEntries(route.parameters!.entries);\n    Get.parameters = parameters;\n  }\n  \n    bool needRecheck() {\n    if (settings == null && route != null) {\n      settings = route;\n    }\n    final match = Get.routeTree.matchRoute(settings!.name!);\n    Get.parameters = match.parameters;\n\n    // No Match found\n    if (match.route == null) {\n      isUnknown = true;\n      return false;\n    }\n\n    final runner = MiddlewareRunner(match.route!.middlewares);\n    route = runner.runOnPageCalled(match.route);\n    addPageParameter(route!);\n\n    // No middlewares found return match.\n    if (match.route!.middlewares == null || match.route!.middlewares!.isEmpty) {\n      return false;\n    }\n    final newSettings = runner.runRedirect(settings!.name);\n    if (newSettings == null) {\n      return false;\n    }\n    settings = newSettings;\n    return true;\n  }\n```\n\n这里的**addPageParameter**也是在**needRecheck**中调用的。\n\n所以主要看**needRecheck**是在哪里调用的。\n\n查找发现有两处调用了**needRecheck**：\n\n```dart\n  // redirect all pages that needes redirecting\n  GetPageRoute<T> page<T>() {\n    while (needRecheck()) {}\n    final _r = (isUnknown ? unknownRoute : route)!;\n    return GetPageRoute<T>(\n      page: _r.page,\n      parameter: _r.parameters,\n      settings: isUnknown\n          ? RouteSettings(\n              name: _r.name,\n              arguments: settings!.arguments,\n            )\n          : settings,\n      curve: _r.curve,\n      opaque: _r.opaque,\n      showCupertinoParallax: _r.showCupertinoParallax,\n      gestureWidth: _r.gestureWidth,\n      customTransition: _r.customTransition,\n      binding: _r.binding,\n      bindings: _r.bindings,\n      transitionDuration:\n          _r.transitionDuration ?? Get.defaultTransitionDuration,\n      transition: _r.transition,\n      popGesture: _r.popGesture,\n      fullscreenDialog: _r.fullscreenDialog,\n      middlewares: _r.middlewares,\n    );\n  }\n\n  // redirect all pages that needes redirecting\n  GetPageRoute<T> getPageToRoute<T>(GetPage rou, GetPage? unk) {\n    while (needRecheck()) {}\n    final _r = (isUnknown ? unk : rou)!;\n\n    return GetPageRoute<T>(\n      page: _r.page,\n      parameter: _r.parameters,\n      alignment: _r.alignment,\n      title: _r.title,\n      maintainState: _r.maintainState,\n      routeName: _r.name,\n      settings: _r,\n      curve: _r.curve,\n      showCupertinoParallax: _r.showCupertinoParallax,\n      gestureWidth: _r.gestureWidth,\n      opaque: _r.opaque,\n      customTransition: _r.customTransition,\n      binding: _r.binding,\n      bindings: _r.bindings,\n      transitionDuration:\n          _r.transitionDuration ?? Get.defaultTransitionDuration,\n      transition: _r.transition,\n      popGesture: _r.popGesture,\n      fullscreenDialog: _r.fullscreenDialog,\n      middlewares: _r.middlewares,\n    );\n  }\n```\n\n## GetPage\n\n看下哪里调用了**getPageToRoute**：\n\n```dart\n  @override\n  Route<T> createRoute(BuildContext context) {\n    // return GetPageRoute<T>(settings: this, page: page);\n    final _page = PageRedirect(\n      route: this,\n      settings: this,\n      unknownRoute: unknownRoute,\n    ).getPageToRoute<T>(this, unknownRoute);\n\n    return _page;\n  }\n```\n\n**GetPage**重写了**createRoute**函数调用了**getPageToRoute**。\n\n这下明了了，**GetPage**通常是在**GetMaterialApp**的**getPages**参数里使用的。\n\n但是我现在由于是延迟加载，\n\n使用的是自定义`onGenerateRoute: BlogRoute.onGenerateRoute`。\n\n所以**GetPage**推进不下去了，暂时打住。\n\n看看**page**在哪调用的。\n\n## GetMaterialApp\n\n**page**函数在**GetMaterialApp**和**GetCupertinoApp**中。\n\n这俩组件只是风格不同，只看一个流程即可：\n\n```dart\n  Route<dynamic> generator(RouteSettings settings) {\n    return PageRedirect(settings: settings, unknownRoute: unknownRoute).page();\n  }\n\n  List<Route<dynamic>> initialRoutesGenerate(String name) {\n    return [\n      PageRedirect(\n        settings: RouteSettings(name: name),\n        unknownRoute: unknownRoute,\n      ).page()\n    ];\n  }\n```\n\n**GetMaterialApp**只是对**MaterialApp**的封装。\n\n这俩函数都在  **MaterialApp**的属性处调用：\n\n```dart\n                onGenerateRoute:\n                    (getPages != null ? generator : onGenerateRoute),\n                onGenerateInitialRoutes: (getPages == null || home != null)\n                    ? onGenerateInitialRoutes\n                    : initialRoutesGenerate,\n```\n\n可以看到由于没有设置**getPages**，所以调用的是我们自定义的**onGenerateRoute**。\n\n同样由于没有设置**getPages**，所以不会调用**initialRoutesGenerate**。\n\n这导致了一直没有机会调用**set**函数设置**parameter**。\n\n# 手动set parameter\n\n既然调用了我们自定义的**onGenerateRoute**。\n\n那我们就在该函数中，页面启动前**set parameter**：\n\n```dart\n  static Route<dynamic>? onGenerateRoute(RouteSettings settings) {\n    //这里设置parameter\n    return MaterialPageRoute(\n        settings: settings,\n        builder: (ctx) => DefferedLoadWidget(settings: settings));\n  }\n```\n\n找到了**set parameter**地方，如何拿到有哪些**parameter**呢？\n\n## 重回needRecheck\n\n这个函数有这样两行代码：\n\n```dart\n    final match = Get.routeTree.matchRoute(settings!.name!);\n    Get.parameters = match.parameters;\n```\n\n传入**settings!.name!** 到`Get.routeTree.matchRoute`：\n\n```dart\n  RouteDecoder matchRoute(String name, {Object? arguments}) {\n    final uri = Uri.parse(name);\n    // /home/profile/123 => home,profile,123 => /,/home,/home/profile,/home/profile/123\n    final split = uri.path.split('/').where((element) => element.isNotEmpty);\n    var curPath = '/';\n    final cumulativePaths = <String>[\n      '/',\n    ];\n    for (var item in split) {\n      if (curPath.endsWith('/')) {\n        curPath += '$item';\n      } else {\n        curPath += '/$item';\n      }\n      cumulativePaths.add(curPath);\n    }\n\n    final treeBranch = cumulativePaths\n        .map((e) => MapEntry(e, _findRoute(e)))\n        .where((element) => element.value != null)\n        .map((e) => MapEntry(e.key, e.value!))\n        .toList();\n\n    final params = Map<String, String>.from(uri.queryParameters);\n    if (treeBranch.isNotEmpty) {\n      //route is found, do further parsing to get nested query params\n      final lastRoute = treeBranch.last;\n      final parsedParams = _parseParams(name, lastRoute.value.path);\n      if (parsedParams.isNotEmpty) {\n        params.addAll(parsedParams);\n      }\n      //copy parameters to all pages.\n      final mappedTreeBranch = treeBranch\n          .map(\n            (e) => e.value.copy(\n              parameters: {\n                if (e.value.parameters != null) ...e.value.parameters!,\n                ...params,\n              },\n              name: e.key,\n            ),\n          )\n          .toList();\n      return RouteDecoder(\n        mappedTreeBranch,\n        params,\n        arguments,\n      );\n    }\n\n    //route not found\n    return RouteDecoder(\n      treeBranch.map((e) => e.value).toList(),\n      params,\n      arguments,\n    );\n  }\n```\n\n这里只看关键两行即可：\n\n```dart\n final uri = Uri.parse(name);\n final params = Map<String, String>.from(uri.queryParameters);\n```\n\n所以通过`Uri.parse(settings.name!).queryParameters;`即可拿到**parameter**了。\n\n最后**set parameter**如下：\n\n```dart\nstatic Route<dynamic>? onGenerateRoute(RouteSettings settings) {\n    Get.parameters = Uri.parse(settings.name!).queryParameters;\n    return MaterialPageRoute(\n        settings: settings,\n        builder: (ctx) => DefferedLoadWidget(settings: settings));\n  }\n```"
  },
  {
    "title": "Channel通信源码分析",
    "created_time": "2023-03-02 14:31:25",
    "body": "# 介绍\n\nFlutter不具备直接和Platform通信的能力，所以诞生了**platformchannel**。\n\n举例来说dart没有直接和Java交互的能力，\n\n但是Dart可以和C++交互，而C++也可以和Java交互。\n\n所以C++实现的Engine/Embeder充当了桥梁角色。\n\n直接看下Flutter和Android端通信的相关类图：\n\n![](https://jenson-1258324340.cos.ap-beijing.myqcloud.com/platformchannel.png)\n\n因为中间涉及语言的转换，所以数据传递前进行编码，得到数据时进行解码。\n\n为了能响应对端的调用，需要进行方法注册(setxxHandler)，\n\n注册的回调，Flutter端存在`ChannelBuffers._channels`。\n\nAndroid端存在于`DartMessenger.messageHandlers`。\n\n# 以BasicMessageChannel为例分析\n\n## Android端send分析\n\n创建好**MessagePllugin**后，调用其**channel**属性发送消息：\n\n```kotlin\n       MessagePllugin(flutterEngine, this).run {\n            channel.send(\"i'am from MessagePllugin\")\n        }\n```\n\n查看`channel.send`方法实现：\n\n```java\n  public void send(@Nullable T message) {\n    send(message, null);\n  }\n\n  @UiThread\n  public void send(@Nullable T message, @Nullable final Reply<T> callback) {\n    messenger.send(\n        name,\n        codec.encodeMessage(message),\n        callback == null ? null : new IncomingReplyHandler(callback));\n  }\n```\n\n这里调用了`messenger.send()`，这个**messenger**类型是接口**BinaryMessenger**，\n\n其实际类型是**BinaryMessenger**默认实现类**DefaultBinaryMessenger**。\n\n该类的**send**方法实现为：\n\n```java\n   @Override\n    @UiThread\n    public void send(\n        @NonNull String channel,\n        @Nullable ByteBuffer message,\n        @Nullable BinaryMessenger.BinaryReply callback) {\n      messenger.send(channel, message, callback);\n    }\n```\n\n这里又一个**messenger**，不过它的类型是**DartMessenger**。\n\n```java\n  @Override\n  public void send(\n      @NonNull String channel,\n      @Nullable ByteBuffer message,\n      @Nullable BinaryMessenger.BinaryReply callback) {\n    TraceSection.begin(\"DartMessenger#send on \" + channel);\n    try {\n      Log.v(TAG, \"Sending message with callback over channel '\" + channel + \"'\");\n      int replyId = nextReplyId++;\n      if (callback != null) {\n        pendingReplies.put(replyId, callback);\n      }\n      if (message == null) {\n        flutterJNI.dispatchEmptyPlatformMessage(channel, replyId);\n      } else {\n        flutterJNI.dispatchPlatformMessage(channel, message, message.position(), replyId);\n      }\n    } finally {\n      TraceSection.end();\n    }\n  }\n```\n\n这里的**send**调用了**flutterJNI**的**dispatchPlatformMessage**方法发送消息。\n\n```java\n  @UiThread\n  public void dispatchPlatformMessage(\n      @NonNull String channel, @Nullable ByteBuffer message, int position, int responseId) {\n    ensureRunningOnMainThread();\n    if (isAttached()) {\n      nativeDispatchPlatformMessage(nativeShellHolderId, channel, message, position, responseId);\n    } else {\n      Log.w(\n          TAG,\n          \"Tried to send a platform message to Flutter, but FlutterJNI was detached from native C++. Could not send. Channel: \"\n              + channel\n              + \". Response ID: \"\n              + responseId);\n    }\n  }\n\n    // Send a data-carrying platform message to Dart.\n  private native void nativeDispatchPlatformMessage(\n      long nativeShellHolderId,\n      @NonNull String channel,\n      @Nullable ByteBuffer message,\n      int position,\n      int responseId);\n```\n\n**dispatchPlatformMessage**调用了**native**方法**nativeDispatchPlatformMessage**。\n\n这样消息从Android端发送给了Engine。\n\n## Flutter端setMessageHandler分析\n\n上边消息从Android端发送给了Engine，\n\n接下来分析Engine收到消息后如何传递给Flutter的。\n\n看下**setMessageHandler**实现：\n\n```dart\n  void setMessageHandler(Future<T> Function(T? message)? handler) {\n    if (handler == null) {\n      binaryMessenger.setMessageHandler(name, null);\n    } else {\n      binaryMessenger.setMessageHandler(name, (ByteData? message) async {\n        return codec.encodeMessage(await handler(codec.decodeMessage(message)));\n      });\n    }\n  }\n```\n\n可以看到这里对参数**handler**进行了封装并通过**binaryMessenger**进行传递。\n\n这里的**binaryMessenger**是**BinaryMessenger** 的\n\n默认实现类 **_DefaultBinaryMessenger**。其实现方法如下：\n\n```dart\n  @override\n  void setMessageHandler(String channel, MessageHandler? handler) {\n    if (handler == null) {\n      ui.channelBuffers.clearListener(channel);\n    } else {\n      ui.channelBuffers.setListener(channel, (ByteData? data, ui.PlatformMessageResponseCallback callback) async {\n        ByteData? response;\n        try {\n          response = await handler(data);\n        } catch (exception, stack) {\n          FlutterError.reportError(FlutterErrorDetails(\n            exception: exception,\n            stack: stack,\n            library: 'services library',\n            context: ErrorDescription('during a platform message callback'),\n          ));\n        } finally {\n          callback(response);\n        }\n      });\n    }\n  }\n```\n\n这里再次对参数**handler**进行了封装，传入到**setListener**：\n\n```dart\n  void setListener(String name, ChannelCallback callback) {\n    final _Channel channel = _channels.putIfAbsent(name, () => _Channel());\n    channel.setListener(callback);\n  }\n```\n\n这里如果是首次的话，**_channels**中不存在**name**的**key**值，\n\n所以创建 **_Channel**进行存储并返回，把**callback**通过 **setListener**设置给它。\n\n```dart\n  void setListener(ChannelCallback callback) {\n    final bool needDrain = _channelCallbackRecord == null;\n    _channelCallbackRecord = _ChannelCallbackRecord(callback);\n    if (needDrain && !_draining) {\n      _drain();\n    }\n  }\n```\n\n这里再次对**callback**进行封装，包到了 **_ChannelCallbackRecord**。\n\n至此**sendMessengerHandler**流程分析完了，记住最初的**handler**经过三次封装进入到了\n\n**channel._channelCallbackRecord**中。\n\n当Android发来消息时，`PlatformDispatcher._dispatchPlatformMessage()`会被调用\n\n```dart\n  void _dispatchPlatformMessage(String name, ByteData? data, int responseId) {\n    if (name == ChannelBuffers.kControlChannelName) {\n      try {\n        channelBuffers.handleMessage(data!);\n      } finally {\n        _respondToPlatformMessage(responseId, null);\n      }\n    } else if (onPlatformMessage != null) {\n      _invoke3<String, ByteData?, PlatformMessageResponseCallback>(\n        onPlatformMessage,\n        _onPlatformMessageZone,\n        name,\n        data,\n        (ByteData? responseData) {\n          _respondToPlatformMessage(responseId, responseData);\n        },\n      );\n    } else {\n      channelBuffers.push(name, data, (ByteData? responseData) {\n        _respondToPlatformMessage(responseId, responseData);\n      });\n    }\n  }\n```\n\n这里会执行最后代码块：\n\n```dart\n  void push(String name, ByteData? data, PlatformMessageResponseCallback callback) {\n    final _Channel channel = _channels.putIfAbsent(name, () => _Channel());\n    if (channel.push(_StoredMessage(data, callback))) {\n      _printDebug(\n        'A message on the $name channel was discarded before it could be handled.\\n'\n        'This happens when a plugin sends messages to the framework side before the '\n        'framework has had an opportunity to register a listener. See the ChannelBuffers '\n        'API documentation for details on how to configure the channel to expect more '\n        'messages, or to expect messages to get discarded:\\n'\n        '  https://api.flutter.dev/flutter/dart-ui/ChannelBuffers-class.html'\n      );\n    }\n  }\n```\n\n由于上面已经通过**putIfAbsent**设置了值，所以这里会直接返回创建好的**channel**。\n\nAndroid端发来的数据封装到 **_StoredMessage**。\n\n```dart\n  bool push(_StoredMessage message) {\n    if (!_draining && _channelCallbackRecord != null) {\n      assert(_queue.isEmpty);\n      _channelCallbackRecord!.invoke(message.data, message.invoke);\n      return false;\n    }\n    if (_capacity <= 0) {\n      return debugEnableDiscardWarnings;\n    }\n    final bool result = _dropOverflowMessages(_capacity - 1);\n    _queue.addLast(message);\n    return result;\n  }\n```\n\n**_draining**默认为**false**，且 **_channelCallbackRecord**里封装了**handler**，\n\n所以不为空，所以会调用`_channelCallbackRecord!.invoke`：\n\n```dart\n  void invoke(ByteData? dataArg, PlatformMessageResponseCallback callbackArg) {\n    _invoke2<ByteData?, PlatformMessageResponseCallback>(_callback, _zone, dataArg, callbackArg);\n  }\n\n  void _invoke2<A1, A2>(void Function(A1 a1, A2 a2)? callback, Zone zone, A1 arg1, A2 arg2) {\n  if (callback == null) {\n    return;\n  }\n  if (identical(zone, Zone.current)) {\n    callback(arg1, arg2);\n  } else {\n    zone.runGuarded(() {\n      callback(arg1, arg2);\n    });\n  }\n}\n```\n\n**_invoke2**调用了`callback(arg1, arg2);`。\n\n这个**callback**就是 **_callback**，就是对**handler**进行二次封装函数：\n\n```dart\n     ui.channelBuffers.setListener(channel, (ByteData? data, ui.PlatformMessageResponseCallback callback) async {\n        ByteData? response;\n        try {\n          response = await handler(data);\n        } catch (exception, stack) {\n          FlutterError.reportError(FlutterErrorDetails(\n            exception: exception,\n            stack: stack,\n            library: 'services library',\n            context: ErrorDescription('during a platform message callback'),\n          ));\n        } finally {\n          callback(response);\n        }\n      });\n```\n\n可以看到这个**setListener**第二个参数为函数类型，\n\n**callback**调用时，即调用该函数类型参数。\n\n也就执行了`await handler(data);`，这里**handler**是首次封装代码块地方：\n\n```dart\n binaryMessenger.setMessageHandler(name, (ByteData? message) async {\n        return codec.encodeMessage(await handler(codec.decodeMessage(message)));\n      });\n```\n\n这里对**message**进行解码通过调用**handler**传递。\n\n此时的**handler**已经是我们调用**setMessageHandler**时的函数了：\n\n```dart\n    BasicMessageChannel basicMessageChannel =\n        const BasicMessageChannel(\"MessagePllugin\", StandardMessageCodec())\n          ..setMessageHandler((msg) {\n            print('BasicMessageChannel setMessageHandler ${msg}');\n            return Future.value(msg);\n          });\n```\n\n至此Android端发送数据，Flutter端接收数据流程已分析完毕，\n\n接下来分析Flutter端发送数据，Android端接收流程。\n\n## Flutter端send分析\n\n```dart\n  Future<T?> send(T message) async {\n    return codec.decodeMessage(await binaryMessenger.send(name, codec.encodeMessage(message)));\n  }\n```\n\n首先**codec**对数据进行编码`codec.encodeMessage(message)`。\n\n**send**方法直接调用了`binaryMessenger.send`：\n\n```dart\n  @override\n  Future<ByteData?> send(String channel, ByteData? message) {\n    final Completer<ByteData?> completer = Completer<ByteData?>();\n    ui.PlatformDispatcher.instance.sendPlatformMessage(channel, message, (ByteData? reply) {\n      try {\n        completer.complete(reply);\n      } catch (exception, stack) {\n        FlutterError.reportError(FlutterErrorDetails(\n          exception: exception,\n          stack: stack,\n          library: 'services library',\n          context: ErrorDescription('during a platform message response callback'),\n        ));\n      }\n    });\n    return completer.future;\n  }\n```\n\n直接调用了`PlatformDispatcher.instance.sendPlatformMessage`：\n\n```dart\n  void sendPlatformMessage(String name, ByteData? data, PlatformMessageResponseCallback? callback) {\n    final String? error =\n        _sendPlatformMessage(name, _zonedPlatformMessageResponseCallback(callback), data);\n    if (error != null) {\n      throw Exception(error);\n    }\n  }\n\n  String? _sendPlatformMessage(String name, PlatformMessageResponseCallback? callback, ByteData? data) =>\n      __sendPlatformMessage(name, callback, data);\n\n  @Native<Handle Function(Handle, Handle, Handle)>(symbol: 'PlatformConfigurationNativeApi::SendPlatformMessage')\n  external static String? __sendPlatformMessage(String name, PlatformMessageResponseCallback? callback, ByteData? data);\n```\n\n可以看到在**PlatformDispatcher**中，经过连续调用最后调用了**external**的 **__sendPlatformMessage**方法，这个是**native**方法。数据由此传递到了Engine。\n\n## Android端setMessageHandler分析\n\nAndroid端自定义的**MessagePllugin**设置了**handler**：\n\n```kotlin\n        channel = BasicMessageChannel(\n            flutterEngine.dartExecutor.binaryMessenger,\n            name,\n            StandardMessageCodec()\n        ).apply { setMessageHandler(this@MessagePllugin) }\n```\n\n看下**setMessagerHandler**实现：\n\n```kotlin\n  @UiThread\n  public void setMessageHandler(@Nullable final MessageHandler<T> handler) {\n    // We call the 2 parameter variant specifically to avoid breaking changes in\n    // mock verify calls.\n    // See https://github.com/flutter/flutter/issues/92582.\n    if (taskQueue != null) {\n      messenger.setMessageHandler(\n          name, handler == null ? null : new IncomingMessageHandler(handler), taskQueue);\n    } else {\n      messenger.setMessageHandler(\n          name, handler == null ? null : new IncomingMessageHandler(handler));\n    }\n  }\n```\n\n直接调用了`messenger.setMessageHandler`。\n\n这个**messenger**类型为**BinaryMessenger**默认实现类**DefaultBinaryMessenger**。\n\n注意这里对**handler**进行了首次封装**IncomingMessageHandler**。\n\n看下`messenger.setMessageHandler`实现：\n\n```kotlin\n    @Override\n    @UiThread\n    public void setMessageHandler(\n        @NonNull String channel, @Nullable BinaryMessenger.BinaryMessageHandler handler) {\n      messenger.setMessageHandler(channel, handler);\n    }\n```\n\n这里的**messenger**类型为**DartMessenger**：\n\n```kotlin\n  @Override\n  public void setMessageHandler(\n      @NonNull String channel, @Nullable BinaryMessenger.BinaryMessageHandler handler) {\n    setMessageHandler(channel, handler, null);\n  }\n\n  @Override\n  public void setMessageHandler(\n      @NonNull String channel,\n      @Nullable BinaryMessenger.BinaryMessageHandler handler,\n      @Nullable TaskQueue taskQueue) {\n    if (handler == null) {\n      Log.v(TAG, \"Removing handler for channel '\" + channel + \"'\");\n      synchronized (handlersLock) {\n        messageHandlers.remove(channel);\n      }\n      return;\n    }\n    DartMessengerTaskQueue dartMessengerTaskQueue = null;\n    if (taskQueue != null) {\n      dartMessengerTaskQueue = createdTaskQueues.get(taskQueue);\n      if (dartMessengerTaskQueue == null) {\n        throw new IllegalArgumentException(\n            \"Unrecognized TaskQueue, use BinaryMessenger to create your TaskQueue (ex makeBackgroundTaskQueue).\");\n      }\n    }\n    Log.v(TAG, \"Setting handler for channel '\" + channel + \"'\");\n\n    List<BufferedMessageInfo> list;\n    synchronized (handlersLock) {\n      messageHandlers.put(channel, new HandlerInfo(handler, dartMessengerTaskQueue));\n      list = bufferedMessages.remove(channel);\n      if (list == null) {\n        return;\n      }\n    }\n    for (BufferedMessageInfo info : list) {\n      dispatchMessageToQueue(\n          channel, messageHandlers.get(channel), info.message, info.replyId, info.messageData);\n    }\n  }\n```\n\n这里主要看加锁部分，这里对**handler**进行了二次封装，存储到**messageHandlers**中。\n\n接收到消息时，会调用`flutterJni.handlePlatformMessage`：\n\n```java\n  @VisibleForTesting\n  public void handlePlatformMessage(\n      @NonNull final String channel,\n      ByteBuffer message,\n      final int replyId,\n      final long messageData) {\n    if (platformMessageHandler != null) {\n      platformMessageHandler.handleMessageFromDart(channel, message, replyId, messageData);\n    } else {\n      nativeCleanupMessageData(messageData);\n    }\n    // TODO(mattcarroll): log dropped messages when in debug mode\n    // (https://github.com/flutter/flutter/issues/25391)\n  }\n```\n\n由于`DartExcutor.onAttachedToJNI()`的调用，\n\n通过`flutterJNI.setPlatformMessageHandler(dartMessenger);`\n\n给**platformMessageHandler**设置了值，所以调用**handleMessageFromDart**：\n\n```java\n  @Override\n  public void handleMessageFromDart(\n      @NonNull String channel, @Nullable ByteBuffer message, int replyId, long messageData) {\n    HandlerInfo handlerInfo;\n    boolean messageDeferred;\n    // This lock can potentially be a bottleneck and could replaced with a\n    // read/write lock.\n    synchronized (handlersLock) {\n      handlerInfo = messageHandlers.get(channel);\n      messageDeferred = (enableBufferingIncomingMessages.get() && handlerInfo == null);\n      if (messageDeferred) {\n        if (!bufferedMessages.containsKey(channel)) {\n          bufferedMessages.put(channel, new LinkedList<>());\n        }\n        List<BufferedMessageInfo> buffer = bufferedMessages.get(channel);\n        buffer.add(new BufferedMessageInfo(message, replyId, messageData));\n      }\n    }\n    if (!messageDeferred) {\n      dispatchMessageToQueue(channel, handlerInfo, message, replyId, messageData);\n    }\n  }\n```\n\n这里取出了之前存储的**handlerInfo**，传递到**dispatchMessageToQueue**：\n\n```java\n  private void dispatchMessageToQueue(\n      @NonNull String channel,\n      @Nullable HandlerInfo handlerInfo,\n      @Nullable ByteBuffer message,\n      int replyId,\n      long messageData) {\n    // Called from any thread.\n    final DartMessengerTaskQueue taskQueue = (handlerInfo != null) ? handlerInfo.taskQueue : null;\n    TraceSection.beginAsyncSection(\"PlatformChannel ScheduleHandler on \" + channel, replyId);\n    Runnable myRunnable =\n        () -> {\n          TraceSection.endAsyncSection(\"PlatformChannel ScheduleHandler on \" + channel, replyId);\n          TraceSection.begin(\"DartMessenger#handleMessageFromDart on \" + channel);\n          try {\n            invokeHandler(handlerInfo, message, replyId);\n            if (message != null && message.isDirect()) {\n              // This ensures that if a user retains an instance to the ByteBuffer and it\n              // happens to be direct they will get a deterministic error.\n              message.limit(0);\n            }\n          } finally {\n            // This is deleting the data underneath the message object.\n            flutterJNI.cleanupMessageData(messageData);\n            TraceSection.end();\n          }\n        };\n    final DartMessengerTaskQueue nonnullTaskQueue =\n        taskQueue == null ? platformTaskQueue : taskQueue;\n    nonnullTaskQueue.dispatch(myRunnable);\n  }\n```\n\n这里主要看看**invokeHandler**方法：\n\n```java\n  private void invokeHandler(\n      @Nullable HandlerInfo handlerInfo, @Nullable ByteBuffer message, final int replyId) {\n    // Called from any thread.\n    if (handlerInfo != null) {\n      try {\n        Log.v(TAG, \"Deferring to registered handler to process message.\");\n        handlerInfo.handler.onMessage(message, new Reply(flutterJNI, replyId));\n      } catch (Exception ex) {\n        Log.e(TAG, \"Uncaught exception in binary message listener\", ex);\n        flutterJNI.invokePlatformMessageEmptyResponseCallback(replyId);\n      } catch (Error err) {\n        handleError(err);\n      }\n    } else {\n      Log.v(TAG, \"No registered handler for message. Responding to Dart with empty reply message.\");\n      flutterJNI.invokePlatformMessageEmptyResponseCallback(replyId);\n    }\n  }\n```\n\n调用了`handlerInfo.handler`解包了第二次封装，\n\n此时`handlerInfo.handler`类型为**IncomingMessageHandler**。\n\n```java\n    @Override\n    public void onMessage(@Nullable ByteBuffer message, @NonNull final BinaryReply callback) {\n      try {\n        handler.onMessage(\n            codec.decodeMessage(message),\n            new Reply<T>() {\n              @Override\n              public void reply(T reply) {\n                callback.reply(codec.encodeMessage(reply));\n              }\n            });\n      } catch (RuntimeException e) {\n        Log.e(TAG + name, \"Failed to handle message\", e);\n        callback.reply(null);\n      }\n    }\n```\n\n**onMessage**方法中再次调用了**handler.onMessage**。\n\n此时的**handler**是我们最初传递的即**MessagePllugin**，因为该类实现了**MessageHandler**接口,这里的**onMessage**是我们重写的方法：\n\n```kotlin\nclass MessagePllugin(flutterEngine: FlutterEngine, context: Activity) : MessageHandler<Any> {\n    lateinit var channel: BasicMessageChannel<Any>\n\n    companion object {\n        const val name = \"MessagePllugin\"\n    }\n\n    init {\n        channel = BasicMessageChannel(\n            flutterEngine.dartExecutor.binaryMessenger,\n            name,\n            StandardMessageCodec()\n        ).apply { setMessageHandler(this@MessagePllugin) }\n    }\n\n    override fun onMessage(message: Any?, reply: BasicMessageChannel.Reply<Any>) {\n        reply.reply(\"reply from android MessagePllugin\")\n        Log.w(javaClass.simpleName, \"message=$message\")\n    }\n\n}\n```\n\n至此Flutter端发送数据，Android接收也已经分析完成。\n\n## 关于Reply\n\n看下我们实现**MessageHandler**后重写的**onMessage**方法：\n\n```kotlin\n    override fun onMessage(message: Any?, reply: BasicMessageChannel.Reply<Any>) {\n        reply.reply(\"reply from android MessagePllugin\")\n        Log.w(javaClass.simpleName, \"message=$message\")\n    }\n```\n\n当我们收到消息后，可以通过`reply.reply()`进行回复。\n\n这里有个问题，系统怎么知道这个**reply**是回复这次消息的？\n\n前边说过了当我们收到Flutter发来消息时，会调用`flutterJNI.handlePlatformMessage`\n\n```java\n  @VisibleForTesting\n  public void handlePlatformMessage(\n      @NonNull final String channel,\n      ByteBuffer message,\n      final int replyId,\n      final long messageData) {\n    if (platformMessageHandler != null) {\n      platformMessageHandler.handleMessageFromDart(channel, message, replyId, messageData);\n    } else {\n      nativeCleanupMessageData(messageData);\n    }\n    // TODO(mattcarroll): log dropped messages when in debug mode\n    // (https://github.com/flutter/flutter/issues/25391)\n  }\n```\n\n可以看到这里通过**channel**除了返回数据**message**外还带了**replyId**。\n\n经过调用把**flutterJNI**和**replyId**封装到`BinaryMessenger.BinaryReply`实现类**Reply**中，\n\n通过`handlerInfo.handler.onMessage()`传递\n\n接着调用`handler.onMessage`方法：\n\n```java\ntry {\n        handler.onMessage(\n            codec.decodeMessage(message),\n            new Reply<T>() {\n              @Override\n              public void reply(T reply) {\n                callback.reply(codec.encodeMessage(reply));\n              }\n            });\n      } catch (RuntimeException e) {\n        Log.e(TAG + name, \"Failed to handle message\", e);\n        callback.reply(null);\n      }\n```\n\n这里再次对上面的**Reply**进行封装。\n\n这里的**new Reply**就是我们调用**reply.reply()** 用到的对象。\n\n接着调用到`callback.reply()`，该方法如下：\n\n```java\n    @Override\n    public void reply(@Nullable ByteBuffer reply) {\n      if (done.getAndSet(true)) {\n        throw new IllegalStateException(\"Reply already submitted\");\n      }\n      if (reply == null) {\n        flutterJNI.invokePlatformMessageEmptyResponseCallback(replyId);\n      } else {\n        flutterJNI.invokePlatformMessageResponseCallback(replyId, reply, reply.position());\n      }\n    }\n```\n\n可以看到跟随**message**返回的**replyId**，这里又跟着**ByteBuffer**一同发送回去了。\n\n# 关于EventChannel\n\n**BasicMessageChannel**和**MethodChannel**都是支持双向通信的，\n\n但**EventChannel**只支持单向通信，即平台向Flutter端发送数据。\n\n通过`events: EventChannel.EventSink?`进行发送。"
  },
  {
    "title": "混合开发之flutter_thrio(一)配置",
    "created_time": "2023-03-04 14:31:25",
    "body": "本文针对的是新版的**kts**的**gralde**文件。\n\n创建一个普通Android项目。\n\n# 创建flutter_module\n\n打开刚创建的项目的**terminal**，使用命令行创建一个flutter_module。\n\n因为直接的**new module**里没有Flutter选项。\n\n`flutter create -t module --org com.example flutter_module`。\n\n# 给flutter_module添加依赖\n\n```yaml\n  get: ^4.6.5\n  flutter_thrio: ^4.6.2\n  flutter_jsonable: ^1.2.0\n```\n\n# 给Android添加flutter_module依赖\n\n## 配置settings.gradle.kts\n\n**repositories**使用如下国内代理：\n\n```kotlin\n        maven { setUrl(\"https://maven.aliyun.com/nexus/content/groups/public\") }\n        maven { setUrl(\"https://maven.aliyun.com/repository/public\") }\n        maven { setUrl(\"https://maven.aliyun.com/repository/google\") }\n        maven { setUrl(\"https://maven.aliyun.com/repository/jcenter\") }\n        maven { setUrl(\"https://maven.aliyun.com/repository/central\") }\n        maven { setUrl(\"https://maven.aliyun.com/nexus/content/repositories/jcenter/\") }\n        maven { setUrl(\"https://download.flutter.io\") }\n        maven { setUrl(\"https://storage.googleapis.com/download.flutter.io\") }\n        maven { setUrl(\"https://jitpack.io\") }\n```\n\n下面添加如下代码：\n\n```kotlin\ninclude(\":app\")\ninclude (\":flutter_module\")\nproject(\":flutter_module\").projectDir = File(settingsDir, \"flutter_module\")                                                                 // new\napply { \"/Users/jenson/Library/flutter/packages/flutter_tools/gradle/app_plugin_loader.gradle\" }\napply { from(\"flutter_settings.gradle\") }\n```\n\n## 创建flutter_settings.gradle\n\n```groovy\nsetBinding(new Binding([gradle: this]))\nevaluate(new File(settingsDir, 'flutter_module/.android/include_flutter.groovy'))\n```\n\n之所以要单独创建一个gradle文件是因为这两行代码在kts文件里没找到对应的代替方法。\n\n## 配置app下的build.gradle.kts\n\n```kotlin\n    implementation (project(\":flutter\"))\n    implementation (project(\":flutter_thrio\"))\n```\n\n# 编译出现namespace问题\n\n哪个模块出现问题就给哪个模块下的**build.gradle**添加\n\n```groovy\nif (project.android.hasProperty('namespace')) {\n    namespace 'com.foxsofter.flutter_thrio'\n}\n```\n\n点击同步后如果没有问题，接下来可以初始化thrio。\n\n# flutter_thrio初始化\n\n## flutter端初始化\n\n**main.dart**文件\n\n```dart\nimport 'app.dart' as app;\n\nvoid main() => app.main();\n```\n\n**app.dart**文件：\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_thrio/flutter_thrio.dart';\nimport 'login/module.dart';\nimport 'module.dart';\n\nvoid main() => runApp(const MainApp());\n\nclass MainApp extends StatefulWidget {\n  const MainApp({super.key, String entrypoint = 'main'})\n      : _entrypoint = entrypoint;\n\n  final String _entrypoint;\n\n  @override\n  _MainAppState createState() => _MainAppState();\n}\n\nclass _MainAppState extends State<MainApp> {\n  @override\n  void initState() {\n    super.initState();\n    ThrioModule.init(RootModule(), entrypoint: widget._entrypoint,\n        onModuleInitStart: (url) {\n      ThrioLogger.i('module start init: $url');\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) => NavigatorMaterialApp(\n        // transitionPage: const NavigatorHome(showRestartButton: true),\n        transitionPage: Container(),\n        builder: (context, child) => Container(\n          child: child,\n        ),\n        theme: ThemeData(\n          pageTransitionsTheme: const PageTransitionsTheme(builders: {\n            TargetPlatform.iOS: CupertinoPageTransitionsBuilder(),\n            TargetPlatform.android: CupertinoPageTransitionsBuilder(),\n          }),\n        ),\n      );\n}\n```\n\n在**initState**中初始化**ThrioModule**：\n\n```dart\n ThrioModule.init(RootModule(), entrypoint: widget._entrypoint,\n        onModuleInitStart: (url) {\n      ThrioLogger.i('module start init: $url');\n    });\n```\n\n这里的**RootModule**为根module，\n\n里面注册所有模块的的module：\n\n```dart\nimport 'package:flutter_thrio/flutter_thrio.dart';\nimport 'login/module.dart' as login;\n\nclass RootModule\n    with\n        ThrioModule,\n        ModuleJsonDeserializer,\n        ModuleJsonSerializer,\n        ModuleParamScheme {\n  @override\n  void onModuleRegister(ModuleContext moduleContext) {\n    navigatorLogEnabled = true;\n    registerModule(login.Module(), moduleContext);\n  }\n}\n```\n\n我这里只有login模块，所以只注册了注册模块module。\n\n注册模块下的module如果没有子module，只有页面，则为每个页面创建一个页面module，将页面module注册到注册模块module下,\n\n首先看下注册模块module：\n\n```dart\nimport 'package:flutter_module/login/login/login_page.dart';\nimport 'package:flutter_module/login/login/module.dart';\nimport 'package:flutter_module/login/register/module.dart';\nimport 'package:flutter_thrio/flutter_thrio.dart';\n\nclass Module\n    with\n        ThrioModule,\n        ModuleJsonDeserializer,\n        ModuleJsonSerializer,\n        ModuleParamScheme,\n        ModulePageBuilder {\n  @override\n  String get key => 'login';\n\n  @override\n  void onModuleRegister(ModuleContext moduleContext) {\n    navigatorLogEnabled = true;\n    registerModule(RegisterModule(), moduleContext);\n    registerModule(LoginModule(), moduleContext);\n  }\n}\n```\n\n可以看到这里又注册了**RegisterModule**和**LoginModule**。\n\n这两个module分别对应注册和登录页面：\n\n```dart\nimport 'package:flutter_module/login/register/register_page.dart';\nimport 'package:flutter_thrio/flutter_thrio.dart';\n\nclass RegisterModule\n    with\n        ThrioModule,\n        ModuleJsonDeserializer,\n        ModuleJsonSerializer,\n        ModuleParamScheme,\n        ModulePageBuilder {\n  @override\n  String get key => 'register';\n\n  @override\n  void onPageBuilderSetting(ModuleContext moduleContext) {\n    pageBuilder = (settings) => RegisterPage(\n          moduleContext: moduleContext,\n          settings: settings,\n        );\n  }\n}\n```\n\n```dart\nimport 'package:flutter_module/login/login/login_page.dart';\nimport 'package:flutter_thrio/flutter_thrio.dart';\n\nclass LoginModule\n    with\n        ThrioModule,\n        ModuleJsonDeserializer,\n        ModuleJsonSerializer,\n        ModuleParamScheme,\n        ModulePageBuilder {\n  @override\n  String get key => 'login';\n\n  @override\n  void onPageBuilderSetting(ModuleContext moduleContext) {\n    pageBuilder = (settings) => LoginPage(\n          moduleContext: moduleContext,\n          settings: settings,\n        );\n  }\n}\n```\n\n通过模块module和页面moudule层层递进，通过重写**key**并进行层层拼接，最后形成路由调用的url。\n\n例如这里注册模块**key**为**login**，注册页面module**key**为**register**，\n\n所以路由为 **/login/register**。\n\n这里的页面继承了**NavigatorStatefulPage**。\n\n## Android端初始化\n\n自定义Application，初始化**ThrioModule**：\n\n```kotlin\nclass MainApp : FlutterApplication() {\n    override fun onCreate() {\n        super.onCreate()\n        ThrioModule.init(MainModule, this)\n    }\n}\n```\n\n**MainModule**：\n\n```kotlin\npackage com.example.thrio_test\n\nimport android.app.Activity\nimport com.foxsofter.flutter_thrio.module.*\nimport com.foxsofter.flutter_thrio.navigator.FlutterIntentBuilder\nimport com.foxsofter.flutter_thrio.navigator.IntentBuilder\nimport io.flutter.embedding.android.ThrioFlutterFragmentActivity\n\nobject MainModule : ThrioModule(), ModuleIntentBuilder, ModuleJsonSerializer,\n    ModuleJsonDeserializer {\n\n    override fun onModuleInit(moduleContext: ModuleContext) {\n        navigatorLogEnabled = true\n    }\n\n    override fun onIntentBuilderRegister(moduleContext: ModuleContext) {\n        setFlutterIntentBuilder(object : FlutterIntentBuilder() {\n            override fun getActivityClz(): Class<out Activity> =\n                CustomFlutterActivity::class.java\n        })\n\n        registerIntentBuilder(\"/biz1/one\", object : IntentBuilder {\n            override fun getActivityClz(): Class<out Activity> {\n                return OneActivity::class.java\n            }\n        })\n        registerIntentBuilder(\"/biz1/two\", object : IntentBuilder {\n            override fun getActivityClz(): Class<out Activity> {\n                return TwoActivity::class.java\n            }\n        })\n    }\n\n    override fun onJsonSerializerRegister(moduleContext: ModuleContext) {\n//        registerJsonSerializer({ people -> people.toJson() }, People::class.java)\n    }\n\n    override fun onJsonDeserializerRegister(moduleContext: ModuleContext) {\n//        registerJsonDeserializer({ json -> People(json) }, People::class.java)\n    }\n}\n```\n\n**onIntentBuilderRegister**方法中，\n\n**setFlutterIntentBuilder**表示设置显示**FlutterView**的容器，这里是**CustomFlutterActivity**，\n\n**registerIntentBuilder**表示要跳转的**Activity**，首个参数url表示路由url，第二个参数为目标页面。\n\n**CustomFlutterActivity**：\n\n```kotlin\npackage com.example.thrio_test\n\nimport com.foxsofter.flutter_thrio.channel.ThrioChannel\nimport io.flutter.embedding.android.ThrioFlutterFragmentActivity\nimport io.flutter.embedding.engine.FlutterEngine\n\nclass CustomFlutterActivity : ThrioFlutterFragmentActivity() {\n\n    private var channel: ThrioChannel? = null\n\n    override fun configureFlutterEngine(flutterEngine: FlutterEngine) {\n        super.configureFlutterEngine(flutterEngine)\n        engine?.apply {\n            channel = ThrioChannel(this, \"custom_thrio_channel\")\n            channel?.setupMethodChannel(flutterEngine.dartExecutor)\n        }\n    }\n\n    // 当在根部时，重写以拦截是否需要再次点击返回键退出\n    //\n    override fun shouldMoveToBack(): Boolean {\n        return true\n    }\n}\n```\n\n至此使用前的配置已经完成。"
  },
  {
    "title": "混合开发之flutter_boost(一)配置",
    "created_time": "2023-03-05 14:31:25",
    "body": "# 创建flutter_module\n\n打开刚创建的项目的**terminal**，使用命令行创建一个flutter_module。\n\n因为直接的**new module**里没有Flutter选项。\n\n`flutter create -t module --org com.example flutter_module`。\n\n# 配置flutter_boost\n\n打开yaml文件添加**flutter_boost**依赖：\n\n```yaml\n  flutter_boost:\n    git:\n      url: 'https://github.com/alibaba/flutter_boost.git'\n      ref: '4.4.0'\n```\n\n# 配置settings.gradle\n\n文件底部添加如下内容：\n\n```groovy\nsetBinding(new Binding([gradle: this]))\nevaluate(new File(settingsDir, 'flutter_module/.android/include_flutter.groovy'))\ninclude ':flutter_module'\nproject(':flutter_module').projectDir = new File(\"${settingsDir}\", 'flutter_module')                                                                 // new\napply { \"/Users/jenson/Library/flutter/packages/flutter_tools/gradle/app_plugin_loader.gradle\" }\n```\n\n# 配置app build.gradle\n\n文件添加依赖：\n\n```groovy\n    implementation project(':flutter')\n    implementation project(':flutter_boost')\n```\n\n# 初始化Flutter端\n\n## 创建自定义Binding\n\n```dart\n///创建一个自定义的Binding，继承和with的关系如下，里面什么都不用写\nclass CustomFlutterBinding extends WidgetsFlutterBinding\n    with BoostFlutterBinding {}\n```\n\n在**runApp**之前调用`CustomFlutterBinding();`。\n\n## FlutterBoostApp\n\n```dart\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return FlutterBoostApp(\n      Routes.routeFactory,\n      appBuilder: (home) => MaterialApp(\n        home: home,\n        builder: (_, __) => home,\n      ),\n    );\n  }\n}\n```\n\n其中**routes.dart**内容如下：\n\n```dart\nimport 'package:flutter/cupertino.dart';\nimport 'package:flutter/widgets.dart';\nimport 'package:flutter_boost/flutter_boost.dart';\n\nimport 'main.dart';\nimport 'one_page.dart';\n\nclass Routes {\n  static Map<String, FlutterBoostRouteFactory> routerMap = {\n    '/': (RouteSettings settings, String? uniqueId) {\n      return CupertinoPageRoute(\n          settings: settings,\n          builder: (_) {\n            final map = settings.arguments as Map<String, dynamic>?;\n            return const MyHomePage();\n          });\n    },\n    'onepage': (settings, uniqueId) {\n      return CupertinoPageRoute(\n          settings: settings,\n          builder: (_) {\n            final map = settings.arguments as Map<String, dynamic>?;\n            return const OnePage();\n          });\n    },\n  };\n\n  static Route<dynamic> routeFactory(RouteSettings settings, String? uniqueId) {\n    print('settings==$settings');\n    FlutterBoostRouteFactory func =\n        routerMap[settings.name] as FlutterBoostRouteFactory;\n    return func(settings, uniqueId)!;\n  }\n}\n```\n\n# 初始化Android端\n\n## 配置 AndroidManifest.xml\n\n```xml\n        <activity\n            android:name=\"io.flutter.embedding.android.FlutterActivity\"\n            android:configChanges=\"orientation|keyboardHidden|keyboard|screenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode\"\n            android:hardwareAccelerated=\"true\"\n            android:windowSoftInputMode=\"adjustResize\" />\n        <activity\n            android:name=\"com.idlefish.flutterboost.containers.FlutterBoostActivity\"\n            android:configChanges=\"orientation|keyboardHidden|keyboard|screenSize|locale|layoutDirection|fontScale|screenLayout|density\"\n            android:hardwareAccelerated=\"true\"\n            android:theme=\"@style/Theme.AppCompat\"\n            android:windowSoftInputMode=\"adjustResize\"></activity>\n\n        <meta-data\n            android:name=\"flutterEmbedding\"\n            android:value=\"2\"></meta-data>\n```\n\n## Application中初始化boost\n\n```kotlin\nclass App : Application() {\n\n    override fun onCreate() {\n        super.onCreate()\n        FlutterBoost.instance().setup(this, object : FlutterBoostDelegate {\n            override fun pushNativeRoute(options: FlutterBoostRouteOptions) {\n                //这里根据options.pageName来判断你想跳转哪个页面，这里简单给一个\n                val intent = Intent(\n                    FlutterBoost.instance().currentActivity(),\n                    SecondActivity::class.java\n                )\n                FlutterBoost.instance().currentActivity()\n                    .startActivityForResult(intent, options.requestCode())\n            }\n\n            override fun pushFlutterRoute(options: FlutterBoostRouteOptions) {\n                val intent = FlutterBoostActivity.CachedEngineIntentBuilder(\n                    FlutterBoostActivity::class.java\n                )\n                    .backgroundMode(FlutterActivityLaunchConfigs.BackgroundMode.transparent)\n                    .destroyEngineWithActivity(false)\n                    .uniqueId(options.uniqueId())\n                    .url(options.pageName())\n                    .urlParams(options.arguments())\n                    .build(FlutterBoost.instance().currentActivity())\n                FlutterBoost.instance().currentActivity().startActivity(intent)\n            }\n        }) { engine: FlutterEngine? -> }\n    }\n}\n```"
  }
]